
==================== Output Cmm ====================
2018-03-16 16:03:36.693310357 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:36.694155756 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule4_bytes" {
     GHC.IO.Encoding.UTF8.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.694870886 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule3_closure" {
     GHC.IO.Encoding.UTF8.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.695602744 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule2_bytes" {
     GHC.IO.Encoding.UTF8.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.69625839 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule1_closure" {
     GHC.IO.Encoding.UTF8.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.696835409 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule_closure" {
     GHC.IO.Encoding.UTF8.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF8.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF8.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.705537326 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF1_info;
 },
 sat_s8uYV_entry() //  [R1]
         { info_tbl: [(c8vd8,
                       label: sat_s8uYV_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vd8: // global
           _s8uYV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vd9; else goto c8vda;
       c8vda: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vdc; else goto c8vdb;
       c8vdc: // global
           HpAlloc = 56;
           goto c8vd9;
       c8vd9: // global
           R1 = _s8uYV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vdb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uYV::P64;
           _s8uYH::I64 = I64[_s8uYV::P64 + 56];
           _s8uYR::I64 = I64[_s8uYV::P64 + 64];
           if (_s8uYR::I64 == _s8uYH::I64) goto c8vd7; else goto c8vd6;
       c8vd7: // global
           _s8uYP::P64 = P64[_s8uYV::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vd6: // global
           _s8uYD::P64 = P64[_s8uYV::P64 + 16];
           _s8uYE::P64 = P64[_s8uYV::P64 + 24];
           _s8uYC::I64 = I64[_s8uYV::P64 + 40];
           _s8uYF::I64 = I64[_s8uYV::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYR::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZ3_entry() //  [R1]
         { info_tbl: [(c8vdu,
                       label: sat_s8uZ3_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vdu: // global
           _s8uZ3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vdv; else goto c8vdw;
       c8vdw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vdy; else goto c8vdx;
       c8vdy: // global
           HpAlloc = 56;
           goto c8vdv;
       c8vdv: // global
           R1 = _s8uZ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vdx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZ3::P64;
           _s8uYH::I64 = I64[_s8uZ3::P64 + 56];
           _s8uYZ::I64 = I64[_s8uZ3::P64 + 64];
           if (_s8uYZ::I64 == _s8uYH::I64) goto c8vdt; else goto c8vds;
       c8vdt: // global
           _s8uYP::P64 = P64[_s8uZ3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vds: // global
           _s8uYD::P64 = P64[_s8uZ3::P64 + 16];
           _s8uYE::P64 = P64[_s8uZ3::P64 + 24];
           _s8uYC::I64 = I64[_s8uZ3::P64 + 40];
           _s8uYF::I64 = I64[_s8uZ3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYZ::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZb_entry() //  [R1]
         { info_tbl: [(c8vdQ,
                       label: sat_s8uZb_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vdQ: // global
           _s8uZb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vdR; else goto c8vdS;
       c8vdS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vdU; else goto c8vdT;
       c8vdU: // global
           HpAlloc = 56;
           goto c8vdR;
       c8vdR: // global
           R1 = _s8uZb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vdT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZb::P64;
           _s8uYH::I64 = I64[_s8uZb::P64 + 56];
           _s8uZ7::I64 = I64[_s8uZb::P64 + 64];
           if (_s8uZ7::I64 == _s8uYH::I64) goto c8vdP; else goto c8vdO;
       c8vdP: // global
           _s8uYP::P64 = P64[_s8uZb::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vdO: // global
           _s8uYD::P64 = P64[_s8uZb::P64 + 16];
           _s8uYE::P64 = P64[_s8uZb::P64 + 24];
           _s8uYC::I64 = I64[_s8uZb::P64 + 40];
           _s8uYF::I64 = I64[_s8uZb::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZ7::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZj_entry() //  [R1]
         { info_tbl: [(c8vec,
                       label: sat_s8uZj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vec: // global
           _s8uZj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ved; else goto c8vee;
       c8vee: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8veg; else goto c8vef;
       c8veg: // global
           HpAlloc = 56;
           goto c8ved;
       c8ved: // global
           R1 = _s8uZj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vef: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZj::P64;
           _s8uYH::I64 = I64[_s8uZj::P64 + 56];
           _s8uZf::I64 = I64[_s8uZj::P64 + 64];
           if (_s8uZf::I64 == _s8uYH::I64) goto c8veb; else goto c8vea;
       c8veb: // global
           _s8uYP::P64 = P64[_s8uZj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vea: // global
           _s8uYD::P64 = P64[_s8uZj::P64 + 16];
           _s8uYE::P64 = P64[_s8uZj::P64 + 24];
           _s8uYC::I64 = I64[_s8uZj::P64 + 40];
           _s8uYF::I64 = I64[_s8uZj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZf::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZr_entry() //  [R1]
         { info_tbl: [(c8vey,
                       label: sat_s8uZr_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vey: // global
           _s8uZr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vez; else goto c8veA;
       c8veA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8veC; else goto c8veB;
       c8veC: // global
           HpAlloc = 56;
           goto c8vez;
       c8vez: // global
           R1 = _s8uZr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8veB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZr::P64;
           _s8uYH::I64 = I64[_s8uZr::P64 + 56];
           _s8uZn::I64 = I64[_s8uZr::P64 + 64];
           if (_s8uZn::I64 == _s8uYH::I64) goto c8vex; else goto c8vew;
       c8vex: // global
           _s8uYP::P64 = P64[_s8uZr::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vew: // global
           _s8uYD::P64 = P64[_s8uZr::P64 + 16];
           _s8uYE::P64 = P64[_s8uZr::P64 + 24];
           _s8uYC::I64 = I64[_s8uZr::P64 + 40];
           _s8uYF::I64 = I64[_s8uZr::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZn::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v1h_entry() //  [R1]
         { info_tbl: [(c8vfp,
                       label: sat_s8v1h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vfp: // global
           _s8v1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vfq; else goto c8vfr;
       c8vfr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vft; else goto c8vfs;
       c8vft: // global
           HpAlloc = 56;
           goto c8vfq;
       c8vfq: // global
           R1 = _s8v1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v1h::P64;
           _s8uYH::I64 = I64[_s8v1h::P64 + 56];
           _s8uZv::I64 = I64[_s8v1h::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8vfo; else goto c8vfn;
       c8vfo: // global
           _s8uYP::P64 = P64[_s8v1h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vfn: // global
           _s8uYD::P64 = P64[_s8v1h::P64 + 16];
           _s8uYE::P64 = P64[_s8v1h::P64 + 24];
           _s8uYC::I64 = I64[_s8v1h::P64 + 40];
           _s8uYF::I64 = I64[_s8v1h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2i_entry() //  [R1]
         { info_tbl: [(c8vfS,
                       label: sat_s8v2i_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vfS: // global
           _s8v2i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vfT; else goto c8vfU;
       c8vfU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vfW; else goto c8vfV;
       c8vfW: // global
           HpAlloc = 56;
           goto c8vfT;
       c8vfT: // global
           R1 = _s8v2i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vfV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2i::P64;
           _s8uYH::I64 = I64[_s8v2i::P64 + 56];
           _s8uZv::I64 = I64[_s8v2i::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8vfR; else goto c8vfQ;
       c8vfR: // global
           _s8uYP::P64 = P64[_s8v2i::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vfQ: // global
           _s8uYD::P64 = P64[_s8v2i::P64 + 16];
           _s8uYE::P64 = P64[_s8v2i::P64 + 24];
           _s8uYC::I64 = I64[_s8v2i::P64 + 40];
           _s8uYF::I64 = I64[_s8v2i::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2m_entry() //  [R1]
         { info_tbl: [(c8vga,
                       label: sat_s8v2m_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vga: // global
           _s8v2m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vgb; else goto c8vgc;
       c8vgc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vge; else goto c8vgd;
       c8vge: // global
           HpAlloc = 56;
           goto c8vgb;
       c8vgb: // global
           R1 = _s8v2m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vgd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2m::P64;
           _s8uYH::I64 = I64[_s8v2m::P64 + 56];
           _s8uZv::I64 = I64[_s8v2m::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8vg9; else goto c8vg8;
       c8vg9: // global
           _s8uYP::P64 = P64[_s8v2m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vg8: // global
           _s8uYD::P64 = P64[_s8v2m::P64 + 16];
           _s8uYE::P64 = P64[_s8v2m::P64 + 24];
           _s8uYC::I64 = I64[_s8v2m::P64 + 40];
           _s8uYF::I64 = I64[_s8v2m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8vgh,
                       label: GHC.IO.Encoding.UTF8.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vgh: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8vgi; else goto c8vgj;
       c8vgi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vgj: // global
           I64[Sp - 16] = block_c8vcI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8voO; else goto c8vcJ;
       u8voO: // global
           call _c8vcI(R1) args: 0, res: 0, upd: 0;
       c8vcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vcI() //  [R1]
         { info_tbl: [(c8vcI,
                       label: block_c8vcI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vcI: // global
           I64[Sp - 40] = block_c8vcN_info;
           _s8uYD::P64 = P64[R1 + 7];
           _s8uYE::P64 = P64[R1 + 15];
           _s8uYC::I64 = I64[R1 + 23];
           _s8uYF::I64 = I64[R1 + 31];
           _s8uYG::I64 = I64[R1 + 39];
           _s8uYH::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8uYE::P64;
           I64[Sp - 24] = _s8uYF::I64;
           I64[Sp - 16] = _s8uYG::I64;
           I64[Sp - 8] = _s8uYH::I64;
           P64[Sp] = _s8uYD::P64;
           I64[Sp + 8] = _s8uYC::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8voA; else goto c8vcO;
       u8voA: // global
           call _c8vcN(R1) args: 0, res: 0, upd: 0;
       c8vcO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vcN() //  [R1]
         { info_tbl: [(c8vcN,
                       label: block_c8vcN_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vcN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vgn; else goto c8vgm;
       c8vgn: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vgm: // global
           _s8uYK::P64 = P64[R1 + 7];
           _s8uYL::P64 = P64[R1 + 15];
           _s8uYJ::I64 = I64[R1 + 23];
           _s8uYM::I64 = I64[R1 + 31];
           _s8uYN::I64 = I64[R1 + 39];
           _s8uYO::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8uYK::P64;
           P64[Sp - 40] = _s8uYL::P64;
           I64[Sp - 32] = _s8uYM::I64;
           I64[Sp - 24] = _s8uYN::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8uYO::I64;
           I64[Sp] = _s8uYJ::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8veH() args: 0, res: 0, upd: 0;
     }
 },
 _c8veH() //  []
         { info_tbl: [(c8veH,
                       label: block_c8veH_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8veH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgK; else goto c8vgJ;
       c8vgK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8veH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgJ: // global
           _s8uYM::I64 = I64[Sp + 24];
           _s8uZv::I64 = I64[Sp + 40];
           _s8uZw::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8uZw::I64,
                            _s8uYM::I64)) goto c8vi6; else goto c8vi7;
       c8vi6: // global
           _s8uYH::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8uZv::I64,
                            _s8uYH::I64)) goto c8vi3; else goto c8vi4;
       c8vi3: // global
           _c8vcS::P64 = P64[Sp + 80];
           _s8uYC::I64 = I64[Sp + 104];
           _s8uYD::P64 = P64[Sp + 96];
           _s8uYE::P64 = P64[Sp + 64];
           _s8uYF::I64 = I64[Sp + 72];
           _s8uYJ::I64 = I64[Sp + 56];
           _s8uYK::P64 = P64[Sp + 8];
           _s8uYL::P64 = P64[Sp + 16];
           _s8uYN::I64 = I64[Sp + 32];
           _s8uZC::I64 = %MO_UU_Conv_W32_W64(I32[_s8uYC::I64 + (_s8uZv::I64 << 2)]);
           call MO_Touch(_s8uYD::P64);
           if (%MO_S_Gt_W64(_s8uZC::I64, 127)) goto c8vi0; else goto c8vi1;
       c8vi0: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 2047)) goto c8vhO; else goto c8vhY;
       c8vhO: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 65535)) goto c8vgU; else goto c8vhM;
       c8vgU: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            4)) goto c8vgR; else goto c8vgS;
       c8vgR: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            18) + 240);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  12) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 4;
           goto u8voL;
       c8vgS: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8vcV() args: 0, res: 0, upd: 0;
       c8vhM: // global
           if (%MO_S_Gt_W64(55296, _s8uZC::I64)) goto c8vhj; else goto c8vhL;
       c8vhj: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8vh4; else goto c8vhh;
       c8vh4: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8vhB; else goto c8vh1;
       c8vh1: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8voL;
       c8vhh: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8vhe; else goto c8vhg;
       c8vhe: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8vhB; else goto c8vhb;
       c8vhb: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8voL;
       c8vhg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v1h_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8vcS::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vhL: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 56319)) goto c8vhI; else goto c8vhK;
       c8vhI: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8vht; else goto c8vhG;
       c8vht: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8vhB; else goto c8vhq;
       c8vhq: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8voL;
       c8vhG: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8vhD; else goto c8vhF;
       c8vhD: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8vhB; else goto c8vhA;
       c8vhB: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8vdh() args: 0, res: 0, upd: 0;
       c8vhA: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8voL;
       c8vhF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2i_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8vcS::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vhK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2m_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8vcS::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vhY: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            2)) goto c8vhW; else goto c8vhX;
       c8vhW: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            6) + 192);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 2;
           goto u8voL;
       c8vhX: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8vdD() args: 0, res: 0, upd: 0;
       c8vi1: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(_s8uZC::I64);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 1;
           goto u8voL;
       u8voL: // global
           call _c8veH() args: 0, res: 0, upd: 0;
       c8vi4: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8vdZ() args: 0, res: 0, upd: 0;
       c8vi7: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8vel() args: 0, res: 0, upd: 0;
     }
 },
 _c8vcV() //  []
         { info_tbl: [(c8vcV,
                       label: block_c8vcV_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vcV: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgr; else goto c8vgq;
       c8vgr: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vcV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uYV_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vdh() //  []
         { info_tbl: [(c8vdh,
                       label: block_c8vdh_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vdh: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgv; else goto c8vgu;
       c8vgv: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vdh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgu: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZ3_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vdD() //  []
         { info_tbl: [(c8vdD,
                       label: block_c8vdD_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vdD: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgz; else goto c8vgy;
       c8vgz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vdD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZb_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vdZ() //  []
         { info_tbl: [(c8vdZ,
                       label: block_c8vdZ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vdZ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgD; else goto c8vgC;
       c8vgD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vdZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZj_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vel() //  []
         { info_tbl: [(c8vel,
                       label: block_c8vel_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vel: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vgH; else goto c8vgG;
       c8vgH: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vel_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vgG: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZr_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.742227739 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF4_closure" {
     GHC.IO.Encoding.UTF8.mkUTF4_closure:
         const GHC.IO.Encoding.UTF8.mkUTF4_info;
 },
 sat_s8v3c_entry() //  [R1]
         { info_tbl: [(c8vpj,
                       label: sat_s8v3c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vpj: // global
           _s8v3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vpk; else goto c8vpl;
       c8vpl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vpn; else goto c8vpm;
       c8vpn: // global
           HpAlloc = 56;
           goto c8vpk;
       c8vpk: // global
           R1 = _s8v3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vpm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3c::P64;
           _s8v2Y::I64 = I64[_s8v3c::P64 + 56];
           _s8v38::I64 = I64[_s8v3c::P64 + 64];
           if (_s8v38::I64 == _s8v2Y::I64) goto c8vpi; else goto c8vph;
       c8vpi: // global
           _s8v36::P64 = P64[_s8v3c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vph: // global
           _s8v2U::P64 = P64[_s8v3c::P64 + 16];
           _s8v2V::P64 = P64[_s8v3c::P64 + 24];
           _s8v2T::I64 = I64[_s8v3c::P64 + 40];
           _s8v2W::I64 = I64[_s8v3c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v38::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3k_entry() //  [R1]
         { info_tbl: [(c8vpF,
                       label: sat_s8v3k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vpF: // global
           _s8v3k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vpG; else goto c8vpH;
       c8vpH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vpJ; else goto c8vpI;
       c8vpJ: // global
           HpAlloc = 56;
           goto c8vpG;
       c8vpG: // global
           R1 = _s8v3k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vpI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3k::P64;
           _s8v2Y::I64 = I64[_s8v3k::P64 + 56];
           _s8v3g::I64 = I64[_s8v3k::P64 + 64];
           if (_s8v3g::I64 == _s8v2Y::I64) goto c8vpE; else goto c8vpD;
       c8vpE: // global
           _s8v36::P64 = P64[_s8v3k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vpD: // global
           _s8v2U::P64 = P64[_s8v3k::P64 + 16];
           _s8v2V::P64 = P64[_s8v3k::P64 + 24];
           _s8v2T::I64 = I64[_s8v3k::P64 + 40];
           _s8v2W::I64 = I64[_s8v3k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3g::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3A_entry() //  [R1]
         { info_tbl: [(c8vqd,
                       label: sat_s8v3A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vqd: // global
           _s8v3A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vqe; else goto c8vqf;
       c8vqf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vqh; else goto c8vqg;
       c8vqh: // global
           HpAlloc = 56;
           goto c8vqe;
       c8vqe: // global
           R1 = _s8v3A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vqg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3A::P64;
           _s8v2Y::I64 = I64[_s8v3A::P64 + 56];
           _s8v3o::I64 = I64[_s8v3A::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8vqc; else goto c8vqb;
       c8vqc: // global
           _s8v36::P64 = P64[_s8v3A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vqb: // global
           _s8v2U::P64 = P64[_s8v3A::P64 + 16];
           _s8v2V::P64 = P64[_s8v3A::P64 + 24];
           _s8v2T::I64 = I64[_s8v3A::P64 + 40];
           _s8v2W::I64 = I64[_s8v3A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3H_entry() //  [R1]
         { info_tbl: [(c8vqG,
                       label: sat_s8v3H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vqG: // global
           _s8v3H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vqH; else goto c8vqI;
       c8vqI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vqK; else goto c8vqJ;
       c8vqK: // global
           HpAlloc = 56;
           goto c8vqH;
       c8vqH: // global
           R1 = _s8v3H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vqJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3H::P64;
           _s8v2Y::I64 = I64[_s8v3H::P64 + 56];
           _s8v3o::I64 = I64[_s8v3H::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8vqF; else goto c8vqE;
       c8vqF: // global
           _s8v36::P64 = P64[_s8v3H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vqE: // global
           _s8v2U::P64 = P64[_s8v3H::P64 + 16];
           _s8v2V::P64 = P64[_s8v3H::P64 + 24];
           _s8v2T::I64 = I64[_s8v3H::P64 + 40];
           _s8v2W::I64 = I64[_s8v3H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3M_entry() //  [R1]
         { info_tbl: [(c8vr1,
                       label: sat_s8v3M_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vr1: // global
           _s8v3M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vr2; else goto c8vr3;
       c8vr3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vr5; else goto c8vr4;
       c8vr5: // global
           HpAlloc = 56;
           goto c8vr2;
       c8vr2: // global
           R1 = _s8v3M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vr4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3M::P64;
           _s8v2Y::I64 = I64[_s8v3M::P64 + 56];
           _s8v3o::I64 = I64[_s8v3M::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8vr0; else goto c8vqZ;
       c8vr0: // global
           _s8v36::P64 = P64[_s8v3M::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vqZ: // global
           _s8v2U::P64 = P64[_s8v3M::P64 + 16];
           _s8v2V::P64 = P64[_s8v3M::P64 + 24];
           _s8v2T::I64 = I64[_s8v3M::P64 + 40];
           _s8v2W::I64 = I64[_s8v3M::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3R_entry() //  [R1]
         { info_tbl: [(c8vrm,
                       label: sat_s8v3R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vrm: // global
           _s8v3R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vrn; else goto c8vro;
       c8vro: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vrq; else goto c8vrp;
       c8vrq: // global
           HpAlloc = 56;
           goto c8vrn;
       c8vrn: // global
           R1 = _s8v3R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vrp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3R::P64;
           _s8v2Y::I64 = I64[_s8v3R::P64 + 56];
           _s8v3o::I64 = I64[_s8v3R::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8vrl; else goto c8vrk;
       c8vrl: // global
           _s8v36::P64 = P64[_s8v3R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vrk: // global
           _s8v2U::P64 = P64[_s8v3R::P64 + 16];
           _s8v2V::P64 = P64[_s8v3R::P64 + 24];
           _s8v2T::I64 = I64[_s8v3R::P64 + 40];
           _s8v2W::I64 = I64[_s8v3R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4k_entry() //  [R1]
         { info_tbl: [(c8vs1,
                       label: sat_s8v4k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vs1: // global
           _s8v4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vs2; else goto c8vs3;
       c8vs3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vs5; else goto c8vs4;
       c8vs5: // global
           HpAlloc = 56;
           goto c8vs2;
       c8vs2: // global
           R1 = _s8v4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vs4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4k::P64;
           _s8v2Y::I64 = I64[_s8v4k::P64 + 56];
           _s8v42::I64 = I64[_s8v4k::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vs0; else goto c8vrZ;
       c8vs0: // global
           _s8v36::P64 = P64[_s8v4k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vrZ: // global
           _s8v2U::P64 = P64[_s8v4k::P64 + 16];
           _s8v2V::P64 = P64[_s8v4k::P64 + 24];
           _s8v2T::I64 = I64[_s8v4k::P64 + 40];
           _s8v2W::I64 = I64[_s8v4k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4r_entry() //  [R1]
         { info_tbl: [(c8vsu,
                       label: sat_s8v4r_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vsu: // global
           _s8v4r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vsv; else goto c8vsw;
       c8vsw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vsy; else goto c8vsx;
       c8vsy: // global
           HpAlloc = 56;
           goto c8vsv;
       c8vsv: // global
           R1 = _s8v4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vsx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4r::P64;
           _s8v2Y::I64 = I64[_s8v4r::P64 + 56];
           _s8v42::I64 = I64[_s8v4r::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vst; else goto c8vss;
       c8vst: // global
           _s8v36::P64 = P64[_s8v4r::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vss: // global
           _s8v2U::P64 = P64[_s8v4r::P64 + 16];
           _s8v2V::P64 = P64[_s8v4r::P64 + 24];
           _s8v2T::I64 = I64[_s8v4r::P64 + 40];
           _s8v2W::I64 = I64[_s8v4r::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4w_entry() //  [R1]
         { info_tbl: [(c8vsP,
                       label: sat_s8v4w_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vsP: // global
           _s8v4w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vsQ; else goto c8vsR;
       c8vsR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vsT; else goto c8vsS;
       c8vsT: // global
           HpAlloc = 56;
           goto c8vsQ;
       c8vsQ: // global
           R1 = _s8v4w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vsS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4w::P64;
           _s8v2Y::I64 = I64[_s8v4w::P64 + 56];
           _s8v42::I64 = I64[_s8v4w::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vsO; else goto c8vsN;
       c8vsO: // global
           _s8v36::P64 = P64[_s8v4w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vsN: // global
           _s8v2U::P64 = P64[_s8v4w::P64 + 16];
           _s8v2V::P64 = P64[_s8v4w::P64 + 24];
           _s8v2T::I64 = I64[_s8v4w::P64 + 40];
           _s8v2W::I64 = I64[_s8v4w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4B_entry() //  [R1]
         { info_tbl: [(c8vta,
                       label: sat_s8v4B_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vta: // global
           _s8v4B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vtb; else goto c8vtc;
       c8vtc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vte; else goto c8vtd;
       c8vte: // global
           HpAlloc = 56;
           goto c8vtb;
       c8vtb: // global
           R1 = _s8v4B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vtd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4B::P64;
           _s8v2Y::I64 = I64[_s8v4B::P64 + 56];
           _s8v42::I64 = I64[_s8v4B::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vt9; else goto c8vt8;
       c8vt9: // global
           _s8v36::P64 = P64[_s8v4B::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vt8: // global
           _s8v2U::P64 = P64[_s8v4B::P64 + 16];
           _s8v2V::P64 = P64[_s8v4B::P64 + 24];
           _s8v2T::I64 = I64[_s8v4B::P64 + 40];
           _s8v2W::I64 = I64[_s8v4B::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4G_entry() //  [R1]
         { info_tbl: [(c8vtv,
                       label: sat_s8v4G_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vtv: // global
           _s8v4G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vtw; else goto c8vtx;
       c8vtx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vtz; else goto c8vty;
       c8vtz: // global
           HpAlloc = 56;
           goto c8vtw;
       c8vtw: // global
           R1 = _s8v4G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vty: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4G::P64;
           _s8v2Y::I64 = I64[_s8v4G::P64 + 56];
           _s8v42::I64 = I64[_s8v4G::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vtu; else goto c8vtt;
       c8vtu: // global
           _s8v36::P64 = P64[_s8v4G::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vtt: // global
           _s8v2U::P64 = P64[_s8v4G::P64 + 16];
           _s8v2V::P64 = P64[_s8v4G::P64 + 24];
           _s8v2T::I64 = I64[_s8v4G::P64 + 40];
           _s8v2W::I64 = I64[_s8v4G::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4L_entry() //  [R1]
         { info_tbl: [(c8vtQ,
                       label: sat_s8v4L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vtQ: // global
           _s8v4L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vtR; else goto c8vtS;
       c8vtS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vtU; else goto c8vtT;
       c8vtU: // global
           HpAlloc = 56;
           goto c8vtR;
       c8vtR: // global
           R1 = _s8v4L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vtT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4L::P64;
           _s8v2Y::I64 = I64[_s8v4L::P64 + 56];
           _s8v42::I64 = I64[_s8v4L::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8vtP; else goto c8vtO;
       c8vtP: // global
           _s8v36::P64 = P64[_s8v4L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vtO: // global
           _s8v2U::P64 = P64[_s8v4L::P64 + 16];
           _s8v2V::P64 = P64[_s8v4L::P64 + 24];
           _s8v2T::I64 = I64[_s8v4L::P64 + 40];
           _s8v2W::I64 = I64[_s8v4L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v54_entry() //  [R1]
         { info_tbl: [(c8vuc,
                       label: sat_s8v54_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vuc: // global
           _s8v54::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vud; else goto c8vue;
       c8vue: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vug; else goto c8vuf;
       c8vug: // global
           HpAlloc = 56;
           goto c8vud;
       c8vud: // global
           R1 = _s8v54::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vuf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v54::P64;
           _s8v2Y::I64 = I64[_s8v54::P64 + 56];
           _s8v50::I64 = I64[_s8v54::P64 + 64];
           if (_s8v50::I64 == _s8v2Y::I64) goto c8vub; else goto c8vua;
       c8vub: // global
           _s8v36::P64 = P64[_s8v54::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vua: // global
           _s8v2U::P64 = P64[_s8v54::P64 + 16];
           _s8v2V::P64 = P64[_s8v54::P64 + 24];
           _s8v2T::I64 = I64[_s8v54::P64 + 40];
           _s8v2W::I64 = I64[_s8v54::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v50::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5k_entry() //  [R1]
         { info_tbl: [(c8vuK,
                       label: sat_s8v5k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vuK: // global
           _s8v5k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vuL; else goto c8vuM;
       c8vuM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vuO; else goto c8vuN;
       c8vuO: // global
           HpAlloc = 56;
           goto c8vuL;
       c8vuL: // global
           R1 = _s8v5k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vuN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5k::P64;
           _s8v2Y::I64 = I64[_s8v5k::P64 + 56];
           _s8v58::I64 = I64[_s8v5k::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8vuJ; else goto c8vuI;
       c8vuJ: // global
           _s8v36::P64 = P64[_s8v5k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vuI: // global
           _s8v2U::P64 = P64[_s8v5k::P64 + 16];
           _s8v2V::P64 = P64[_s8v5k::P64 + 24];
           _s8v2T::I64 = I64[_s8v5k::P64 + 40];
           _s8v2W::I64 = I64[_s8v5k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5s_entry() //  [R1]
         { info_tbl: [(c8vvj,
                       label: sat_s8v5s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vvj: // global
           _s8v5s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vvk; else goto c8vvl;
       c8vvl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vvn; else goto c8vvm;
       c8vvn: // global
           HpAlloc = 56;
           goto c8vvk;
       c8vvk: // global
           R1 = _s8v5s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vvm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5s::P64;
           _s8v2Y::I64 = I64[_s8v5s::P64 + 56];
           _s8v58::I64 = I64[_s8v5s::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8vvi; else goto c8vvh;
       c8vvi: // global
           _s8v36::P64 = P64[_s8v5s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vvh: // global
           _s8v2U::P64 = P64[_s8v5s::P64 + 16];
           _s8v2V::P64 = P64[_s8v5s::P64 + 24];
           _s8v2T::I64 = I64[_s8v5s::P64 + 40];
           _s8v2W::I64 = I64[_s8v5s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5x_entry() //  [R1]
         { info_tbl: [(c8vvE,
                       label: sat_s8v5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vvE: // global
           _s8v5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vvF; else goto c8vvG;
       c8vvG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vvI; else goto c8vvH;
       c8vvI: // global
           HpAlloc = 56;
           goto c8vvF;
       c8vvF: // global
           R1 = _s8v5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vvH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5x::P64;
           _s8v2Y::I64 = I64[_s8v5x::P64 + 56];
           _s8v58::I64 = I64[_s8v5x::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8vvD; else goto c8vvC;
       c8vvD: // global
           _s8v36::P64 = P64[_s8v5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vvC: // global
           _s8v2U::P64 = P64[_s8v5x::P64 + 16];
           _s8v2V::P64 = P64[_s8v5x::P64 + 24];
           _s8v2T::I64 = I64[_s8v5x::P64 + 40];
           _s8v2W::I64 = I64[_s8v5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5C_entry() //  [R1]
         { info_tbl: [(c8vvZ,
                       label: sat_s8v5C_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vvZ: // global
           _s8v5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vw0; else goto c8vw1;
       c8vw1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vw3; else goto c8vw2;
       c8vw3: // global
           HpAlloc = 56;
           goto c8vw0;
       c8vw0: // global
           R1 = _s8v5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vw2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5C::P64;
           _s8v2Y::I64 = I64[_s8v5C::P64 + 56];
           _s8v58::I64 = I64[_s8v5C::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8vvY; else goto c8vvX;
       c8vvY: // global
           _s8v36::P64 = P64[_s8v5C::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vvX: // global
           _s8v2U::P64 = P64[_s8v5C::P64 + 16];
           _s8v2V::P64 = P64[_s8v5C::P64 + 24];
           _s8v2T::I64 = I64[_s8v5C::P64 + 40];
           _s8v2W::I64 = I64[_s8v5C::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5H_entry() //  [R1]
         { info_tbl: [(c8vwk,
                       label: sat_s8v5H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vwk: // global
           _s8v5H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vwl; else goto c8vwm;
       c8vwm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vwo; else goto c8vwn;
       c8vwo: // global
           HpAlloc = 56;
           goto c8vwl;
       c8vwl: // global
           R1 = _s8v5H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vwn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5H::P64;
           _s8v2Y::I64 = I64[_s8v5H::P64 + 56];
           _s8v58::I64 = I64[_s8v5H::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8vwj; else goto c8vwi;
       c8vwj: // global
           _s8v36::P64 = P64[_s8v5H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vwi: // global
           _s8v2U::P64 = P64[_s8v5H::P64 + 16];
           _s8v2V::P64 = P64[_s8v5H::P64 + 24];
           _s8v2T::I64 = I64[_s8v5H::P64 + 40];
           _s8v2W::I64 = I64[_s8v5H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5Z_entry() //  [R1]
         { info_tbl: [(c8vwG,
                       label: sat_s8v5Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vwG: // global
           _s8v5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vwH; else goto c8vwI;
       c8vwI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vwK; else goto c8vwJ;
       c8vwK: // global
           HpAlloc = 56;
           goto c8vwH;
       c8vwH: // global
           R1 = _s8v5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5Z::P64;
           _s8v2Y::I64 = I64[_s8v5Z::P64 + 56];
           _s8v5V::I64 = I64[_s8v5Z::P64 + 64];
           if (_s8v5V::I64 == _s8v2Y::I64) goto c8vwF; else goto c8vwE;
       c8vwF: // global
           _s8v36::P64 = P64[_s8v5Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vwE: // global
           _s8v2U::P64 = P64[_s8v5Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v5Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v5Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v5Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v5V::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v67_entry() //  [R1]
         { info_tbl: [(c8vx2,
                       label: sat_s8v67_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vx2: // global
           _s8v67::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vx3; else goto c8vx4;
       c8vx4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vx6; else goto c8vx5;
       c8vx6: // global
           HpAlloc = 56;
           goto c8vx3;
       c8vx3: // global
           R1 = _s8v67::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vx5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v67::P64;
           _s8v2Y::I64 = I64[_s8v67::P64 + 56];
           _s8v63::I64 = I64[_s8v67::P64 + 64];
           if (_s8v63::I64 == _s8v2Y::I64) goto c8vx1; else goto c8vx0;
       c8vx1: // global
           _s8v36::P64 = P64[_s8v67::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vx0: // global
           _s8v2U::P64 = P64[_s8v67::P64 + 16];
           _s8v2V::P64 = P64[_s8v67::P64 + 24];
           _s8v2T::I64 = I64[_s8v67::P64 + 40];
           _s8v2W::I64 = I64[_s8v67::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v63::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6f_entry() //  [R1]
         { info_tbl: [(c8vxo,
                       label: sat_s8v6f_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vxo: // global
           _s8v6f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vxp; else goto c8vxq;
       c8vxq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vxs; else goto c8vxr;
       c8vxs: // global
           HpAlloc = 56;
           goto c8vxp;
       c8vxp: // global
           R1 = _s8v6f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vxr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6f::P64;
           _s8v2Y::I64 = I64[_s8v6f::P64 + 56];
           _s8v6b::I64 = I64[_s8v6f::P64 + 64];
           if (_s8v6b::I64 == _s8v2Y::I64) goto c8vxn; else goto c8vxm;
       c8vxn: // global
           _s8v36::P64 = P64[_s8v6f::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vxm: // global
           _s8v2U::P64 = P64[_s8v6f::P64 + 16];
           _s8v2V::P64 = P64[_s8v6f::P64 + 24];
           _s8v2T::I64 = I64[_s8v6f::P64 + 40];
           _s8v2W::I64 = I64[_s8v6f::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6b::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6n_entry() //  [R1]
         { info_tbl: [(c8vxK,
                       label: sat_s8v6n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vxK: // global
           _s8v6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vxL; else goto c8vxM;
       c8vxM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vxO; else goto c8vxN;
       c8vxO: // global
           HpAlloc = 56;
           goto c8vxL;
       c8vxL: // global
           R1 = _s8v6n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vxN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6n::P64;
           _s8v2Y::I64 = I64[_s8v6n::P64 + 56];
           _s8v6j::I64 = I64[_s8v6n::P64 + 64];
           if (_s8v6j::I64 == _s8v2Y::I64) goto c8vxJ; else goto c8vxI;
       c8vxJ: // global
           _s8v36::P64 = P64[_s8v6n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vxI: // global
           _s8v2U::P64 = P64[_s8v6n::P64 + 16];
           _s8v2V::P64 = P64[_s8v6n::P64 + 24];
           _s8v2T::I64 = I64[_s8v6n::P64 + 40];
           _s8v2W::I64 = I64[_s8v6n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6j::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6v_entry() //  [R1]
         { info_tbl: [(c8vy6,
                       label: sat_s8v6v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vy6: // global
           _s8v6v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vy7; else goto c8vy8;
       c8vy8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vya; else goto c8vy9;
       c8vya: // global
           HpAlloc = 56;
           goto c8vy7;
       c8vy7: // global
           R1 = _s8v6v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vy9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6v::P64;
           _s8v2Y::I64 = I64[_s8v6v::P64 + 56];
           _s8v6r::I64 = I64[_s8v6v::P64 + 64];
           if (_s8v6r::I64 == _s8v2Y::I64) goto c8vy5; else goto c8vy4;
       c8vy5: // global
           _s8v36::P64 = P64[_s8v6v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vy4: // global
           _s8v2U::P64 = P64[_s8v6v::P64 + 16];
           _s8v2V::P64 = P64[_s8v6v::P64 + 24];
           _s8v2T::I64 = I64[_s8v6v::P64 + 40];
           _s8v2W::I64 = I64[_s8v6v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6r::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7v_entry() //  [R1]
         { info_tbl: [(c8vzD,
                       label: sat_s8v7v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vzD: // global
           _s8v7v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vzE; else goto c8vzF;
       c8vzF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vzH; else goto c8vzG;
       c8vzH: // global
           HpAlloc = 56;
           goto c8vzE;
       c8vzE: // global
           R1 = _s8v7v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vzG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7v::P64;
           _s8v2Y::I64 = I64[_s8v7v::P64 + 56];
           _s8v6z::I64 = I64[_s8v7v::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vzC; else goto c8vzB;
       c8vzC: // global
           _s8v36::P64 = P64[_s8v7v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vzB: // global
           _s8v2U::P64 = P64[_s8v7v::P64 + 16];
           _s8v2V::P64 = P64[_s8v7v::P64 + 24];
           _s8v2T::I64 = I64[_s8v7v::P64 + 40];
           _s8v2W::I64 = I64[_s8v7v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7A_entry() //  [R1]
         { info_tbl: [(c8vzY,
                       label: sat_s8v7A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vzY: // global
           _s8v7A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vzZ; else goto c8vA0;
       c8vA0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vA2; else goto c8vA1;
       c8vA2: // global
           HpAlloc = 56;
           goto c8vzZ;
       c8vzZ: // global
           R1 = _s8v7A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vA1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7A::P64;
           _s8v2Y::I64 = I64[_s8v7A::P64 + 56];
           _s8v6z::I64 = I64[_s8v7A::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vzX; else goto c8vzW;
       c8vzX: // global
           _s8v36::P64 = P64[_s8v7A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vzW: // global
           _s8v2U::P64 = P64[_s8v7A::P64 + 16];
           _s8v2V::P64 = P64[_s8v7A::P64 + 24];
           _s8v2T::I64 = I64[_s8v7A::P64 + 40];
           _s8v2W::I64 = I64[_s8v7A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7F_entry() //  [R1]
         { info_tbl: [(c8vAj,
                       label: sat_s8v7F_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vAj: // global
           _s8v7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vAk; else goto c8vAl;
       c8vAl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vAn; else goto c8vAm;
       c8vAn: // global
           HpAlloc = 56;
           goto c8vAk;
       c8vAk: // global
           R1 = _s8v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vAm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7F::P64;
           _s8v2Y::I64 = I64[_s8v7F::P64 + 56];
           _s8v6z::I64 = I64[_s8v7F::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vAi; else goto c8vAh;
       c8vAi: // global
           _s8v36::P64 = P64[_s8v7F::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vAh: // global
           _s8v2U::P64 = P64[_s8v7F::P64 + 16];
           _s8v2V::P64 = P64[_s8v7F::P64 + 24];
           _s8v2T::I64 = I64[_s8v7F::P64 + 40];
           _s8v2W::I64 = I64[_s8v7F::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7K_entry() //  [R1]
         { info_tbl: [(c8vAE,
                       label: sat_s8v7K_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vAE: // global
           _s8v7K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vAF; else goto c8vAG;
       c8vAG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vAI; else goto c8vAH;
       c8vAI: // global
           HpAlloc = 56;
           goto c8vAF;
       c8vAF: // global
           R1 = _s8v7K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vAH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7K::P64;
           _s8v2Y::I64 = I64[_s8v7K::P64 + 56];
           _s8v6z::I64 = I64[_s8v7K::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vAD; else goto c8vAC;
       c8vAD: // global
           _s8v36::P64 = P64[_s8v7K::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vAC: // global
           _s8v2U::P64 = P64[_s8v7K::P64 + 16];
           _s8v2V::P64 = P64[_s8v7K::P64 + 24];
           _s8v2T::I64 = I64[_s8v7K::P64 + 40];
           _s8v2W::I64 = I64[_s8v7K::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7P_entry() //  [R1]
         { info_tbl: [(c8vAZ,
                       label: sat_s8v7P_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vAZ: // global
           _s8v7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vB0; else goto c8vB1;
       c8vB1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vB3; else goto c8vB2;
       c8vB3: // global
           HpAlloc = 56;
           goto c8vB0;
       c8vB0: // global
           R1 = _s8v7P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vB2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7P::P64;
           _s8v2Y::I64 = I64[_s8v7P::P64 + 56];
           _s8v6z::I64 = I64[_s8v7P::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vAY; else goto c8vAX;
       c8vAY: // global
           _s8v36::P64 = P64[_s8v7P::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vAX: // global
           _s8v2U::P64 = P64[_s8v7P::P64 + 16];
           _s8v2V::P64 = P64[_s8v7P::P64 + 24];
           _s8v2T::I64 = I64[_s8v7P::P64 + 40];
           _s8v2W::I64 = I64[_s8v7P::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7U_entry() //  [R1]
         { info_tbl: [(c8vBk,
                       label: sat_s8v7U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vBk: // global
           _s8v7U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vBl; else goto c8vBm;
       c8vBm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vBo; else goto c8vBn;
       c8vBo: // global
           HpAlloc = 56;
           goto c8vBl;
       c8vBl: // global
           R1 = _s8v7U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vBn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7U::P64;
           _s8v2Y::I64 = I64[_s8v7U::P64 + 56];
           _s8v6z::I64 = I64[_s8v7U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vBj; else goto c8vBi;
       c8vBj: // global
           _s8v36::P64 = P64[_s8v7U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vBi: // global
           _s8v2U::P64 = P64[_s8v7U::P64 + 16];
           _s8v2V::P64 = P64[_s8v7U::P64 + 24];
           _s8v2T::I64 = I64[_s8v7U::P64 + 40];
           _s8v2W::I64 = I64[_s8v7U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7Z_entry() //  [R1]
         { info_tbl: [(c8vBF,
                       label: sat_s8v7Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vBF: // global
           _s8v7Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vBG; else goto c8vBH;
       c8vBH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vBJ; else goto c8vBI;
       c8vBJ: // global
           HpAlloc = 56;
           goto c8vBG;
       c8vBG: // global
           R1 = _s8v7Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vBI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7Z::P64;
           _s8v2Y::I64 = I64[_s8v7Z::P64 + 56];
           _s8v6z::I64 = I64[_s8v7Z::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vBE; else goto c8vBD;
       c8vBE: // global
           _s8v36::P64 = P64[_s8v7Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vBD: // global
           _s8v2U::P64 = P64[_s8v7Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v7Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v7Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v7Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8R_entry() //  [R1]
         { info_tbl: [(c8vCI,
                       label: sat_s8v8R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vCI: // global
           _s8v8R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vCJ; else goto c8vCK;
       c8vCK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vCM; else goto c8vCL;
       c8vCM: // global
           HpAlloc = 56;
           goto c8vCJ;
       c8vCJ: // global
           R1 = _s8v8R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vCL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8R::P64;
           _s8v2Y::I64 = I64[_s8v8R::P64 + 56];
           _s8v6z::I64 = I64[_s8v8R::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vCH; else goto c8vCG;
       c8vCH: // global
           _s8v36::P64 = P64[_s8v8R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vCG: // global
           _s8v2U::P64 = P64[_s8v8R::P64 + 16];
           _s8v2V::P64 = P64[_s8v8R::P64 + 24];
           _s8v2T::I64 = I64[_s8v8R::P64 + 40];
           _s8v2W::I64 = I64[_s8v8R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8W_entry() //  [R1]
         { info_tbl: [(c8vD3,
                       label: sat_s8v8W_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vD3: // global
           _s8v8W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vD4; else goto c8vD5;
       c8vD5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vD7; else goto c8vD6;
       c8vD7: // global
           HpAlloc = 56;
           goto c8vD4;
       c8vD4: // global
           R1 = _s8v8W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vD6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8W::P64;
           _s8v2Y::I64 = I64[_s8v8W::P64 + 56];
           _s8v6z::I64 = I64[_s8v8W::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vD2; else goto c8vD1;
       c8vD2: // global
           _s8v36::P64 = P64[_s8v8W::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vD1: // global
           _s8v2U::P64 = P64[_s8v8W::P64 + 16];
           _s8v2V::P64 = P64[_s8v8W::P64 + 24];
           _s8v2T::I64 = I64[_s8v8W::P64 + 40];
           _s8v2W::I64 = I64[_s8v8W::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v91_entry() //  [R1]
         { info_tbl: [(c8vDo,
                       label: sat_s8v91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vDo: // global
           _s8v91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vDp; else goto c8vDq;
       c8vDq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vDs; else goto c8vDr;
       c8vDs: // global
           HpAlloc = 56;
           goto c8vDp;
       c8vDp: // global
           R1 = _s8v91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vDr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v91::P64;
           _s8v2Y::I64 = I64[_s8v91::P64 + 56];
           _s8v6z::I64 = I64[_s8v91::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vDn; else goto c8vDm;
       c8vDn: // global
           _s8v36::P64 = P64[_s8v91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vDm: // global
           _s8v2U::P64 = P64[_s8v91::P64 + 16];
           _s8v2V::P64 = P64[_s8v91::P64 + 24];
           _s8v2T::I64 = I64[_s8v91::P64 + 40];
           _s8v2W::I64 = I64[_s8v91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v96_entry() //  [R1]
         { info_tbl: [(c8vDJ,
                       label: sat_s8v96_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vDJ: // global
           _s8v96::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vDK; else goto c8vDL;
       c8vDL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vDN; else goto c8vDM;
       c8vDN: // global
           HpAlloc = 56;
           goto c8vDK;
       c8vDK: // global
           R1 = _s8v96::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vDM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v96::P64;
           _s8v2Y::I64 = I64[_s8v96::P64 + 56];
           _s8v6z::I64 = I64[_s8v96::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vDI; else goto c8vDH;
       c8vDI: // global
           _s8v36::P64 = P64[_s8v96::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vDH: // global
           _s8v2U::P64 = P64[_s8v96::P64 + 16];
           _s8v2V::P64 = P64[_s8v96::P64 + 24];
           _s8v2T::I64 = I64[_s8v96::P64 + 40];
           _s8v2W::I64 = I64[_s8v96::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9b_entry() //  [R1]
         { info_tbl: [(c8vE4,
                       label: sat_s8v9b_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vE4: // global
           _s8v9b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vE5; else goto c8vE6;
       c8vE6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vE8; else goto c8vE7;
       c8vE8: // global
           HpAlloc = 56;
           goto c8vE5;
       c8vE5: // global
           R1 = _s8v9b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vE7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9b::P64;
           _s8v2Y::I64 = I64[_s8v9b::P64 + 56];
           _s8v6z::I64 = I64[_s8v9b::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vE3; else goto c8vE2;
       c8vE3: // global
           _s8v36::P64 = P64[_s8v9b::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vE2: // global
           _s8v2U::P64 = P64[_s8v9b::P64 + 16];
           _s8v2V::P64 = P64[_s8v9b::P64 + 24];
           _s8v2T::I64 = I64[_s8v9b::P64 + 40];
           _s8v2W::I64 = I64[_s8v9b::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9U_entry() //  [R1]
         { info_tbl: [(c8vEt,
                       label: sat_s8v9U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vEt: // global
           _s8v9U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8vEu; else goto c8vEv;
       c8vEv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vEx; else goto c8vEw;
       c8vEx: // global
           HpAlloc = 56;
           goto c8vEu;
       c8vEu: // global
           R1 = _s8v9U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vEw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9U::P64;
           _s8v2Y::I64 = I64[_s8v9U::P64 + 56];
           _s8v6z::I64 = I64[_s8v9U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8vEs; else goto c8vEr;
       c8vEs: // global
           _s8v36::P64 = P64[_s8v9U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8vEr: // global
           _s8v2U::P64 = P64[_s8v9U::P64 + 16];
           _s8v2V::P64 = P64[_s8v9U::P64 + 24];
           _s8v2T::I64 = I64[_s8v9U::P64 + 40];
           _s8v2W::I64 = I64[_s8v9U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF4_entry() //  [R2, R3]
         { info_tbl: [(c8vEA,
                       label: GHC.IO.Encoding.UTF8.mkUTF4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vEA: // global
           if ((Sp + -144) < SpLim) (likely: False) goto c8vEB; else goto c8vEC;
       c8vEB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vEC: // global
           I64[Sp - 16] = block_c8voT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8vTi; else goto c8voU;
       u8vTi: // global
           call _c8voT(R1) args: 0, res: 0, upd: 0;
       c8voU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8voT() //  [R1]
         { info_tbl: [(c8voT,
                       label: block_c8voT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8voT: // global
           I64[Sp - 40] = block_c8voY_info;
           _s8v2U::P64 = P64[R1 + 7];
           _s8v2V::P64 = P64[R1 + 15];
           _s8v2T::I64 = I64[R1 + 23];
           _s8v2W::I64 = I64[R1 + 31];
           _s8v2X::I64 = I64[R1 + 39];
           _s8v2Y::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8v2V::P64;
           I64[Sp - 24] = _s8v2W::I64;
           I64[Sp - 16] = _s8v2X::I64;
           I64[Sp - 8] = _s8v2Y::I64;
           P64[Sp] = _s8v2U::P64;
           I64[Sp + 8] = _s8v2T::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8vSp; else goto c8voZ;
       u8vSp: // global
           call _c8voY(R1) args: 0, res: 0, upd: 0;
       c8voZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8voY() //  [R1]
         { info_tbl: [(c8voY,
                       label: block_c8voY_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8voY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vEG; else goto c8vEF;
       c8vEG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vEF: // global
           _s8v31::P64 = P64[R1 + 7];
           _s8v32::P64 = P64[R1 + 15];
           _s8v30::I64 = I64[R1 + 23];
           _s8v33::I64 = I64[R1 + 31];
           _s8v34::I64 = I64[R1 + 39];
           _s8v35::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8v31::P64;
           P64[Sp - 40] = _s8v32::P64;
           I64[Sp - 32] = _s8v33::I64;
           I64[Sp - 24] = _s8v34::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8v35::I64;
           I64[Sp] = _s8v30::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8vyf() args: 0, res: 0, upd: 0;
     }
 },
 _c8vyf() //  []
         { info_tbl: [(c8vyf,
                       label: block_c8vyf_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vyf: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJl; else goto c8vJk;
       c8vJl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vyf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJk: // global
           _s8v33::I64 = I64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 40];
           _s8v6A::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8v6A::I64,
                            _s8v33::I64)) goto c8vPm; else goto c8vPn;
       c8vPm: // global
           _s8v2Y::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8v6z::I64,
                            _s8v2Y::I64)) goto c8vPj; else goto c8vPk;
       c8vPj: // global
           _c8vp3::P64 = P64[Sp + 80];
           _s8v2T::I64 = I64[Sp + 104];
           _s8v2U::P64 = P64[Sp + 96];
           _s8v2V::P64 = P64[Sp + 64];
           _s8v2W::I64 = I64[Sp + 72];
           _s8v30::I64 = I64[Sp + 56];
           _s8v31::P64 = P64[Sp + 8];
           _s8v32::P64 = P64[Sp + 16];
           _s8v34::I64 = I64[Sp + 32];
           _s8v6H::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + _s8v6z::I64]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 > 127) goto c8vPg; else goto c8vPh;
       c8vPg: // global
           if (_s8v6H::I64 < 192) goto c8vPb; else goto c8vPe;
       c8vPe: // global
           if (_s8v6H::I64 > 193) goto c8vPb; else goto c8vPd;
       c8vPb: // global
           Hp = Hp - 160;
           if (_s8v6H::I64 < 194) goto s8v6L; else goto c8vP7;
       c8vP7: // global
           if (_s8v6H::I64 > 223) goto s8v6L; else goto c8vP6;
       s8v6L: // global
           if (_s8v6H::I64 < 224) goto s8v6M; else goto c8vOs;
       c8vOs: // global
           if (_s8v6H::I64 > 239) goto s8v6M; else goto c8vOr;
       s8v6M: // global
           if (_s8v6H::I64 < 240) goto c8vJq; else goto c8vLY;
       c8vJq: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vp6() args: 0, res: 0, upd: 0;
       c8vLY: // global
           _s8v6O::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (%MO_S_Lt_W64(_s8v6O::I64, 3)) goto u8vRr; else goto u8vRt;
       u8vRr: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 2)) goto u8vRs; else goto c8vLO;
       u8vRs: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 1)) goto c8vJs; else goto c8vLI;
       c8vLI: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vps() args: 0, res: 0, upd: 0;
       c8vLO: // global
           _s8v3w::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v3q::I64 = _s8v6H::I64;
           _s8v3p::I64 = _s8v6A::I64;
           _s8v3o::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v3D; else goto c8vFR;
       c8vFR: // global
           if (_s8v3w::I64 < 144) goto s8v3D; else goto c8vFQ;
       c8vFQ: // global
           if (_s8v3w::I64 > 191) goto s8v3D; else goto u8vRy;
       s8v3D: // global
           if (_s8v3q::I64 < 241) goto u8vRz; else goto c8vFz;
       u8vRz: // global
           I64[Sp - 8] = _s8v3w::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           Sp = Sp - 16;
           goto u8vSB;
       c8vFz: // global
           if (_s8v3q::I64 > 243) goto u8vRA; else goto c8vFy;
       u8vRA: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8vSB;
       c8vFy: // global
           if (_s8v3w::I64 < 128) goto u8vRB; else goto c8vFx;
       u8vRB: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8vSB;
       c8vFx: // global
           if (_s8v3w::I64 > 191) goto u8vRD; else goto u8vRC;
       u8vRD: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8vSB;
       u8vSB: // global
           call _c8vqs() args: 0, res: 0, upd: 0;
       u8vRC: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           goto u8vSA;
       u8vRy: // global
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           goto u8vSA;
       u8vSA: // global
           call _c8vq1() args: 0, res: 0, upd: 0;
       u8vRt: // global
           if (%MO_S_Ge_W64(_s8v6O::I64, 4)) goto c8vJs; else goto c8vLU;
       c8vJs: // global
           _s8v6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v75::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 3)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 240) goto s8v7r; else goto c8vLF;
       c8vLF: // global
           if (_s8v6T::I64 < 144) goto s8v7r; else goto c8vLE;
       c8vLE: // global
           if (_s8v6T::I64 > 191) goto s8v7r; else goto c8vLD;
       c8vLD: // global
           if (_s8v6Z::I64 < 128) goto s8v7r; else goto c8vLC;
       c8vLC: // global
           if (_s8v6Z::I64 > 191) goto s8v7r; else goto c8vLB;
       c8vLB: // global
           if (_s8v75::I64 < 128) goto s8v7r; else goto c8vLA;
       c8vLA: // global
           if (_s8v75::I64 > 191) goto s8v7r; else goto u8vRO;
       s8v7r: // global
           if (_s8v6H::I64 < 241) goto u8vRP; else goto c8vKV;
       u8vRP: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKV: // global
           if (_s8v6H::I64 > 243) goto u8vRQ; else goto c8vKU;
       u8vRQ: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKU: // global
           if (_s8v6T::I64 < 128) goto u8vRR; else goto c8vKT;
       u8vRR: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKT: // global
           if (_s8v6T::I64 > 191) goto u8vRS; else goto c8vKS;
       u8vRS: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKS: // global
           if (_s8v6Z::I64 < 128) goto u8vRT; else goto c8vKR;
       u8vRT: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKR: // global
           if (_s8v6Z::I64 > 191) goto u8vRU; else goto c8vKQ;
       u8vRU: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKQ: // global
           if (_s8v75::I64 < 128) goto u8vRV; else goto c8vKP;
       u8vRV: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       c8vKP: // global
           if (_s8v75::I64 > 191) goto u8vRX; else goto u8vRW;
       u8vRX: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8vST;
       u8vST: // global
           call _c8vzp() args: 0, res: 0, upd: 0;
       u8vRW: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 24;
           goto u8vSS;
       u8vRO: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8vSS;
       u8vSS: // global
           call _s8v77() args: 0, res: 0, upd: 0;
       c8vLU: // global
           _s8v4a::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v4g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v44::I64 = _s8v6H::I64;
           _s8v43::I64 = _s8v6A::I64;
           _s8v42::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v4n; else goto c8vHu;
       c8vHu: // global
           if (_s8v4a::I64 < 144) goto s8v4n; else goto c8vHt;
       c8vHt: // global
           if (_s8v4a::I64 > 191) goto s8v4n; else goto c8vHs;
       c8vHs: // global
           if (_s8v4g::I64 < 128) goto s8v4n; else goto c8vHr;
       c8vHr: // global
           if (_s8v4g::I64 > 191) goto s8v4n; else goto u8vRF;
       s8v4n: // global
           if (_s8v44::I64 < 241) goto u8vRG; else goto c8vGY;
       u8vRG: // global
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       c8vGY: // global
           if (_s8v44::I64 > 243) goto u8vRH; else goto c8vGX;
       u8vRH: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       c8vGX: // global
           if (_s8v4a::I64 < 128) goto u8vRI; else goto c8vGW;
       u8vRI: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       c8vGW: // global
           if (_s8v4a::I64 > 191) goto u8vRJ; else goto c8vGV;
       u8vRJ: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       c8vGV: // global
           if (_s8v4g::I64 < 128) goto u8vRK; else goto c8vGU;
       u8vRK: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       c8vGU: // global
           if (_s8v4g::I64 > 191) goto u8vRM; else goto u8vRL;
       u8vRM: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8vSJ;
       u8vSJ: // global
           call _c8vsg() args: 0, res: 0, upd: 0;
       u8vRL: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           goto u8vSI;
       u8vRF: // global
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           goto u8vSI;
       u8vSI: // global
           call _c8vrP() args: 0, res: 0, upd: 0;
       c8vOr: // global
           _s8v8j::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (_s8v8j::I64 != 1) goto u8vRu; else goto c8vOh;
       u8vRu: // global
           if (_s8v8j::I64 != 2) goto c8vM4; else goto c8vOn;
       c8vM4: // global
           _s8v8o::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v8u::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 224) goto s8v8M; else goto c8vOe;
       c8vOe: // global
           if (_s8v8o::I64 < 160) goto s8v8M; else goto c8vOd;
       c8vOd: // global
           if (_s8v8o::I64 > 191) goto s8v8M; else goto c8vOc;
       c8vOc: // global
           if (_s8v8u::I64 < 128) goto s8v8M; else goto c8vOb;
       c8vOb: // global
           if (_s8v8u::I64 > 191) goto s8v8M; else goto u8vS0;
       s8v8M: // global
           if (_s8v6H::I64 < 225) goto s8v8N; else goto c8vNI;
       c8vNI: // global
           if (_s8v6H::I64 > 236) goto s8v8N; else goto c8vNH;
       c8vNH: // global
           if (_s8v8o::I64 < 128) goto s8v8N; else goto c8vNG;
       c8vNG: // global
           if (_s8v8o::I64 > 191) goto s8v8N; else goto c8vNF;
       c8vNF: // global
           if (_s8v8u::I64 < 128) goto s8v8N; else goto c8vNE;
       c8vNE: // global
           if (_s8v8u::I64 > 191) goto s8v8N; else goto u8vS1;
       s8v8N: // global
           if (_s8v6H::I64 == 237) goto c8vN4; else goto u8vS2;
       c8vN4: // global
           if (_s8v8o::I64 < 128) goto u8vS3; else goto c8vN3;
       u8vS3: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8vT1;
       c8vN3: // global
           if (_s8v8o::I64 > 159) goto u8vS4; else goto c8vN2;
       u8vS4: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8vT1;
       c8vN2: // global
           if (_s8v8u::I64 < 128) goto u8vS5; else goto c8vN1;
       u8vS5: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8vT1;
       c8vN1: // global
           if (_s8v8u::I64 > 191) goto u8vS7; else goto u8vS6;
       u8vS7: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8vT1;
       u8vS6: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8vT0;
       u8vS2: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8vT1;
       u8vT1: // global
           call _c8vCt() args: 0, res: 0, upd: 0;
       u8vS1: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8vT0;
       u8vS0: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 16;
           goto u8vT0;
       u8vT0: // global
           call _s8v8w() args: 0, res: 0, upd: 0;
       c8vOn: // global
           _s8v5g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v5a::I64 = _s8v6H::I64;
           _s8v59::I64 = _s8v6A::I64;
           _s8v58::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 224) goto s8v5n; else goto c8vIY;
       c8vIY: // global
           if (_s8v5g::I64 < 160) goto s8v5n; else goto c8vIX;
       c8vIX: // global
           if (_s8v5g::I64 > 191) goto s8v5n; else goto u8vSa;
       s8v5n: // global
           if (_s8v5a::I64 < 225) goto s8v5o; else goto c8vIG;
       c8vIG: // global
           if (_s8v5a::I64 > 236) goto s8v5o; else goto c8vIF;
       c8vIF: // global
           if (_s8v5g::I64 < 128) goto s8v5o; else goto c8vIE;
       c8vIE: // global
           if (_s8v5g::I64 > 191) goto s8v5o; else goto u8vSb;
       s8v5o: // global
           if (_s8v5a::I64 == 237) goto c8vIg; else goto u8vSc;
       c8vIg: // global
           if (_s8v5g::I64 < 128) goto u8vSd; else goto c8vIf;
       u8vSd: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8vT7;
       c8vIf: // global
           if (_s8v5g::I64 > 159) goto u8vSf; else goto u8vSe;
       u8vSf: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8vT7;
       u8vSe: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8vT6;
       u8vSc: // global
           I64[Sp - 8] = _s8v5g::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           Sp = Sp - 16;
           goto u8vT7;
       u8vT7: // global
           call _c8vv4() args: 0, res: 0, upd: 0;
       u8vSb: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8vT6;
       u8vSa: // global
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           goto u8vT6;
       u8vT6: // global
           call _c8vuy() args: 0, res: 0, upd: 0;
       c8vOh: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vtZ() args: 0, res: 0, upd: 0;
       c8vP6: // global
           if (%MO_S_Ge_W64(_s8v2Y::I64 - _s8v6z::I64,
                            2)) goto c8vP4; else goto c8vP5;
       c8vP4: // global
           _s8v9C::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v9C::I64 >= 128) goto c8vP1; else goto c8vP2;
       c8vP1: // global
           if (_s8v9C::I64 < 192) goto c8vOY; else goto c8vOZ;
       c8vOY: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8v6H::I64 + -192) << 6) + (_s8v9C::I64 + -128));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 40] = _s8v6z::I64 + 2;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8vTd;
       c8vOZ: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vwt() args: 0, res: 0, upd: 0;
       c8vP2: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vwP() args: 0, res: 0, upd: 0;
       c8vP5: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vxb() args: 0, res: 0, upd: 0;
       c8vPd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vPh: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8v6H::I64);
           call MO_Touch(_s8v31::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6z::I64 + 1;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8vTd;
       u8vTd: // global
           call _c8vyf() args: 0, res: 0, upd: 0;
       c8vPk: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vxx() args: 0, res: 0, upd: 0;
       c8vPn: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8vxT() args: 0, res: 0, upd: 0;
     }
 },
 _c8vp6() //  []
         { info_tbl: [(c8vp6,
                       label: block_c8vp6_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vp6: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vEK; else goto c8vEJ;
       c8vEK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vp6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vEJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vps() //  []
         { info_tbl: [(c8vps,
                       label: block_c8vps_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vps: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vEO; else goto c8vEN;
       c8vEO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vps_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vEN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vqs() //  []
         { info_tbl: [(c8vqs,
                       label: block_c8vqs_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vqs: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vEX; else goto c8vEW;
       c8vEX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vqs_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vEW: // global
           _c8vp3::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v3o::I64 = I64[Sp + 64];
           _s8v3p::I64 = I64[Sp + 56];
           if (I64[Sp + 16] == 244) goto c8vF9; else goto c8vF0;
       c8vF9: // global
           _s8v3w::I64 = I64[Sp + 8];
           if (_s8v3w::I64 < 128) goto c8vF3; else goto c8vF8;
       c8vF3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3M_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vF8: // global
           if (_s8v3w::I64 > 143) goto c8vF6; else goto c8vF7;
       c8vF6: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vF7: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8vq1() args: 0, res: 0, upd: 0;
       c8vF0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vq1() //  []
         { info_tbl: [(c8vq1,
                       label: block_c8vq1_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vq1: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vET; else goto c8vES;
       c8vET: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vq1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vES: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vsg() //  []
         { info_tbl: [(c8vsg,
                       label: block_c8vsg_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vsg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vG0; else goto c8vFZ;
       c8vG0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vsg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vFZ: // global
           _c8vp3::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v42::I64 = I64[Sp + 72];
           _s8v43::I64 = I64[Sp + 64];
           if (I64[Sp + 24] == 244) goto c8vGk; else goto c8vG3;
       c8vGk: // global
           _s8v4a::I64 = I64[Sp + 8];
           if (_s8v4a::I64 < 128) goto c8vG6; else goto c8vGj;
       c8vG6: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4w_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vGj: // global
           if (_s8v4a::I64 > 143) goto c8vG9; else goto c8vGi;
       c8vG9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4B_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vGi: // global
           _s8v4g::I64 = I64[Sp + 16];
           if (_s8v4g::I64 < 128) goto c8vGc; else goto c8vGh;
       c8vGc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4G_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vGh: // global
           if (_s8v4g::I64 > 191) goto c8vGf; else goto c8vGg;
       c8vGf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4L_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vGg: // global
           Hp = Hp - 160;
           Sp = Sp + 24;
           call _c8vrP() args: 0, res: 0, upd: 0;
       c8vG3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4r_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vrP() //  []
         { info_tbl: [(c8vrP,
                       label: block_c8vrP_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vrP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vFW; else goto c8vFV;
       c8vFW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vrP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vFV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v4k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vzp() //  []
         { info_tbl: [(c8vzp,
                       label: block_c8vzp_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vzp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJB; else goto c8vJA;
       c8vJB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vzp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJA: // global
           _c8vp3::P64 = P64[Sp + 112];
           _s8v2T::I64 = I64[Sp + 136];
           _s8v2U::P64 = P64[Sp + 128];
           _s8v2V::P64 = P64[Sp + 96];
           _s8v2W::I64 = I64[Sp + 104];
           _s8v2Y::I64 = I64[Sp + 120];
           _s8v30::I64 = I64[Sp + 88];
           _s8v31::P64 = P64[Sp + 40];
           _s8v32::P64 = P64[Sp + 48];
           _s8v33::I64 = I64[Sp + 56];
           _s8v34::I64 = I64[Sp + 64];
           _s8v6z::I64 = I64[Sp + 72];
           _s8v6A::I64 = I64[Sp + 80];
           if (I64[Sp + 32] == 244) goto c8vK3; else goto c8vJE;
       c8vK3: // global
           _s8v6T::I64 = I64[Sp + 8];
           if (_s8v6T::I64 < 128) goto c8vJH; else goto c8vK2;
       c8vJH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7A_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vK2: // global
           if (_s8v6T::I64 > 143) goto c8vJK; else goto c8vK1;
       c8vJK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7F_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vK1: // global
           _s8v6Z::I64 = I64[Sp + 16];
           if (_s8v6Z::I64 < 128) goto c8vJN; else goto c8vK0;
       c8vJN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7K_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vK0: // global
           if (_s8v6Z::I64 > 191) goto c8vJQ; else goto c8vJZ;
       c8vJQ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7P_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vJZ: // global
           _s8v75::I64 = I64[Sp + 24];
           if (_s8v75::I64 < 128) goto c8vJT; else goto c8vJY;
       c8vJT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vJY: // global
           if (_s8v75::I64 > 191) goto c8vJW; else goto c8vJX;
       c8vJW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7Z_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vJX: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v77() args: 0, res: 0, upd: 0;
       c8vJE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7v_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s8v77() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v77: // global
           _s8v31::P64 = P64[Sp + 32];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           I32[I64[Sp + 80] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 24] - 240 << 18) + ((I64[Sp] - 128 << 12) + ((I64[Sp + 8] - 128 << 6) + (I64[Sp + 16] - 128))));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 64] = _s8v6z::I64 + 4;
           I64[Sp + 72] = _s8v6A::I64 + 1;
           Sp = Sp + 24;
           call _c8vyf() args: 0, res: 0, upd: 0;
     }
 },
 _c8vCt() //  []
         { info_tbl: [(c8vCt,
                       label: block_c8vCt_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vCt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vMe; else goto c8vMd;
       c8vMe: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vCt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vMd: // global
           _c8vp3::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           if (I64[Sp + 24] < 238) goto c8vMh; else goto c8vMy;
       c8vMh: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vMy: // global
           _s8v8o::I64 = I64[Sp + 8];
           if (_s8v8o::I64 < 128) goto c8vMk; else goto c8vMx;
       c8vMk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8W_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vMx: // global
           if (_s8v8o::I64 > 191) goto c8vMn; else goto c8vMw;
       c8vMn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v91_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vMw: // global
           _s8v8u::I64 = I64[Sp + 16];
           if (_s8v8u::I64 < 128) goto c8vMq; else goto c8vMv;
       c8vMq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v96_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vMv: // global
           if (_s8v8u::I64 > 191) goto c8vMt; else goto c8vMu;
       c8vMt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9b_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vMu: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v8w() args: 0, res: 0, upd: 0;
     }
 },
 _s8v8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v8w: // global
           _s8v31::P64 = P64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 56];
           _s8v6A::I64 = I64[Sp + 64];
           I32[I64[Sp + 72] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 16] - 224 << 12) + ((I64[Sp] - 128 << 6) + (I64[Sp + 8] - 128)));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 56] = _s8v6z::I64 + 3;
           I64[Sp + 64] = _s8v6A::I64 + 1;
           Sp = Sp + 16;
           call _c8vyf() args: 0, res: 0, upd: 0;
     }
 },
 _c8vv4() //  []
         { info_tbl: [(c8vv4,
                       label: block_c8vv4_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vv4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vHI; else goto c8vHH;
       c8vHI: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vv4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vHH: // global
           _c8vp3::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v58::I64 = I64[Sp + 64];
           _s8v59::I64 = I64[Sp + 56];
           _s8v5a::I64 = I64[Sp + 16];
           if (_s8v5a::I64 < 238) goto c8vHL; else goto c8vHY;
       c8vHL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5s_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vHY: // global
           if (_s8v5a::I64 > 239) goto c8vHO; else goto c8vHX;
       c8vHO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5x_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vHX: // global
           _s8v5g::I64 = I64[Sp + 8];
           if (_s8v5g::I64 < 128) goto c8vHR; else goto c8vHW;
       c8vHR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5C_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vHW: // global
           if (_s8v5g::I64 > 191) goto c8vHU; else goto c8vHV;
       c8vHU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8vp3::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vHV: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8vuy() args: 0, res: 0, upd: 0;
     }
 },
 _c8vuy() //  []
         { info_tbl: [(c8vuy,
                       label: block_c8vuy_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vuy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vHD; else goto c8vHC;
       c8vHD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vuy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vHC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vtZ() //  []
         { info_tbl: [(c8vtZ,
                       label: block_c8vtZ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vtZ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vHy; else goto c8vHx;
       c8vHy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vtZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vHx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v54_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vwt() //  []
         { info_tbl: [(c8vwt,
                       label: block_c8vwt_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vwt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJ2; else goto c8vJ1;
       c8vJ2: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vwt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJ1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5Z_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vwP() //  []
         { info_tbl: [(c8vwP,
                       label: block_c8vwP_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vwP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJ6; else goto c8vJ5;
       c8vJ6: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vwP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJ5: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v67_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vxb() //  []
         { info_tbl: [(c8vxb,
                       label: block_c8vxb_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vxb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJa; else goto c8vJ9;
       c8vJa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vxb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJ9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6f_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vxx() //  []
         { info_tbl: [(c8vxx,
                       label: block_c8vxx_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vxx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJe; else goto c8vJd;
       c8vJe: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vxx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vxT() //  []
         { info_tbl: [(c8vxT,
                       label: block_c8vxT_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vxT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8vJi; else goto c8vJh;
       c8vJi: // global
           HpAlloc = 160;
           I64[Sp] = block_c8vxT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJh: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.789113898 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes:
         I8[] [85,84,70,45,56,66,79,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.790071524 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom1_entry() //  [R1]
         { info_tbl: [(c8vTr,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vTr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vTs; else goto c8vTt;
       c8vTs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vTt: // global
           (_c8vTo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8vTo::I64 == 0) goto c8vTq; else goto c8vTp;
       c8vTq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8vTp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8vTo::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.791105332 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF3_closure" {
     GHC.IO.Encoding.UTF8.mkUTF3_closure:
         const GHC.IO.Encoding.UTF8.mkUTF3_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF3_entry() //  []
         { info_tbl: [(c8vTy,
                       label: GHC.IO.Encoding.UTF8.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vTy: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.795346065 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_info;
         const 0;
 },
 sat_s8vbM_entry() //  [R1, R2]
         { info_tbl: [(c8vTU,
                       label: sat_s8vbM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vTU: // global
           _s8vb9::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbI_entry() //  [R1]
         { info_tbl: [(c8vU3,
                       label: sat_s8vbI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vU3: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vUb,
                       label: sat_s8vbG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vUb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vUm,
                       label: sat_s8vbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vUm: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8vUn; else goto c8vUo;
       c8vUn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vUo: // global
           I64[Sp - 24] = block_c8vUj_info;
           _s8vb9::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8vb9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8vVi; else goto c8vUk;
       u8vVi: // global
           call _c8vUj(R1) args: 0, res: 0, upd: 0;
       c8vUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vUj() //  [R1]
         { info_tbl: [(c8vUj,
                       label: block_c8vUj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vUj: // global
           _s8vbm::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8vUr_info;
           _s8vbd::P64 = R1;
           _s8vbf::P64 = P64[R1 + 7];
           _s8vbg::P64 = P64[R1 + 15];
           _s8vbe::I64 = I64[R1 + 23];
           _s8vbh::I64 = I64[R1 + 31];
           _s8vbi::I64 = I64[R1 + 39];
           _s8vbj::I64 = I64[R1 + 47];
           R1 = _s8vbm::P64;
           I64[Sp - 48] = _s8vbe::I64;
           P64[Sp - 40] = _s8vbf::P64;
           P64[Sp - 32] = _s8vbg::P64;
           I64[Sp - 24] = _s8vbh::I64;
           I64[Sp - 16] = _s8vbi::I64;
           I64[Sp - 8] = _s8vbj::I64;
           P64[Sp] = _s8vbd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8vVh; else goto c8vUt;
       u8vVh: // global
           call _c8vUr(R1) args: 0, res: 0, upd: 0;
       c8vUt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vUr() //  [R1]
         { info_tbl: [(c8vUr,
                       label: block_c8vUr_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vUr: // global
           _s8vba::P64 = P64[Sp + 72];
           _s8vbd::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8vUz; else goto c8vUA;
       c8vUz: // global
           R3 = _s8vbd::P64;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vUA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vUF; else goto c8vUE;
       c8vUF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vUE: // global
           _s8vbh::I64 = I64[Sp + 32];
           _s8vbj::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vbh::I64 - _s8vbj::I64,
                            3)) goto c8vVc; else goto c8vVf;
       c8vVc: // global
           _s8vb9::P64 = P64[Sp + 64];
           _s8vbe::I64 = I64[Sp + 8];
           _s8vbf::P64 = P64[Sp + 16];
           _s8vbg::P64 = P64[Sp + 24];
           _s8vbi::I64 = I64[Sp + 40];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           I8[_s8vbe::I64 + _s8vbj::I64] = 239 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 1)] = 187 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 2)] = 191 :: W8;
           call MO_Touch(_s8vbf::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vbf::P64;
           P64[Hp - 32] = _s8vbg::P64;
           I64[Hp - 24] = _s8vbe::I64;
           I64[Hp - 16] = _s8vbh::I64;
           I64[Hp - 8] = _s8vbi::I64;
           I64[Hp] = _s8vbj::I64 + 3;
           R3 = Hp - 47;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vVf: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _s8vba::P64;
           P64[Hp - 24] = _s8vbd::P64;
           _c8vVe::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8vVe::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbO_entry() //  [R1]
         { info_tbl: [(c8vVk,
                       label: sat_s8vbO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vVk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vVl; else goto c8vVm;
       c8vVl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8vVm: // global
           I64[Sp - 16] = block_c8vTK_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vTK() //  [R1]
         { info_tbl: [(c8vTK,
                       label: block_c8vTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vTK: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8vVp; else goto c8vVo;
       c8vVp: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vVo: // global
           I64[Hp - 104] = sat_s8vbM_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vbI_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vbG_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vbF_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb3_entry() //  [R1, R2]
         { info_tbl: [(c8vVF,
                       label: sat_s8vb3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vVF: // global
           _s8va8::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaZ_entry() //  [R1]
         { info_tbl: [(c8vVO,
                       label: sat_s8vaZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vVO: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vVW,
                       label: sat_s8vaX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vVW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaW_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vW7,
                       label: sat_s8vaW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vW7: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8vW8; else goto c8vW9;
       c8vW8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vW9: // global
           I64[Sp - 24] = block_c8vW4_info;
           _s8va8::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8va8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8vXQ; else goto c8vW5;
       u8vXQ: // global
           call _c8vW4(R1) args: 0, res: 0, upd: 0;
       c8vW5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vW4() //  [R1]
         { info_tbl: [(c8vW4,
                       label: block_c8vW4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vW4: // global
           _s8val::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8vWc_info;
           _s8vac::P64 = R1;
           _s8vae::P64 = P64[R1 + 7];
           _s8vaf::P64 = P64[R1 + 15];
           _s8vad::I64 = I64[R1 + 23];
           _s8vag::I64 = I64[R1 + 31];
           _s8vah::I64 = I64[R1 + 39];
           _s8vai::I64 = I64[R1 + 47];
           R1 = _s8val::P64;
           I64[Sp - 48] = _s8vad::I64;
           P64[Sp - 40] = _s8vae::P64;
           P64[Sp - 32] = _s8vaf::P64;
           I64[Sp - 24] = _s8vag::I64;
           I64[Sp - 16] = _s8vah::I64;
           I64[Sp - 8] = _s8vai::I64;
           P64[Sp] = _s8vac::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8vXP; else goto c8vWe;
       u8vXP: // global
           call _c8vWc(R1) args: 0, res: 0, upd: 0;
       c8vWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vWc() //  [R1]
         { info_tbl: [(c8vWc,
                       label: block_c8vWc_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vWc: // global
           _s8vaa::P64 = P64[Sp + 72];
           _s8vac::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8vWk; else goto c8vWl;
       c8vWk: // global
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vWl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8vWq; else goto c8vWp;
       c8vWq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vWp: // global
           _s8vah::I64 = I64[Sp + 40];
           _s8vai::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            1)) goto c8vXB; else goto c8vXE;
       c8vXB: // global
           _s8va8::P64 = P64[Sp + 64];
           _s8vad::I64 = I64[Sp + 8];
           _s8vae::P64 = P64[Sp + 16];
           _s8vaf::P64 = P64[Sp + 24];
           _s8vag::I64 = I64[Sp + 32];
           _s8vas::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + _s8vah::I64]);
           call MO_Touch(_s8vae::P64);
           if (_s8vas::I64 == 239) goto c8vXz; else goto c8vWD;
       c8vXz: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            2)) goto c8vXv; else goto c8vXy;
       c8vXv: // global
           _s8vaC::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 1)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaC::I64 == 187) goto c8vXt; else goto c8vWV;
       c8vXt: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            3)) goto c8vXp; else goto c8vXs;
       c8vXp: // global
           _s8vaM::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 2)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaM::I64 == 191) goto c8vXn; else goto c8vXd;
       c8vXn: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vae::P64;
           P64[Hp - 32] = _s8vaf::P64;
           I64[Hp - 24] = _s8vad::I64;
           I64[Hp - 16] = _s8vag::I64;
           I64[Hp - 8] = _s8vah::I64 + 3;
           I64[Hp] = _s8vai::I64;
           R3 = _s8vaa::P64;
           R2 = Hp - 47;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vXd: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vXs: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8vXr::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8vXr::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vWV: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vXy: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8vXx::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8vXx::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8vWD: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8vXE: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8vXD::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8vXD::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb5_entry() //  [R1]
         { info_tbl: [(c8vXS,
                       label: sat_s8vb5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vXS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vXT; else goto c8vXU;
       c8vXT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8vXU: // global
           I64[Sp - 16] = block_c8vVv_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vVv() //  [R1]
         { info_tbl: [(c8vVv,
                       label: block_c8vVv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vVv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8vXX; else goto c8vXW;
       c8vXX: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vXW: // global
           I64[Hp - 104] = sat_s8vb3_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vaZ_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vaX_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vaW_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom_entry() //  [R2]
         { info_tbl: [(c8vXZ,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vXZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8vY3; else goto c8vY2;
       c8vY3: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vY2: // global
           I64[Hp - 56] = sat_s8vbO_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vb5_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.802351459 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_bom_closure" {
     GHC.IO.Encoding.UTF8.utf8_bom_closure:
         const GHC.IO.Encoding.UTF8.utf8_bom_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf8_bom_entry() //  [R1]
         { info_tbl: [(c8vYb,
                       label: GHC.IO.Encoding.UTF8.utf8_bom_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vYb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vYc; else goto c8vYd;
       c8vYc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vYd: // global
           (_c8vY8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8vY8::I64 == 0) goto c8vYa; else goto c8vY9;
       c8vYa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8vY9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8vY8::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF8.mkUTF8_bom_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.803308918 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF6_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF6_bytes:
         I8[] [85,84,70,45,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.804069862 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF5_closure" {
     GHC.IO.Encoding.UTF8.mkUTF5_closure:
         const GHC.IO.Encoding.UTF8.mkUTF5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF5_entry() //  [R1]
         { info_tbl: [(c8vYk,
                       label: GHC.IO.Encoding.UTF8.mkUTF5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vYk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vYl; else goto c8vYm;
       c8vYl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vYm: // global
           (_c8vYh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8vYh::I64 == 0) goto c8vYj; else goto c8vYi;
       c8vYj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8vYi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8vYh::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.805070631 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF2_closure" {
     GHC.IO.Encoding.UTF8.mkUTF2_closure:
         const GHC.IO.Encoding.UTF8.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF2_entry() //  []
         { info_tbl: [(c8vYr,
                       label: GHC.IO.Encoding.UTF8.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vYr: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.806645754 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_info;
         const 0;
 },
 sat_s8vbX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vYI,
                       label: sat_s8vbX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vYI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbZ_entry() //  [R1]
         { info_tbl: [(c8vYM,
                       label: sat_s8vbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vYM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8vYQ; else goto c8vYP;
       c8vYQ: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8vYP: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbX_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8vZ1,
                       label: sat_s8vbT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZ1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbV_entry() //  [R1]
         { info_tbl: [(c8vZ5,
                       label: sat_s8vbV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZ5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8vZ9; else goto c8vZ8;
       c8vZ9: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8vZ8: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbT_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_entry() //  [R2]
         { info_tbl: [(c8vZb,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8vZf; else goto c8vZe;
       c8vZf: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vZe: // global
           I64[Hp - 56] = sat_s8vbZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vbV_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF5_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.808798627 UTC

[section ""data" . lvl_r8uYu_closure" {
     lvl_r8uYu_closure:
         const lvl_r8uYu_info;
         const 0;
 },
 lvl_r8uYu_entry() //  [R2, R3]
         { info_tbl: [(c8vZn,
                       label: lvl_r8uYu_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vZr; else goto c8vZs;
       c8vZr: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8uYu_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vZs: // global
           I64[Sp - 16] = block_c8vZk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8vZA; else goto c8vZl;
       u8vZA: // global
           call _c8vZk() args: 0, res: 0, upd: 0;
       c8vZl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vZk() //  []
         { info_tbl: [(c8vZk,
                       label: block_c8vZk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZk: // global
           _s8vc1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8vZq_info;
           R1 = _s8vc1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8vZz; else goto c8vZu;
       u8vZz: // global
           call _c8vZq() args: 0, res: 0, upd: 0;
       c8vZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vZq() //  []
         { info_tbl: [(c8vZq,
                       label: block_c8vZq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZq: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.810018194 UTC

[section ""data" . lvl1_r8uYv_closure" {
     lvl1_r8uYv_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
         const lvl_r8uYu_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.810777477 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf3_closure" {
     GHC.IO.Encoding.UTF8.utf3_closure:
         const GHC.IO.Encoding.UTF8.utf3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf3_entry() //  []
         { info_tbl: [(c8vZF,
                       label: GHC.IO.Encoding.UTF8.utf3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZF: // global
           R1 = lvl1_r8uYv_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.811847126 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf2_closure" {
     GHC.IO.Encoding.UTF8.utf2_closure:
         const GHC.IO.Encoding.UTF8.utf2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf2_entry() //  [R2, R3]
         { info_tbl: [(c8vZP,
                       label: GHC.IO.Encoding.UTF8.utf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8vZT; else goto c8vZU;
       c8vZT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.utf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8vZU: // global
           I64[Sp - 16] = block_c8vZM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8w03; else goto c8vZN;
       u8w03: // global
           call _c8vZM(R1) args: 0, res: 0, upd: 0;
       c8vZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vZM() //  [R1]
         { info_tbl: [(c8vZM,
                       label: block_c8vZM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZM: // global
           I64[Sp - 16] = block_c8vZS_info;
           _s8vcn::P64 = P64[R1 + 7];
           _s8vcm::I64 = I64[R1 + 23];
           _s8vcq::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8vcq::I64;
           P64[Sp] = _s8vcn::P64;
           I64[Sp + 8] = _s8vcm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8w02; else goto c8vZW;
       u8w02: // global
           call _c8vZS() args: 0, res: 0, upd: 0;
       c8vZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vZS() //  []
         { info_tbl: [(c8vZS,
                       label: block_c8vZS_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vZS: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.813113222 UTC

[section ""data" . lvl2_r8uYw_closure" {
     lvl2_r8uYw_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF8.utf2_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.813881308 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf1_closure" {
     GHC.IO.Encoding.UTF8.utf1_closure:
         const GHC.IO.Encoding.UTF8.utf1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf1_entry() //  []
         { info_tbl: [(c8w08,
                       label: GHC.IO.Encoding.UTF8.utf1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w08: // global
           R1 = lvl2_r8uYw_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.814612866 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_closure" {
     GHC.IO.Encoding.UTF8.utf8_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.UTF8.utf3_closure+1;
         const GHC.IO.Encoding.UTF8.utf1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.815177904 UTC

[section ""relreadonly" . S8vY4_srt" {
     S8vY4_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_closure;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8uYu_closure;
         const lvl1_r8uYv_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF8.utf2_closure;
         const lvl2_r8uYw_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.815845549 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:36.816393106 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule4_bytes" {
     GHC.IO.Encoding.UTF8.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.816930544 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule3_closure" {
     GHC.IO.Encoding.UTF8.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.817647195 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule2_bytes" {
     GHC.IO.Encoding.UTF8.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.818154146 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule1_closure" {
     GHC.IO.Encoding.UTF8.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.818689272 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule_closure" {
     GHC.IO.Encoding.UTF8.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF8.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF8.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.826496918 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF1_info;
 },
 sat_s8uYV_entry() //  [R1]
         { info_tbl: [(c8w0F,
                       label: sat_s8uYV_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w0F: // global
           _s8uYV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w0G; else goto c8w0H;
       c8w0H: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w0J; else goto c8w0I;
       c8w0J: // global
           HpAlloc = 56;
           goto c8w0G;
       c8w0G: // global
           R1 = _s8uYV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w0I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uYV::P64;
           _s8uYH::I64 = I64[_s8uYV::P64 + 56];
           _s8uYR::I64 = I64[_s8uYV::P64 + 64];
           if (_s8uYR::I64 == _s8uYH::I64) goto c8w0E; else goto c8w0D;
       c8w0E: // global
           _s8uYP::P64 = P64[_s8uYV::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w0D: // global
           _s8uYD::P64 = P64[_s8uYV::P64 + 16];
           _s8uYE::P64 = P64[_s8uYV::P64 + 24];
           _s8uYC::I64 = I64[_s8uYV::P64 + 40];
           _s8uYF::I64 = I64[_s8uYV::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYR::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZ3_entry() //  [R1]
         { info_tbl: [(c8w11,
                       label: sat_s8uZ3_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w11: // global
           _s8uZ3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w12; else goto c8w13;
       c8w13: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w15; else goto c8w14;
       c8w15: // global
           HpAlloc = 56;
           goto c8w12;
       c8w12: // global
           R1 = _s8uZ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w14: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZ3::P64;
           _s8uYH::I64 = I64[_s8uZ3::P64 + 56];
           _s8uYZ::I64 = I64[_s8uZ3::P64 + 64];
           if (_s8uYZ::I64 == _s8uYH::I64) goto c8w10; else goto c8w0Z;
       c8w10: // global
           _s8uYP::P64 = P64[_s8uZ3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w0Z: // global
           _s8uYD::P64 = P64[_s8uZ3::P64 + 16];
           _s8uYE::P64 = P64[_s8uZ3::P64 + 24];
           _s8uYC::I64 = I64[_s8uZ3::P64 + 40];
           _s8uYF::I64 = I64[_s8uZ3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYZ::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZb_entry() //  [R1]
         { info_tbl: [(c8w1n,
                       label: sat_s8uZb_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w1n: // global
           _s8uZb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w1o; else goto c8w1p;
       c8w1p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w1r; else goto c8w1q;
       c8w1r: // global
           HpAlloc = 56;
           goto c8w1o;
       c8w1o: // global
           R1 = _s8uZb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZb::P64;
           _s8uYH::I64 = I64[_s8uZb::P64 + 56];
           _s8uZ7::I64 = I64[_s8uZb::P64 + 64];
           if (_s8uZ7::I64 == _s8uYH::I64) goto c8w1m; else goto c8w1l;
       c8w1m: // global
           _s8uYP::P64 = P64[_s8uZb::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w1l: // global
           _s8uYD::P64 = P64[_s8uZb::P64 + 16];
           _s8uYE::P64 = P64[_s8uZb::P64 + 24];
           _s8uYC::I64 = I64[_s8uZb::P64 + 40];
           _s8uYF::I64 = I64[_s8uZb::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZ7::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZj_entry() //  [R1]
         { info_tbl: [(c8w1J,
                       label: sat_s8uZj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w1J: // global
           _s8uZj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w1K; else goto c8w1L;
       c8w1L: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w1N; else goto c8w1M;
       c8w1N: // global
           HpAlloc = 56;
           goto c8w1K;
       c8w1K: // global
           R1 = _s8uZj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w1M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZj::P64;
           _s8uYH::I64 = I64[_s8uZj::P64 + 56];
           _s8uZf::I64 = I64[_s8uZj::P64 + 64];
           if (_s8uZf::I64 == _s8uYH::I64) goto c8w1I; else goto c8w1H;
       c8w1I: // global
           _s8uYP::P64 = P64[_s8uZj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w1H: // global
           _s8uYD::P64 = P64[_s8uZj::P64 + 16];
           _s8uYE::P64 = P64[_s8uZj::P64 + 24];
           _s8uYC::I64 = I64[_s8uZj::P64 + 40];
           _s8uYF::I64 = I64[_s8uZj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZf::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZr_entry() //  [R1]
         { info_tbl: [(c8w25,
                       label: sat_s8uZr_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w25: // global
           _s8uZr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w26; else goto c8w27;
       c8w27: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w29; else goto c8w28;
       c8w29: // global
           HpAlloc = 56;
           goto c8w26;
       c8w26: // global
           R1 = _s8uZr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w28: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZr::P64;
           _s8uYH::I64 = I64[_s8uZr::P64 + 56];
           _s8uZn::I64 = I64[_s8uZr::P64 + 64];
           if (_s8uZn::I64 == _s8uYH::I64) goto c8w24; else goto c8w23;
       c8w24: // global
           _s8uYP::P64 = P64[_s8uZr::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w23: // global
           _s8uYD::P64 = P64[_s8uZr::P64 + 16];
           _s8uYE::P64 = P64[_s8uZr::P64 + 24];
           _s8uYC::I64 = I64[_s8uZr::P64 + 40];
           _s8uYF::I64 = I64[_s8uZr::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZn::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v1h_entry() //  [R1]
         { info_tbl: [(c8w2W,
                       label: sat_s8v1h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w2W: // global
           _s8v1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w2X; else goto c8w2Y;
       c8w2Y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w30; else goto c8w2Z;
       c8w30: // global
           HpAlloc = 56;
           goto c8w2X;
       c8w2X: // global
           R1 = _s8v1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v1h::P64;
           _s8uYH::I64 = I64[_s8v1h::P64 + 56];
           _s8uZv::I64 = I64[_s8v1h::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8w2V; else goto c8w2U;
       c8w2V: // global
           _s8uYP::P64 = P64[_s8v1h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w2U: // global
           _s8uYD::P64 = P64[_s8v1h::P64 + 16];
           _s8uYE::P64 = P64[_s8v1h::P64 + 24];
           _s8uYC::I64 = I64[_s8v1h::P64 + 40];
           _s8uYF::I64 = I64[_s8v1h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2i_entry() //  [R1]
         { info_tbl: [(c8w3p,
                       label: sat_s8v2i_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w3p: // global
           _s8v2i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w3q; else goto c8w3r;
       c8w3r: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w3t; else goto c8w3s;
       c8w3t: // global
           HpAlloc = 56;
           goto c8w3q;
       c8w3q: // global
           R1 = _s8v2i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w3s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2i::P64;
           _s8uYH::I64 = I64[_s8v2i::P64 + 56];
           _s8uZv::I64 = I64[_s8v2i::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8w3o; else goto c8w3n;
       c8w3o: // global
           _s8uYP::P64 = P64[_s8v2i::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w3n: // global
           _s8uYD::P64 = P64[_s8v2i::P64 + 16];
           _s8uYE::P64 = P64[_s8v2i::P64 + 24];
           _s8uYC::I64 = I64[_s8v2i::P64 + 40];
           _s8uYF::I64 = I64[_s8v2i::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2m_entry() //  [R1]
         { info_tbl: [(c8w3H,
                       label: sat_s8v2m_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w3H: // global
           _s8v2m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8w3I; else goto c8w3J;
       c8w3J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w3L; else goto c8w3K;
       c8w3L: // global
           HpAlloc = 56;
           goto c8w3I;
       c8w3I: // global
           R1 = _s8v2m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8w3K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2m::P64;
           _s8uYH::I64 = I64[_s8v2m::P64 + 56];
           _s8uZv::I64 = I64[_s8v2m::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8w3G; else goto c8w3F;
       c8w3G: // global
           _s8uYP::P64 = P64[_s8v2m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8w3F: // global
           _s8uYD::P64 = P64[_s8v2m::P64 + 16];
           _s8uYE::P64 = P64[_s8v2m::P64 + 24];
           _s8uYC::I64 = I64[_s8v2m::P64 + 40];
           _s8uYF::I64 = I64[_s8v2m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8w3O,
                       label: GHC.IO.Encoding.UTF8.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w3O: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8w3P; else goto c8w3Q;
       c8w3P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8w3Q: // global
           I64[Sp - 16] = block_c8w0f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wcl; else goto c8w0g;
       u8wcl: // global
           call _c8w0f(R1) args: 0, res: 0, upd: 0;
       c8w0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8w0f() //  [R1]
         { info_tbl: [(c8w0f,
                       label: block_c8w0f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w0f: // global
           I64[Sp - 40] = block_c8w0k_info;
           _s8uYD::P64 = P64[R1 + 7];
           _s8uYE::P64 = P64[R1 + 15];
           _s8uYC::I64 = I64[R1 + 23];
           _s8uYF::I64 = I64[R1 + 31];
           _s8uYG::I64 = I64[R1 + 39];
           _s8uYH::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8uYE::P64;
           I64[Sp - 24] = _s8uYF::I64;
           I64[Sp - 16] = _s8uYG::I64;
           I64[Sp - 8] = _s8uYH::I64;
           P64[Sp] = _s8uYD::P64;
           I64[Sp + 8] = _s8uYC::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8wc7; else goto c8w0l;
       u8wc7: // global
           call _c8w0k(R1) args: 0, res: 0, upd: 0;
       c8w0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8w0k() //  [R1]
         { info_tbl: [(c8w0k,
                       label: block_c8w0k_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w0k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8w3U; else goto c8w3T;
       c8w3U: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8w3T: // global
           _s8uYK::P64 = P64[R1 + 7];
           _s8uYL::P64 = P64[R1 + 15];
           _s8uYJ::I64 = I64[R1 + 23];
           _s8uYM::I64 = I64[R1 + 31];
           _s8uYN::I64 = I64[R1 + 39];
           _s8uYO::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8uYK::P64;
           P64[Sp - 40] = _s8uYL::P64;
           I64[Sp - 32] = _s8uYM::I64;
           I64[Sp - 24] = _s8uYN::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8uYO::I64;
           I64[Sp] = _s8uYJ::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8w2e() args: 0, res: 0, upd: 0;
     }
 },
 _c8w2e() //  []
         { info_tbl: [(c8w2e,
                       label: block_c8w2e_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w2e: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w4h; else goto c8w4g;
       c8w4h: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w2e_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w4g: // global
           _s8uYM::I64 = I64[Sp + 24];
           _s8uZv::I64 = I64[Sp + 40];
           _s8uZw::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8uZw::I64,
                            _s8uYM::I64)) goto c8w5D; else goto c8w5E;
       c8w5D: // global
           _s8uYH::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8uZv::I64,
                            _s8uYH::I64)) goto c8w5A; else goto c8w5B;
       c8w5A: // global
           _c8w0p::P64 = P64[Sp + 80];
           _s8uYC::I64 = I64[Sp + 104];
           _s8uYD::P64 = P64[Sp + 96];
           _s8uYE::P64 = P64[Sp + 64];
           _s8uYF::I64 = I64[Sp + 72];
           _s8uYJ::I64 = I64[Sp + 56];
           _s8uYK::P64 = P64[Sp + 8];
           _s8uYL::P64 = P64[Sp + 16];
           _s8uYN::I64 = I64[Sp + 32];
           _s8uZC::I64 = %MO_UU_Conv_W32_W64(I32[_s8uYC::I64 + (_s8uZv::I64 << 2)]);
           call MO_Touch(_s8uYD::P64);
           if (%MO_S_Gt_W64(_s8uZC::I64, 127)) goto c8w5x; else goto c8w5y;
       c8w5x: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 2047)) goto c8w5l; else goto c8w5v;
       c8w5l: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 65535)) goto c8w4r; else goto c8w5j;
       c8w4r: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            4)) goto c8w4o; else goto c8w4p;
       c8w4o: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            18) + 240);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  12) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 4;
           goto u8wci;
       c8w4p: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8w0s() args: 0, res: 0, upd: 0;
       c8w5j: // global
           if (%MO_S_Gt_W64(55296, _s8uZC::I64)) goto c8w4Q; else goto c8w5i;
       c8w4Q: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8w4B; else goto c8w4O;
       c8w4B: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8w58; else goto c8w4y;
       c8w4y: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wci;
       c8w4O: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8w4L; else goto c8w4N;
       c8w4L: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8w58; else goto c8w4I;
       c8w4I: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wci;
       c8w4N: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v1h_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8w0p::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8w5i: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 56319)) goto c8w5f; else goto c8w5h;
       c8w5f: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8w50; else goto c8w5d;
       c8w50: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8w58; else goto c8w4X;
       c8w4X: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wci;
       c8w5d: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8w5a; else goto c8w5c;
       c8w5a: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8w58; else goto c8w57;
       c8w58: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8w0O() args: 0, res: 0, upd: 0;
       c8w57: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wci;
       c8w5c: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2i_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8w0p::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8w5h: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2m_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8w0p::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8w5v: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            2)) goto c8w5t; else goto c8w5u;
       c8w5t: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            6) + 192);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 2;
           goto u8wci;
       c8w5u: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8w1a() args: 0, res: 0, upd: 0;
       c8w5y: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(_s8uZC::I64);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 1;
           goto u8wci;
       u8wci: // global
           call _c8w2e() args: 0, res: 0, upd: 0;
       c8w5B: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8w1w() args: 0, res: 0, upd: 0;
       c8w5E: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8w1S() args: 0, res: 0, upd: 0;
     }
 },
 _c8w0s() //  []
         { info_tbl: [(c8w0s,
                       label: block_c8w0s_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w0s: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w3Y; else goto c8w3X;
       c8w3Y: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w0s_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w3X: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uYV_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8w0O() //  []
         { info_tbl: [(c8w0O,
                       label: block_c8w0O_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w0O: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w42; else goto c8w41;
       c8w42: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w0O_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w41: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZ3_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8w1a() //  []
         { info_tbl: [(c8w1a,
                       label: block_c8w1a_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w1a: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w46; else goto c8w45;
       c8w46: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w1a_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w45: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZb_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8w1w() //  []
         { info_tbl: [(c8w1w,
                       label: block_c8w1w_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w1w: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w4a; else goto c8w49;
       c8w4a: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w1w_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w49: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZj_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8w1S() //  []
         { info_tbl: [(c8w1S,
                       label: block_c8w1S_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w1S: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8w4e; else goto c8w4d;
       c8w4e: // global
           HpAlloc = 160;
           I64[Sp] = block_c8w1S_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8w4d: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZr_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.869012382 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF4_closure" {
     GHC.IO.Encoding.UTF8.mkUTF4_closure:
         const GHC.IO.Encoding.UTF8.mkUTF4_info;
 },
 sat_s8v3c_entry() //  [R1]
         { info_tbl: [(c8wcQ,
                       label: sat_s8v3c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wcQ: // global
           _s8v3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wcR; else goto c8wcS;
       c8wcS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wcU; else goto c8wcT;
       c8wcU: // global
           HpAlloc = 56;
           goto c8wcR;
       c8wcR: // global
           R1 = _s8v3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wcT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3c::P64;
           _s8v2Y::I64 = I64[_s8v3c::P64 + 56];
           _s8v38::I64 = I64[_s8v3c::P64 + 64];
           if (_s8v38::I64 == _s8v2Y::I64) goto c8wcP; else goto c8wcO;
       c8wcP: // global
           _s8v36::P64 = P64[_s8v3c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wcO: // global
           _s8v2U::P64 = P64[_s8v3c::P64 + 16];
           _s8v2V::P64 = P64[_s8v3c::P64 + 24];
           _s8v2T::I64 = I64[_s8v3c::P64 + 40];
           _s8v2W::I64 = I64[_s8v3c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v38::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3k_entry() //  [R1]
         { info_tbl: [(c8wdc,
                       label: sat_s8v3k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wdc: // global
           _s8v3k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wdd; else goto c8wde;
       c8wde: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wdg; else goto c8wdf;
       c8wdg: // global
           HpAlloc = 56;
           goto c8wdd;
       c8wdd: // global
           R1 = _s8v3k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wdf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3k::P64;
           _s8v2Y::I64 = I64[_s8v3k::P64 + 56];
           _s8v3g::I64 = I64[_s8v3k::P64 + 64];
           if (_s8v3g::I64 == _s8v2Y::I64) goto c8wdb; else goto c8wda;
       c8wdb: // global
           _s8v36::P64 = P64[_s8v3k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wda: // global
           _s8v2U::P64 = P64[_s8v3k::P64 + 16];
           _s8v2V::P64 = P64[_s8v3k::P64 + 24];
           _s8v2T::I64 = I64[_s8v3k::P64 + 40];
           _s8v2W::I64 = I64[_s8v3k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3g::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3A_entry() //  [R1]
         { info_tbl: [(c8wdK,
                       label: sat_s8v3A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wdK: // global
           _s8v3A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wdL; else goto c8wdM;
       c8wdM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wdO; else goto c8wdN;
       c8wdO: // global
           HpAlloc = 56;
           goto c8wdL;
       c8wdL: // global
           R1 = _s8v3A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wdN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3A::P64;
           _s8v2Y::I64 = I64[_s8v3A::P64 + 56];
           _s8v3o::I64 = I64[_s8v3A::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8wdJ; else goto c8wdI;
       c8wdJ: // global
           _s8v36::P64 = P64[_s8v3A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wdI: // global
           _s8v2U::P64 = P64[_s8v3A::P64 + 16];
           _s8v2V::P64 = P64[_s8v3A::P64 + 24];
           _s8v2T::I64 = I64[_s8v3A::P64 + 40];
           _s8v2W::I64 = I64[_s8v3A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3H_entry() //  [R1]
         { info_tbl: [(c8wed,
                       label: sat_s8v3H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wed: // global
           _s8v3H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wee; else goto c8wef;
       c8wef: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8weh; else goto c8weg;
       c8weh: // global
           HpAlloc = 56;
           goto c8wee;
       c8wee: // global
           R1 = _s8v3H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8weg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3H::P64;
           _s8v2Y::I64 = I64[_s8v3H::P64 + 56];
           _s8v3o::I64 = I64[_s8v3H::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8wec; else goto c8web;
       c8wec: // global
           _s8v36::P64 = P64[_s8v3H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8web: // global
           _s8v2U::P64 = P64[_s8v3H::P64 + 16];
           _s8v2V::P64 = P64[_s8v3H::P64 + 24];
           _s8v2T::I64 = I64[_s8v3H::P64 + 40];
           _s8v2W::I64 = I64[_s8v3H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3M_entry() //  [R1]
         { info_tbl: [(c8wey,
                       label: sat_s8v3M_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wey: // global
           _s8v3M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wez; else goto c8weA;
       c8weA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8weC; else goto c8weB;
       c8weC: // global
           HpAlloc = 56;
           goto c8wez;
       c8wez: // global
           R1 = _s8v3M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8weB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3M::P64;
           _s8v2Y::I64 = I64[_s8v3M::P64 + 56];
           _s8v3o::I64 = I64[_s8v3M::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8wex; else goto c8wew;
       c8wex: // global
           _s8v36::P64 = P64[_s8v3M::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wew: // global
           _s8v2U::P64 = P64[_s8v3M::P64 + 16];
           _s8v2V::P64 = P64[_s8v3M::P64 + 24];
           _s8v2T::I64 = I64[_s8v3M::P64 + 40];
           _s8v2W::I64 = I64[_s8v3M::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3R_entry() //  [R1]
         { info_tbl: [(c8weT,
                       label: sat_s8v3R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8weT: // global
           _s8v3R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8weU; else goto c8weV;
       c8weV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8weX; else goto c8weW;
       c8weX: // global
           HpAlloc = 56;
           goto c8weU;
       c8weU: // global
           R1 = _s8v3R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8weW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3R::P64;
           _s8v2Y::I64 = I64[_s8v3R::P64 + 56];
           _s8v3o::I64 = I64[_s8v3R::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8weS; else goto c8weR;
       c8weS: // global
           _s8v36::P64 = P64[_s8v3R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8weR: // global
           _s8v2U::P64 = P64[_s8v3R::P64 + 16];
           _s8v2V::P64 = P64[_s8v3R::P64 + 24];
           _s8v2T::I64 = I64[_s8v3R::P64 + 40];
           _s8v2W::I64 = I64[_s8v3R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4k_entry() //  [R1]
         { info_tbl: [(c8wfy,
                       label: sat_s8v4k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wfy: // global
           _s8v4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wfz; else goto c8wfA;
       c8wfA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wfC; else goto c8wfB;
       c8wfC: // global
           HpAlloc = 56;
           goto c8wfz;
       c8wfz: // global
           R1 = _s8v4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wfB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4k::P64;
           _s8v2Y::I64 = I64[_s8v4k::P64 + 56];
           _s8v42::I64 = I64[_s8v4k::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8wfx; else goto c8wfw;
       c8wfx: // global
           _s8v36::P64 = P64[_s8v4k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wfw: // global
           _s8v2U::P64 = P64[_s8v4k::P64 + 16];
           _s8v2V::P64 = P64[_s8v4k::P64 + 24];
           _s8v2T::I64 = I64[_s8v4k::P64 + 40];
           _s8v2W::I64 = I64[_s8v4k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4r_entry() //  [R1]
         { info_tbl: [(c8wg1,
                       label: sat_s8v4r_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wg1: // global
           _s8v4r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wg2; else goto c8wg3;
       c8wg3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wg5; else goto c8wg4;
       c8wg5: // global
           HpAlloc = 56;
           goto c8wg2;
       c8wg2: // global
           R1 = _s8v4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4r::P64;
           _s8v2Y::I64 = I64[_s8v4r::P64 + 56];
           _s8v42::I64 = I64[_s8v4r::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8wg0; else goto c8wfZ;
       c8wg0: // global
           _s8v36::P64 = P64[_s8v4r::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wfZ: // global
           _s8v2U::P64 = P64[_s8v4r::P64 + 16];
           _s8v2V::P64 = P64[_s8v4r::P64 + 24];
           _s8v2T::I64 = I64[_s8v4r::P64 + 40];
           _s8v2W::I64 = I64[_s8v4r::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4w_entry() //  [R1]
         { info_tbl: [(c8wgm,
                       label: sat_s8v4w_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wgm: // global
           _s8v4w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wgn; else goto c8wgo;
       c8wgo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wgq; else goto c8wgp;
       c8wgq: // global
           HpAlloc = 56;
           goto c8wgn;
       c8wgn: // global
           R1 = _s8v4w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wgp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4w::P64;
           _s8v2Y::I64 = I64[_s8v4w::P64 + 56];
           _s8v42::I64 = I64[_s8v4w::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8wgl; else goto c8wgk;
       c8wgl: // global
           _s8v36::P64 = P64[_s8v4w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wgk: // global
           _s8v2U::P64 = P64[_s8v4w::P64 + 16];
           _s8v2V::P64 = P64[_s8v4w::P64 + 24];
           _s8v2T::I64 = I64[_s8v4w::P64 + 40];
           _s8v2W::I64 = I64[_s8v4w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4B_entry() //  [R1]
         { info_tbl: [(c8wgH,
                       label: sat_s8v4B_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wgH: // global
           _s8v4B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wgI; else goto c8wgJ;
       c8wgJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wgL; else goto c8wgK;
       c8wgL: // global
           HpAlloc = 56;
           goto c8wgI;
       c8wgI: // global
           R1 = _s8v4B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wgK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4B::P64;
           _s8v2Y::I64 = I64[_s8v4B::P64 + 56];
           _s8v42::I64 = I64[_s8v4B::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8wgG; else goto c8wgF;
       c8wgG: // global
           _s8v36::P64 = P64[_s8v4B::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wgF: // global
           _s8v2U::P64 = P64[_s8v4B::P64 + 16];
           _s8v2V::P64 = P64[_s8v4B::P64 + 24];
           _s8v2T::I64 = I64[_s8v4B::P64 + 40];
           _s8v2W::I64 = I64[_s8v4B::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4G_entry() //  [R1]
         { info_tbl: [(c8wh2,
                       label: sat_s8v4G_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wh2: // global
           _s8v4G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wh3; else goto c8wh4;
       c8wh4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wh6; else goto c8wh5;
       c8wh6: // global
           HpAlloc = 56;
           goto c8wh3;
       c8wh3: // global
           R1 = _s8v4G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wh5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4G::P64;
           _s8v2Y::I64 = I64[_s8v4G::P64 + 56];
           _s8v42::I64 = I64[_s8v4G::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8wh1; else goto c8wh0;
       c8wh1: // global
           _s8v36::P64 = P64[_s8v4G::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wh0: // global
           _s8v2U::P64 = P64[_s8v4G::P64 + 16];
           _s8v2V::P64 = P64[_s8v4G::P64 + 24];
           _s8v2T::I64 = I64[_s8v4G::P64 + 40];
           _s8v2W::I64 = I64[_s8v4G::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4L_entry() //  [R1]
         { info_tbl: [(c8whn,
                       label: sat_s8v4L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8whn: // global
           _s8v4L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8who; else goto c8whp;
       c8whp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8whr; else goto c8whq;
       c8whr: // global
           HpAlloc = 56;
           goto c8who;
       c8who: // global
           R1 = _s8v4L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8whq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4L::P64;
           _s8v2Y::I64 = I64[_s8v4L::P64 + 56];
           _s8v42::I64 = I64[_s8v4L::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8whm; else goto c8whl;
       c8whm: // global
           _s8v36::P64 = P64[_s8v4L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8whl: // global
           _s8v2U::P64 = P64[_s8v4L::P64 + 16];
           _s8v2V::P64 = P64[_s8v4L::P64 + 24];
           _s8v2T::I64 = I64[_s8v4L::P64 + 40];
           _s8v2W::I64 = I64[_s8v4L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v54_entry() //  [R1]
         { info_tbl: [(c8whJ,
                       label: sat_s8v54_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8whJ: // global
           _s8v54::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8whK; else goto c8whL;
       c8whL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8whN; else goto c8whM;
       c8whN: // global
           HpAlloc = 56;
           goto c8whK;
       c8whK: // global
           R1 = _s8v54::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8whM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v54::P64;
           _s8v2Y::I64 = I64[_s8v54::P64 + 56];
           _s8v50::I64 = I64[_s8v54::P64 + 64];
           if (_s8v50::I64 == _s8v2Y::I64) goto c8whI; else goto c8whH;
       c8whI: // global
           _s8v36::P64 = P64[_s8v54::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8whH: // global
           _s8v2U::P64 = P64[_s8v54::P64 + 16];
           _s8v2V::P64 = P64[_s8v54::P64 + 24];
           _s8v2T::I64 = I64[_s8v54::P64 + 40];
           _s8v2W::I64 = I64[_s8v54::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v50::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5k_entry() //  [R1]
         { info_tbl: [(c8wih,
                       label: sat_s8v5k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wih: // global
           _s8v5k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wii; else goto c8wij;
       c8wij: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wil; else goto c8wik;
       c8wil: // global
           HpAlloc = 56;
           goto c8wii;
       c8wii: // global
           R1 = _s8v5k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wik: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5k::P64;
           _s8v2Y::I64 = I64[_s8v5k::P64 + 56];
           _s8v58::I64 = I64[_s8v5k::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8wig; else goto c8wif;
       c8wig: // global
           _s8v36::P64 = P64[_s8v5k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wif: // global
           _s8v2U::P64 = P64[_s8v5k::P64 + 16];
           _s8v2V::P64 = P64[_s8v5k::P64 + 24];
           _s8v2T::I64 = I64[_s8v5k::P64 + 40];
           _s8v2W::I64 = I64[_s8v5k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5s_entry() //  [R1]
         { info_tbl: [(c8wiQ,
                       label: sat_s8v5s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wiQ: // global
           _s8v5s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wiR; else goto c8wiS;
       c8wiS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wiU; else goto c8wiT;
       c8wiU: // global
           HpAlloc = 56;
           goto c8wiR;
       c8wiR: // global
           R1 = _s8v5s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wiT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5s::P64;
           _s8v2Y::I64 = I64[_s8v5s::P64 + 56];
           _s8v58::I64 = I64[_s8v5s::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8wiP; else goto c8wiO;
       c8wiP: // global
           _s8v36::P64 = P64[_s8v5s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wiO: // global
           _s8v2U::P64 = P64[_s8v5s::P64 + 16];
           _s8v2V::P64 = P64[_s8v5s::P64 + 24];
           _s8v2T::I64 = I64[_s8v5s::P64 + 40];
           _s8v2W::I64 = I64[_s8v5s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5x_entry() //  [R1]
         { info_tbl: [(c8wjb,
                       label: sat_s8v5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wjb: // global
           _s8v5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wjc; else goto c8wjd;
       c8wjd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wjf; else goto c8wje;
       c8wjf: // global
           HpAlloc = 56;
           goto c8wjc;
       c8wjc: // global
           R1 = _s8v5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wje: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5x::P64;
           _s8v2Y::I64 = I64[_s8v5x::P64 + 56];
           _s8v58::I64 = I64[_s8v5x::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8wja; else goto c8wj9;
       c8wja: // global
           _s8v36::P64 = P64[_s8v5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wj9: // global
           _s8v2U::P64 = P64[_s8v5x::P64 + 16];
           _s8v2V::P64 = P64[_s8v5x::P64 + 24];
           _s8v2T::I64 = I64[_s8v5x::P64 + 40];
           _s8v2W::I64 = I64[_s8v5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5C_entry() //  [R1]
         { info_tbl: [(c8wjw,
                       label: sat_s8v5C_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wjw: // global
           _s8v5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wjx; else goto c8wjy;
       c8wjy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wjA; else goto c8wjz;
       c8wjA: // global
           HpAlloc = 56;
           goto c8wjx;
       c8wjx: // global
           R1 = _s8v5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wjz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5C::P64;
           _s8v2Y::I64 = I64[_s8v5C::P64 + 56];
           _s8v58::I64 = I64[_s8v5C::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8wjv; else goto c8wju;
       c8wjv: // global
           _s8v36::P64 = P64[_s8v5C::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wju: // global
           _s8v2U::P64 = P64[_s8v5C::P64 + 16];
           _s8v2V::P64 = P64[_s8v5C::P64 + 24];
           _s8v2T::I64 = I64[_s8v5C::P64 + 40];
           _s8v2W::I64 = I64[_s8v5C::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5H_entry() //  [R1]
         { info_tbl: [(c8wjR,
                       label: sat_s8v5H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wjR: // global
           _s8v5H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wjS; else goto c8wjT;
       c8wjT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wjV; else goto c8wjU;
       c8wjV: // global
           HpAlloc = 56;
           goto c8wjS;
       c8wjS: // global
           R1 = _s8v5H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wjU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5H::P64;
           _s8v2Y::I64 = I64[_s8v5H::P64 + 56];
           _s8v58::I64 = I64[_s8v5H::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8wjQ; else goto c8wjP;
       c8wjQ: // global
           _s8v36::P64 = P64[_s8v5H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wjP: // global
           _s8v2U::P64 = P64[_s8v5H::P64 + 16];
           _s8v2V::P64 = P64[_s8v5H::P64 + 24];
           _s8v2T::I64 = I64[_s8v5H::P64 + 40];
           _s8v2W::I64 = I64[_s8v5H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5Z_entry() //  [R1]
         { info_tbl: [(c8wkd,
                       label: sat_s8v5Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wkd: // global
           _s8v5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wke; else goto c8wkf;
       c8wkf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wkh; else goto c8wkg;
       c8wkh: // global
           HpAlloc = 56;
           goto c8wke;
       c8wke: // global
           R1 = _s8v5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wkg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5Z::P64;
           _s8v2Y::I64 = I64[_s8v5Z::P64 + 56];
           _s8v5V::I64 = I64[_s8v5Z::P64 + 64];
           if (_s8v5V::I64 == _s8v2Y::I64) goto c8wkc; else goto c8wkb;
       c8wkc: // global
           _s8v36::P64 = P64[_s8v5Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wkb: // global
           _s8v2U::P64 = P64[_s8v5Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v5Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v5Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v5Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v5V::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v67_entry() //  [R1]
         { info_tbl: [(c8wkz,
                       label: sat_s8v67_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wkz: // global
           _s8v67::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wkA; else goto c8wkB;
       c8wkB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wkD; else goto c8wkC;
       c8wkD: // global
           HpAlloc = 56;
           goto c8wkA;
       c8wkA: // global
           R1 = _s8v67::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v67::P64;
           _s8v2Y::I64 = I64[_s8v67::P64 + 56];
           _s8v63::I64 = I64[_s8v67::P64 + 64];
           if (_s8v63::I64 == _s8v2Y::I64) goto c8wky; else goto c8wkx;
       c8wky: // global
           _s8v36::P64 = P64[_s8v67::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wkx: // global
           _s8v2U::P64 = P64[_s8v67::P64 + 16];
           _s8v2V::P64 = P64[_s8v67::P64 + 24];
           _s8v2T::I64 = I64[_s8v67::P64 + 40];
           _s8v2W::I64 = I64[_s8v67::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v63::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6f_entry() //  [R1]
         { info_tbl: [(c8wkV,
                       label: sat_s8v6f_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wkV: // global
           _s8v6f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wkW; else goto c8wkX;
       c8wkX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wkZ; else goto c8wkY;
       c8wkZ: // global
           HpAlloc = 56;
           goto c8wkW;
       c8wkW: // global
           R1 = _s8v6f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wkY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6f::P64;
           _s8v2Y::I64 = I64[_s8v6f::P64 + 56];
           _s8v6b::I64 = I64[_s8v6f::P64 + 64];
           if (_s8v6b::I64 == _s8v2Y::I64) goto c8wkU; else goto c8wkT;
       c8wkU: // global
           _s8v36::P64 = P64[_s8v6f::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wkT: // global
           _s8v2U::P64 = P64[_s8v6f::P64 + 16];
           _s8v2V::P64 = P64[_s8v6f::P64 + 24];
           _s8v2T::I64 = I64[_s8v6f::P64 + 40];
           _s8v2W::I64 = I64[_s8v6f::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6b::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6n_entry() //  [R1]
         { info_tbl: [(c8wlh,
                       label: sat_s8v6n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wlh: // global
           _s8v6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wli; else goto c8wlj;
       c8wlj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wll; else goto c8wlk;
       c8wll: // global
           HpAlloc = 56;
           goto c8wli;
       c8wli: // global
           R1 = _s8v6n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6n::P64;
           _s8v2Y::I64 = I64[_s8v6n::P64 + 56];
           _s8v6j::I64 = I64[_s8v6n::P64 + 64];
           if (_s8v6j::I64 == _s8v2Y::I64) goto c8wlg; else goto c8wlf;
       c8wlg: // global
           _s8v36::P64 = P64[_s8v6n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wlf: // global
           _s8v2U::P64 = P64[_s8v6n::P64 + 16];
           _s8v2V::P64 = P64[_s8v6n::P64 + 24];
           _s8v2T::I64 = I64[_s8v6n::P64 + 40];
           _s8v2W::I64 = I64[_s8v6n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6j::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6v_entry() //  [R1]
         { info_tbl: [(c8wlD,
                       label: sat_s8v6v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wlD: // global
           _s8v6v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wlE; else goto c8wlF;
       c8wlF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wlH; else goto c8wlG;
       c8wlH: // global
           HpAlloc = 56;
           goto c8wlE;
       c8wlE: // global
           R1 = _s8v6v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wlG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6v::P64;
           _s8v2Y::I64 = I64[_s8v6v::P64 + 56];
           _s8v6r::I64 = I64[_s8v6v::P64 + 64];
           if (_s8v6r::I64 == _s8v2Y::I64) goto c8wlC; else goto c8wlB;
       c8wlC: // global
           _s8v36::P64 = P64[_s8v6v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wlB: // global
           _s8v2U::P64 = P64[_s8v6v::P64 + 16];
           _s8v2V::P64 = P64[_s8v6v::P64 + 24];
           _s8v2T::I64 = I64[_s8v6v::P64 + 40];
           _s8v2W::I64 = I64[_s8v6v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6r::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7v_entry() //  [R1]
         { info_tbl: [(c8wna,
                       label: sat_s8v7v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wna: // global
           _s8v7v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wnb; else goto c8wnc;
       c8wnc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wne; else goto c8wnd;
       c8wne: // global
           HpAlloc = 56;
           goto c8wnb;
       c8wnb: // global
           R1 = _s8v7v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wnd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7v::P64;
           _s8v2Y::I64 = I64[_s8v7v::P64 + 56];
           _s8v6z::I64 = I64[_s8v7v::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wn9; else goto c8wn8;
       c8wn9: // global
           _s8v36::P64 = P64[_s8v7v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wn8: // global
           _s8v2U::P64 = P64[_s8v7v::P64 + 16];
           _s8v2V::P64 = P64[_s8v7v::P64 + 24];
           _s8v2T::I64 = I64[_s8v7v::P64 + 40];
           _s8v2W::I64 = I64[_s8v7v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7A_entry() //  [R1]
         { info_tbl: [(c8wnv,
                       label: sat_s8v7A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wnv: // global
           _s8v7A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wnw; else goto c8wnx;
       c8wnx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wnz; else goto c8wny;
       c8wnz: // global
           HpAlloc = 56;
           goto c8wnw;
       c8wnw: // global
           R1 = _s8v7A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7A::P64;
           _s8v2Y::I64 = I64[_s8v7A::P64 + 56];
           _s8v6z::I64 = I64[_s8v7A::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wnu; else goto c8wnt;
       c8wnu: // global
           _s8v36::P64 = P64[_s8v7A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wnt: // global
           _s8v2U::P64 = P64[_s8v7A::P64 + 16];
           _s8v2V::P64 = P64[_s8v7A::P64 + 24];
           _s8v2T::I64 = I64[_s8v7A::P64 + 40];
           _s8v2W::I64 = I64[_s8v7A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7F_entry() //  [R1]
         { info_tbl: [(c8wnQ,
                       label: sat_s8v7F_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wnQ: // global
           _s8v7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wnR; else goto c8wnS;
       c8wnS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wnU; else goto c8wnT;
       c8wnU: // global
           HpAlloc = 56;
           goto c8wnR;
       c8wnR: // global
           R1 = _s8v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wnT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7F::P64;
           _s8v2Y::I64 = I64[_s8v7F::P64 + 56];
           _s8v6z::I64 = I64[_s8v7F::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wnP; else goto c8wnO;
       c8wnP: // global
           _s8v36::P64 = P64[_s8v7F::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wnO: // global
           _s8v2U::P64 = P64[_s8v7F::P64 + 16];
           _s8v2V::P64 = P64[_s8v7F::P64 + 24];
           _s8v2T::I64 = I64[_s8v7F::P64 + 40];
           _s8v2W::I64 = I64[_s8v7F::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7K_entry() //  [R1]
         { info_tbl: [(c8wob,
                       label: sat_s8v7K_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wob: // global
           _s8v7K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8woc; else goto c8wod;
       c8wod: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wof; else goto c8woe;
       c8wof: // global
           HpAlloc = 56;
           goto c8woc;
       c8woc: // global
           R1 = _s8v7K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8woe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7K::P64;
           _s8v2Y::I64 = I64[_s8v7K::P64 + 56];
           _s8v6z::I64 = I64[_s8v7K::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8woa; else goto c8wo9;
       c8woa: // global
           _s8v36::P64 = P64[_s8v7K::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wo9: // global
           _s8v2U::P64 = P64[_s8v7K::P64 + 16];
           _s8v2V::P64 = P64[_s8v7K::P64 + 24];
           _s8v2T::I64 = I64[_s8v7K::P64 + 40];
           _s8v2W::I64 = I64[_s8v7K::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7P_entry() //  [R1]
         { info_tbl: [(c8wow,
                       label: sat_s8v7P_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wow: // global
           _s8v7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wox; else goto c8woy;
       c8woy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8woA; else goto c8woz;
       c8woA: // global
           HpAlloc = 56;
           goto c8wox;
       c8wox: // global
           R1 = _s8v7P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8woz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7P::P64;
           _s8v2Y::I64 = I64[_s8v7P::P64 + 56];
           _s8v6z::I64 = I64[_s8v7P::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wov; else goto c8wou;
       c8wov: // global
           _s8v36::P64 = P64[_s8v7P::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wou: // global
           _s8v2U::P64 = P64[_s8v7P::P64 + 16];
           _s8v2V::P64 = P64[_s8v7P::P64 + 24];
           _s8v2T::I64 = I64[_s8v7P::P64 + 40];
           _s8v2W::I64 = I64[_s8v7P::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7U_entry() //  [R1]
         { info_tbl: [(c8woR,
                       label: sat_s8v7U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8woR: // global
           _s8v7U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8woS; else goto c8woT;
       c8woT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8woV; else goto c8woU;
       c8woV: // global
           HpAlloc = 56;
           goto c8woS;
       c8woS: // global
           R1 = _s8v7U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8woU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7U::P64;
           _s8v2Y::I64 = I64[_s8v7U::P64 + 56];
           _s8v6z::I64 = I64[_s8v7U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8woQ; else goto c8woP;
       c8woQ: // global
           _s8v36::P64 = P64[_s8v7U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8woP: // global
           _s8v2U::P64 = P64[_s8v7U::P64 + 16];
           _s8v2V::P64 = P64[_s8v7U::P64 + 24];
           _s8v2T::I64 = I64[_s8v7U::P64 + 40];
           _s8v2W::I64 = I64[_s8v7U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7Z_entry() //  [R1]
         { info_tbl: [(c8wpc,
                       label: sat_s8v7Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wpc: // global
           _s8v7Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wpd; else goto c8wpe;
       c8wpe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wpg; else goto c8wpf;
       c8wpg: // global
           HpAlloc = 56;
           goto c8wpd;
       c8wpd: // global
           R1 = _s8v7Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wpf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7Z::P64;
           _s8v2Y::I64 = I64[_s8v7Z::P64 + 56];
           _s8v6z::I64 = I64[_s8v7Z::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wpb; else goto c8wpa;
       c8wpb: // global
           _s8v36::P64 = P64[_s8v7Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wpa: // global
           _s8v2U::P64 = P64[_s8v7Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v7Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v7Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v7Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8R_entry() //  [R1]
         { info_tbl: [(c8wqf,
                       label: sat_s8v8R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wqf: // global
           _s8v8R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wqg; else goto c8wqh;
       c8wqh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wqj; else goto c8wqi;
       c8wqj: // global
           HpAlloc = 56;
           goto c8wqg;
       c8wqg: // global
           R1 = _s8v8R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wqi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8R::P64;
           _s8v2Y::I64 = I64[_s8v8R::P64 + 56];
           _s8v6z::I64 = I64[_s8v8R::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wqe; else goto c8wqd;
       c8wqe: // global
           _s8v36::P64 = P64[_s8v8R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wqd: // global
           _s8v2U::P64 = P64[_s8v8R::P64 + 16];
           _s8v2V::P64 = P64[_s8v8R::P64 + 24];
           _s8v2T::I64 = I64[_s8v8R::P64 + 40];
           _s8v2W::I64 = I64[_s8v8R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8W_entry() //  [R1]
         { info_tbl: [(c8wqA,
                       label: sat_s8v8W_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wqA: // global
           _s8v8W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wqB; else goto c8wqC;
       c8wqC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wqE; else goto c8wqD;
       c8wqE: // global
           HpAlloc = 56;
           goto c8wqB;
       c8wqB: // global
           R1 = _s8v8W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wqD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8W::P64;
           _s8v2Y::I64 = I64[_s8v8W::P64 + 56];
           _s8v6z::I64 = I64[_s8v8W::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wqz; else goto c8wqy;
       c8wqz: // global
           _s8v36::P64 = P64[_s8v8W::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wqy: // global
           _s8v2U::P64 = P64[_s8v8W::P64 + 16];
           _s8v2V::P64 = P64[_s8v8W::P64 + 24];
           _s8v2T::I64 = I64[_s8v8W::P64 + 40];
           _s8v2W::I64 = I64[_s8v8W::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v91_entry() //  [R1]
         { info_tbl: [(c8wqV,
                       label: sat_s8v91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wqV: // global
           _s8v91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wqW; else goto c8wqX;
       c8wqX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wqZ; else goto c8wqY;
       c8wqZ: // global
           HpAlloc = 56;
           goto c8wqW;
       c8wqW: // global
           R1 = _s8v91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v91::P64;
           _s8v2Y::I64 = I64[_s8v91::P64 + 56];
           _s8v6z::I64 = I64[_s8v91::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wqU; else goto c8wqT;
       c8wqU: // global
           _s8v36::P64 = P64[_s8v91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wqT: // global
           _s8v2U::P64 = P64[_s8v91::P64 + 16];
           _s8v2V::P64 = P64[_s8v91::P64 + 24];
           _s8v2T::I64 = I64[_s8v91::P64 + 40];
           _s8v2W::I64 = I64[_s8v91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v96_entry() //  [R1]
         { info_tbl: [(c8wrg,
                       label: sat_s8v96_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wrg: // global
           _s8v96::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wrh; else goto c8wri;
       c8wri: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wrk; else goto c8wrj;
       c8wrk: // global
           HpAlloc = 56;
           goto c8wrh;
       c8wrh: // global
           R1 = _s8v96::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wrj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v96::P64;
           _s8v2Y::I64 = I64[_s8v96::P64 + 56];
           _s8v6z::I64 = I64[_s8v96::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wrf; else goto c8wre;
       c8wrf: // global
           _s8v36::P64 = P64[_s8v96::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wre: // global
           _s8v2U::P64 = P64[_s8v96::P64 + 16];
           _s8v2V::P64 = P64[_s8v96::P64 + 24];
           _s8v2T::I64 = I64[_s8v96::P64 + 40];
           _s8v2W::I64 = I64[_s8v96::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9b_entry() //  [R1]
         { info_tbl: [(c8wrB,
                       label: sat_s8v9b_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wrB: // global
           _s8v9b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wrC; else goto c8wrD;
       c8wrD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wrF; else goto c8wrE;
       c8wrF: // global
           HpAlloc = 56;
           goto c8wrC;
       c8wrC: // global
           R1 = _s8v9b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wrE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9b::P64;
           _s8v2Y::I64 = I64[_s8v9b::P64 + 56];
           _s8v6z::I64 = I64[_s8v9b::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wrA; else goto c8wrz;
       c8wrA: // global
           _s8v36::P64 = P64[_s8v9b::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wrz: // global
           _s8v2U::P64 = P64[_s8v9b::P64 + 16];
           _s8v2V::P64 = P64[_s8v9b::P64 + 24];
           _s8v2T::I64 = I64[_s8v9b::P64 + 40];
           _s8v2W::I64 = I64[_s8v9b::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9U_entry() //  [R1]
         { info_tbl: [(c8ws0,
                       label: sat_s8v9U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ws0: // global
           _s8v9U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ws1; else goto c8ws2;
       c8ws2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ws4; else goto c8ws3;
       c8ws4: // global
           HpAlloc = 56;
           goto c8ws1;
       c8ws1: // global
           R1 = _s8v9U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ws3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9U::P64;
           _s8v2Y::I64 = I64[_s8v9U::P64 + 56];
           _s8v6z::I64 = I64[_s8v9U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8wrZ; else goto c8wrY;
       c8wrZ: // global
           _s8v36::P64 = P64[_s8v9U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wrY: // global
           _s8v2U::P64 = P64[_s8v9U::P64 + 16];
           _s8v2V::P64 = P64[_s8v9U::P64 + 24];
           _s8v2T::I64 = I64[_s8v9U::P64 + 40];
           _s8v2W::I64 = I64[_s8v9U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF4_entry() //  [R2, R3]
         { info_tbl: [(c8ws7,
                       label: GHC.IO.Encoding.UTF8.mkUTF4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ws7: // global
           if ((Sp + -144) < SpLim) (likely: False) goto c8ws8; else goto c8ws9;
       c8ws8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ws9: // global
           I64[Sp - 16] = block_c8wcq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wGP; else goto c8wcr;
       u8wGP: // global
           call _c8wcq(R1) args: 0, res: 0, upd: 0;
       c8wcr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wcq() //  [R1]
         { info_tbl: [(c8wcq,
                       label: block_c8wcq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wcq: // global
           I64[Sp - 40] = block_c8wcv_info;
           _s8v2U::P64 = P64[R1 + 7];
           _s8v2V::P64 = P64[R1 + 15];
           _s8v2T::I64 = I64[R1 + 23];
           _s8v2W::I64 = I64[R1 + 31];
           _s8v2X::I64 = I64[R1 + 39];
           _s8v2Y::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8v2V::P64;
           I64[Sp - 24] = _s8v2W::I64;
           I64[Sp - 16] = _s8v2X::I64;
           I64[Sp - 8] = _s8v2Y::I64;
           P64[Sp] = _s8v2U::P64;
           I64[Sp + 8] = _s8v2T::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8wFW; else goto c8wcw;
       u8wFW: // global
           call _c8wcv(R1) args: 0, res: 0, upd: 0;
       c8wcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wcv() //  [R1]
         { info_tbl: [(c8wcv,
                       label: block_c8wcv_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wcv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wsd; else goto c8wsc;
       c8wsd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wsc: // global
           _s8v31::P64 = P64[R1 + 7];
           _s8v32::P64 = P64[R1 + 15];
           _s8v30::I64 = I64[R1 + 23];
           _s8v33::I64 = I64[R1 + 31];
           _s8v34::I64 = I64[R1 + 39];
           _s8v35::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8v31::P64;
           P64[Sp - 40] = _s8v32::P64;
           I64[Sp - 32] = _s8v33::I64;
           I64[Sp - 24] = _s8v34::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8v35::I64;
           I64[Sp] = _s8v30::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8wlM() args: 0, res: 0, upd: 0;
     }
 },
 _c8wlM() //  []
         { info_tbl: [(c8wlM,
                       label: block_c8wlM_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wlM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwS; else goto c8wwR;
       c8wwS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wlM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwR: // global
           _s8v33::I64 = I64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 40];
           _s8v6A::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8v6A::I64,
                            _s8v33::I64)) goto c8wCT; else goto c8wCU;
       c8wCT: // global
           _s8v2Y::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8v6z::I64,
                            _s8v2Y::I64)) goto c8wCQ; else goto c8wCR;
       c8wCQ: // global
           _c8wcA::P64 = P64[Sp + 80];
           _s8v2T::I64 = I64[Sp + 104];
           _s8v2U::P64 = P64[Sp + 96];
           _s8v2V::P64 = P64[Sp + 64];
           _s8v2W::I64 = I64[Sp + 72];
           _s8v30::I64 = I64[Sp + 56];
           _s8v31::P64 = P64[Sp + 8];
           _s8v32::P64 = P64[Sp + 16];
           _s8v34::I64 = I64[Sp + 32];
           _s8v6H::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + _s8v6z::I64]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 > 127) goto c8wCN; else goto c8wCO;
       c8wCN: // global
           if (_s8v6H::I64 < 192) goto c8wCI; else goto c8wCL;
       c8wCL: // global
           if (_s8v6H::I64 > 193) goto c8wCI; else goto c8wCK;
       c8wCI: // global
           Hp = Hp - 160;
           if (_s8v6H::I64 < 194) goto s8v6L; else goto c8wCE;
       c8wCE: // global
           if (_s8v6H::I64 > 223) goto s8v6L; else goto c8wCD;
       s8v6L: // global
           if (_s8v6H::I64 < 224) goto s8v6M; else goto c8wBZ;
       c8wBZ: // global
           if (_s8v6H::I64 > 239) goto s8v6M; else goto c8wBY;
       s8v6M: // global
           if (_s8v6H::I64 < 240) goto c8wwX; else goto c8wzv;
       c8wwX: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wcD() args: 0, res: 0, upd: 0;
       c8wzv: // global
           _s8v6O::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (%MO_S_Lt_W64(_s8v6O::I64, 3)) goto u8wEY; else goto u8wF0;
       u8wEY: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 2)) goto u8wEZ; else goto c8wzl;
       u8wEZ: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 1)) goto c8wwZ; else goto c8wzf;
       c8wzf: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wcZ() args: 0, res: 0, upd: 0;
       c8wzl: // global
           _s8v3w::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v3q::I64 = _s8v6H::I64;
           _s8v3p::I64 = _s8v6A::I64;
           _s8v3o::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v3D; else goto c8wto;
       c8wto: // global
           if (_s8v3w::I64 < 144) goto s8v3D; else goto c8wtn;
       c8wtn: // global
           if (_s8v3w::I64 > 191) goto s8v3D; else goto u8wF5;
       s8v3D: // global
           if (_s8v3q::I64 < 241) goto u8wF6; else goto c8wt6;
       u8wF6: // global
           I64[Sp - 8] = _s8v3w::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           Sp = Sp - 16;
           goto u8wG8;
       c8wt6: // global
           if (_s8v3q::I64 > 243) goto u8wF7; else goto c8wt5;
       u8wF7: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8wG8;
       c8wt5: // global
           if (_s8v3w::I64 < 128) goto u8wF8; else goto c8wt4;
       u8wF8: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8wG8;
       c8wt4: // global
           if (_s8v3w::I64 > 191) goto u8wFa; else goto u8wF9;
       u8wFa: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8wG8;
       u8wG8: // global
           call _c8wdZ() args: 0, res: 0, upd: 0;
       u8wF9: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           goto u8wG7;
       u8wF5: // global
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           goto u8wG7;
       u8wG7: // global
           call _c8wdy() args: 0, res: 0, upd: 0;
       u8wF0: // global
           if (%MO_S_Ge_W64(_s8v6O::I64, 4)) goto c8wwZ; else goto c8wzr;
       c8wwZ: // global
           _s8v6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v75::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 3)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 240) goto s8v7r; else goto c8wzc;
       c8wzc: // global
           if (_s8v6T::I64 < 144) goto s8v7r; else goto c8wzb;
       c8wzb: // global
           if (_s8v6T::I64 > 191) goto s8v7r; else goto c8wza;
       c8wza: // global
           if (_s8v6Z::I64 < 128) goto s8v7r; else goto c8wz9;
       c8wz9: // global
           if (_s8v6Z::I64 > 191) goto s8v7r; else goto c8wz8;
       c8wz8: // global
           if (_s8v75::I64 < 128) goto s8v7r; else goto c8wz7;
       c8wz7: // global
           if (_s8v75::I64 > 191) goto s8v7r; else goto u8wFl;
       s8v7r: // global
           if (_s8v6H::I64 < 241) goto u8wFm; else goto c8wys;
       u8wFm: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wys: // global
           if (_s8v6H::I64 > 243) goto u8wFn; else goto c8wyr;
       u8wFn: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wyr: // global
           if (_s8v6T::I64 < 128) goto u8wFo; else goto c8wyq;
       u8wFo: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wyq: // global
           if (_s8v6T::I64 > 191) goto u8wFp; else goto c8wyp;
       u8wFp: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wyp: // global
           if (_s8v6Z::I64 < 128) goto u8wFq; else goto c8wyo;
       u8wFq: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wyo: // global
           if (_s8v6Z::I64 > 191) goto u8wFr; else goto c8wyn;
       u8wFr: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wyn: // global
           if (_s8v75::I64 < 128) goto u8wFs; else goto c8wym;
       u8wFs: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       c8wym: // global
           if (_s8v75::I64 > 191) goto u8wFu; else goto u8wFt;
       u8wFu: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8wGq;
       u8wGq: // global
           call _c8wmW() args: 0, res: 0, upd: 0;
       u8wFt: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 24;
           goto u8wGp;
       u8wFl: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8wGp;
       u8wGp: // global
           call _s8v77() args: 0, res: 0, upd: 0;
       c8wzr: // global
           _s8v4a::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v4g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v44::I64 = _s8v6H::I64;
           _s8v43::I64 = _s8v6A::I64;
           _s8v42::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v4n; else goto c8wv1;
       c8wv1: // global
           if (_s8v4a::I64 < 144) goto s8v4n; else goto c8wv0;
       c8wv0: // global
           if (_s8v4a::I64 > 191) goto s8v4n; else goto c8wuZ;
       c8wuZ: // global
           if (_s8v4g::I64 < 128) goto s8v4n; else goto c8wuY;
       c8wuY: // global
           if (_s8v4g::I64 > 191) goto s8v4n; else goto u8wFc;
       s8v4n: // global
           if (_s8v44::I64 < 241) goto u8wFd; else goto c8wuv;
       u8wFd: // global
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           Sp = Sp - 24;
           goto u8wGg;
       c8wuv: // global
           if (_s8v44::I64 > 243) goto u8wFe; else goto c8wuu;
       u8wFe: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8wGg;
       c8wuu: // global
           if (_s8v4a::I64 < 128) goto u8wFf; else goto c8wut;
       u8wFf: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8wGg;
       c8wut: // global
           if (_s8v4a::I64 > 191) goto u8wFg; else goto c8wus;
       u8wFg: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8wGg;
       c8wus: // global
           if (_s8v4g::I64 < 128) goto u8wFh; else goto c8wur;
       u8wFh: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8wGg;
       c8wur: // global
           if (_s8v4g::I64 > 191) goto u8wFj; else goto u8wFi;
       u8wFj: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8wGg;
       u8wGg: // global
           call _c8wfN() args: 0, res: 0, upd: 0;
       u8wFi: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           goto u8wGf;
       u8wFc: // global
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           goto u8wGf;
       u8wGf: // global
           call _c8wfm() args: 0, res: 0, upd: 0;
       c8wBY: // global
           _s8v8j::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (_s8v8j::I64 != 1) goto u8wF1; else goto c8wBO;
       u8wF1: // global
           if (_s8v8j::I64 != 2) goto c8wzB; else goto c8wBU;
       c8wzB: // global
           _s8v8o::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v8u::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 224) goto s8v8M; else goto c8wBL;
       c8wBL: // global
           if (_s8v8o::I64 < 160) goto s8v8M; else goto c8wBK;
       c8wBK: // global
           if (_s8v8o::I64 > 191) goto s8v8M; else goto c8wBJ;
       c8wBJ: // global
           if (_s8v8u::I64 < 128) goto s8v8M; else goto c8wBI;
       c8wBI: // global
           if (_s8v8u::I64 > 191) goto s8v8M; else goto u8wFx;
       s8v8M: // global
           if (_s8v6H::I64 < 225) goto s8v8N; else goto c8wBf;
       c8wBf: // global
           if (_s8v6H::I64 > 236) goto s8v8N; else goto c8wBe;
       c8wBe: // global
           if (_s8v8o::I64 < 128) goto s8v8N; else goto c8wBd;
       c8wBd: // global
           if (_s8v8o::I64 > 191) goto s8v8N; else goto c8wBc;
       c8wBc: // global
           if (_s8v8u::I64 < 128) goto s8v8N; else goto c8wBb;
       c8wBb: // global
           if (_s8v8u::I64 > 191) goto s8v8N; else goto u8wFy;
       s8v8N: // global
           if (_s8v6H::I64 == 237) goto c8wAB; else goto u8wFz;
       c8wAB: // global
           if (_s8v8o::I64 < 128) goto u8wFA; else goto c8wAA;
       u8wFA: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8wGy;
       c8wAA: // global
           if (_s8v8o::I64 > 159) goto u8wFB; else goto c8wAz;
       u8wFB: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8wGy;
       c8wAz: // global
           if (_s8v8u::I64 < 128) goto u8wFC; else goto c8wAy;
       u8wFC: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8wGy;
       c8wAy: // global
           if (_s8v8u::I64 > 191) goto u8wFE; else goto u8wFD;
       u8wFE: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8wGy;
       u8wFD: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8wGx;
       u8wFz: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8wGy;
       u8wGy: // global
           call _c8wq0() args: 0, res: 0, upd: 0;
       u8wFy: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8wGx;
       u8wFx: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 16;
           goto u8wGx;
       u8wGx: // global
           call _s8v8w() args: 0, res: 0, upd: 0;
       c8wBU: // global
           _s8v5g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v5a::I64 = _s8v6H::I64;
           _s8v59::I64 = _s8v6A::I64;
           _s8v58::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 224) goto s8v5n; else goto c8wwv;
       c8wwv: // global
           if (_s8v5g::I64 < 160) goto s8v5n; else goto c8wwu;
       c8wwu: // global
           if (_s8v5g::I64 > 191) goto s8v5n; else goto u8wFH;
       s8v5n: // global
           if (_s8v5a::I64 < 225) goto s8v5o; else goto c8wwd;
       c8wwd: // global
           if (_s8v5a::I64 > 236) goto s8v5o; else goto c8wwc;
       c8wwc: // global
           if (_s8v5g::I64 < 128) goto s8v5o; else goto c8wwb;
       c8wwb: // global
           if (_s8v5g::I64 > 191) goto s8v5o; else goto u8wFI;
       s8v5o: // global
           if (_s8v5a::I64 == 237) goto c8wvN; else goto u8wFJ;
       c8wvN: // global
           if (_s8v5g::I64 < 128) goto u8wFK; else goto c8wvM;
       u8wFK: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8wGE;
       c8wvM: // global
           if (_s8v5g::I64 > 159) goto u8wFM; else goto u8wFL;
       u8wFM: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8wGE;
       u8wFL: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8wGD;
       u8wFJ: // global
           I64[Sp - 8] = _s8v5g::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           Sp = Sp - 16;
           goto u8wGE;
       u8wGE: // global
           call _c8wiB() args: 0, res: 0, upd: 0;
       u8wFI: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8wGD;
       u8wFH: // global
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           goto u8wGD;
       u8wGD: // global
           call _c8wi5() args: 0, res: 0, upd: 0;
       c8wBO: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8whw() args: 0, res: 0, upd: 0;
       c8wCD: // global
           if (%MO_S_Ge_W64(_s8v2Y::I64 - _s8v6z::I64,
                            2)) goto c8wCB; else goto c8wCC;
       c8wCB: // global
           _s8v9C::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v9C::I64 >= 128) goto c8wCy; else goto c8wCz;
       c8wCy: // global
           if (_s8v9C::I64 < 192) goto c8wCv; else goto c8wCw;
       c8wCv: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8v6H::I64 + -192) << 6) + (_s8v9C::I64 + -128));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 40] = _s8v6z::I64 + 2;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8wGK;
       c8wCw: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wk0() args: 0, res: 0, upd: 0;
       c8wCz: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wkm() args: 0, res: 0, upd: 0;
       c8wCC: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wkI() args: 0, res: 0, upd: 0;
       c8wCK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wCO: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8v6H::I64);
           call MO_Touch(_s8v31::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6z::I64 + 1;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8wGK;
       u8wGK: // global
           call _c8wlM() args: 0, res: 0, upd: 0;
       c8wCR: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wl4() args: 0, res: 0, upd: 0;
       c8wCU: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8wlq() args: 0, res: 0, upd: 0;
     }
 },
 _c8wcD() //  []
         { info_tbl: [(c8wcD,
                       label: block_c8wcD_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wcD: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wsh; else goto c8wsg;
       c8wsh: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wcD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wsg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wcZ() //  []
         { info_tbl: [(c8wcZ,
                       label: block_c8wcZ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wcZ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wsl; else goto c8wsk;
       c8wsl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wcZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wsk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wdZ() //  []
         { info_tbl: [(c8wdZ,
                       label: block_c8wdZ_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wdZ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wsu; else goto c8wst;
       c8wsu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wdZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wst: // global
           _c8wcA::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v3o::I64 = I64[Sp + 64];
           _s8v3p::I64 = I64[Sp + 56];
           if (I64[Sp + 16] == 244) goto c8wsG; else goto c8wsx;
       c8wsG: // global
           _s8v3w::I64 = I64[Sp + 8];
           if (_s8v3w::I64 < 128) goto c8wsA; else goto c8wsF;
       c8wsA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3M_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wsF: // global
           if (_s8v3w::I64 > 143) goto c8wsD; else goto c8wsE;
       c8wsD: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wsE: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8wdy() args: 0, res: 0, upd: 0;
       c8wsx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wdy() //  []
         { info_tbl: [(c8wdy,
                       label: block_c8wdy_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wdy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wsq; else goto c8wsp;
       c8wsq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wdy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wsp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wfN() //  []
         { info_tbl: [(c8wfN,
                       label: block_c8wfN_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wfN: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wtx; else goto c8wtw;
       c8wtx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wfN_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wtw: // global
           _c8wcA::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v42::I64 = I64[Sp + 72];
           _s8v43::I64 = I64[Sp + 64];
           if (I64[Sp + 24] == 244) goto c8wtR; else goto c8wtA;
       c8wtR: // global
           _s8v4a::I64 = I64[Sp + 8];
           if (_s8v4a::I64 < 128) goto c8wtD; else goto c8wtQ;
       c8wtD: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4w_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wtQ: // global
           if (_s8v4a::I64 > 143) goto c8wtG; else goto c8wtP;
       c8wtG: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4B_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wtP: // global
           _s8v4g::I64 = I64[Sp + 16];
           if (_s8v4g::I64 < 128) goto c8wtJ; else goto c8wtO;
       c8wtJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4G_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wtO: // global
           if (_s8v4g::I64 > 191) goto c8wtM; else goto c8wtN;
       c8wtM: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4L_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wtN: // global
           Hp = Hp - 160;
           Sp = Sp + 24;
           call _c8wfm() args: 0, res: 0, upd: 0;
       c8wtA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4r_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wfm() //  []
         { info_tbl: [(c8wfm,
                       label: block_c8wfm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wfm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wtt; else goto c8wts;
       c8wtt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wfm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wts: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v4k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wmW() //  []
         { info_tbl: [(c8wmW,
                       label: block_c8wmW_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wmW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wx8; else goto c8wx7;
       c8wx8: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wmW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wx7: // global
           _c8wcA::P64 = P64[Sp + 112];
           _s8v2T::I64 = I64[Sp + 136];
           _s8v2U::P64 = P64[Sp + 128];
           _s8v2V::P64 = P64[Sp + 96];
           _s8v2W::I64 = I64[Sp + 104];
           _s8v2Y::I64 = I64[Sp + 120];
           _s8v30::I64 = I64[Sp + 88];
           _s8v31::P64 = P64[Sp + 40];
           _s8v32::P64 = P64[Sp + 48];
           _s8v33::I64 = I64[Sp + 56];
           _s8v34::I64 = I64[Sp + 64];
           _s8v6z::I64 = I64[Sp + 72];
           _s8v6A::I64 = I64[Sp + 80];
           if (I64[Sp + 32] == 244) goto c8wxA; else goto c8wxb;
       c8wxA: // global
           _s8v6T::I64 = I64[Sp + 8];
           if (_s8v6T::I64 < 128) goto c8wxe; else goto c8wxz;
       c8wxe: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7A_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxz: // global
           if (_s8v6T::I64 > 143) goto c8wxh; else goto c8wxy;
       c8wxh: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7F_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxy: // global
           _s8v6Z::I64 = I64[Sp + 16];
           if (_s8v6Z::I64 < 128) goto c8wxk; else goto c8wxx;
       c8wxk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7K_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxx: // global
           if (_s8v6Z::I64 > 191) goto c8wxn; else goto c8wxw;
       c8wxn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7P_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxw: // global
           _s8v75::I64 = I64[Sp + 24];
           if (_s8v75::I64 < 128) goto c8wxq; else goto c8wxv;
       c8wxq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxv: // global
           if (_s8v75::I64 > 191) goto c8wxt; else goto c8wxu;
       c8wxt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7Z_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wxu: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v77() args: 0, res: 0, upd: 0;
       c8wxb: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7v_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s8v77() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v77: // global
           _s8v31::P64 = P64[Sp + 32];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           I32[I64[Sp + 80] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 24] - 240 << 18) + ((I64[Sp] - 128 << 12) + ((I64[Sp + 8] - 128 << 6) + (I64[Sp + 16] - 128))));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 64] = _s8v6z::I64 + 4;
           I64[Sp + 72] = _s8v6A::I64 + 1;
           Sp = Sp + 24;
           call _c8wlM() args: 0, res: 0, upd: 0;
     }
 },
 _c8wq0() //  []
         { info_tbl: [(c8wq0,
                       label: block_c8wq0_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wq0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wzL; else goto c8wzK;
       c8wzL: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wq0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wzK: // global
           _c8wcA::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           if (I64[Sp + 24] < 238) goto c8wzO; else goto c8wA5;
       c8wzO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wA5: // global
           _s8v8o::I64 = I64[Sp + 8];
           if (_s8v8o::I64 < 128) goto c8wzR; else goto c8wA4;
       c8wzR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8W_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wA4: // global
           if (_s8v8o::I64 > 191) goto c8wzU; else goto c8wA3;
       c8wzU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v91_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wA3: // global
           _s8v8u::I64 = I64[Sp + 16];
           if (_s8v8u::I64 < 128) goto c8wzX; else goto c8wA2;
       c8wzX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v96_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wA2: // global
           if (_s8v8u::I64 > 191) goto c8wA0; else goto c8wA1;
       c8wA0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9b_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wA1: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v8w() args: 0, res: 0, upd: 0;
     }
 },
 _s8v8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v8w: // global
           _s8v31::P64 = P64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 56];
           _s8v6A::I64 = I64[Sp + 64];
           I32[I64[Sp + 72] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 16] - 224 << 12) + ((I64[Sp] - 128 << 6) + (I64[Sp + 8] - 128)));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 56] = _s8v6z::I64 + 3;
           I64[Sp + 64] = _s8v6A::I64 + 1;
           Sp = Sp + 16;
           call _c8wlM() args: 0, res: 0, upd: 0;
     }
 },
 _c8wiB() //  []
         { info_tbl: [(c8wiB,
                       label: block_c8wiB_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wiB: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wvf; else goto c8wve;
       c8wvf: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wiB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wve: // global
           _c8wcA::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v58::I64 = I64[Sp + 64];
           _s8v59::I64 = I64[Sp + 56];
           _s8v5a::I64 = I64[Sp + 16];
           if (_s8v5a::I64 < 238) goto c8wvi; else goto c8wvv;
       c8wvi: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5s_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wvv: // global
           if (_s8v5a::I64 > 239) goto c8wvl; else goto c8wvu;
       c8wvl: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5x_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wvu: // global
           _s8v5g::I64 = I64[Sp + 8];
           if (_s8v5g::I64 < 128) goto c8wvo; else goto c8wvt;
       c8wvo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5C_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wvt: // global
           if (_s8v5g::I64 > 191) goto c8wvr; else goto c8wvs;
       c8wvr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8wcA::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wvs: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8wi5() args: 0, res: 0, upd: 0;
     }
 },
 _c8wi5() //  []
         { info_tbl: [(c8wi5,
                       label: block_c8wi5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wi5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wva; else goto c8wv9;
       c8wva: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wi5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wv9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8whw() //  []
         { info_tbl: [(c8whw,
                       label: block_c8whw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8whw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wv5; else goto c8wv4;
       c8wv5: // global
           HpAlloc = 160;
           I64[Sp] = block_c8whw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wv4: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v54_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wk0() //  []
         { info_tbl: [(c8wk0,
                       label: block_c8wk0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wk0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwz; else goto c8wwy;
       c8wwz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wk0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5Z_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wkm() //  []
         { info_tbl: [(c8wkm,
                       label: block_c8wkm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wkm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwD; else goto c8wwC;
       c8wwD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wkm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v67_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wkI() //  []
         { info_tbl: [(c8wkI,
                       label: block_c8wkI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wkI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwH; else goto c8wwG;
       c8wwH: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wkI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwG: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6f_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wl4() //  []
         { info_tbl: [(c8wl4,
                       label: block_c8wl4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wl4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwL; else goto c8wwK;
       c8wwL: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wl4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wlq() //  []
         { info_tbl: [(c8wlq,
                       label: block_c8wlq_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wlq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wwP; else goto c8wwO;
       c8wwP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wlq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wwO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.911697098 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes:
         I8[] [85,84,70,45,56,66,79,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.912670101 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom1_entry() //  [R1]
         { info_tbl: [(c8wGY,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wGY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wGZ; else goto c8wH0;
       c8wGZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wH0: // global
           (_c8wGV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8wGV::I64 == 0) goto c8wGX; else goto c8wGW;
       c8wGX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8wGW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8wGV::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.913802656 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF3_closure" {
     GHC.IO.Encoding.UTF8.mkUTF3_closure:
         const GHC.IO.Encoding.UTF8.mkUTF3_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF3_entry() //  []
         { info_tbl: [(c8wH5,
                       label: GHC.IO.Encoding.UTF8.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wH5: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.918115307 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_info;
         const 0;
 },
 sat_s8vbM_entry() //  [R1, R2]
         { info_tbl: [(c8wHr,
                       label: sat_s8vbM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHr: // global
           _s8vb9::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbI_entry() //  [R1]
         { info_tbl: [(c8wHA,
                       label: sat_s8vbI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHA: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wHI,
                       label: sat_s8vbG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wHT,
                       label: sat_s8vbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHT: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8wHU; else goto c8wHV;
       c8wHU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8wHV: // global
           I64[Sp - 24] = block_c8wHQ_info;
           _s8vb9::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8vb9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8wIP; else goto c8wHR;
       u8wIP: // global
           call _c8wHQ(R1) args: 0, res: 0, upd: 0;
       c8wHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wHQ() //  [R1]
         { info_tbl: [(c8wHQ,
                       label: block_c8wHQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHQ: // global
           _s8vbm::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8wHY_info;
           _s8vbd::P64 = R1;
           _s8vbf::P64 = P64[R1 + 7];
           _s8vbg::P64 = P64[R1 + 15];
           _s8vbe::I64 = I64[R1 + 23];
           _s8vbh::I64 = I64[R1 + 31];
           _s8vbi::I64 = I64[R1 + 39];
           _s8vbj::I64 = I64[R1 + 47];
           R1 = _s8vbm::P64;
           I64[Sp - 48] = _s8vbe::I64;
           P64[Sp - 40] = _s8vbf::P64;
           P64[Sp - 32] = _s8vbg::P64;
           I64[Sp - 24] = _s8vbh::I64;
           I64[Sp - 16] = _s8vbi::I64;
           I64[Sp - 8] = _s8vbj::I64;
           P64[Sp] = _s8vbd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8wIO; else goto c8wI0;
       u8wIO: // global
           call _c8wHY(R1) args: 0, res: 0, upd: 0;
       c8wI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wHY() //  [R1]
         { info_tbl: [(c8wHY,
                       label: block_c8wHY_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHY: // global
           _s8vba::P64 = P64[Sp + 72];
           _s8vbd::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8wI6; else goto c8wI7;
       c8wI6: // global
           R3 = _s8vbd::P64;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wI7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wIc; else goto c8wIb;
       c8wIc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wIb: // global
           _s8vbh::I64 = I64[Sp + 32];
           _s8vbj::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vbh::I64 - _s8vbj::I64,
                            3)) goto c8wIJ; else goto c8wIM;
       c8wIJ: // global
           _s8vb9::P64 = P64[Sp + 64];
           _s8vbe::I64 = I64[Sp + 8];
           _s8vbf::P64 = P64[Sp + 16];
           _s8vbg::P64 = P64[Sp + 24];
           _s8vbi::I64 = I64[Sp + 40];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           I8[_s8vbe::I64 + _s8vbj::I64] = 239 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 1)] = 187 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 2)] = 191 :: W8;
           call MO_Touch(_s8vbf::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vbf::P64;
           P64[Hp - 32] = _s8vbg::P64;
           I64[Hp - 24] = _s8vbe::I64;
           I64[Hp - 16] = _s8vbh::I64;
           I64[Hp - 8] = _s8vbi::I64;
           I64[Hp] = _s8vbj::I64 + 3;
           R3 = Hp - 47;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wIM: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _s8vba::P64;
           P64[Hp - 24] = _s8vbd::P64;
           _c8wIL::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8wIL::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbO_entry() //  [R1]
         { info_tbl: [(c8wIR,
                       label: sat_s8vbO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wIR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wIS; else goto c8wIT;
       c8wIS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8wIT: // global
           I64[Sp - 16] = block_c8wHh_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wHh() //  [R1]
         { info_tbl: [(c8wHh,
                       label: block_c8wHh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wHh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8wIW; else goto c8wIV;
       c8wIW: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wIV: // global
           I64[Hp - 104] = sat_s8vbM_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vbI_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vbG_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vbF_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb3_entry() //  [R1, R2]
         { info_tbl: [(c8wJc,
                       label: sat_s8vb3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJc: // global
           _s8va8::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaZ_entry() //  [R1]
         { info_tbl: [(c8wJl,
                       label: sat_s8vaZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJl: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wJt,
                       label: sat_s8vaX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaW_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wJE,
                       label: sat_s8vaW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJE: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8wJF; else goto c8wJG;
       c8wJF: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8wJG: // global
           I64[Sp - 24] = block_c8wJB_info;
           _s8va8::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8va8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8wLn; else goto c8wJC;
       u8wLn: // global
           call _c8wJB(R1) args: 0, res: 0, upd: 0;
       c8wJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wJB() //  [R1]
         { info_tbl: [(c8wJB,
                       label: block_c8wJB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJB: // global
           _s8val::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8wJJ_info;
           _s8vac::P64 = R1;
           _s8vae::P64 = P64[R1 + 7];
           _s8vaf::P64 = P64[R1 + 15];
           _s8vad::I64 = I64[R1 + 23];
           _s8vag::I64 = I64[R1 + 31];
           _s8vah::I64 = I64[R1 + 39];
           _s8vai::I64 = I64[R1 + 47];
           R1 = _s8val::P64;
           I64[Sp - 48] = _s8vad::I64;
           P64[Sp - 40] = _s8vae::P64;
           P64[Sp - 32] = _s8vaf::P64;
           I64[Sp - 24] = _s8vag::I64;
           I64[Sp - 16] = _s8vah::I64;
           I64[Sp - 8] = _s8vai::I64;
           P64[Sp] = _s8vac::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8wLm; else goto c8wJL;
       u8wLm: // global
           call _c8wJJ(R1) args: 0, res: 0, upd: 0;
       c8wJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wJJ() //  [R1]
         { info_tbl: [(c8wJJ,
                       label: block_c8wJJ_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJJ: // global
           _s8vaa::P64 = P64[Sp + 72];
           _s8vac::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8wJR; else goto c8wJS;
       c8wJR: // global
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wJS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wJX; else goto c8wJW;
       c8wJX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wJW: // global
           _s8vah::I64 = I64[Sp + 40];
           _s8vai::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            1)) goto c8wL8; else goto c8wLb;
       c8wL8: // global
           _s8va8::P64 = P64[Sp + 64];
           _s8vad::I64 = I64[Sp + 8];
           _s8vae::P64 = P64[Sp + 16];
           _s8vaf::P64 = P64[Sp + 24];
           _s8vag::I64 = I64[Sp + 32];
           _s8vas::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + _s8vah::I64]);
           call MO_Touch(_s8vae::P64);
           if (_s8vas::I64 == 239) goto c8wL6; else goto c8wKa;
       c8wL6: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            2)) goto c8wL2; else goto c8wL5;
       c8wL2: // global
           _s8vaC::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 1)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaC::I64 == 187) goto c8wL0; else goto c8wKs;
       c8wL0: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            3)) goto c8wKW; else goto c8wKZ;
       c8wKW: // global
           _s8vaM::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 2)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaM::I64 == 191) goto c8wKU; else goto c8wKK;
       c8wKU: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vae::P64;
           P64[Hp - 32] = _s8vaf::P64;
           I64[Hp - 24] = _s8vad::I64;
           I64[Hp - 16] = _s8vag::I64;
           I64[Hp - 8] = _s8vah::I64 + 3;
           I64[Hp] = _s8vai::I64;
           R3 = _s8vaa::P64;
           R2 = Hp - 47;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wKK: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wKZ: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8wKY::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8wKY::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wKs: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wL5: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8wL4::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8wL4::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wKa: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8wLb: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8wLa::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8wLa::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb5_entry() //  [R1]
         { info_tbl: [(c8wLp,
                       label: sat_s8vb5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wLp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wLq; else goto c8wLr;
       c8wLq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8wLr: // global
           I64[Sp - 16] = block_c8wJ2_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wJ2() //  [R1]
         { info_tbl: [(c8wJ2,
                       label: block_c8wJ2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wJ2: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8wLu; else goto c8wLt;
       c8wLu: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wLt: // global
           I64[Hp - 104] = sat_s8vb3_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vaZ_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vaX_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vaW_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom_entry() //  [R2]
         { info_tbl: [(c8wLw,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wLw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8wLA; else goto c8wLz;
       c8wLA: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8wLz: // global
           I64[Hp - 56] = sat_s8vbO_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vb5_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.925875665 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_bom_closure" {
     GHC.IO.Encoding.UTF8.utf8_bom_closure:
         const GHC.IO.Encoding.UTF8.utf8_bom_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf8_bom_entry() //  [R1]
         { info_tbl: [(c8wLH,
                       label: GHC.IO.Encoding.UTF8.utf8_bom_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wLH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wLI; else goto c8wLJ;
       c8wLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wLJ: // global
           (_c8wLE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8wLE::I64 == 0) goto c8wLG; else goto c8wLF;
       c8wLG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8wLF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8wLE::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF8.mkUTF8_bom_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.926886339 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF6_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF6_bytes:
         I8[] [85,84,70,45,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.927657022 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF5_closure" {
     GHC.IO.Encoding.UTF8.mkUTF5_closure:
         const GHC.IO.Encoding.UTF8.mkUTF5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF5_entry() //  [R1]
         { info_tbl: [(c8wLQ,
                       label: GHC.IO.Encoding.UTF8.mkUTF5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wLQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wLR; else goto c8wLS;
       c8wLR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wLS: // global
           (_c8wLN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8wLN::I64 == 0) goto c8wLP; else goto c8wLO;
       c8wLP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8wLO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8wLN::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.928685042 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF2_closure" {
     GHC.IO.Encoding.UTF8.mkUTF2_closure:
         const GHC.IO.Encoding.UTF8.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF2_entry() //  []
         { info_tbl: [(c8wLX,
                       label: GHC.IO.Encoding.UTF8.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wLX: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.930211713 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_info;
         const 0;
 },
 sat_s8vbX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wMe,
                       label: sat_s8vbX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbZ_entry() //  [R1]
         { info_tbl: [(c8wMi,
                       label: sat_s8vbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8wMm; else goto c8wMl;
       c8wMm: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8wMl: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbX_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8wMx,
                       label: sat_s8vbT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbV_entry() //  [R1]
         { info_tbl: [(c8wMB,
                       label: sat_s8vbV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8wMF; else goto c8wME;
       c8wMF: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8wME: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbT_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_entry() //  [R2]
         { info_tbl: [(c8wMH,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8wML; else goto c8wMK;
       c8wML: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8wMK: // global
           I64[Hp - 56] = sat_s8vbZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vbV_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF5_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.932626472 UTC

[section ""data" . lvl_r8uYu_closure" {
     lvl_r8uYu_closure:
         const lvl_r8uYu_info;
         const 0;
 },
 lvl_r8uYu_entry() //  [R2, R3]
         { info_tbl: [(c8wMT,
                       label: lvl_r8uYu_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wMX; else goto c8wMY;
       c8wMX: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8uYu_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8wMY: // global
           I64[Sp - 16] = block_c8wMQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wN6; else goto c8wMR;
       u8wN6: // global
           call _c8wMQ() args: 0, res: 0, upd: 0;
       c8wMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wMQ() //  []
         { info_tbl: [(c8wMQ,
                       label: block_c8wMQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMQ: // global
           _s8vc1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8wMW_info;
           R1 = _s8vc1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8wN5; else goto c8wN0;
       u8wN5: // global
           call _c8wMW() args: 0, res: 0, upd: 0;
       c8wN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wMW() //  []
         { info_tbl: [(c8wMW,
                       label: block_c8wMW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wMW: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.933969187 UTC

[section ""data" . lvl1_r8uYv_closure" {
     lvl1_r8uYv_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
         const lvl_r8uYu_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.934717494 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf3_closure" {
     GHC.IO.Encoding.UTF8.utf3_closure:
         const GHC.IO.Encoding.UTF8.utf3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf3_entry() //  []
         { info_tbl: [(c8wNb,
                       label: GHC.IO.Encoding.UTF8.utf3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNb: // global
           R1 = lvl1_r8uYv_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.938770079 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf2_closure" {
     GHC.IO.Encoding.UTF8.utf2_closure:
         const GHC.IO.Encoding.UTF8.utf2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf2_entry() //  [R2, R3]
         { info_tbl: [(c8wNl,
                       label: GHC.IO.Encoding.UTF8.utf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8wNp; else goto c8wNq;
       c8wNp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.utf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8wNq: // global
           I64[Sp - 16] = block_c8wNi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wNz; else goto c8wNj;
       u8wNz: // global
           call _c8wNi(R1) args: 0, res: 0, upd: 0;
       c8wNj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wNi() //  [R1]
         { info_tbl: [(c8wNi,
                       label: block_c8wNi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNi: // global
           I64[Sp - 16] = block_c8wNo_info;
           _s8vcn::P64 = P64[R1 + 7];
           _s8vcm::I64 = I64[R1 + 23];
           _s8vcq::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8vcq::I64;
           P64[Sp] = _s8vcn::P64;
           I64[Sp + 8] = _s8vcm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wNy; else goto c8wNs;
       u8wNy: // global
           call _c8wNo() args: 0, res: 0, upd: 0;
       c8wNs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wNo() //  []
         { info_tbl: [(c8wNo,
                       label: block_c8wNo_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNo: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.940073133 UTC

[section ""data" . lvl2_r8uYw_closure" {
     lvl2_r8uYw_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF8.utf2_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.940891062 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf1_closure" {
     GHC.IO.Encoding.UTF8.utf1_closure:
         const GHC.IO.Encoding.UTF8.utf1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf1_entry() //  []
         { info_tbl: [(c8wNE,
                       label: GHC.IO.Encoding.UTF8.utf1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNE: // global
           R1 = lvl2_r8uYw_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.941697282 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_closure" {
     GHC.IO.Encoding.UTF8.utf8_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.UTF8.utf3_closure+1;
         const GHC.IO.Encoding.UTF8.utf1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.942363764 UTC

[section ""relreadonly" . S8vY4_srt" {
     S8vY4_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_closure;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8uYu_closure;
         const lvl1_r8uYv_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF8.utf2_closure;
         const lvl2_r8uYw_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.943328812 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:36.944591765 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule4_bytes" {
     GHC.IO.Encoding.UTF8.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.946775138 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule3_closure" {
     GHC.IO.Encoding.UTF8.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.94858961 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule2_bytes" {
     GHC.IO.Encoding.UTF8.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.950329161 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule1_closure" {
     GHC.IO.Encoding.UTF8.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.952088423 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule_closure" {
     GHC.IO.Encoding.UTF8.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF8.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF8.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:36.961695295 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF1_info;
 },
 sat_s8uYV_entry() //  [R1]
         { info_tbl: [(c8wOg,
                       label: sat_s8uYV_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wOg: // global
           _s8uYV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wOh; else goto c8wOi;
       c8wOi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wOk; else goto c8wOj;
       c8wOk: // global
           HpAlloc = 56;
           goto c8wOh;
       c8wOh: // global
           R1 = _s8uYV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wOj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uYV::P64;
           _s8uYH::I64 = I64[_s8uYV::P64 + 56];
           _s8uYR::I64 = I64[_s8uYV::P64 + 64];
           if (_s8uYR::I64 == _s8uYH::I64) goto c8wOf; else goto c8wOe;
       c8wOf: // global
           _s8uYP::P64 = P64[_s8uYV::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wOe: // global
           _s8uYD::P64 = P64[_s8uYV::P64 + 16];
           _s8uYE::P64 = P64[_s8uYV::P64 + 24];
           _s8uYC::I64 = I64[_s8uYV::P64 + 40];
           _s8uYF::I64 = I64[_s8uYV::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYR::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZ3_entry() //  [R1]
         { info_tbl: [(c8wOC,
                       label: sat_s8uZ3_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wOC: // global
           _s8uZ3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wOD; else goto c8wOE;
       c8wOE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wOG; else goto c8wOF;
       c8wOG: // global
           HpAlloc = 56;
           goto c8wOD;
       c8wOD: // global
           R1 = _s8uZ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZ3::P64;
           _s8uYH::I64 = I64[_s8uZ3::P64 + 56];
           _s8uYZ::I64 = I64[_s8uZ3::P64 + 64];
           if (_s8uYZ::I64 == _s8uYH::I64) goto c8wOB; else goto c8wOA;
       c8wOB: // global
           _s8uYP::P64 = P64[_s8uZ3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wOA: // global
           _s8uYD::P64 = P64[_s8uZ3::P64 + 16];
           _s8uYE::P64 = P64[_s8uZ3::P64 + 24];
           _s8uYC::I64 = I64[_s8uZ3::P64 + 40];
           _s8uYF::I64 = I64[_s8uZ3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uYZ::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZb_entry() //  [R1]
         { info_tbl: [(c8wOY,
                       label: sat_s8uZb_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wOY: // global
           _s8uZb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wOZ; else goto c8wP0;
       c8wP0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wP2; else goto c8wP1;
       c8wP2: // global
           HpAlloc = 56;
           goto c8wOZ;
       c8wOZ: // global
           R1 = _s8uZb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZb::P64;
           _s8uYH::I64 = I64[_s8uZb::P64 + 56];
           _s8uZ7::I64 = I64[_s8uZb::P64 + 64];
           if (_s8uZ7::I64 == _s8uYH::I64) goto c8wOX; else goto c8wOW;
       c8wOX: // global
           _s8uYP::P64 = P64[_s8uZb::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wOW: // global
           _s8uYD::P64 = P64[_s8uZb::P64 + 16];
           _s8uYE::P64 = P64[_s8uZb::P64 + 24];
           _s8uYC::I64 = I64[_s8uZb::P64 + 40];
           _s8uYF::I64 = I64[_s8uZb::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZ7::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZj_entry() //  [R1]
         { info_tbl: [(c8wPk,
                       label: sat_s8uZj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wPk: // global
           _s8uZj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wPl; else goto c8wPm;
       c8wPm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wPo; else goto c8wPn;
       c8wPo: // global
           HpAlloc = 56;
           goto c8wPl;
       c8wPl: // global
           R1 = _s8uZj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wPn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZj::P64;
           _s8uYH::I64 = I64[_s8uZj::P64 + 56];
           _s8uZf::I64 = I64[_s8uZj::P64 + 64];
           if (_s8uZf::I64 == _s8uYH::I64) goto c8wPj; else goto c8wPi;
       c8wPj: // global
           _s8uYP::P64 = P64[_s8uZj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wPi: // global
           _s8uYD::P64 = P64[_s8uZj::P64 + 16];
           _s8uYE::P64 = P64[_s8uZj::P64 + 24];
           _s8uYC::I64 = I64[_s8uZj::P64 + 40];
           _s8uYF::I64 = I64[_s8uZj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZf::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8uZr_entry() //  [R1]
         { info_tbl: [(c8wPG,
                       label: sat_s8uZr_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wPG: // global
           _s8uZr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wPH; else goto c8wPI;
       c8wPI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wPK; else goto c8wPJ;
       c8wPK: // global
           HpAlloc = 56;
           goto c8wPH;
       c8wPH: // global
           R1 = _s8uZr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8uZr::P64;
           _s8uYH::I64 = I64[_s8uZr::P64 + 56];
           _s8uZn::I64 = I64[_s8uZr::P64 + 64];
           if (_s8uZn::I64 == _s8uYH::I64) goto c8wPF; else goto c8wPE;
       c8wPF: // global
           _s8uYP::P64 = P64[_s8uZr::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wPE: // global
           _s8uYD::P64 = P64[_s8uZr::P64 + 16];
           _s8uYE::P64 = P64[_s8uZr::P64 + 24];
           _s8uYC::I64 = I64[_s8uZr::P64 + 40];
           _s8uYF::I64 = I64[_s8uZr::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZn::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v1h_entry() //  [R1]
         { info_tbl: [(c8wQx,
                       label: sat_s8v1h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wQx: // global
           _s8v1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wQy; else goto c8wQz;
       c8wQz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wQB; else goto c8wQA;
       c8wQB: // global
           HpAlloc = 56;
           goto c8wQy;
       c8wQy: // global
           R1 = _s8v1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wQA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v1h::P64;
           _s8uYH::I64 = I64[_s8v1h::P64 + 56];
           _s8uZv::I64 = I64[_s8v1h::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8wQw; else goto c8wQv;
       c8wQw: // global
           _s8uYP::P64 = P64[_s8v1h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wQv: // global
           _s8uYD::P64 = P64[_s8v1h::P64 + 16];
           _s8uYE::P64 = P64[_s8v1h::P64 + 24];
           _s8uYC::I64 = I64[_s8v1h::P64 + 40];
           _s8uYF::I64 = I64[_s8v1h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2i_entry() //  [R1]
         { info_tbl: [(c8wR0,
                       label: sat_s8v2i_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wR0: // global
           _s8v2i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wR1; else goto c8wR2;
       c8wR2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wR4; else goto c8wR3;
       c8wR4: // global
           HpAlloc = 56;
           goto c8wR1;
       c8wR1: // global
           R1 = _s8v2i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wR3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2i::P64;
           _s8uYH::I64 = I64[_s8v2i::P64 + 56];
           _s8uZv::I64 = I64[_s8v2i::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8wQZ; else goto c8wQY;
       c8wQZ: // global
           _s8uYP::P64 = P64[_s8v2i::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wQY: // global
           _s8uYD::P64 = P64[_s8v2i::P64 + 16];
           _s8uYE::P64 = P64[_s8v2i::P64 + 24];
           _s8uYC::I64 = I64[_s8v2i::P64 + 40];
           _s8uYF::I64 = I64[_s8v2i::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v2m_entry() //  [R1]
         { info_tbl: [(c8wRi,
                       label: sat_s8v2m_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wRi: // global
           _s8v2m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8wRj; else goto c8wRk;
       c8wRk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wRm; else goto c8wRl;
       c8wRm: // global
           HpAlloc = 56;
           goto c8wRj;
       c8wRj: // global
           R1 = _s8v2m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wRl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v2m::P64;
           _s8uYH::I64 = I64[_s8v2m::P64 + 56];
           _s8uZv::I64 = I64[_s8v2m::P64 + 64];
           if (_s8uZv::I64 == _s8uYH::I64) goto c8wRh; else goto c8wRg;
       c8wRh: // global
           _s8uYP::P64 = P64[_s8v2m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8uYP::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8wRg: // global
           _s8uYD::P64 = P64[_s8v2m::P64 + 16];
           _s8uYE::P64 = P64[_s8v2m::P64 + 24];
           _s8uYC::I64 = I64[_s8v2m::P64 + 40];
           _s8uYF::I64 = I64[_s8v2m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8uYD::P64;
           P64[Hp - 32] = _s8uYE::P64;
           I64[Hp - 24] = _s8uYC::I64;
           I64[Hp - 16] = _s8uYF::I64;
           I64[Hp - 8] = _s8uZv::I64;
           I64[Hp] = _s8uYH::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8wRp,
                       label: GHC.IO.Encoding.UTF8.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wRp: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8wRq; else goto c8wRr;
       c8wRq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8wRr: // global
           I64[Sp - 16] = block_c8wNQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wZW; else goto c8wNR;
       u8wZW: // global
           call _c8wNQ(R1) args: 0, res: 0, upd: 0;
       c8wNR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wNQ() //  [R1]
         { info_tbl: [(c8wNQ,
                       label: block_c8wNQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNQ: // global
           I64[Sp - 40] = block_c8wNV_info;
           _s8uYD::P64 = P64[R1 + 7];
           _s8uYE::P64 = P64[R1 + 15];
           _s8uYC::I64 = I64[R1 + 23];
           _s8uYF::I64 = I64[R1 + 31];
           _s8uYG::I64 = I64[R1 + 39];
           _s8uYH::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8uYE::P64;
           I64[Sp - 24] = _s8uYF::I64;
           I64[Sp - 16] = _s8uYG::I64;
           I64[Sp - 8] = _s8uYH::I64;
           P64[Sp] = _s8uYD::P64;
           I64[Sp + 8] = _s8uYC::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8wZI; else goto c8wNW;
       u8wZI: // global
           call _c8wNV(R1) args: 0, res: 0, upd: 0;
       c8wNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wNV() //  [R1]
         { info_tbl: [(c8wNV,
                       label: block_c8wNV_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wNV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8wRv; else goto c8wRu;
       c8wRv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wRu: // global
           _s8uYK::P64 = P64[R1 + 7];
           _s8uYL::P64 = P64[R1 + 15];
           _s8uYJ::I64 = I64[R1 + 23];
           _s8uYM::I64 = I64[R1 + 31];
           _s8uYN::I64 = I64[R1 + 39];
           _s8uYO::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8uYK::P64;
           P64[Sp - 40] = _s8uYL::P64;
           I64[Sp - 32] = _s8uYM::I64;
           I64[Sp - 24] = _s8uYN::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8uYO::I64;
           I64[Sp] = _s8uYJ::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8wPP() args: 0, res: 0, upd: 0;
     }
 },
 _c8wPP() //  []
         { info_tbl: [(c8wPP,
                       label: block_c8wPP_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wPP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRS; else goto c8wRR;
       c8wRS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wPP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRR: // global
           _s8uYM::I64 = I64[Sp + 24];
           _s8uZv::I64 = I64[Sp + 40];
           _s8uZw::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8uZw::I64,
                            _s8uYM::I64)) goto c8wTe; else goto c8wTf;
       c8wTe: // global
           _s8uYH::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8uZv::I64,
                            _s8uYH::I64)) goto c8wTb; else goto c8wTc;
       c8wTb: // global
           _c8wO0::P64 = P64[Sp + 80];
           _s8uYC::I64 = I64[Sp + 104];
           _s8uYD::P64 = P64[Sp + 96];
           _s8uYE::P64 = P64[Sp + 64];
           _s8uYF::I64 = I64[Sp + 72];
           _s8uYJ::I64 = I64[Sp + 56];
           _s8uYK::P64 = P64[Sp + 8];
           _s8uYL::P64 = P64[Sp + 16];
           _s8uYN::I64 = I64[Sp + 32];
           _s8uZC::I64 = %MO_UU_Conv_W32_W64(I32[_s8uYC::I64 + (_s8uZv::I64 << 2)]);
           call MO_Touch(_s8uYD::P64);
           if (%MO_S_Gt_W64(_s8uZC::I64, 127)) goto c8wT8; else goto c8wT9;
       c8wT8: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 2047)) goto c8wSW; else goto c8wT6;
       c8wSW: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 65535)) goto c8wS2; else goto c8wSU;
       c8wS2: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            4)) goto c8wRZ; else goto c8wS0;
       c8wRZ: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            18) + 240);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  12) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 4;
           goto u8wZT;
       c8wS0: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8wO3() args: 0, res: 0, upd: 0;
       c8wSU: // global
           if (%MO_S_Gt_W64(55296, _s8uZC::I64)) goto c8wSr; else goto c8wST;
       c8wSr: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8wSc; else goto c8wSp;
       c8wSc: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8wSJ; else goto c8wS9;
       c8wS9: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wZT;
       c8wSp: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8wSm; else goto c8wSo;
       c8wSm: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8wSJ; else goto c8wSj;
       c8wSj: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wZT;
       c8wSo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v1h_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8wO0::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wST: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 56319)) goto c8wSQ; else goto c8wSS;
       c8wSQ: // global
           if (%MO_S_Gt_W64(56320, _s8uZC::I64)) goto c8wSB; else goto c8wSO;
       c8wSB: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8wSJ; else goto c8wSy;
       c8wSy: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wZT;
       c8wSO: // global
           if (%MO_S_Gt_W64(_s8uZC::I64, 57343)) goto c8wSL; else goto c8wSN;
       c8wSL: // global
           if (%MO_S_Lt_W64(_s8uYM::I64 - _s8uZw::I64,
                            3)) goto c8wSJ; else goto c8wSI;
       c8wSJ: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8wOp() args: 0, res: 0, upd: 0;
       c8wSI: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            12) + 224);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 3;
           goto u8wZT;
       c8wSN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2i_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8wO0::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wSS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8uYK::P64;
           P64[Hp - 136] = _s8uYL::P64;
           I64[Hp - 128] = _s8uYJ::I64;
           I64[Hp - 120] = _s8uYM::I64;
           I64[Hp - 112] = _s8uYN::I64;
           I64[Hp - 104] = _s8uZw::I64;
           I64[Hp - 96] = sat_s8v2m_info;
           P64[Hp - 80] = _s8uYD::P64;
           P64[Hp - 72] = _s8uYE::P64;
           P64[Hp - 64] = _c8wO0::P64;
           I64[Hp - 56] = _s8uYC::I64;
           I64[Hp - 48] = _s8uYF::I64;
           I64[Hp - 40] = _s8uYH::I64;
           I64[Hp - 32] = _s8uZv::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8wT6: // global
           if (%MO_S_Ge_W64(_s8uYM::I64 - _s8uZw::I64,
                            2)) goto c8wT4; else goto c8wT5;
       c8wT4: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8uZC::I64,
                                                                            6) + 192);
           call MO_Touch(_s8uYK::P64);
           I8[_s8uYJ::I64 + (_s8uZw::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8uZC::I64 & 63 + 128);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 2;
           goto u8wZT;
       c8wT5: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8wOL() args: 0, res: 0, upd: 0;
       c8wT9: // global
           I8[_s8uYJ::I64 + _s8uZw::I64] = %MO_UU_Conv_W64_W8(_s8uZC::I64);
           call MO_Touch(_s8uYK::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZv::I64 + 1;
           I64[Sp + 48] = _s8uZw::I64 + 1;
           goto u8wZT;
       u8wZT: // global
           call _c8wPP() args: 0, res: 0, upd: 0;
       c8wTc: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8wP7() args: 0, res: 0, upd: 0;
       c8wTf: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8uZw::I64;
           I64[Sp + 48] = _s8uZv::I64;
           call _c8wPt() args: 0, res: 0, upd: 0;
     }
 },
 _c8wO3() //  []
         { info_tbl: [(c8wO3,
                       label: block_c8wO3_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wO3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRz; else goto c8wRy;
       c8wRz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wO3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uYV_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wOp() //  []
         { info_tbl: [(c8wOp,
                       label: block_c8wOp_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wOp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRD; else goto c8wRC;
       c8wRD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wOp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZ3_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wOL() //  []
         { info_tbl: [(c8wOL,
                       label: block_c8wOL_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wOL: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRH; else goto c8wRG;
       c8wRH: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wOL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRG: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZb_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wP7() //  []
         { info_tbl: [(c8wP7,
                       label: block_c8wP7_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wP7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRL; else goto c8wRK;
       c8wRL: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wP7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZj_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8wPt() //  []
         { info_tbl: [(c8wPt,
                       label: block_c8wPt_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wPt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8wRP; else goto c8wRO;
       c8wRP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8wPt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8wRO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8uZr_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.044758656 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF4_closure" {
     GHC.IO.Encoding.UTF8.mkUTF4_closure:
         const GHC.IO.Encoding.UTF8.mkUTF4_info;
 },
 sat_s8v3c_entry() //  [R1]
         { info_tbl: [(c8x4E,
                       label: sat_s8v3c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x4E: // global
           _s8v3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x4F; else goto c8x4G;
       c8x4G: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x4I; else goto c8x4H;
       c8x4I: // global
           HpAlloc = 56;
           goto c8x4F;
       c8x4F: // global
           R1 = _s8v3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x4H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3c::P64;
           _s8v2Y::I64 = I64[_s8v3c::P64 + 56];
           _s8v38::I64 = I64[_s8v3c::P64 + 64];
           if (_s8v38::I64 == _s8v2Y::I64) goto c8x4D; else goto c8x4C;
       c8x4D: // global
           _s8v36::P64 = P64[_s8v3c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x4C: // global
           _s8v2U::P64 = P64[_s8v3c::P64 + 16];
           _s8v2V::P64 = P64[_s8v3c::P64 + 24];
           _s8v2T::I64 = I64[_s8v3c::P64 + 40];
           _s8v2W::I64 = I64[_s8v3c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v38::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3k_entry() //  [R1]
         { info_tbl: [(c8x50,
                       label: sat_s8v3k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x50: // global
           _s8v3k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x51; else goto c8x52;
       c8x52: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x54; else goto c8x53;
       c8x54: // global
           HpAlloc = 56;
           goto c8x51;
       c8x51: // global
           R1 = _s8v3k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x53: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3k::P64;
           _s8v2Y::I64 = I64[_s8v3k::P64 + 56];
           _s8v3g::I64 = I64[_s8v3k::P64 + 64];
           if (_s8v3g::I64 == _s8v2Y::I64) goto c8x4Z; else goto c8x4Y;
       c8x4Z: // global
           _s8v36::P64 = P64[_s8v3k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x4Y: // global
           _s8v2U::P64 = P64[_s8v3k::P64 + 16];
           _s8v2V::P64 = P64[_s8v3k::P64 + 24];
           _s8v2T::I64 = I64[_s8v3k::P64 + 40];
           _s8v2W::I64 = I64[_s8v3k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3g::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3A_entry() //  [R1]
         { info_tbl: [(c8x5y,
                       label: sat_s8v3A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x5y: // global
           _s8v3A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x5z; else goto c8x5A;
       c8x5A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x5C; else goto c8x5B;
       c8x5C: // global
           HpAlloc = 56;
           goto c8x5z;
       c8x5z: // global
           R1 = _s8v3A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3A::P64;
           _s8v2Y::I64 = I64[_s8v3A::P64 + 56];
           _s8v3o::I64 = I64[_s8v3A::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8x5x; else goto c8x5w;
       c8x5x: // global
           _s8v36::P64 = P64[_s8v3A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x5w: // global
           _s8v2U::P64 = P64[_s8v3A::P64 + 16];
           _s8v2V::P64 = P64[_s8v3A::P64 + 24];
           _s8v2T::I64 = I64[_s8v3A::P64 + 40];
           _s8v2W::I64 = I64[_s8v3A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3H_entry() //  [R1]
         { info_tbl: [(c8x61,
                       label: sat_s8v3H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x61: // global
           _s8v3H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x62; else goto c8x63;
       c8x63: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x65; else goto c8x64;
       c8x65: // global
           HpAlloc = 56;
           goto c8x62;
       c8x62: // global
           R1 = _s8v3H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3H::P64;
           _s8v2Y::I64 = I64[_s8v3H::P64 + 56];
           _s8v3o::I64 = I64[_s8v3H::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8x60; else goto c8x5Z;
       c8x60: // global
           _s8v36::P64 = P64[_s8v3H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x5Z: // global
           _s8v2U::P64 = P64[_s8v3H::P64 + 16];
           _s8v2V::P64 = P64[_s8v3H::P64 + 24];
           _s8v2T::I64 = I64[_s8v3H::P64 + 40];
           _s8v2W::I64 = I64[_s8v3H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3M_entry() //  [R1]
         { info_tbl: [(c8x6m,
                       label: sat_s8v3M_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x6m: // global
           _s8v3M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x6n; else goto c8x6o;
       c8x6o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x6q; else goto c8x6p;
       c8x6q: // global
           HpAlloc = 56;
           goto c8x6n;
       c8x6n: // global
           R1 = _s8v3M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x6p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3M::P64;
           _s8v2Y::I64 = I64[_s8v3M::P64 + 56];
           _s8v3o::I64 = I64[_s8v3M::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8x6l; else goto c8x6k;
       c8x6l: // global
           _s8v36::P64 = P64[_s8v3M::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x6k: // global
           _s8v2U::P64 = P64[_s8v3M::P64 + 16];
           _s8v2V::P64 = P64[_s8v3M::P64 + 24];
           _s8v2T::I64 = I64[_s8v3M::P64 + 40];
           _s8v2W::I64 = I64[_s8v3M::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v3R_entry() //  [R1]
         { info_tbl: [(c8x6H,
                       label: sat_s8v3R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x6H: // global
           _s8v3R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x6I; else goto c8x6J;
       c8x6J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x6L; else goto c8x6K;
       c8x6L: // global
           HpAlloc = 56;
           goto c8x6I;
       c8x6I: // global
           R1 = _s8v3R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v3R::P64;
           _s8v2Y::I64 = I64[_s8v3R::P64 + 56];
           _s8v3o::I64 = I64[_s8v3R::P64 + 64];
           if (_s8v3o::I64 == _s8v2Y::I64) goto c8x6G; else goto c8x6F;
       c8x6G: // global
           _s8v36::P64 = P64[_s8v3R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x6F: // global
           _s8v2U::P64 = P64[_s8v3R::P64 + 16];
           _s8v2V::P64 = P64[_s8v3R::P64 + 24];
           _s8v2T::I64 = I64[_s8v3R::P64 + 40];
           _s8v2W::I64 = I64[_s8v3R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v3o::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4k_entry() //  [R1]
         { info_tbl: [(c8x7m,
                       label: sat_s8v4k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x7m: // global
           _s8v4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x7n; else goto c8x7o;
       c8x7o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x7q; else goto c8x7p;
       c8x7q: // global
           HpAlloc = 56;
           goto c8x7n;
       c8x7n: // global
           R1 = _s8v4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x7p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4k::P64;
           _s8v2Y::I64 = I64[_s8v4k::P64 + 56];
           _s8v42::I64 = I64[_s8v4k::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x7l; else goto c8x7k;
       c8x7l: // global
           _s8v36::P64 = P64[_s8v4k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x7k: // global
           _s8v2U::P64 = P64[_s8v4k::P64 + 16];
           _s8v2V::P64 = P64[_s8v4k::P64 + 24];
           _s8v2T::I64 = I64[_s8v4k::P64 + 40];
           _s8v2W::I64 = I64[_s8v4k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4r_entry() //  [R1]
         { info_tbl: [(c8x7P,
                       label: sat_s8v4r_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x7P: // global
           _s8v4r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x7Q; else goto c8x7R;
       c8x7R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x7T; else goto c8x7S;
       c8x7T: // global
           HpAlloc = 56;
           goto c8x7Q;
       c8x7Q: // global
           R1 = _s8v4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x7S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4r::P64;
           _s8v2Y::I64 = I64[_s8v4r::P64 + 56];
           _s8v42::I64 = I64[_s8v4r::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x7O; else goto c8x7N;
       c8x7O: // global
           _s8v36::P64 = P64[_s8v4r::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x7N: // global
           _s8v2U::P64 = P64[_s8v4r::P64 + 16];
           _s8v2V::P64 = P64[_s8v4r::P64 + 24];
           _s8v2T::I64 = I64[_s8v4r::P64 + 40];
           _s8v2W::I64 = I64[_s8v4r::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4w_entry() //  [R1]
         { info_tbl: [(c8x8a,
                       label: sat_s8v4w_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x8a: // global
           _s8v4w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x8b; else goto c8x8c;
       c8x8c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x8e; else goto c8x8d;
       c8x8e: // global
           HpAlloc = 56;
           goto c8x8b;
       c8x8b: // global
           R1 = _s8v4w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x8d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4w::P64;
           _s8v2Y::I64 = I64[_s8v4w::P64 + 56];
           _s8v42::I64 = I64[_s8v4w::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x89; else goto c8x88;
       c8x89: // global
           _s8v36::P64 = P64[_s8v4w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x88: // global
           _s8v2U::P64 = P64[_s8v4w::P64 + 16];
           _s8v2V::P64 = P64[_s8v4w::P64 + 24];
           _s8v2T::I64 = I64[_s8v4w::P64 + 40];
           _s8v2W::I64 = I64[_s8v4w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4B_entry() //  [R1]
         { info_tbl: [(c8x8v,
                       label: sat_s8v4B_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x8v: // global
           _s8v4B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x8w; else goto c8x8x;
       c8x8x: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x8z; else goto c8x8y;
       c8x8z: // global
           HpAlloc = 56;
           goto c8x8w;
       c8x8w: // global
           R1 = _s8v4B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x8y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4B::P64;
           _s8v2Y::I64 = I64[_s8v4B::P64 + 56];
           _s8v42::I64 = I64[_s8v4B::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x8u; else goto c8x8t;
       c8x8u: // global
           _s8v36::P64 = P64[_s8v4B::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x8t: // global
           _s8v2U::P64 = P64[_s8v4B::P64 + 16];
           _s8v2V::P64 = P64[_s8v4B::P64 + 24];
           _s8v2T::I64 = I64[_s8v4B::P64 + 40];
           _s8v2W::I64 = I64[_s8v4B::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4G_entry() //  [R1]
         { info_tbl: [(c8x8Q,
                       label: sat_s8v4G_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x8Q: // global
           _s8v4G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x8R; else goto c8x8S;
       c8x8S: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x8U; else goto c8x8T;
       c8x8U: // global
           HpAlloc = 56;
           goto c8x8R;
       c8x8R: // global
           R1 = _s8v4G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x8T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4G::P64;
           _s8v2Y::I64 = I64[_s8v4G::P64 + 56];
           _s8v42::I64 = I64[_s8v4G::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x8P; else goto c8x8O;
       c8x8P: // global
           _s8v36::P64 = P64[_s8v4G::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x8O: // global
           _s8v2U::P64 = P64[_s8v4G::P64 + 16];
           _s8v2V::P64 = P64[_s8v4G::P64 + 24];
           _s8v2T::I64 = I64[_s8v4G::P64 + 40];
           _s8v2W::I64 = I64[_s8v4G::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v4L_entry() //  [R1]
         { info_tbl: [(c8x9b,
                       label: sat_s8v4L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x9b: // global
           _s8v4L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x9c; else goto c8x9d;
       c8x9d: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x9f; else goto c8x9e;
       c8x9f: // global
           HpAlloc = 56;
           goto c8x9c;
       c8x9c: // global
           R1 = _s8v4L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x9e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v4L::P64;
           _s8v2Y::I64 = I64[_s8v4L::P64 + 56];
           _s8v42::I64 = I64[_s8v4L::P64 + 64];
           if (_s8v42::I64 == _s8v2Y::I64) goto c8x9a; else goto c8x99;
       c8x9a: // global
           _s8v36::P64 = P64[_s8v4L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x99: // global
           _s8v2U::P64 = P64[_s8v4L::P64 + 16];
           _s8v2V::P64 = P64[_s8v4L::P64 + 24];
           _s8v2T::I64 = I64[_s8v4L::P64 + 40];
           _s8v2W::I64 = I64[_s8v4L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v42::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v54_entry() //  [R1]
         { info_tbl: [(c8x9x,
                       label: sat_s8v54_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x9x: // global
           _s8v54::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8x9y; else goto c8x9z;
       c8x9z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8x9B; else goto c8x9A;
       c8x9B: // global
           HpAlloc = 56;
           goto c8x9y;
       c8x9y: // global
           R1 = _s8v54::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8x9A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v54::P64;
           _s8v2Y::I64 = I64[_s8v54::P64 + 56];
           _s8v50::I64 = I64[_s8v54::P64 + 64];
           if (_s8v50::I64 == _s8v2Y::I64) goto c8x9w; else goto c8x9v;
       c8x9w: // global
           _s8v36::P64 = P64[_s8v54::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8x9v: // global
           _s8v2U::P64 = P64[_s8v54::P64 + 16];
           _s8v2V::P64 = P64[_s8v54::P64 + 24];
           _s8v2T::I64 = I64[_s8v54::P64 + 40];
           _s8v2W::I64 = I64[_s8v54::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v50::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5k_entry() //  [R1]
         { info_tbl: [(c8xa5,
                       label: sat_s8v5k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xa5: // global
           _s8v5k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xa6; else goto c8xa7;
       c8xa7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xa9; else goto c8xa8;
       c8xa9: // global
           HpAlloc = 56;
           goto c8xa6;
       c8xa6: // global
           R1 = _s8v5k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xa8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5k::P64;
           _s8v2Y::I64 = I64[_s8v5k::P64 + 56];
           _s8v58::I64 = I64[_s8v5k::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8xa4; else goto c8xa3;
       c8xa4: // global
           _s8v36::P64 = P64[_s8v5k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xa3: // global
           _s8v2U::P64 = P64[_s8v5k::P64 + 16];
           _s8v2V::P64 = P64[_s8v5k::P64 + 24];
           _s8v2T::I64 = I64[_s8v5k::P64 + 40];
           _s8v2W::I64 = I64[_s8v5k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5s_entry() //  [R1]
         { info_tbl: [(c8xaE,
                       label: sat_s8v5s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xaE: // global
           _s8v5s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xaF; else goto c8xaG;
       c8xaG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xaI; else goto c8xaH;
       c8xaI: // global
           HpAlloc = 56;
           goto c8xaF;
       c8xaF: // global
           R1 = _s8v5s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5s::P64;
           _s8v2Y::I64 = I64[_s8v5s::P64 + 56];
           _s8v58::I64 = I64[_s8v5s::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8xaD; else goto c8xaC;
       c8xaD: // global
           _s8v36::P64 = P64[_s8v5s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xaC: // global
           _s8v2U::P64 = P64[_s8v5s::P64 + 16];
           _s8v2V::P64 = P64[_s8v5s::P64 + 24];
           _s8v2T::I64 = I64[_s8v5s::P64 + 40];
           _s8v2W::I64 = I64[_s8v5s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5x_entry() //  [R1]
         { info_tbl: [(c8xaZ,
                       label: sat_s8v5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xaZ: // global
           _s8v5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xb0; else goto c8xb1;
       c8xb1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xb3; else goto c8xb2;
       c8xb3: // global
           HpAlloc = 56;
           goto c8xb0;
       c8xb0: // global
           R1 = _s8v5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5x::P64;
           _s8v2Y::I64 = I64[_s8v5x::P64 + 56];
           _s8v58::I64 = I64[_s8v5x::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8xaY; else goto c8xaX;
       c8xaY: // global
           _s8v36::P64 = P64[_s8v5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xaX: // global
           _s8v2U::P64 = P64[_s8v5x::P64 + 16];
           _s8v2V::P64 = P64[_s8v5x::P64 + 24];
           _s8v2T::I64 = I64[_s8v5x::P64 + 40];
           _s8v2W::I64 = I64[_s8v5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5C_entry() //  [R1]
         { info_tbl: [(c8xbk,
                       label: sat_s8v5C_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xbk: // global
           _s8v5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xbl; else goto c8xbm;
       c8xbm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xbo; else goto c8xbn;
       c8xbo: // global
           HpAlloc = 56;
           goto c8xbl;
       c8xbl: // global
           R1 = _s8v5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xbn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5C::P64;
           _s8v2Y::I64 = I64[_s8v5C::P64 + 56];
           _s8v58::I64 = I64[_s8v5C::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8xbj; else goto c8xbi;
       c8xbj: // global
           _s8v36::P64 = P64[_s8v5C::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xbi: // global
           _s8v2U::P64 = P64[_s8v5C::P64 + 16];
           _s8v2V::P64 = P64[_s8v5C::P64 + 24];
           _s8v2T::I64 = I64[_s8v5C::P64 + 40];
           _s8v2W::I64 = I64[_s8v5C::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5H_entry() //  [R1]
         { info_tbl: [(c8xbF,
                       label: sat_s8v5H_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xbF: // global
           _s8v5H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xbG; else goto c8xbH;
       c8xbH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xbJ; else goto c8xbI;
       c8xbJ: // global
           HpAlloc = 56;
           goto c8xbG;
       c8xbG: // global
           R1 = _s8v5H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xbI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5H::P64;
           _s8v2Y::I64 = I64[_s8v5H::P64 + 56];
           _s8v58::I64 = I64[_s8v5H::P64 + 64];
           if (_s8v58::I64 == _s8v2Y::I64) goto c8xbE; else goto c8xbD;
       c8xbE: // global
           _s8v36::P64 = P64[_s8v5H::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xbD: // global
           _s8v2U::P64 = P64[_s8v5H::P64 + 16];
           _s8v2V::P64 = P64[_s8v5H::P64 + 24];
           _s8v2T::I64 = I64[_s8v5H::P64 + 40];
           _s8v2W::I64 = I64[_s8v5H::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v58::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v5Z_entry() //  [R1]
         { info_tbl: [(c8xc1,
                       label: sat_s8v5Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xc1: // global
           _s8v5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xc2; else goto c8xc3;
       c8xc3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xc5; else goto c8xc4;
       c8xc5: // global
           HpAlloc = 56;
           goto c8xc2;
       c8xc2: // global
           R1 = _s8v5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xc4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v5Z::P64;
           _s8v2Y::I64 = I64[_s8v5Z::P64 + 56];
           _s8v5V::I64 = I64[_s8v5Z::P64 + 64];
           if (_s8v5V::I64 == _s8v2Y::I64) goto c8xc0; else goto c8xbZ;
       c8xc0: // global
           _s8v36::P64 = P64[_s8v5Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xbZ: // global
           _s8v2U::P64 = P64[_s8v5Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v5Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v5Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v5Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v5V::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v67_entry() //  [R1]
         { info_tbl: [(c8xcn,
                       label: sat_s8v67_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xcn: // global
           _s8v67::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xco; else goto c8xcp;
       c8xcp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xcr; else goto c8xcq;
       c8xcr: // global
           HpAlloc = 56;
           goto c8xco;
       c8xco: // global
           R1 = _s8v67::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xcq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v67::P64;
           _s8v2Y::I64 = I64[_s8v67::P64 + 56];
           _s8v63::I64 = I64[_s8v67::P64 + 64];
           if (_s8v63::I64 == _s8v2Y::I64) goto c8xcm; else goto c8xcl;
       c8xcm: // global
           _s8v36::P64 = P64[_s8v67::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xcl: // global
           _s8v2U::P64 = P64[_s8v67::P64 + 16];
           _s8v2V::P64 = P64[_s8v67::P64 + 24];
           _s8v2T::I64 = I64[_s8v67::P64 + 40];
           _s8v2W::I64 = I64[_s8v67::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v63::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6f_entry() //  [R1]
         { info_tbl: [(c8xcJ,
                       label: sat_s8v6f_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xcJ: // global
           _s8v6f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xcK; else goto c8xcL;
       c8xcL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xcN; else goto c8xcM;
       c8xcN: // global
           HpAlloc = 56;
           goto c8xcK;
       c8xcK: // global
           R1 = _s8v6f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6f::P64;
           _s8v2Y::I64 = I64[_s8v6f::P64 + 56];
           _s8v6b::I64 = I64[_s8v6f::P64 + 64];
           if (_s8v6b::I64 == _s8v2Y::I64) goto c8xcI; else goto c8xcH;
       c8xcI: // global
           _s8v36::P64 = P64[_s8v6f::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xcH: // global
           _s8v2U::P64 = P64[_s8v6f::P64 + 16];
           _s8v2V::P64 = P64[_s8v6f::P64 + 24];
           _s8v2T::I64 = I64[_s8v6f::P64 + 40];
           _s8v2W::I64 = I64[_s8v6f::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6b::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6n_entry() //  [R1]
         { info_tbl: [(c8xd5,
                       label: sat_s8v6n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xd5: // global
           _s8v6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xd6; else goto c8xd7;
       c8xd7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xd9; else goto c8xd8;
       c8xd9: // global
           HpAlloc = 56;
           goto c8xd6;
       c8xd6: // global
           R1 = _s8v6n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xd8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6n::P64;
           _s8v2Y::I64 = I64[_s8v6n::P64 + 56];
           _s8v6j::I64 = I64[_s8v6n::P64 + 64];
           if (_s8v6j::I64 == _s8v2Y::I64) goto c8xd4; else goto c8xd3;
       c8xd4: // global
           _s8v36::P64 = P64[_s8v6n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xd3: // global
           _s8v2U::P64 = P64[_s8v6n::P64 + 16];
           _s8v2V::P64 = P64[_s8v6n::P64 + 24];
           _s8v2T::I64 = I64[_s8v6n::P64 + 40];
           _s8v2W::I64 = I64[_s8v6n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6j::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v6v_entry() //  [R1]
         { info_tbl: [(c8xdr,
                       label: sat_s8v6v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xdr: // global
           _s8v6v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xds; else goto c8xdt;
       c8xdt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xdv; else goto c8xdu;
       c8xdv: // global
           HpAlloc = 56;
           goto c8xds;
       c8xds: // global
           R1 = _s8v6v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xdu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v6v::P64;
           _s8v2Y::I64 = I64[_s8v6v::P64 + 56];
           _s8v6r::I64 = I64[_s8v6v::P64 + 64];
           if (_s8v6r::I64 == _s8v2Y::I64) goto c8xdq; else goto c8xdp;
       c8xdq: // global
           _s8v36::P64 = P64[_s8v6v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xdp: // global
           _s8v2U::P64 = P64[_s8v6v::P64 + 16];
           _s8v2V::P64 = P64[_s8v6v::P64 + 24];
           _s8v2T::I64 = I64[_s8v6v::P64 + 40];
           _s8v2W::I64 = I64[_s8v6v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6r::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7v_entry() //  [R1]
         { info_tbl: [(c8xeY,
                       label: sat_s8v7v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xeY: // global
           _s8v7v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xeZ; else goto c8xf0;
       c8xf0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xf2; else goto c8xf1;
       c8xf2: // global
           HpAlloc = 56;
           goto c8xeZ;
       c8xeZ: // global
           R1 = _s8v7v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xf1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7v::P64;
           _s8v2Y::I64 = I64[_s8v7v::P64 + 56];
           _s8v6z::I64 = I64[_s8v7v::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xeX; else goto c8xeW;
       c8xeX: // global
           _s8v36::P64 = P64[_s8v7v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xeW: // global
           _s8v2U::P64 = P64[_s8v7v::P64 + 16];
           _s8v2V::P64 = P64[_s8v7v::P64 + 24];
           _s8v2T::I64 = I64[_s8v7v::P64 + 40];
           _s8v2W::I64 = I64[_s8v7v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7A_entry() //  [R1]
         { info_tbl: [(c8xfj,
                       label: sat_s8v7A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xfj: // global
           _s8v7A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xfk; else goto c8xfl;
       c8xfl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xfn; else goto c8xfm;
       c8xfn: // global
           HpAlloc = 56;
           goto c8xfk;
       c8xfk: // global
           R1 = _s8v7A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xfm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7A::P64;
           _s8v2Y::I64 = I64[_s8v7A::P64 + 56];
           _s8v6z::I64 = I64[_s8v7A::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xfi; else goto c8xfh;
       c8xfi: // global
           _s8v36::P64 = P64[_s8v7A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xfh: // global
           _s8v2U::P64 = P64[_s8v7A::P64 + 16];
           _s8v2V::P64 = P64[_s8v7A::P64 + 24];
           _s8v2T::I64 = I64[_s8v7A::P64 + 40];
           _s8v2W::I64 = I64[_s8v7A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7F_entry() //  [R1]
         { info_tbl: [(c8xfE,
                       label: sat_s8v7F_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xfE: // global
           _s8v7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xfF; else goto c8xfG;
       c8xfG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xfI; else goto c8xfH;
       c8xfI: // global
           HpAlloc = 56;
           goto c8xfF;
       c8xfF: // global
           R1 = _s8v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xfH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7F::P64;
           _s8v2Y::I64 = I64[_s8v7F::P64 + 56];
           _s8v6z::I64 = I64[_s8v7F::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xfD; else goto c8xfC;
       c8xfD: // global
           _s8v36::P64 = P64[_s8v7F::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xfC: // global
           _s8v2U::P64 = P64[_s8v7F::P64 + 16];
           _s8v2V::P64 = P64[_s8v7F::P64 + 24];
           _s8v2T::I64 = I64[_s8v7F::P64 + 40];
           _s8v2W::I64 = I64[_s8v7F::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7K_entry() //  [R1]
         { info_tbl: [(c8xfZ,
                       label: sat_s8v7K_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xfZ: // global
           _s8v7K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xg0; else goto c8xg1;
       c8xg1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xg3; else goto c8xg2;
       c8xg3: // global
           HpAlloc = 56;
           goto c8xg0;
       c8xg0: // global
           R1 = _s8v7K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xg2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7K::P64;
           _s8v2Y::I64 = I64[_s8v7K::P64 + 56];
           _s8v6z::I64 = I64[_s8v7K::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xfY; else goto c8xfX;
       c8xfY: // global
           _s8v36::P64 = P64[_s8v7K::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xfX: // global
           _s8v2U::P64 = P64[_s8v7K::P64 + 16];
           _s8v2V::P64 = P64[_s8v7K::P64 + 24];
           _s8v2T::I64 = I64[_s8v7K::P64 + 40];
           _s8v2W::I64 = I64[_s8v7K::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7P_entry() //  [R1]
         { info_tbl: [(c8xgk,
                       label: sat_s8v7P_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xgk: // global
           _s8v7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xgl; else goto c8xgm;
       c8xgm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xgo; else goto c8xgn;
       c8xgo: // global
           HpAlloc = 56;
           goto c8xgl;
       c8xgl: // global
           R1 = _s8v7P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xgn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7P::P64;
           _s8v2Y::I64 = I64[_s8v7P::P64 + 56];
           _s8v6z::I64 = I64[_s8v7P::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xgj; else goto c8xgi;
       c8xgj: // global
           _s8v36::P64 = P64[_s8v7P::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xgi: // global
           _s8v2U::P64 = P64[_s8v7P::P64 + 16];
           _s8v2V::P64 = P64[_s8v7P::P64 + 24];
           _s8v2T::I64 = I64[_s8v7P::P64 + 40];
           _s8v2W::I64 = I64[_s8v7P::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7U_entry() //  [R1]
         { info_tbl: [(c8xgF,
                       label: sat_s8v7U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xgF: // global
           _s8v7U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xgG; else goto c8xgH;
       c8xgH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xgJ; else goto c8xgI;
       c8xgJ: // global
           HpAlloc = 56;
           goto c8xgG;
       c8xgG: // global
           R1 = _s8v7U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xgI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7U::P64;
           _s8v2Y::I64 = I64[_s8v7U::P64 + 56];
           _s8v6z::I64 = I64[_s8v7U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xgE; else goto c8xgD;
       c8xgE: // global
           _s8v36::P64 = P64[_s8v7U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xgD: // global
           _s8v2U::P64 = P64[_s8v7U::P64 + 16];
           _s8v2V::P64 = P64[_s8v7U::P64 + 24];
           _s8v2T::I64 = I64[_s8v7U::P64 + 40];
           _s8v2W::I64 = I64[_s8v7U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v7Z_entry() //  [R1]
         { info_tbl: [(c8xh0,
                       label: sat_s8v7Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xh0: // global
           _s8v7Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xh1; else goto c8xh2;
       c8xh2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xh4; else goto c8xh3;
       c8xh4: // global
           HpAlloc = 56;
           goto c8xh1;
       c8xh1: // global
           R1 = _s8v7Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xh3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v7Z::P64;
           _s8v2Y::I64 = I64[_s8v7Z::P64 + 56];
           _s8v6z::I64 = I64[_s8v7Z::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xgZ; else goto c8xgY;
       c8xgZ: // global
           _s8v36::P64 = P64[_s8v7Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xgY: // global
           _s8v2U::P64 = P64[_s8v7Z::P64 + 16];
           _s8v2V::P64 = P64[_s8v7Z::P64 + 24];
           _s8v2T::I64 = I64[_s8v7Z::P64 + 40];
           _s8v2W::I64 = I64[_s8v7Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8R_entry() //  [R1]
         { info_tbl: [(c8xi3,
                       label: sat_s8v8R_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xi3: // global
           _s8v8R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xi4; else goto c8xi5;
       c8xi5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xi7; else goto c8xi6;
       c8xi7: // global
           HpAlloc = 56;
           goto c8xi4;
       c8xi4: // global
           R1 = _s8v8R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xi6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8R::P64;
           _s8v2Y::I64 = I64[_s8v8R::P64 + 56];
           _s8v6z::I64 = I64[_s8v8R::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xi2; else goto c8xi1;
       c8xi2: // global
           _s8v36::P64 = P64[_s8v8R::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xi1: // global
           _s8v2U::P64 = P64[_s8v8R::P64 + 16];
           _s8v2V::P64 = P64[_s8v8R::P64 + 24];
           _s8v2T::I64 = I64[_s8v8R::P64 + 40];
           _s8v2W::I64 = I64[_s8v8R::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v8W_entry() //  [R1]
         { info_tbl: [(c8xio,
                       label: sat_s8v8W_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xio: // global
           _s8v8W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xip; else goto c8xiq;
       c8xiq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xis; else goto c8xir;
       c8xis: // global
           HpAlloc = 56;
           goto c8xip;
       c8xip: // global
           R1 = _s8v8W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xir: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v8W::P64;
           _s8v2Y::I64 = I64[_s8v8W::P64 + 56];
           _s8v6z::I64 = I64[_s8v8W::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xin; else goto c8xim;
       c8xin: // global
           _s8v36::P64 = P64[_s8v8W::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xim: // global
           _s8v2U::P64 = P64[_s8v8W::P64 + 16];
           _s8v2V::P64 = P64[_s8v8W::P64 + 24];
           _s8v2T::I64 = I64[_s8v8W::P64 + 40];
           _s8v2W::I64 = I64[_s8v8W::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v91_entry() //  [R1]
         { info_tbl: [(c8xiJ,
                       label: sat_s8v91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xiJ: // global
           _s8v91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xiK; else goto c8xiL;
       c8xiL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xiN; else goto c8xiM;
       c8xiN: // global
           HpAlloc = 56;
           goto c8xiK;
       c8xiK: // global
           R1 = _s8v91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xiM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v91::P64;
           _s8v2Y::I64 = I64[_s8v91::P64 + 56];
           _s8v6z::I64 = I64[_s8v91::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xiI; else goto c8xiH;
       c8xiI: // global
           _s8v36::P64 = P64[_s8v91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xiH: // global
           _s8v2U::P64 = P64[_s8v91::P64 + 16];
           _s8v2V::P64 = P64[_s8v91::P64 + 24];
           _s8v2T::I64 = I64[_s8v91::P64 + 40];
           _s8v2W::I64 = I64[_s8v91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v96_entry() //  [R1]
         { info_tbl: [(c8xj4,
                       label: sat_s8v96_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xj4: // global
           _s8v96::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xj5; else goto c8xj6;
       c8xj6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xj8; else goto c8xj7;
       c8xj8: // global
           HpAlloc = 56;
           goto c8xj5;
       c8xj5: // global
           R1 = _s8v96::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xj7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v96::P64;
           _s8v2Y::I64 = I64[_s8v96::P64 + 56];
           _s8v6z::I64 = I64[_s8v96::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xj3; else goto c8xj2;
       c8xj3: // global
           _s8v36::P64 = P64[_s8v96::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xj2: // global
           _s8v2U::P64 = P64[_s8v96::P64 + 16];
           _s8v2V::P64 = P64[_s8v96::P64 + 24];
           _s8v2T::I64 = I64[_s8v96::P64 + 40];
           _s8v2W::I64 = I64[_s8v96::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9b_entry() //  [R1]
         { info_tbl: [(c8xjp,
                       label: sat_s8v9b_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xjp: // global
           _s8v9b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xjq; else goto c8xjr;
       c8xjr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xjt; else goto c8xjs;
       c8xjt: // global
           HpAlloc = 56;
           goto c8xjq;
       c8xjq: // global
           R1 = _s8v9b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xjs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9b::P64;
           _s8v2Y::I64 = I64[_s8v9b::P64 + 56];
           _s8v6z::I64 = I64[_s8v9b::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xjo; else goto c8xjn;
       c8xjo: // global
           _s8v36::P64 = P64[_s8v9b::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xjn: // global
           _s8v2U::P64 = P64[_s8v9b::P64 + 16];
           _s8v2V::P64 = P64[_s8v9b::P64 + 24];
           _s8v2T::I64 = I64[_s8v9b::P64 + 40];
           _s8v2W::I64 = I64[_s8v9b::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8v9U_entry() //  [R1]
         { info_tbl: [(c8xjO,
                       label: sat_s8v9U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xjO: // global
           _s8v9U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8xjP; else goto c8xjQ;
       c8xjQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xjS; else goto c8xjR;
       c8xjS: // global
           HpAlloc = 56;
           goto c8xjP;
       c8xjP: // global
           R1 = _s8v9U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8v9U::P64;
           _s8v2Y::I64 = I64[_s8v9U::P64 + 56];
           _s8v6z::I64 = I64[_s8v9U::P64 + 64];
           if (_s8v6z::I64 == _s8v2Y::I64) goto c8xjN; else goto c8xjM;
       c8xjN: // global
           _s8v36::P64 = P64[_s8v9U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8v36::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8xjM: // global
           _s8v2U::P64 = P64[_s8v9U::P64 + 16];
           _s8v2V::P64 = P64[_s8v9U::P64 + 24];
           _s8v2T::I64 = I64[_s8v9U::P64 + 40];
           _s8v2W::I64 = I64[_s8v9U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8v2U::P64;
           P64[Hp - 32] = _s8v2V::P64;
           I64[Hp - 24] = _s8v2T::I64;
           I64[Hp - 16] = _s8v2W::I64;
           I64[Hp - 8] = _s8v6z::I64;
           I64[Hp] = _s8v2Y::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF4_entry() //  [R2, R3]
         { info_tbl: [(c8xjV,
                       label: GHC.IO.Encoding.UTF8.mkUTF4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xjV: // global
           if ((Sp + -144) < SpLim) (likely: False) goto c8xjW; else goto c8xjX;
       c8xjW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8xjX: // global
           I64[Sp - 16] = block_c8x4e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8xyD; else goto c8x4f;
       u8xyD: // global
           call _c8x4e(R1) args: 0, res: 0, upd: 0;
       c8x4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8x4e() //  [R1]
         { info_tbl: [(c8x4e,
                       label: block_c8x4e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x4e: // global
           I64[Sp - 40] = block_c8x4j_info;
           _s8v2U::P64 = P64[R1 + 7];
           _s8v2V::P64 = P64[R1 + 15];
           _s8v2T::I64 = I64[R1 + 23];
           _s8v2W::I64 = I64[R1 + 31];
           _s8v2X::I64 = I64[R1 + 39];
           _s8v2Y::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8v2V::P64;
           I64[Sp - 24] = _s8v2W::I64;
           I64[Sp - 16] = _s8v2X::I64;
           I64[Sp - 8] = _s8v2Y::I64;
           P64[Sp] = _s8v2U::P64;
           I64[Sp + 8] = _s8v2T::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8xxK; else goto c8x4k;
       u8xxK: // global
           call _c8x4j(R1) args: 0, res: 0, upd: 0;
       c8x4k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8x4j() //  [R1]
         { info_tbl: [(c8x4j,
                       label: block_c8x4j_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x4j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xk1; else goto c8xk0;
       c8xk1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8xk0: // global
           _s8v31::P64 = P64[R1 + 7];
           _s8v32::P64 = P64[R1 + 15];
           _s8v30::I64 = I64[R1 + 23];
           _s8v33::I64 = I64[R1 + 31];
           _s8v34::I64 = I64[R1 + 39];
           _s8v35::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8v31::P64;
           P64[Sp - 40] = _s8v32::P64;
           I64[Sp - 32] = _s8v33::I64;
           I64[Sp - 24] = _s8v34::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8v35::I64;
           I64[Sp] = _s8v30::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8xdA() args: 0, res: 0, upd: 0;
     }
 },
 _c8xdA() //  []
         { info_tbl: [(c8xdA,
                       label: block_c8xdA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xdA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xoG; else goto c8xoF;
       c8xoG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xdA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xoF: // global
           _s8v33::I64 = I64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 40];
           _s8v6A::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8v6A::I64,
                            _s8v33::I64)) goto c8xuH; else goto c8xuI;
       c8xuH: // global
           _s8v2Y::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8v6z::I64,
                            _s8v2Y::I64)) goto c8xuE; else goto c8xuF;
       c8xuE: // global
           _c8x4o::P64 = P64[Sp + 80];
           _s8v2T::I64 = I64[Sp + 104];
           _s8v2U::P64 = P64[Sp + 96];
           _s8v2V::P64 = P64[Sp + 64];
           _s8v2W::I64 = I64[Sp + 72];
           _s8v30::I64 = I64[Sp + 56];
           _s8v31::P64 = P64[Sp + 8];
           _s8v32::P64 = P64[Sp + 16];
           _s8v34::I64 = I64[Sp + 32];
           _s8v6H::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + _s8v6z::I64]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 > 127) goto c8xuB; else goto c8xuC;
       c8xuB: // global
           if (_s8v6H::I64 < 192) goto c8xuw; else goto c8xuz;
       c8xuz: // global
           if (_s8v6H::I64 > 193) goto c8xuw; else goto c8xuy;
       c8xuw: // global
           Hp = Hp - 160;
           if (_s8v6H::I64 < 194) goto s8v6L; else goto c8xus;
       c8xus: // global
           if (_s8v6H::I64 > 223) goto s8v6L; else goto c8xur;
       s8v6L: // global
           if (_s8v6H::I64 < 224) goto s8v6M; else goto c8xtN;
       c8xtN: // global
           if (_s8v6H::I64 > 239) goto s8v6M; else goto c8xtM;
       s8v6M: // global
           if (_s8v6H::I64 < 240) goto c8xoL; else goto c8xrj;
       c8xoL: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8x4r() args: 0, res: 0, upd: 0;
       c8xrj: // global
           _s8v6O::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (%MO_S_Lt_W64(_s8v6O::I64, 3)) goto u8xwM; else goto u8xwO;
       u8xwM: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 2)) goto u8xwN; else goto c8xr9;
       u8xwN: // global
           if (%MO_S_Lt_W64(_s8v6O::I64, 1)) goto c8xoN; else goto c8xr3;
       c8xr3: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8x4N() args: 0, res: 0, upd: 0;
       c8xr9: // global
           _s8v3w::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v3q::I64 = _s8v6H::I64;
           _s8v3p::I64 = _s8v6A::I64;
           _s8v3o::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v3D; else goto c8xlc;
       c8xlc: // global
           if (_s8v3w::I64 < 144) goto s8v3D; else goto c8xlb;
       c8xlb: // global
           if (_s8v3w::I64 > 191) goto s8v3D; else goto u8xwT;
       s8v3D: // global
           if (_s8v3q::I64 < 241) goto u8xwU; else goto c8xkU;
       u8xwU: // global
           I64[Sp - 8] = _s8v3w::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           Sp = Sp - 16;
           goto u8xxW;
       c8xkU: // global
           if (_s8v3q::I64 > 243) goto u8xwV; else goto c8xkT;
       u8xwV: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8xxW;
       c8xkT: // global
           if (_s8v3w::I64 < 128) goto u8xwW; else goto c8xkS;
       u8xwW: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8xxW;
       c8xkS: // global
           if (_s8v3w::I64 > 191) goto u8xwY; else goto u8xwX;
       u8xwY: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp] = _s8v3q::I64;
           I64[Sp - 8] = _s8v3w::I64;
           Sp = Sp - 16;
           goto u8xxW;
       u8xxW: // global
           call _c8x5N() args: 0, res: 0, upd: 0;
       u8xwX: // global
           I64[Sp + 48] = _s8v3o::I64;
           I64[Sp + 40] = _s8v3p::I64;
           goto u8xxV;
       u8xwT: // global
           I64[Sp + 40] = _s8v3p::I64;
           I64[Sp + 48] = _s8v3o::I64;
           goto u8xxV;
       u8xxV: // global
           call _c8x5m() args: 0, res: 0, upd: 0;
       u8xwO: // global
           if (%MO_S_Ge_W64(_s8v6O::I64, 4)) goto c8xoN; else goto c8xrf;
       c8xoN: // global
           _s8v6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v75::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 3)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 240) goto s8v7r; else goto c8xr0;
       c8xr0: // global
           if (_s8v6T::I64 < 144) goto s8v7r; else goto c8xqZ;
       c8xqZ: // global
           if (_s8v6T::I64 > 191) goto s8v7r; else goto c8xqY;
       c8xqY: // global
           if (_s8v6Z::I64 < 128) goto s8v7r; else goto c8xqX;
       c8xqX: // global
           if (_s8v6Z::I64 > 191) goto s8v7r; else goto c8xqW;
       c8xqW: // global
           if (_s8v75::I64 < 128) goto s8v7r; else goto c8xqV;
       c8xqV: // global
           if (_s8v75::I64 > 191) goto s8v7r; else goto u8xx9;
       s8v7r: // global
           if (_s8v6H::I64 < 241) goto u8xxa; else goto c8xqg;
       u8xxa: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqg: // global
           if (_s8v6H::I64 > 243) goto u8xxb; else goto c8xqf;
       u8xxb: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqf: // global
           if (_s8v6T::I64 < 128) goto u8xxc; else goto c8xqe;
       u8xxc: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqe: // global
           if (_s8v6T::I64 > 191) goto u8xxd; else goto c8xqd;
       u8xxd: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqd: // global
           if (_s8v6Z::I64 < 128) goto u8xxe; else goto c8xqc;
       u8xxe: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqc: // global
           if (_s8v6Z::I64 > 191) goto u8xxf; else goto c8xqb;
       u8xxf: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqb: // global
           if (_s8v75::I64 < 128) goto u8xxg; else goto c8xqa;
       u8xxg: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       c8xqa: // global
           if (_s8v75::I64 > 191) goto u8xxi; else goto u8xxh;
       u8xxi: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 32;
           goto u8xye;
       u8xye: // global
           call _c8xeK() args: 0, res: 0, upd: 0;
       u8xxh: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           Sp = Sp - 24;
           goto u8xyd;
       u8xx9: // global
           I64[Sp - 24] = _s8v6T::I64;
           I64[Sp - 16] = _s8v6Z::I64;
           I64[Sp - 8] = _s8v75::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8xyd;
       u8xyd: // global
           call _s8v77() args: 0, res: 0, upd: 0;
       c8xrf: // global
           _s8v4a::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v4g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           _s8v44::I64 = _s8v6H::I64;
           _s8v43::I64 = _s8v6A::I64;
           _s8v42::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 240) goto s8v4n; else goto c8xmP;
       c8xmP: // global
           if (_s8v4a::I64 < 144) goto s8v4n; else goto c8xmO;
       c8xmO: // global
           if (_s8v4a::I64 > 191) goto s8v4n; else goto c8xmN;
       c8xmN: // global
           if (_s8v4g::I64 < 128) goto s8v4n; else goto c8xmM;
       c8xmM: // global
           if (_s8v4g::I64 > 191) goto s8v4n; else goto u8xx0;
       s8v4n: // global
           if (_s8v44::I64 < 241) goto u8xx1; else goto c8xmj;
       u8xx1: // global
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           Sp = Sp - 24;
           goto u8xy4;
       c8xmj: // global
           if (_s8v44::I64 > 243) goto u8xx2; else goto c8xmi;
       u8xx2: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8xy4;
       c8xmi: // global
           if (_s8v4a::I64 < 128) goto u8xx3; else goto c8xmh;
       u8xx3: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8xy4;
       c8xmh: // global
           if (_s8v4a::I64 > 191) goto u8xx4; else goto c8xmg;
       u8xx4: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8xy4;
       c8xmg: // global
           if (_s8v4g::I64 < 128) goto u8xx5; else goto c8xmf;
       u8xx5: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8xy4;
       c8xmf: // global
           if (_s8v4g::I64 > 191) goto u8xx7; else goto u8xx6;
       u8xx7: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp] = _s8v44::I64;
           I64[Sp - 16] = _s8v4a::I64;
           I64[Sp - 8] = _s8v4g::I64;
           Sp = Sp - 24;
           goto u8xy4;
       u8xy4: // global
           call _c8x7B() args: 0, res: 0, upd: 0;
       u8xx6: // global
           I64[Sp + 48] = _s8v42::I64;
           I64[Sp + 40] = _s8v43::I64;
           goto u8xy3;
       u8xx0: // global
           I64[Sp + 40] = _s8v43::I64;
           I64[Sp + 48] = _s8v42::I64;
           goto u8xy3;
       u8xy3: // global
           call _c8x7a() args: 0, res: 0, upd: 0;
       c8xtM: // global
           _s8v8j::I64 = _s8v2Y::I64 - _s8v6z::I64;
           if (_s8v8j::I64 != 1) goto u8xwP; else goto c8xtC;
       u8xwP: // global
           if (_s8v8j::I64 != 2) goto c8xrp; else goto c8xtI;
       c8xrp: // global
           _s8v8o::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v8u::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 2)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v6H::I64 != 224) goto s8v8M; else goto c8xtz;
       c8xtz: // global
           if (_s8v8o::I64 < 160) goto s8v8M; else goto c8xty;
       c8xty: // global
           if (_s8v8o::I64 > 191) goto s8v8M; else goto c8xtx;
       c8xtx: // global
           if (_s8v8u::I64 < 128) goto s8v8M; else goto c8xtw;
       c8xtw: // global
           if (_s8v8u::I64 > 191) goto s8v8M; else goto u8xxl;
       s8v8M: // global
           if (_s8v6H::I64 < 225) goto s8v8N; else goto c8xt3;
       c8xt3: // global
           if (_s8v6H::I64 > 236) goto s8v8N; else goto c8xt2;
       c8xt2: // global
           if (_s8v8o::I64 < 128) goto s8v8N; else goto c8xt1;
       c8xt1: // global
           if (_s8v8o::I64 > 191) goto s8v8N; else goto c8xt0;
       c8xt0: // global
           if (_s8v8u::I64 < 128) goto s8v8N; else goto c8xsZ;
       c8xsZ: // global
           if (_s8v8u::I64 > 191) goto s8v8N; else goto u8xxm;
       s8v8N: // global
           if (_s8v6H::I64 == 237) goto c8xsp; else goto u8xxn;
       c8xsp: // global
           if (_s8v8o::I64 < 128) goto u8xxo; else goto c8xso;
       u8xxo: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8xym;
       c8xso: // global
           if (_s8v8o::I64 > 159) goto u8xxp; else goto c8xsn;
       u8xxp: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8xym;
       c8xsn: // global
           if (_s8v8u::I64 < 128) goto u8xxq; else goto c8xsm;
       u8xxq: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8xym;
       c8xsm: // global
           if (_s8v8u::I64 > 191) goto u8xxs; else goto u8xxr;
       u8xxs: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 24;
           goto u8xym;
       u8xxr: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8xyl;
       u8xxn: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 24;
           goto u8xym;
       u8xym: // global
           call _c8xhO() args: 0, res: 0, upd: 0;
       u8xxm: // global
           I64[Sp] = _s8v6H::I64;
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           Sp = Sp - 16;
           goto u8xyl;
       u8xxl: // global
           I64[Sp - 16] = _s8v8o::I64;
           I64[Sp - 8] = _s8v8u::I64;
           I64[Sp] = _s8v6H::I64;
           Sp = Sp - 16;
           goto u8xyl;
       u8xyl: // global
           call _s8v8w() args: 0, res: 0, upd: 0;
       c8xtI: // global
           _s8v5g::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           _s8v5a::I64 = _s8v6H::I64;
           _s8v59::I64 = _s8v6A::I64;
           _s8v58::I64 = _s8v6z::I64;
           if (_s8v6H::I64 != 224) goto s8v5n; else goto c8xoj;
       c8xoj: // global
           if (_s8v5g::I64 < 160) goto s8v5n; else goto c8xoi;
       c8xoi: // global
           if (_s8v5g::I64 > 191) goto s8v5n; else goto u8xxv;
       s8v5n: // global
           if (_s8v5a::I64 < 225) goto s8v5o; else goto c8xo1;
       c8xo1: // global
           if (_s8v5a::I64 > 236) goto s8v5o; else goto c8xo0;
       c8xo0: // global
           if (_s8v5g::I64 < 128) goto s8v5o; else goto c8xnZ;
       c8xnZ: // global
           if (_s8v5g::I64 > 191) goto s8v5o; else goto u8xxw;
       s8v5o: // global
           if (_s8v5a::I64 == 237) goto c8xnB; else goto u8xxx;
       c8xnB: // global
           if (_s8v5g::I64 < 128) goto u8xxy; else goto c8xnA;
       u8xxy: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8xys;
       c8xnA: // global
           if (_s8v5g::I64 > 159) goto u8xxA; else goto u8xxz;
       u8xxA: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp - 8] = _s8v5g::I64;
           Sp = Sp - 16;
           goto u8xys;
       u8xxz: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8xyr;
       u8xxx: // global
           I64[Sp - 8] = _s8v5g::I64;
           I64[Sp] = _s8v5a::I64;
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           Sp = Sp - 16;
           goto u8xys;
       u8xys: // global
           call _c8xap() args: 0, res: 0, upd: 0;
       u8xxw: // global
           I64[Sp + 48] = _s8v58::I64;
           I64[Sp + 40] = _s8v59::I64;
           goto u8xyr;
       u8xxv: // global
           I64[Sp + 40] = _s8v59::I64;
           I64[Sp + 48] = _s8v58::I64;
           goto u8xyr;
       u8xyr: // global
           call _c8x9T() args: 0, res: 0, upd: 0;
       c8xtC: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8x9k() args: 0, res: 0, upd: 0;
       c8xur: // global
           if (%MO_S_Ge_W64(_s8v2Y::I64 - _s8v6z::I64,
                            2)) goto c8xup; else goto c8xuq;
       c8xup: // global
           _s8v9C::I64 = %MO_UU_Conv_W8_W64(I8[_s8v2T::I64 + (_s8v6z::I64 + 1)]);
           call MO_Touch(_s8v2U::P64);
           if (_s8v9C::I64 >= 128) goto c8xum; else goto c8xun;
       c8xum: // global
           if (_s8v9C::I64 < 192) goto c8xuj; else goto c8xuk;
       c8xuj: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8v6H::I64 + -192) << 6) + (_s8v9C::I64 + -128));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 40] = _s8v6z::I64 + 2;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8xyy;
       c8xuk: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8xbO() args: 0, res: 0, upd: 0;
       c8xun: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8xca() args: 0, res: 0, upd: 0;
       c8xuq: // global
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8xcw() args: 0, res: 0, upd: 0;
       c8xuy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xuC: // global
           I32[_s8v30::I64 + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8v6H::I64);
           call MO_Touch(_s8v31::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6z::I64 + 1;
           I64[Sp + 48] = _s8v6A::I64 + 1;
           goto u8xyy;
       u8xyy: // global
           call _c8xdA() args: 0, res: 0, upd: 0;
       c8xuF: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8xcS() args: 0, res: 0, upd: 0;
       c8xuI: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8v6A::I64;
           I64[Sp + 48] = _s8v6z::I64;
           call _c8xde() args: 0, res: 0, upd: 0;
     }
 },
 _c8x4r() //  []
         { info_tbl: [(c8x4r,
                       label: block_c8x4r_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x4r: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xk5; else goto c8xk4;
       c8xk5: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x4r_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xk4: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x4N() //  []
         { info_tbl: [(c8x4N,
                       label: block_c8x4N_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x4N: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xk9; else goto c8xk8;
       c8xk9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x4N_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xk8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x5N() //  []
         { info_tbl: [(c8x5N,
                       label: block_c8x5N_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x5N: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xki; else goto c8xkh;
       c8xki: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x5N_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xkh: // global
           _c8x4o::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v3o::I64 = I64[Sp + 64];
           _s8v3p::I64 = I64[Sp + 56];
           if (I64[Sp + 16] == 244) goto c8xku; else goto c8xkl;
       c8xku: // global
           _s8v3w::I64 = I64[Sp + 8];
           if (_s8v3w::I64 < 128) goto c8xko; else goto c8xkt;
       c8xko: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3M_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xkt: // global
           if (_s8v3w::I64 > 143) goto c8xkr; else goto c8xks;
       c8xkr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xks: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8x5m() args: 0, res: 0, upd: 0;
       c8xkl: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v3p::I64;
           I64[Hp - 96] = sat_s8v3H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v3o::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x5m() //  []
         { info_tbl: [(c8x5m,
                       label: block_c8x5m_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x5m: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xke; else goto c8xkd;
       c8xke: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x5m_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xkd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v3A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x7B() //  []
         { info_tbl: [(c8x7B,
                       label: block_c8x7B_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x7B: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xll; else goto c8xlk;
       c8xll: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x7B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xlk: // global
           _c8x4o::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v42::I64 = I64[Sp + 72];
           _s8v43::I64 = I64[Sp + 64];
           if (I64[Sp + 24] == 244) goto c8xlF; else goto c8xlo;
       c8xlF: // global
           _s8v4a::I64 = I64[Sp + 8];
           if (_s8v4a::I64 < 128) goto c8xlr; else goto c8xlE;
       c8xlr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4w_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xlE: // global
           if (_s8v4a::I64 > 143) goto c8xlu; else goto c8xlD;
       c8xlu: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4B_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xlD: // global
           _s8v4g::I64 = I64[Sp + 16];
           if (_s8v4g::I64 < 128) goto c8xlx; else goto c8xlC;
       c8xlx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4G_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xlC: // global
           if (_s8v4g::I64 > 191) goto c8xlA; else goto c8xlB;
       c8xlA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4L_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xlB: // global
           Hp = Hp - 160;
           Sp = Sp + 24;
           call _c8x7a() args: 0, res: 0, upd: 0;
       c8xlo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v43::I64;
           I64[Hp - 96] = sat_s8v4r_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v42::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x7a() //  []
         { info_tbl: [(c8x7a,
                       label: block_c8x7a_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x7a: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xlh; else goto c8xlg;
       c8xlh: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x7a_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xlg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v4k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xeK() //  []
         { info_tbl: [(c8xeK,
                       label: block_c8xeK_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xeK: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xoW; else goto c8xoV;
       c8xoW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xeK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xoV: // global
           _c8x4o::P64 = P64[Sp + 112];
           _s8v2T::I64 = I64[Sp + 136];
           _s8v2U::P64 = P64[Sp + 128];
           _s8v2V::P64 = P64[Sp + 96];
           _s8v2W::I64 = I64[Sp + 104];
           _s8v2Y::I64 = I64[Sp + 120];
           _s8v30::I64 = I64[Sp + 88];
           _s8v31::P64 = P64[Sp + 40];
           _s8v32::P64 = P64[Sp + 48];
           _s8v33::I64 = I64[Sp + 56];
           _s8v34::I64 = I64[Sp + 64];
           _s8v6z::I64 = I64[Sp + 72];
           _s8v6A::I64 = I64[Sp + 80];
           if (I64[Sp + 32] == 244) goto c8xpo; else goto c8xoZ;
       c8xpo: // global
           _s8v6T::I64 = I64[Sp + 8];
           if (_s8v6T::I64 < 128) goto c8xp2; else goto c8xpn;
       c8xp2: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7A_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpn: // global
           if (_s8v6T::I64 > 143) goto c8xp5; else goto c8xpm;
       c8xp5: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7F_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpm: // global
           _s8v6Z::I64 = I64[Sp + 16];
           if (_s8v6Z::I64 < 128) goto c8xp8; else goto c8xpl;
       c8xp8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7K_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpl: // global
           if (_s8v6Z::I64 > 191) goto c8xpb; else goto c8xpk;
       c8xpb: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7P_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpk: // global
           _s8v75::I64 = I64[Sp + 24];
           if (_s8v75::I64 < 128) goto c8xpe; else goto c8xpj;
       c8xpe: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7U_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpj: // global
           if (_s8v75::I64 > 191) goto c8xph; else goto c8xpi;
       c8xph: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7Z_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xpi: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v77() args: 0, res: 0, upd: 0;
       c8xoZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v7v_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s8v77() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v77: // global
           _s8v31::P64 = P64[Sp + 32];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           I32[I64[Sp + 80] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 24] - 240 << 18) + ((I64[Sp] - 128 << 12) + ((I64[Sp + 8] - 128 << 6) + (I64[Sp + 16] - 128))));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 64] = _s8v6z::I64 + 4;
           I64[Sp + 72] = _s8v6A::I64 + 1;
           Sp = Sp + 24;
           call _c8xdA() args: 0, res: 0, upd: 0;
     }
 },
 _c8xhO() //  []
         { info_tbl: [(c8xhO,
                       label: block_c8xhO_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xhO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xrz; else goto c8xry;
       c8xrz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xhO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xry: // global
           _c8x4o::P64 = P64[Sp + 104];
           _s8v2T::I64 = I64[Sp + 128];
           _s8v2U::P64 = P64[Sp + 120];
           _s8v2V::P64 = P64[Sp + 88];
           _s8v2W::I64 = I64[Sp + 96];
           _s8v2Y::I64 = I64[Sp + 112];
           _s8v30::I64 = I64[Sp + 80];
           _s8v31::P64 = P64[Sp + 32];
           _s8v32::P64 = P64[Sp + 40];
           _s8v33::I64 = I64[Sp + 48];
           _s8v34::I64 = I64[Sp + 56];
           _s8v6z::I64 = I64[Sp + 64];
           _s8v6A::I64 = I64[Sp + 72];
           if (I64[Sp + 24] < 238) goto c8xrC; else goto c8xrT;
       c8xrC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8R_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xrT: // global
           _s8v8o::I64 = I64[Sp + 8];
           if (_s8v8o::I64 < 128) goto c8xrF; else goto c8xrS;
       c8xrF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v8W_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xrS: // global
           if (_s8v8o::I64 > 191) goto c8xrI; else goto c8xrR;
       c8xrI: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v91_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xrR: // global
           _s8v8u::I64 = I64[Sp + 16];
           if (_s8v8u::I64 < 128) goto c8xrL; else goto c8xrQ;
       c8xrL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v96_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xrQ: // global
           if (_s8v8u::I64 > 191) goto c8xrO; else goto c8xrP;
       c8xrO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v6A::I64;
           I64[Hp - 96] = sat_s8v9b_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v6z::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xrP: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8v8w() args: 0, res: 0, upd: 0;
     }
 },
 _s8v8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8v8w: // global
           _s8v31::P64 = P64[Sp + 24];
           _s8v6z::I64 = I64[Sp + 56];
           _s8v6A::I64 = I64[Sp + 64];
           I32[I64[Sp + 72] + (_s8v6A::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 16] - 224 << 12) + ((I64[Sp] - 128 << 6) + (I64[Sp + 8] - 128)));
           call MO_Touch(_s8v31::P64);
           I64[Sp + 56] = _s8v6z::I64 + 3;
           I64[Sp + 64] = _s8v6A::I64 + 1;
           Sp = Sp + 16;
           call _c8xdA() args: 0, res: 0, upd: 0;
     }
 },
 _c8xap() //  []
         { info_tbl: [(c8xap,
                       label: block_c8xap_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xap: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xn3; else goto c8xn2;
       c8xn3: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xap_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xn2: // global
           _c8x4o::P64 = P64[Sp + 96];
           _s8v2T::I64 = I64[Sp + 120];
           _s8v2U::P64 = P64[Sp + 112];
           _s8v2V::P64 = P64[Sp + 80];
           _s8v2W::I64 = I64[Sp + 88];
           _s8v2Y::I64 = I64[Sp + 104];
           _s8v30::I64 = I64[Sp + 72];
           _s8v31::P64 = P64[Sp + 24];
           _s8v32::P64 = P64[Sp + 32];
           _s8v33::I64 = I64[Sp + 40];
           _s8v34::I64 = I64[Sp + 48];
           _s8v58::I64 = I64[Sp + 64];
           _s8v59::I64 = I64[Sp + 56];
           _s8v5a::I64 = I64[Sp + 16];
           if (_s8v5a::I64 < 238) goto c8xn6; else goto c8xnj;
       c8xn6: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5s_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xnj: // global
           if (_s8v5a::I64 > 239) goto c8xn9; else goto c8xni;
       c8xn9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5x_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xni: // global
           _s8v5g::I64 = I64[Sp + 8];
           if (_s8v5g::I64 < 128) goto c8xnc; else goto c8xnh;
       c8xnc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5C_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xnh: // global
           if (_s8v5g::I64 > 191) goto c8xnf; else goto c8xng;
       c8xnf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8v31::P64;
           P64[Hp - 136] = _s8v32::P64;
           I64[Hp - 128] = _s8v30::I64;
           I64[Hp - 120] = _s8v33::I64;
           I64[Hp - 112] = _s8v34::I64;
           I64[Hp - 104] = _s8v59::I64;
           I64[Hp - 96] = sat_s8v5H_info;
           P64[Hp - 80] = _s8v2U::P64;
           P64[Hp - 72] = _s8v2V::P64;
           P64[Hp - 64] = _c8x4o::P64;
           I64[Hp - 56] = _s8v2T::I64;
           I64[Hp - 48] = _s8v2W::I64;
           I64[Hp - 40] = _s8v2Y::I64;
           I64[Hp - 32] = _s8v58::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xng: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8x9T() args: 0, res: 0, upd: 0;
     }
 },
 _c8x9T() //  []
         { info_tbl: [(c8x9T,
                       label: block_c8x9T_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x9T: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xmY; else goto c8xmX;
       c8xmY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x9T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xmX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8x9k() //  []
         { info_tbl: [(c8x9k,
                       label: block_c8x9k_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x9k: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xmT; else goto c8xmS;
       c8xmT: // global
           HpAlloc = 160;
           I64[Sp] = block_c8x9k_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xmS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v54_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xbO() //  []
         { info_tbl: [(c8xbO,
                       label: block_c8xbO_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xbO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xon; else goto c8xom;
       c8xon: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xbO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xom: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v5Z_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xca() //  []
         { info_tbl: [(c8xca,
                       label: block_c8xca_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xca: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xor; else goto c8xoq;
       c8xor: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xca_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xoq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v67_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xcw() //  []
         { info_tbl: [(c8xcw,
                       label: block_c8xcw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xcw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xov; else goto c8xou;
       c8xov: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xcw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xou: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6f_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xcS() //  []
         { info_tbl: [(c8xcS,
                       label: block_c8xcS_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xcS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xoz; else goto c8xoy;
       c8xoz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xcS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xoy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8xde() //  []
         { info_tbl: [(c8xde,
                       label: block_c8xde_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xde: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8xoD; else goto c8xoC;
       c8xoD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8xde_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8xoC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8v6v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.252051336 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes:
         I8[] [85,84,70,45,56,66,79,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.254342133 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom1_entry() //  [R1]
         { info_tbl: [(c8xIg,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xIg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xIh; else goto c8xIi;
       c8xIh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xIi: // global
           (_c8xId::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8xId::I64 == 0) goto c8xIf; else goto c8xIe;
       c8xIf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8xIe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8xId::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.258409747 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF3_closure" {
     GHC.IO.Encoding.UTF8.mkUTF3_closure:
         const GHC.IO.Encoding.UTF8.mkUTF3_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF3_entry() //  []
         { info_tbl: [(c8xIu,
                       label: GHC.IO.Encoding.UTF8.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xIu: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.265105583 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_info;
         const 0;
 },
 sat_s8vbM_entry() //  [R1, R2]
         { info_tbl: [(c8xIV,
                       label: sat_s8vbM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xIV: // global
           _s8vb9::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbI_entry() //  [R1]
         { info_tbl: [(c8xJ4,
                       label: sat_s8vbI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJ4: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xJc,
                       label: sat_s8vbG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xJn,
                       label: sat_s8vbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJn: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8xJo; else goto c8xJp;
       c8xJo: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8xJp: // global
           I64[Sp - 24] = block_c8xJk_info;
           _s8vb9::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8vb9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8xKj; else goto c8xJl;
       u8xKj: // global
           call _c8xJk(R1) args: 0, res: 0, upd: 0;
       c8xJl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xJk() //  [R1]
         { info_tbl: [(c8xJk,
                       label: block_c8xJk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJk: // global
           _s8vbm::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8xJs_info;
           _s8vbd::P64 = R1;
           _s8vbf::P64 = P64[R1 + 7];
           _s8vbg::P64 = P64[R1 + 15];
           _s8vbe::I64 = I64[R1 + 23];
           _s8vbh::I64 = I64[R1 + 31];
           _s8vbi::I64 = I64[R1 + 39];
           _s8vbj::I64 = I64[R1 + 47];
           R1 = _s8vbm::P64;
           I64[Sp - 48] = _s8vbe::I64;
           P64[Sp - 40] = _s8vbf::P64;
           P64[Sp - 32] = _s8vbg::P64;
           I64[Sp - 24] = _s8vbh::I64;
           I64[Sp - 16] = _s8vbi::I64;
           I64[Sp - 8] = _s8vbj::I64;
           P64[Sp] = _s8vbd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8xKi; else goto c8xJu;
       u8xKi: // global
           call _c8xJs(R1) args: 0, res: 0, upd: 0;
       c8xJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xJs() //  [R1]
         { info_tbl: [(c8xJs,
                       label: block_c8xJs_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJs: // global
           _s8vba::P64 = P64[Sp + 72];
           _s8vbd::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8xJA; else goto c8xJB;
       c8xJA: // global
           R3 = _s8vbd::P64;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xJB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xJG; else goto c8xJF;
       c8xJG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8xJF: // global
           _s8vbh::I64 = I64[Sp + 32];
           _s8vbj::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vbh::I64 - _s8vbj::I64,
                            3)) goto c8xKd; else goto c8xKg;
       c8xKd: // global
           _s8vb9::P64 = P64[Sp + 64];
           _s8vbe::I64 = I64[Sp + 8];
           _s8vbf::P64 = P64[Sp + 16];
           _s8vbg::P64 = P64[Sp + 24];
           _s8vbi::I64 = I64[Sp + 40];
           call MO_WriteBarrier();
           P64[_s8vb9::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8vb9::P64);
           I8[_s8vbe::I64 + _s8vbj::I64] = 239 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 1)] = 187 :: W8;
           call MO_Touch(_s8vbf::P64);
           I8[_s8vbe::I64 + (_s8vbj::I64 + 2)] = 191 :: W8;
           call MO_Touch(_s8vbf::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vbf::P64;
           P64[Hp - 32] = _s8vbg::P64;
           I64[Hp - 24] = _s8vbe::I64;
           I64[Hp - 16] = _s8vbh::I64;
           I64[Hp - 8] = _s8vbi::I64;
           I64[Hp] = _s8vbj::I64 + 3;
           R3 = Hp - 47;
           R2 = _s8vba::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xKg: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _s8vba::P64;
           P64[Hp - 24] = _s8vbd::P64;
           _c8xKf::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8xKf::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbO_entry() //  [R1]
         { info_tbl: [(c8xKl,
                       label: sat_s8vbO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xKl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xKm; else goto c8xKn;
       c8xKm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8xKn: // global
           I64[Sp - 16] = block_c8xIL_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xIL() //  [R1]
         { info_tbl: [(c8xIL,
                       label: block_c8xIL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xIL: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8xKq; else goto c8xKp;
       c8xKq: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8xKp: // global
           I64[Hp - 104] = sat_s8vbM_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vbI_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vbG_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vbF_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb3_entry() //  [R1, R2]
         { info_tbl: [(c8xKG,
                       label: sat_s8vb3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xKG: // global
           _s8va8::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaZ_entry() //  [R1]
         { info_tbl: [(c8xKP,
                       label: sat_s8vaZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xKP: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xKX,
                       label: sat_s8vaX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xKX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vaW_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xL8,
                       label: sat_s8vaW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xL8: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8xL9; else goto c8xLa;
       c8xL9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8xLa: // global
           I64[Sp - 24] = block_c8xL5_info;
           _s8va8::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8va8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8xMR; else goto c8xL6;
       u8xMR: // global
           call _c8xL5(R1) args: 0, res: 0, upd: 0;
       c8xL6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xL5() //  [R1]
         { info_tbl: [(c8xL5,
                       label: block_c8xL5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xL5: // global
           _s8val::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8xLd_info;
           _s8vac::P64 = R1;
           _s8vae::P64 = P64[R1 + 7];
           _s8vaf::P64 = P64[R1 + 15];
           _s8vad::I64 = I64[R1 + 23];
           _s8vag::I64 = I64[R1 + 31];
           _s8vah::I64 = I64[R1 + 39];
           _s8vai::I64 = I64[R1 + 47];
           R1 = _s8val::P64;
           I64[Sp - 48] = _s8vad::I64;
           P64[Sp - 40] = _s8vae::P64;
           P64[Sp - 32] = _s8vaf::P64;
           I64[Sp - 24] = _s8vag::I64;
           I64[Sp - 16] = _s8vah::I64;
           I64[Sp - 8] = _s8vai::I64;
           P64[Sp] = _s8vac::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8xMQ; else goto c8xLf;
       u8xMQ: // global
           call _c8xLd(R1) args: 0, res: 0, upd: 0;
       c8xLf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xLd() //  [R1]
         { info_tbl: [(c8xLd,
                       label: block_c8xLd_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xLd: // global
           _s8vaa::P64 = P64[Sp + 72];
           _s8vac::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8xLl; else goto c8xLm;
       c8xLl: // global
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xLm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8xLr; else goto c8xLq;
       c8xLr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8xLq: // global
           _s8vah::I64 = I64[Sp + 40];
           _s8vai::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            1)) goto c8xMC; else goto c8xMF;
       c8xMC: // global
           _s8va8::P64 = P64[Sp + 64];
           _s8vad::I64 = I64[Sp + 8];
           _s8vae::P64 = P64[Sp + 16];
           _s8vaf::P64 = P64[Sp + 24];
           _s8vag::I64 = I64[Sp + 32];
           _s8vas::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + _s8vah::I64]);
           call MO_Touch(_s8vae::P64);
           if (_s8vas::I64 == 239) goto c8xMA; else goto c8xLE;
       c8xMA: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            2)) goto c8xMw; else goto c8xMz;
       c8xMw: // global
           _s8vaC::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 1)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaC::I64 == 187) goto c8xMu; else goto c8xLW;
       c8xMu: // global
           if (%MO_S_Ge_W64(_s8vai::I64 - _s8vah::I64,
                            3)) goto c8xMq; else goto c8xMt;
       c8xMq: // global
           _s8vaM::I64 = %MO_UU_Conv_W8_W64(I8[_s8vad::I64 + (_s8vah::I64 + 2)]);
           call MO_Touch(_s8vae::P64);
           if (_s8vaM::I64 == 191) goto c8xMo; else goto c8xMe;
       c8xMo: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8vae::P64;
           P64[Hp - 32] = _s8vaf::P64;
           I64[Hp - 24] = _s8vad::I64;
           I64[Hp - 16] = _s8vag::I64;
           I64[Hp - 8] = _s8vah::I64 + 3;
           I64[Hp] = _s8vai::I64;
           R3 = _s8vaa::P64;
           R2 = Hp - 47;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xMe: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xMt: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8xMs::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8xMs::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xLW: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xMz: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8xMy::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8xMy::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8xLE: // global
           call MO_WriteBarrier();
           P64[_s8va8::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8va8::P64);
           Hp = Hp - 56;
           R3 = _s8vaa::P64;
           R2 = _s8vac::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8xMF: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8vac::P64;
           P64[Hp - 24] = _s8vaa::P64;
           _c8xME::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8xME::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vb5_entry() //  [R1]
         { info_tbl: [(c8xMT,
                       label: sat_s8vb5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xMU; else goto c8xMV;
       c8xMU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8xMV: // global
           I64[Sp - 16] = block_c8xKw_info;
           _s8va4::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8va4::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xKw() //  [R1]
         { info_tbl: [(c8xKw,
                       label: block_c8xKw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xKw: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8xMY; else goto c8xMX;
       c8xMY: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8xMX: // global
           I64[Hp - 104] = sat_s8vb3_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8vaZ_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8vaX_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8vaW_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom_entry() //  [R2]
         { info_tbl: [(c8xN0,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xN0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8xN4; else goto c8xN3;
       c8xN4: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8xN3: // global
           I64[Hp - 56] = sat_s8vbO_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vb5_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.309232059 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_bom_closure" {
     GHC.IO.Encoding.UTF8.utf8_bom_closure:
         const GHC.IO.Encoding.UTF8.utf8_bom_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf8_bom_entry() //  [R1]
         { info_tbl: [(c8xOZ,
                       label: GHC.IO.Encoding.UTF8.utf8_bom_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xOZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xP0; else goto c8xP1;
       c8xP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xP1: // global
           (_c8xOW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8xOW::I64 == 0) goto c8xOY; else goto c8xOX;
       c8xOY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8xOX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8xOW::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF8.mkUTF8_bom_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.315256942 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF6_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF6_bytes:
         I8[] [85,84,70,45,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.318171504 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF5_closure" {
     GHC.IO.Encoding.UTF8.mkUTF5_closure:
         const GHC.IO.Encoding.UTF8.mkUTF5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF5_entry() //  [R1]
         { info_tbl: [(c8xPg,
                       label: GHC.IO.Encoding.UTF8.mkUTF5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xPh; else goto c8xPi;
       c8xPh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8xPi: // global
           (_c8xPd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8xPd::I64 == 0) goto c8xPf; else goto c8xPe;
       c8xPf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8xPe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8xPd::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.324411003 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF2_closure" {
     GHC.IO.Encoding.UTF8.mkUTF2_closure:
         const GHC.IO.Encoding.UTF8.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF2_entry() //  []
         { info_tbl: [(c8xPu,
                       label: GHC.IO.Encoding.UTF8.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xPu: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.33044743 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_info;
         const 0;
 },
 sat_s8vbX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xPQ,
                       label: sat_s8vbX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xPQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbZ_entry() //  [R1]
         { info_tbl: [(c8xPU,
                       label: sat_s8vbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xPU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8xPY; else goto c8xPX;
       c8xPY: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8xPX: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbX_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8xQ9,
                       label: sat_s8vbT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQ9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8vbV_entry() //  [R1]
         { info_tbl: [(c8xQd,
                       label: sat_s8vbV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8xQh; else goto c8xQg;
       c8xQh: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8xQg: // global
           _s8vbR::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8vbT_info;
           P64[Hp - 48] = _s8vbR::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_entry() //  [R2]
         { info_tbl: [(c8xQj,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8xQn; else goto c8xQm;
       c8xQn: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8xQm: // global
           I64[Hp - 56] = sat_s8vbZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8vbV_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF5_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.348737017 UTC

[section ""data" . lvl_r8uYu_closure" {
     lvl_r8uYu_closure:
         const lvl_r8uYu_info;
         const 0;
 },
 lvl_r8uYu_entry() //  [R2, R3]
         { info_tbl: [(c8xQS,
                       label: lvl_r8uYu_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8xQW; else goto c8xQX;
       c8xQW: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8uYu_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8xQX: // global
           I64[Sp - 16] = block_c8xQP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8xR5; else goto c8xQQ;
       u8xR5: // global
           call _c8xQP() args: 0, res: 0, upd: 0;
       c8xQQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xQP() //  []
         { info_tbl: [(c8xQP,
                       label: block_c8xQP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQP: // global
           _s8vc1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8xQV_info;
           R1 = _s8vc1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8xR4; else goto c8xQZ;
       u8xR4: // global
           call _c8xQV() args: 0, res: 0, upd: 0;
       c8xQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xQV() //  []
         { info_tbl: [(c8xQV,
                       label: block_c8xQV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xQV: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.359605282 UTC

[section ""data" . lvl1_r8uYv_closure" {
     lvl1_r8uYv_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
         const lvl_r8uYu_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.362233628 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf3_closure" {
     GHC.IO.Encoding.UTF8.utf3_closure:
         const GHC.IO.Encoding.UTF8.utf3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf3_entry() //  []
         { info_tbl: [(c8xRo,
                       label: GHC.IO.Encoding.UTF8.utf3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xRo: // global
           R1 = lvl1_r8uYv_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.366135197 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf2_closure" {
     GHC.IO.Encoding.UTF8.utf2_closure:
         const GHC.IO.Encoding.UTF8.utf2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf2_entry() //  [R2, R3]
         { info_tbl: [(c8xRD,
                       label: GHC.IO.Encoding.UTF8.utf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xRD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8xRH; else goto c8xRI;
       c8xRH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.utf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8xRI: // global
           I64[Sp - 16] = block_c8xRA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8xRR; else goto c8xRB;
       u8xRR: // global
           call _c8xRA(R1) args: 0, res: 0, upd: 0;
       c8xRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xRA() //  [R1]
         { info_tbl: [(c8xRA,
                       label: block_c8xRA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xRA: // global
           I64[Sp - 16] = block_c8xRG_info;
           _s8vcn::P64 = P64[R1 + 7];
           _s8vcm::I64 = I64[R1 + 23];
           _s8vcq::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8vcq::I64;
           P64[Sp] = _s8vcn::P64;
           I64[Sp + 8] = _s8vcm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8xRQ; else goto c8xRK;
       u8xRQ: // global
           call _c8xRG() args: 0, res: 0, upd: 0;
       c8xRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xRG() //  []
         { info_tbl: [(c8xRG,
                       label: block_c8xRG_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xRG: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.373694775 UTC

[section ""data" . lvl2_r8uYw_closure" {
     lvl2_r8uYw_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF8.utf2_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.375711106 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf1_closure" {
     GHC.IO.Encoding.UTF8.utf1_closure:
         const GHC.IO.Encoding.UTF8.utf1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf1_entry() //  []
         { info_tbl: [(c8xSa,
                       label: GHC.IO.Encoding.UTF8.utf1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xSa: // global
           R1 = lvl2_r8uYw_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.379096899 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_closure" {
     GHC.IO.Encoding.UTF8.utf8_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.UTF8.utf3_closure+1;
         const GHC.IO.Encoding.UTF8.utf1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:37.380975024 UTC

[section ""relreadonly" . S8vY4_srt" {
     S8vY4_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_closure;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8uYu_closure;
         const lvl1_r8uYv_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF8.utf2_closure;
         const lvl2_r8uYw_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.436827234 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:42.43798159 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule4_bytes" {
     GHC.IO.Encoding.UTF8.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.439814382 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule3_closure" {
     GHC.IO.Encoding.UTF8.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.441625051 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.$trModule2_bytes" {
     GHC.IO.Encoding.UTF8.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.443258472 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule1_closure" {
     GHC.IO.Encoding.UTF8.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF8.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.444983471 UTC

[section ""data" . GHC.IO.Encoding.UTF8.$trModule_closure" {
     GHC.IO.Encoding.UTF8.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF8.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF8.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.454535719 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF1_info;
 },
 sat_s8xSH_entry() //  [R1]
         { info_tbl: [(c8y6Z,
                       label: sat_s8xSH_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y6Z: // global
           _s8xSH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y70; else goto c8y71;
       c8y71: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y73; else goto c8y72;
       c8y73: // global
           HpAlloc = 56;
           goto c8y70;
       c8y70: // global
           R1 = _s8xSH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xSH::P64;
           _s8xSt::I64 = I64[_s8xSH::P64 + 56];
           _s8xSD::I64 = I64[_s8xSH::P64 + 64];
           if (_s8xSD::I64 == _s8xSt::I64) goto c8y6Y; else goto c8y6X;
       c8y6Y: // global
           _s8xSB::P64 = P64[_s8xSH::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y6X: // global
           _s8xSp::P64 = P64[_s8xSH::P64 + 16];
           _s8xSq::P64 = P64[_s8xSH::P64 + 24];
           _s8xSo::I64 = I64[_s8xSH::P64 + 40];
           _s8xSr::I64 = I64[_s8xSH::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xSD::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xSP_entry() //  [R1]
         { info_tbl: [(c8y7l,
                       label: sat_s8xSP_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y7l: // global
           _s8xSP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y7m; else goto c8y7n;
       c8y7n: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y7p; else goto c8y7o;
       c8y7p: // global
           HpAlloc = 56;
           goto c8y7m;
       c8y7m: // global
           R1 = _s8xSP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y7o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xSP::P64;
           _s8xSt::I64 = I64[_s8xSP::P64 + 56];
           _s8xSL::I64 = I64[_s8xSP::P64 + 64];
           if (_s8xSL::I64 == _s8xSt::I64) goto c8y7k; else goto c8y7j;
       c8y7k: // global
           _s8xSB::P64 = P64[_s8xSP::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y7j: // global
           _s8xSp::P64 = P64[_s8xSP::P64 + 16];
           _s8xSq::P64 = P64[_s8xSP::P64 + 24];
           _s8xSo::I64 = I64[_s8xSP::P64 + 40];
           _s8xSr::I64 = I64[_s8xSP::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xSL::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xSX_entry() //  [R1]
         { info_tbl: [(c8y7H,
                       label: sat_s8xSX_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y7H: // global
           _s8xSX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y7I; else goto c8y7J;
       c8y7J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y7L; else goto c8y7K;
       c8y7L: // global
           HpAlloc = 56;
           goto c8y7I;
       c8y7I: // global
           R1 = _s8xSX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xSX::P64;
           _s8xSt::I64 = I64[_s8xSX::P64 + 56];
           _s8xST::I64 = I64[_s8xSX::P64 + 64];
           if (_s8xST::I64 == _s8xSt::I64) goto c8y7G; else goto c8y7F;
       c8y7G: // global
           _s8xSB::P64 = P64[_s8xSX::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y7F: // global
           _s8xSp::P64 = P64[_s8xSX::P64 + 16];
           _s8xSq::P64 = P64[_s8xSX::P64 + 24];
           _s8xSo::I64 = I64[_s8xSX::P64 + 40];
           _s8xSr::I64 = I64[_s8xSX::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xST::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xT5_entry() //  [R1]
         { info_tbl: [(c8y83,
                       label: sat_s8xT5_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y83: // global
           _s8xT5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y84; else goto c8y85;
       c8y85: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y87; else goto c8y86;
       c8y87: // global
           HpAlloc = 56;
           goto c8y84;
       c8y84: // global
           R1 = _s8xT5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y86: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xT5::P64;
           _s8xSt::I64 = I64[_s8xT5::P64 + 56];
           _s8xT1::I64 = I64[_s8xT5::P64 + 64];
           if (_s8xT1::I64 == _s8xSt::I64) goto c8y82; else goto c8y81;
       c8y82: // global
           _s8xSB::P64 = P64[_s8xT5::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y81: // global
           _s8xSp::P64 = P64[_s8xT5::P64 + 16];
           _s8xSq::P64 = P64[_s8xT5::P64 + 24];
           _s8xSo::I64 = I64[_s8xT5::P64 + 40];
           _s8xSr::I64 = I64[_s8xT5::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xT1::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xTd_entry() //  [R1]
         { info_tbl: [(c8y8p,
                       label: sat_s8xTd_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y8p: // global
           _s8xTd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y8q; else goto c8y8r;
       c8y8r: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y8t; else goto c8y8s;
       c8y8t: // global
           HpAlloc = 56;
           goto c8y8q;
       c8y8q: // global
           R1 = _s8xTd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y8s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xTd::P64;
           _s8xSt::I64 = I64[_s8xTd::P64 + 56];
           _s8xT9::I64 = I64[_s8xTd::P64 + 64];
           if (_s8xT9::I64 == _s8xSt::I64) goto c8y8o; else goto c8y8n;
       c8y8o: // global
           _s8xSB::P64 = P64[_s8xTd::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y8n: // global
           _s8xSp::P64 = P64[_s8xTd::P64 + 16];
           _s8xSq::P64 = P64[_s8xTd::P64 + 24];
           _s8xSo::I64 = I64[_s8xTd::P64 + 40];
           _s8xSr::I64 = I64[_s8xTd::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xT9::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xV3_entry() //  [R1]
         { info_tbl: [(c8y9g,
                       label: sat_s8xV3_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y9g: // global
           _s8xV3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y9h; else goto c8y9i;
       c8y9i: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y9k; else goto c8y9j;
       c8y9k: // global
           HpAlloc = 56;
           goto c8y9h;
       c8y9h: // global
           R1 = _s8xV3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y9j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xV3::P64;
           _s8xSt::I64 = I64[_s8xV3::P64 + 56];
           _s8xTh::I64 = I64[_s8xV3::P64 + 64];
           if (_s8xTh::I64 == _s8xSt::I64) goto c8y9f; else goto c8y9e;
       c8y9f: // global
           _s8xSB::P64 = P64[_s8xV3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y9e: // global
           _s8xSp::P64 = P64[_s8xV3::P64 + 16];
           _s8xSq::P64 = P64[_s8xV3::P64 + 24];
           _s8xSo::I64 = I64[_s8xV3::P64 + 40];
           _s8xSr::I64 = I64[_s8xV3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xTh::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xW4_entry() //  [R1]
         { info_tbl: [(c8y9J,
                       label: sat_s8xW4_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y9J: // global
           _s8xW4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8y9K; else goto c8y9L;
       c8y9L: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8y9N; else goto c8y9M;
       c8y9N: // global
           HpAlloc = 56;
           goto c8y9K;
       c8y9K: // global
           R1 = _s8xW4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8y9M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xW4::P64;
           _s8xSt::I64 = I64[_s8xW4::P64 + 56];
           _s8xTh::I64 = I64[_s8xW4::P64 + 64];
           if (_s8xTh::I64 == _s8xSt::I64) goto c8y9I; else goto c8y9H;
       c8y9I: // global
           _s8xSB::P64 = P64[_s8xW4::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y9H: // global
           _s8xSp::P64 = P64[_s8xW4::P64 + 16];
           _s8xSq::P64 = P64[_s8xW4::P64 + 24];
           _s8xSo::I64 = I64[_s8xW4::P64 + 40];
           _s8xSr::I64 = I64[_s8xW4::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xTh::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xW8_entry() //  [R1]
         { info_tbl: [(c8ya1,
                       label: sat_s8xW8_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ya1: // global
           _s8xW8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ya2; else goto c8ya3;
       c8ya3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ya5; else goto c8ya4;
       c8ya5: // global
           HpAlloc = 56;
           goto c8ya2;
       c8ya2: // global
           R1 = _s8xW8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ya4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xW8::P64;
           _s8xSt::I64 = I64[_s8xW8::P64 + 56];
           _s8xTh::I64 = I64[_s8xW8::P64 + 64];
           if (_s8xTh::I64 == _s8xSt::I64) goto c8ya0; else goto c8y9Z;
       c8ya0: // global
           _s8xSB::P64 = P64[_s8xW8::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xSB::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8y9Z: // global
           _s8xSp::P64 = P64[_s8xW8::P64 + 16];
           _s8xSq::P64 = P64[_s8xW8::P64 + 24];
           _s8xSo::I64 = I64[_s8xW8::P64 + 40];
           _s8xSr::I64 = I64[_s8xW8::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xSp::P64;
           P64[Hp - 32] = _s8xSq::P64;
           I64[Hp - 24] = _s8xSo::I64;
           I64[Hp - 16] = _s8xSr::I64;
           I64[Hp - 8] = _s8xTh::I64;
           I64[Hp] = _s8xSt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8ya8,
                       label: GHC.IO.Encoding.UTF8.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ya8: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8ya9; else goto c8yaa;
       c8ya9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8yaa: // global
           I64[Sp - 16] = block_c8y6z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8yiF; else goto c8y6A;
       u8yiF: // global
           call _c8y6z(R1) args: 0, res: 0, upd: 0;
       c8y6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8y6z() //  [R1]
         { info_tbl: [(c8y6z,
                       label: block_c8y6z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y6z: // global
           I64[Sp - 40] = block_c8y6E_info;
           _s8xSp::P64 = P64[R1 + 7];
           _s8xSq::P64 = P64[R1 + 15];
           _s8xSo::I64 = I64[R1 + 23];
           _s8xSr::I64 = I64[R1 + 31];
           _s8xSs::I64 = I64[R1 + 39];
           _s8xSt::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8xSq::P64;
           I64[Sp - 24] = _s8xSr::I64;
           I64[Sp - 16] = _s8xSs::I64;
           I64[Sp - 8] = _s8xSt::I64;
           P64[Sp] = _s8xSp::P64;
           I64[Sp + 8] = _s8xSo::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8yir; else goto c8y6F;
       u8yir: // global
           call _c8y6E(R1) args: 0, res: 0, upd: 0;
       c8y6F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8y6E() //  [R1]
         { info_tbl: [(c8y6E,
                       label: block_c8y6E_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y6E: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yae; else goto c8yad;
       c8yae: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8yad: // global
           _s8xSw::P64 = P64[R1 + 7];
           _s8xSx::P64 = P64[R1 + 15];
           _s8xSv::I64 = I64[R1 + 23];
           _s8xSy::I64 = I64[R1 + 31];
           _s8xSz::I64 = I64[R1 + 39];
           _s8xSA::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8xSw::P64;
           P64[Sp - 40] = _s8xSx::P64;
           I64[Sp - 32] = _s8xSy::I64;
           I64[Sp - 24] = _s8xSz::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8xSA::I64;
           I64[Sp] = _s8xSv::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8y8y() args: 0, res: 0, upd: 0;
     }
 },
 _c8y8y() //  []
         { info_tbl: [(c8y8y,
                       label: block_c8y8y_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y8y: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yaB; else goto c8yaA;
       c8yaB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y8y_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yaA: // global
           _s8xSy::I64 = I64[Sp + 24];
           _s8xTh::I64 = I64[Sp + 40];
           _s8xTi::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8xTi::I64,
                            _s8xSy::I64)) goto c8ybX; else goto c8ybY;
       c8ybX: // global
           _s8xSt::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8xTh::I64,
                            _s8xSt::I64)) goto c8ybU; else goto c8ybV;
       c8ybU: // global
           _c8y6J::P64 = P64[Sp + 80];
           _s8xSo::I64 = I64[Sp + 104];
           _s8xSp::P64 = P64[Sp + 96];
           _s8xSq::P64 = P64[Sp + 64];
           _s8xSr::I64 = I64[Sp + 72];
           _s8xSv::I64 = I64[Sp + 56];
           _s8xSw::P64 = P64[Sp + 8];
           _s8xSx::P64 = P64[Sp + 16];
           _s8xSz::I64 = I64[Sp + 32];
           _s8xTo::I64 = %MO_UU_Conv_W32_W64(I32[_s8xSo::I64 + (_s8xTh::I64 << 2)]);
           call MO_Touch(_s8xSp::P64);
           if (%MO_S_Gt_W64(_s8xTo::I64, 127)) goto c8ybR; else goto c8ybS;
       c8ybR: // global
           if (%MO_S_Gt_W64(_s8xTo::I64, 2047)) goto c8ybF; else goto c8ybP;
       c8ybF: // global
           if (%MO_S_Gt_W64(_s8xTo::I64, 65535)) goto c8yaL; else goto c8ybD;
       c8yaL: // global
           if (%MO_S_Ge_W64(_s8xSy::I64 - _s8xTi::I64,
                            4)) goto c8yaI; else goto c8yaJ;
       c8yaI: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            18) + 240);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  12) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 4;
           goto u8yiC;
       c8yaJ: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTi::I64;
           I64[Sp + 48] = _s8xTh::I64;
           call _c8y6M() args: 0, res: 0, upd: 0;
       c8ybD: // global
           if (%MO_S_Gt_W64(55296, _s8xTo::I64)) goto c8yba; else goto c8ybC;
       c8yba: // global
           if (%MO_S_Gt_W64(56320, _s8xTo::I64)) goto c8yaV; else goto c8yb8;
       c8yaV: // global
           if (%MO_S_Lt_W64(_s8xSy::I64 - _s8xTi::I64,
                            3)) goto c8ybs; else goto c8yaS;
       c8yaS: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            12) + 224);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 3;
           goto u8yiC;
       c8yb8: // global
           if (%MO_S_Gt_W64(_s8xTo::I64, 57343)) goto c8yb5; else goto c8yb7;
       c8yb5: // global
           if (%MO_S_Lt_W64(_s8xSy::I64 - _s8xTi::I64,
                            3)) goto c8ybs; else goto c8yb2;
       c8yb2: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            12) + 224);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 3;
           goto u8yiC;
       c8yb7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xSw::P64;
           P64[Hp - 136] = _s8xSx::P64;
           I64[Hp - 128] = _s8xSv::I64;
           I64[Hp - 120] = _s8xSy::I64;
           I64[Hp - 112] = _s8xSz::I64;
           I64[Hp - 104] = _s8xTi::I64;
           I64[Hp - 96] = sat_s8xV3_info;
           P64[Hp - 80] = _s8xSp::P64;
           P64[Hp - 72] = _s8xSq::P64;
           P64[Hp - 64] = _c8y6J::P64;
           I64[Hp - 56] = _s8xSo::I64;
           I64[Hp - 48] = _s8xSr::I64;
           I64[Hp - 40] = _s8xSt::I64;
           I64[Hp - 32] = _s8xTh::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ybC: // global
           if (%MO_S_Gt_W64(_s8xTo::I64, 56319)) goto c8ybz; else goto c8ybB;
       c8ybz: // global
           if (%MO_S_Gt_W64(56320, _s8xTo::I64)) goto c8ybk; else goto c8ybx;
       c8ybk: // global
           if (%MO_S_Lt_W64(_s8xSy::I64 - _s8xTi::I64,
                            3)) goto c8ybs; else goto c8ybh;
       c8ybh: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            12) + 224);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 3;
           goto u8yiC;
       c8ybx: // global
           if (%MO_S_Gt_W64(_s8xTo::I64, 57343)) goto c8ybu; else goto c8ybw;
       c8ybu: // global
           if (%MO_S_Lt_W64(_s8xSy::I64 - _s8xTi::I64,
                            3)) goto c8ybs; else goto c8ybr;
       c8ybs: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTi::I64;
           I64[Sp + 48] = _s8xTh::I64;
           call _c8y78() args: 0, res: 0, upd: 0;
       c8ybr: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            12) + 224);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                                  6) & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 3;
           goto u8yiC;
       c8ybw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xSw::P64;
           P64[Hp - 136] = _s8xSx::P64;
           I64[Hp - 128] = _s8xSv::I64;
           I64[Hp - 120] = _s8xSy::I64;
           I64[Hp - 112] = _s8xSz::I64;
           I64[Hp - 104] = _s8xTi::I64;
           I64[Hp - 96] = sat_s8xW4_info;
           P64[Hp - 80] = _s8xSp::P64;
           P64[Hp - 72] = _s8xSq::P64;
           P64[Hp - 64] = _c8y6J::P64;
           I64[Hp - 56] = _s8xSo::I64;
           I64[Hp - 48] = _s8xSr::I64;
           I64[Hp - 40] = _s8xSt::I64;
           I64[Hp - 32] = _s8xTh::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ybB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xSw::P64;
           P64[Hp - 136] = _s8xSx::P64;
           I64[Hp - 128] = _s8xSv::I64;
           I64[Hp - 120] = _s8xSy::I64;
           I64[Hp - 112] = _s8xSz::I64;
           I64[Hp - 104] = _s8xTi::I64;
           I64[Hp - 96] = sat_s8xW8_info;
           P64[Hp - 80] = _s8xSp::P64;
           P64[Hp - 72] = _s8xSq::P64;
           P64[Hp - 64] = _c8y6J::P64;
           I64[Hp - 56] = _s8xSo::I64;
           I64[Hp - 48] = _s8xSr::I64;
           I64[Hp - 40] = _s8xSt::I64;
           I64[Hp - 32] = _s8xTh::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ybP: // global
           if (%MO_S_Ge_W64(_s8xSy::I64 - _s8xTi::I64,
                            2)) goto c8ybN; else goto c8ybO;
       c8ybN: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8xTo::I64,
                                                                            6) + 192);
           call MO_Touch(_s8xSw::P64);
           I8[_s8xSv::I64 + (_s8xTi::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8xTo::I64 & 63 + 128);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 2;
           goto u8yiC;
       c8ybO: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTi::I64;
           I64[Sp + 48] = _s8xTh::I64;
           call _c8y7u() args: 0, res: 0, upd: 0;
       c8ybS: // global
           I8[_s8xSv::I64 + _s8xTi::I64] = %MO_UU_Conv_W64_W8(_s8xTo::I64);
           call MO_Touch(_s8xSw::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTh::I64 + 1;
           I64[Sp + 48] = _s8xTi::I64 + 1;
           goto u8yiC;
       u8yiC: // global
           call _c8y8y() args: 0, res: 0, upd: 0;
       c8ybV: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTi::I64;
           I64[Sp + 48] = _s8xTh::I64;
           call _c8y7Q() args: 0, res: 0, upd: 0;
       c8ybY: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8xTi::I64;
           I64[Sp + 48] = _s8xTh::I64;
           call _c8y8c() args: 0, res: 0, upd: 0;
     }
 },
 _c8y6M() //  []
         { info_tbl: [(c8y6M,
                       label: block_c8y6M_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y6M: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yai; else goto c8yah;
       c8yai: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y6M_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yah: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xSH_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8y78() //  []
         { info_tbl: [(c8y78,
                       label: block_c8y78_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y78: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yam; else goto c8yal;
       c8yam: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y78_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yal: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xSP_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8y7u() //  []
         { info_tbl: [(c8y7u,
                       label: block_c8y7u_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y7u: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yaq; else goto c8yap;
       c8yaq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y7u_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yap: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xSX_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8y7Q() //  []
         { info_tbl: [(c8y7Q,
                       label: block_c8y7Q_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y7Q: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yau; else goto c8yat;
       c8yau: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y7Q_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yat: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xT5_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8y8c() //  []
         { info_tbl: [(c8y8c,
                       label: block_c8y8c_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y8c: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yay; else goto c8yax;
       c8yay: // global
           HpAlloc = 160;
           I64[Sp] = block_c8y8c_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yax: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xTd_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.545442292 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF4_closure" {
     GHC.IO.Encoding.UTF8.mkUTF4_closure:
         const GHC.IO.Encoding.UTF8.mkUTF4_info;
 },
 sat_s8xWY_entry() //  [R1]
         { info_tbl: [(c8yoq,
                       label: sat_s8xWY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yoq: // global
           _s8xWY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yor; else goto c8yos;
       c8yos: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8you; else goto c8yot;
       c8you: // global
           HpAlloc = 56;
           goto c8yor;
       c8yor: // global
           R1 = _s8xWY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yot: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xWY::P64;
           _s8xWK::I64 = I64[_s8xWY::P64 + 56];
           _s8xWU::I64 = I64[_s8xWY::P64 + 64];
           if (_s8xWU::I64 == _s8xWK::I64) goto c8yop; else goto c8yoo;
       c8yop: // global
           _s8xWS::P64 = P64[_s8xWY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yoo: // global
           _s8xWG::P64 = P64[_s8xWY::P64 + 16];
           _s8xWH::P64 = P64[_s8xWY::P64 + 24];
           _s8xWF::I64 = I64[_s8xWY::P64 + 40];
           _s8xWI::I64 = I64[_s8xWY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xWU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xX6_entry() //  [R1]
         { info_tbl: [(c8yoM,
                       label: sat_s8xX6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yoM: // global
           _s8xX6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yoN; else goto c8yoO;
       c8yoO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yoQ; else goto c8yoP;
       c8yoQ: // global
           HpAlloc = 56;
           goto c8yoN;
       c8yoN: // global
           R1 = _s8xX6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yoP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xX6::P64;
           _s8xWK::I64 = I64[_s8xX6::P64 + 56];
           _s8xX2::I64 = I64[_s8xX6::P64 + 64];
           if (_s8xX2::I64 == _s8xWK::I64) goto c8yoL; else goto c8yoK;
       c8yoL: // global
           _s8xWS::P64 = P64[_s8xX6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yoK: // global
           _s8xWG::P64 = P64[_s8xX6::P64 + 16];
           _s8xWH::P64 = P64[_s8xX6::P64 + 24];
           _s8xWF::I64 = I64[_s8xX6::P64 + 40];
           _s8xWI::I64 = I64[_s8xX6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xX2::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xXm_entry() //  [R1]
         { info_tbl: [(c8ypk,
                       label: sat_s8xXm_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ypk: // global
           _s8xXm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ypl; else goto c8ypm;
       c8ypm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ypo; else goto c8ypn;
       c8ypo: // global
           HpAlloc = 56;
           goto c8ypl;
       c8ypl: // global
           R1 = _s8xXm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ypn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xXm::P64;
           _s8xWK::I64 = I64[_s8xXm::P64 + 56];
           _s8xXa::I64 = I64[_s8xXm::P64 + 64];
           if (_s8xXa::I64 == _s8xWK::I64) goto c8ypj; else goto c8ypi;
       c8ypj: // global
           _s8xWS::P64 = P64[_s8xXm::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ypi: // global
           _s8xWG::P64 = P64[_s8xXm::P64 + 16];
           _s8xWH::P64 = P64[_s8xXm::P64 + 24];
           _s8xWF::I64 = I64[_s8xXm::P64 + 40];
           _s8xWI::I64 = I64[_s8xXm::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXa::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xXt_entry() //  [R1]
         { info_tbl: [(c8ypN,
                       label: sat_s8xXt_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ypN: // global
           _s8xXt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ypO; else goto c8ypP;
       c8ypP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ypR; else goto c8ypQ;
       c8ypR: // global
           HpAlloc = 56;
           goto c8ypO;
       c8ypO: // global
           R1 = _s8xXt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ypQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xXt::P64;
           _s8xWK::I64 = I64[_s8xXt::P64 + 56];
           _s8xXa::I64 = I64[_s8xXt::P64 + 64];
           if (_s8xXa::I64 == _s8xWK::I64) goto c8ypM; else goto c8ypL;
       c8ypM: // global
           _s8xWS::P64 = P64[_s8xXt::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ypL: // global
           _s8xWG::P64 = P64[_s8xXt::P64 + 16];
           _s8xWH::P64 = P64[_s8xXt::P64 + 24];
           _s8xWF::I64 = I64[_s8xXt::P64 + 40];
           _s8xWI::I64 = I64[_s8xXt::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXa::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xXy_entry() //  [R1]
         { info_tbl: [(c8yq8,
                       label: sat_s8xXy_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yq8: // global
           _s8xXy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yq9; else goto c8yqa;
       c8yqa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yqc; else goto c8yqb;
       c8yqc: // global
           HpAlloc = 56;
           goto c8yq9;
       c8yq9: // global
           R1 = _s8xXy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yqb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xXy::P64;
           _s8xWK::I64 = I64[_s8xXy::P64 + 56];
           _s8xXa::I64 = I64[_s8xXy::P64 + 64];
           if (_s8xXa::I64 == _s8xWK::I64) goto c8yq7; else goto c8yq6;
       c8yq7: // global
           _s8xWS::P64 = P64[_s8xXy::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yq6: // global
           _s8xWG::P64 = P64[_s8xXy::P64 + 16];
           _s8xWH::P64 = P64[_s8xXy::P64 + 24];
           _s8xWF::I64 = I64[_s8xXy::P64 + 40];
           _s8xWI::I64 = I64[_s8xXy::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXa::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xXD_entry() //  [R1]
         { info_tbl: [(c8yqt,
                       label: sat_s8xXD_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yqt: // global
           _s8xXD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yqu; else goto c8yqv;
       c8yqv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yqx; else goto c8yqw;
       c8yqx: // global
           HpAlloc = 56;
           goto c8yqu;
       c8yqu: // global
           R1 = _s8xXD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yqw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xXD::P64;
           _s8xWK::I64 = I64[_s8xXD::P64 + 56];
           _s8xXa::I64 = I64[_s8xXD::P64 + 64];
           if (_s8xXa::I64 == _s8xWK::I64) goto c8yqs; else goto c8yqr;
       c8yqs: // global
           _s8xWS::P64 = P64[_s8xXD::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yqr: // global
           _s8xWG::P64 = P64[_s8xXD::P64 + 16];
           _s8xWH::P64 = P64[_s8xXD::P64 + 24];
           _s8xWF::I64 = I64[_s8xXD::P64 + 40];
           _s8xWI::I64 = I64[_s8xXD::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXa::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xY6_entry() //  [R1]
         { info_tbl: [(c8yr8,
                       label: sat_s8xY6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yr8: // global
           _s8xY6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yr9; else goto c8yra;
       c8yra: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yrc; else goto c8yrb;
       c8yrc: // global
           HpAlloc = 56;
           goto c8yr9;
       c8yr9: // global
           R1 = _s8xY6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yrb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xY6::P64;
           _s8xWK::I64 = I64[_s8xY6::P64 + 56];
           _s8xXO::I64 = I64[_s8xY6::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8yr7; else goto c8yr6;
       c8yr7: // global
           _s8xWS::P64 = P64[_s8xY6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yr6: // global
           _s8xWG::P64 = P64[_s8xY6::P64 + 16];
           _s8xWH::P64 = P64[_s8xY6::P64 + 24];
           _s8xWF::I64 = I64[_s8xY6::P64 + 40];
           _s8xWI::I64 = I64[_s8xY6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYd_entry() //  [R1]
         { info_tbl: [(c8yrB,
                       label: sat_s8xYd_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yrB: // global
           _s8xYd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yrC; else goto c8yrD;
       c8yrD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yrF; else goto c8yrE;
       c8yrF: // global
           HpAlloc = 56;
           goto c8yrC;
       c8yrC: // global
           R1 = _s8xYd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yrE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYd::P64;
           _s8xWK::I64 = I64[_s8xYd::P64 + 56];
           _s8xXO::I64 = I64[_s8xYd::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8yrA; else goto c8yrz;
       c8yrA: // global
           _s8xWS::P64 = P64[_s8xYd::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yrz: // global
           _s8xWG::P64 = P64[_s8xYd::P64 + 16];
           _s8xWH::P64 = P64[_s8xYd::P64 + 24];
           _s8xWF::I64 = I64[_s8xYd::P64 + 40];
           _s8xWI::I64 = I64[_s8xYd::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYi_entry() //  [R1]
         { info_tbl: [(c8yrW,
                       label: sat_s8xYi_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yrW: // global
           _s8xYi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yrX; else goto c8yrY;
       c8yrY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ys0; else goto c8yrZ;
       c8ys0: // global
           HpAlloc = 56;
           goto c8yrX;
       c8yrX: // global
           R1 = _s8xYi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yrZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYi::P64;
           _s8xWK::I64 = I64[_s8xYi::P64 + 56];
           _s8xXO::I64 = I64[_s8xYi::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8yrV; else goto c8yrU;
       c8yrV: // global
           _s8xWS::P64 = P64[_s8xYi::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yrU: // global
           _s8xWG::P64 = P64[_s8xYi::P64 + 16];
           _s8xWH::P64 = P64[_s8xYi::P64 + 24];
           _s8xWF::I64 = I64[_s8xYi::P64 + 40];
           _s8xWI::I64 = I64[_s8xYi::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYn_entry() //  [R1]
         { info_tbl: [(c8ysh,
                       label: sat_s8xYn_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ysh: // global
           _s8xYn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ysi; else goto c8ysj;
       c8ysj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ysl; else goto c8ysk;
       c8ysl: // global
           HpAlloc = 56;
           goto c8ysi;
       c8ysi: // global
           R1 = _s8xYn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ysk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYn::P64;
           _s8xWK::I64 = I64[_s8xYn::P64 + 56];
           _s8xXO::I64 = I64[_s8xYn::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8ysg; else goto c8ysf;
       c8ysg: // global
           _s8xWS::P64 = P64[_s8xYn::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ysf: // global
           _s8xWG::P64 = P64[_s8xYn::P64 + 16];
           _s8xWH::P64 = P64[_s8xYn::P64 + 24];
           _s8xWF::I64 = I64[_s8xYn::P64 + 40];
           _s8xWI::I64 = I64[_s8xYn::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYs_entry() //  [R1]
         { info_tbl: [(c8ysC,
                       label: sat_s8xYs_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ysC: // global
           _s8xYs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ysD; else goto c8ysE;
       c8ysE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ysG; else goto c8ysF;
       c8ysG: // global
           HpAlloc = 56;
           goto c8ysD;
       c8ysD: // global
           R1 = _s8xYs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ysF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYs::P64;
           _s8xWK::I64 = I64[_s8xYs::P64 + 56];
           _s8xXO::I64 = I64[_s8xYs::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8ysB; else goto c8ysA;
       c8ysB: // global
           _s8xWS::P64 = P64[_s8xYs::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ysA: // global
           _s8xWG::P64 = P64[_s8xYs::P64 + 16];
           _s8xWH::P64 = P64[_s8xYs::P64 + 24];
           _s8xWF::I64 = I64[_s8xYs::P64 + 40];
           _s8xWI::I64 = I64[_s8xYs::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYx_entry() //  [R1]
         { info_tbl: [(c8ysX,
                       label: sat_s8xYx_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ysX: // global
           _s8xYx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ysY; else goto c8ysZ;
       c8ysZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yt1; else goto c8yt0;
       c8yt1: // global
           HpAlloc = 56;
           goto c8ysY;
       c8ysY: // global
           R1 = _s8xYx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYx::P64;
           _s8xWK::I64 = I64[_s8xYx::P64 + 56];
           _s8xXO::I64 = I64[_s8xYx::P64 + 64];
           if (_s8xXO::I64 == _s8xWK::I64) goto c8ysW; else goto c8ysV;
       c8ysW: // global
           _s8xWS::P64 = P64[_s8xYx::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ysV: // global
           _s8xWG::P64 = P64[_s8xYx::P64 + 16];
           _s8xWH::P64 = P64[_s8xYx::P64 + 24];
           _s8xWF::I64 = I64[_s8xYx::P64 + 40];
           _s8xWI::I64 = I64[_s8xYx::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xXO::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xYQ_entry() //  [R1]
         { info_tbl: [(c8ytj,
                       label: sat_s8xYQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ytj: // global
           _s8xYQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ytk; else goto c8ytl;
       c8ytl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ytn; else goto c8ytm;
       c8ytn: // global
           HpAlloc = 56;
           goto c8ytk;
       c8ytk: // global
           R1 = _s8xYQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ytm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xYQ::P64;
           _s8xWK::I64 = I64[_s8xYQ::P64 + 56];
           _s8xYM::I64 = I64[_s8xYQ::P64 + 64];
           if (_s8xYM::I64 == _s8xWK::I64) goto c8yti; else goto c8yth;
       c8yti: // global
           _s8xWS::P64 = P64[_s8xYQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yth: // global
           _s8xWG::P64 = P64[_s8xYQ::P64 + 16];
           _s8xWH::P64 = P64[_s8xYQ::P64 + 24];
           _s8xWF::I64 = I64[_s8xYQ::P64 + 40];
           _s8xWI::I64 = I64[_s8xYQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYM::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZ6_entry() //  [R1]
         { info_tbl: [(c8ytR,
                       label: sat_s8xZ6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ytR: // global
           _s8xZ6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ytS; else goto c8ytT;
       c8ytT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ytV; else goto c8ytU;
       c8ytV: // global
           HpAlloc = 56;
           goto c8ytS;
       c8ytS: // global
           R1 = _s8xZ6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ytU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZ6::P64;
           _s8xWK::I64 = I64[_s8xZ6::P64 + 56];
           _s8xYU::I64 = I64[_s8xZ6::P64 + 64];
           if (_s8xYU::I64 == _s8xWK::I64) goto c8ytQ; else goto c8ytP;
       c8ytQ: // global
           _s8xWS::P64 = P64[_s8xZ6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ytP: // global
           _s8xWG::P64 = P64[_s8xZ6::P64 + 16];
           _s8xWH::P64 = P64[_s8xZ6::P64 + 24];
           _s8xWF::I64 = I64[_s8xZ6::P64 + 40];
           _s8xWI::I64 = I64[_s8xZ6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZe_entry() //  [R1]
         { info_tbl: [(c8yuq,
                       label: sat_s8xZe_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yuq: // global
           _s8xZe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yur; else goto c8yus;
       c8yus: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yuu; else goto c8yut;
       c8yuu: // global
           HpAlloc = 56;
           goto c8yur;
       c8yur: // global
           R1 = _s8xZe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZe::P64;
           _s8xWK::I64 = I64[_s8xZe::P64 + 56];
           _s8xYU::I64 = I64[_s8xZe::P64 + 64];
           if (_s8xYU::I64 == _s8xWK::I64) goto c8yup; else goto c8yuo;
       c8yup: // global
           _s8xWS::P64 = P64[_s8xZe::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yuo: // global
           _s8xWG::P64 = P64[_s8xZe::P64 + 16];
           _s8xWH::P64 = P64[_s8xZe::P64 + 24];
           _s8xWF::I64 = I64[_s8xZe::P64 + 40];
           _s8xWI::I64 = I64[_s8xZe::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZj_entry() //  [R1]
         { info_tbl: [(c8yuL,
                       label: sat_s8xZj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yuL: // global
           _s8xZj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yuM; else goto c8yuN;
       c8yuN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yuP; else goto c8yuO;
       c8yuP: // global
           HpAlloc = 56;
           goto c8yuM;
       c8yuM: // global
           R1 = _s8xZj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZj::P64;
           _s8xWK::I64 = I64[_s8xZj::P64 + 56];
           _s8xYU::I64 = I64[_s8xZj::P64 + 64];
           if (_s8xYU::I64 == _s8xWK::I64) goto c8yuK; else goto c8yuJ;
       c8yuK: // global
           _s8xWS::P64 = P64[_s8xZj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yuJ: // global
           _s8xWG::P64 = P64[_s8xZj::P64 + 16];
           _s8xWH::P64 = P64[_s8xZj::P64 + 24];
           _s8xWF::I64 = I64[_s8xZj::P64 + 40];
           _s8xWI::I64 = I64[_s8xZj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZo_entry() //  [R1]
         { info_tbl: [(c8yv6,
                       label: sat_s8xZo_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yv6: // global
           _s8xZo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yv7; else goto c8yv8;
       c8yv8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yva; else goto c8yv9;
       c8yva: // global
           HpAlloc = 56;
           goto c8yv7;
       c8yv7: // global
           R1 = _s8xZo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZo::P64;
           _s8xWK::I64 = I64[_s8xZo::P64 + 56];
           _s8xYU::I64 = I64[_s8xZo::P64 + 64];
           if (_s8xYU::I64 == _s8xWK::I64) goto c8yv5; else goto c8yv4;
       c8yv5: // global
           _s8xWS::P64 = P64[_s8xZo::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yv4: // global
           _s8xWG::P64 = P64[_s8xZo::P64 + 16];
           _s8xWH::P64 = P64[_s8xZo::P64 + 24];
           _s8xWF::I64 = I64[_s8xZo::P64 + 40];
           _s8xWI::I64 = I64[_s8xZo::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZt_entry() //  [R1]
         { info_tbl: [(c8yvr,
                       label: sat_s8xZt_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yvr: // global
           _s8xZt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yvs; else goto c8yvt;
       c8yvt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yvv; else goto c8yvu;
       c8yvv: // global
           HpAlloc = 56;
           goto c8yvs;
       c8yvs: // global
           R1 = _s8xZt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yvu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZt::P64;
           _s8xWK::I64 = I64[_s8xZt::P64 + 56];
           _s8xYU::I64 = I64[_s8xZt::P64 + 64];
           if (_s8xYU::I64 == _s8xWK::I64) goto c8yvq; else goto c8yvp;
       c8yvq: // global
           _s8xWS::P64 = P64[_s8xZt::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yvp: // global
           _s8xWG::P64 = P64[_s8xZt::P64 + 16];
           _s8xWH::P64 = P64[_s8xZt::P64 + 24];
           _s8xWF::I64 = I64[_s8xZt::P64 + 40];
           _s8xWI::I64 = I64[_s8xZt::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xYU::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZL_entry() //  [R1]
         { info_tbl: [(c8yvN,
                       label: sat_s8xZL_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yvN: // global
           _s8xZL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yvO; else goto c8yvP;
       c8yvP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yvR; else goto c8yvQ;
       c8yvR: // global
           HpAlloc = 56;
           goto c8yvO;
       c8yvO: // global
           R1 = _s8xZL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yvQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZL::P64;
           _s8xWK::I64 = I64[_s8xZL::P64 + 56];
           _s8xZH::I64 = I64[_s8xZL::P64 + 64];
           if (_s8xZH::I64 == _s8xWK::I64) goto c8yvM; else goto c8yvL;
       c8yvM: // global
           _s8xWS::P64 = P64[_s8xZL::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yvL: // global
           _s8xWG::P64 = P64[_s8xZL::P64 + 16];
           _s8xWH::P64 = P64[_s8xZL::P64 + 24];
           _s8xWF::I64 = I64[_s8xZL::P64 + 40];
           _s8xWI::I64 = I64[_s8xZL::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xZH::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8xZT_entry() //  [R1]
         { info_tbl: [(c8yw9,
                       label: sat_s8xZT_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yw9: // global
           _s8xZT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ywa; else goto c8ywb;
       c8ywb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ywd; else goto c8ywc;
       c8ywd: // global
           HpAlloc = 56;
           goto c8ywa;
       c8ywa: // global
           R1 = _s8xZT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ywc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8xZT::P64;
           _s8xWK::I64 = I64[_s8xZT::P64 + 56];
           _s8xZP::I64 = I64[_s8xZT::P64 + 64];
           if (_s8xZP::I64 == _s8xWK::I64) goto c8yw8; else goto c8yw7;
       c8yw8: // global
           _s8xWS::P64 = P64[_s8xZT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yw7: // global
           _s8xWG::P64 = P64[_s8xZT::P64 + 16];
           _s8xWH::P64 = P64[_s8xZT::P64 + 24];
           _s8xWF::I64 = I64[_s8xZT::P64 + 40];
           _s8xWI::I64 = I64[_s8xZT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xZP::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y01_entry() //  [R1]
         { info_tbl: [(c8ywv,
                       label: sat_s8y01_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ywv: // global
           _s8y01::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yww; else goto c8ywx;
       c8ywx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ywz; else goto c8ywy;
       c8ywz: // global
           HpAlloc = 56;
           goto c8yww;
       c8yww: // global
           R1 = _s8y01::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ywy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y01::P64;
           _s8xWK::I64 = I64[_s8y01::P64 + 56];
           _s8xZX::I64 = I64[_s8y01::P64 + 64];
           if (_s8xZX::I64 == _s8xWK::I64) goto c8ywu; else goto c8ywt;
       c8ywu: // global
           _s8xWS::P64 = P64[_s8y01::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ywt: // global
           _s8xWG::P64 = P64[_s8y01::P64 + 16];
           _s8xWH::P64 = P64[_s8y01::P64 + 24];
           _s8xWF::I64 = I64[_s8y01::P64 + 40];
           _s8xWI::I64 = I64[_s8y01::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8xZX::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y09_entry() //  [R1]
         { info_tbl: [(c8ywR,
                       label: sat_s8y09_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ywR: // global
           _s8y09::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ywS; else goto c8ywT;
       c8ywT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ywV; else goto c8ywU;
       c8ywV: // global
           HpAlloc = 56;
           goto c8ywS;
       c8ywS: // global
           R1 = _s8y09::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ywU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y09::P64;
           _s8xWK::I64 = I64[_s8y09::P64 + 56];
           _s8y05::I64 = I64[_s8y09::P64 + 64];
           if (_s8y05::I64 == _s8xWK::I64) goto c8ywQ; else goto c8ywP;
       c8ywQ: // global
           _s8xWS::P64 = P64[_s8y09::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8ywP: // global
           _s8xWG::P64 = P64[_s8y09::P64 + 16];
           _s8xWH::P64 = P64[_s8y09::P64 + 24];
           _s8xWF::I64 = I64[_s8y09::P64 + 40];
           _s8xWI::I64 = I64[_s8y09::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y05::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y0h_entry() //  [R1]
         { info_tbl: [(c8yxd,
                       label: sat_s8y0h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yxd: // global
           _s8y0h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yxe; else goto c8yxf;
       c8yxf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yxh; else goto c8yxg;
       c8yxh: // global
           HpAlloc = 56;
           goto c8yxe;
       c8yxe: // global
           R1 = _s8y0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y0h::P64;
           _s8xWK::I64 = I64[_s8y0h::P64 + 56];
           _s8y0d::I64 = I64[_s8y0h::P64 + 64];
           if (_s8y0d::I64 == _s8xWK::I64) goto c8yxc; else goto c8yxb;
       c8yxc: // global
           _s8xWS::P64 = P64[_s8y0h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yxb: // global
           _s8xWG::P64 = P64[_s8y0h::P64 + 16];
           _s8xWH::P64 = P64[_s8y0h::P64 + 24];
           _s8xWF::I64 = I64[_s8y0h::P64 + 40];
           _s8xWI::I64 = I64[_s8y0h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0d::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1h_entry() //  [R1]
         { info_tbl: [(c8yyK,
                       label: sat_s8y1h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yyK: // global
           _s8y1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yyL; else goto c8yyM;
       c8yyM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yyO; else goto c8yyN;
       c8yyO: // global
           HpAlloc = 56;
           goto c8yyL;
       c8yyL: // global
           R1 = _s8y1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yyN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1h::P64;
           _s8xWK::I64 = I64[_s8y1h::P64 + 56];
           _s8y0l::I64 = I64[_s8y1h::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yyJ; else goto c8yyI;
       c8yyJ: // global
           _s8xWS::P64 = P64[_s8y1h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yyI: // global
           _s8xWG::P64 = P64[_s8y1h::P64 + 16];
           _s8xWH::P64 = P64[_s8y1h::P64 + 24];
           _s8xWF::I64 = I64[_s8y1h::P64 + 40];
           _s8xWI::I64 = I64[_s8y1h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1m_entry() //  [R1]
         { info_tbl: [(c8yz5,
                       label: sat_s8y1m_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yz5: // global
           _s8y1m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yz6; else goto c8yz7;
       c8yz7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yz9; else goto c8yz8;
       c8yz9: // global
           HpAlloc = 56;
           goto c8yz6;
       c8yz6: // global
           R1 = _s8y1m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1m::P64;
           _s8xWK::I64 = I64[_s8y1m::P64 + 56];
           _s8y0l::I64 = I64[_s8y1m::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yz4; else goto c8yz3;
       c8yz4: // global
           _s8xWS::P64 = P64[_s8y1m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yz3: // global
           _s8xWG::P64 = P64[_s8y1m::P64 + 16];
           _s8xWH::P64 = P64[_s8y1m::P64 + 24];
           _s8xWF::I64 = I64[_s8y1m::P64 + 40];
           _s8xWI::I64 = I64[_s8y1m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1r_entry() //  [R1]
         { info_tbl: [(c8yzq,
                       label: sat_s8y1r_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yzq: // global
           _s8y1r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yzr; else goto c8yzs;
       c8yzs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yzu; else goto c8yzt;
       c8yzu: // global
           HpAlloc = 56;
           goto c8yzr;
       c8yzr: // global
           R1 = _s8y1r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yzt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1r::P64;
           _s8xWK::I64 = I64[_s8y1r::P64 + 56];
           _s8y0l::I64 = I64[_s8y1r::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yzp; else goto c8yzo;
       c8yzp: // global
           _s8xWS::P64 = P64[_s8y1r::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yzo: // global
           _s8xWG::P64 = P64[_s8y1r::P64 + 16];
           _s8xWH::P64 = P64[_s8y1r::P64 + 24];
           _s8xWF::I64 = I64[_s8y1r::P64 + 40];
           _s8xWI::I64 = I64[_s8y1r::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1w_entry() //  [R1]
         { info_tbl: [(c8yzL,
                       label: sat_s8y1w_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yzL: // global
           _s8y1w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yzM; else goto c8yzN;
       c8yzN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yzP; else goto c8yzO;
       c8yzP: // global
           HpAlloc = 56;
           goto c8yzM;
       c8yzM: // global
           R1 = _s8y1w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yzO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1w::P64;
           _s8xWK::I64 = I64[_s8y1w::P64 + 56];
           _s8y0l::I64 = I64[_s8y1w::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yzK; else goto c8yzJ;
       c8yzK: // global
           _s8xWS::P64 = P64[_s8y1w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yzJ: // global
           _s8xWG::P64 = P64[_s8y1w::P64 + 16];
           _s8xWH::P64 = P64[_s8y1w::P64 + 24];
           _s8xWF::I64 = I64[_s8y1w::P64 + 40];
           _s8xWI::I64 = I64[_s8y1w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1B_entry() //  [R1]
         { info_tbl: [(c8yA6,
                       label: sat_s8y1B_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yA6: // global
           _s8y1B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yA7; else goto c8yA8;
       c8yA8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yAa; else goto c8yA9;
       c8yAa: // global
           HpAlloc = 56;
           goto c8yA7;
       c8yA7: // global
           R1 = _s8y1B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yA9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1B::P64;
           _s8xWK::I64 = I64[_s8y1B::P64 + 56];
           _s8y0l::I64 = I64[_s8y1B::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yA5; else goto c8yA4;
       c8yA5: // global
           _s8xWS::P64 = P64[_s8y1B::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yA4: // global
           _s8xWG::P64 = P64[_s8y1B::P64 + 16];
           _s8xWH::P64 = P64[_s8y1B::P64 + 24];
           _s8xWF::I64 = I64[_s8y1B::P64 + 40];
           _s8xWI::I64 = I64[_s8y1B::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1G_entry() //  [R1]
         { info_tbl: [(c8yAr,
                       label: sat_s8y1G_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yAr: // global
           _s8y1G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yAs; else goto c8yAt;
       c8yAt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yAv; else goto c8yAu;
       c8yAv: // global
           HpAlloc = 56;
           goto c8yAs;
       c8yAs: // global
           R1 = _s8y1G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yAu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1G::P64;
           _s8xWK::I64 = I64[_s8y1G::P64 + 56];
           _s8y0l::I64 = I64[_s8y1G::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yAq; else goto c8yAp;
       c8yAq: // global
           _s8xWS::P64 = P64[_s8y1G::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yAp: // global
           _s8xWG::P64 = P64[_s8y1G::P64 + 16];
           _s8xWH::P64 = P64[_s8y1G::P64 + 24];
           _s8xWF::I64 = I64[_s8y1G::P64 + 40];
           _s8xWI::I64 = I64[_s8y1G::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y1L_entry() //  [R1]
         { info_tbl: [(c8yAM,
                       label: sat_s8y1L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yAM: // global
           _s8y1L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yAN; else goto c8yAO;
       c8yAO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yAQ; else goto c8yAP;
       c8yAQ: // global
           HpAlloc = 56;
           goto c8yAN;
       c8yAN: // global
           R1 = _s8y1L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yAP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y1L::P64;
           _s8xWK::I64 = I64[_s8y1L::P64 + 56];
           _s8y0l::I64 = I64[_s8y1L::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yAL; else goto c8yAK;
       c8yAL: // global
           _s8xWS::P64 = P64[_s8y1L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yAK: // global
           _s8xWG::P64 = P64[_s8y1L::P64 + 16];
           _s8xWH::P64 = P64[_s8y1L::P64 + 24];
           _s8xWF::I64 = I64[_s8y1L::P64 + 40];
           _s8xWI::I64 = I64[_s8y1L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y2D_entry() //  [R1]
         { info_tbl: [(c8yBP,
                       label: sat_s8y2D_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yBP: // global
           _s8y2D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yBQ; else goto c8yBR;
       c8yBR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yBT; else goto c8yBS;
       c8yBT: // global
           HpAlloc = 56;
           goto c8yBQ;
       c8yBQ: // global
           R1 = _s8y2D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yBS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y2D::P64;
           _s8xWK::I64 = I64[_s8y2D::P64 + 56];
           _s8y0l::I64 = I64[_s8y2D::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yBO; else goto c8yBN;
       c8yBO: // global
           _s8xWS::P64 = P64[_s8y2D::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yBN: // global
           _s8xWG::P64 = P64[_s8y2D::P64 + 16];
           _s8xWH::P64 = P64[_s8y2D::P64 + 24];
           _s8xWF::I64 = I64[_s8y2D::P64 + 40];
           _s8xWI::I64 = I64[_s8y2D::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y2I_entry() //  [R1]
         { info_tbl: [(c8yCa,
                       label: sat_s8y2I_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yCa: // global
           _s8y2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yCb; else goto c8yCc;
       c8yCc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yCe; else goto c8yCd;
       c8yCe: // global
           HpAlloc = 56;
           goto c8yCb;
       c8yCb: // global
           R1 = _s8y2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yCd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y2I::P64;
           _s8xWK::I64 = I64[_s8y2I::P64 + 56];
           _s8y0l::I64 = I64[_s8y2I::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yC9; else goto c8yC8;
       c8yC9: // global
           _s8xWS::P64 = P64[_s8y2I::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yC8: // global
           _s8xWG::P64 = P64[_s8y2I::P64 + 16];
           _s8xWH::P64 = P64[_s8y2I::P64 + 24];
           _s8xWF::I64 = I64[_s8y2I::P64 + 40];
           _s8xWI::I64 = I64[_s8y2I::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y2N_entry() //  [R1]
         { info_tbl: [(c8yCv,
                       label: sat_s8y2N_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yCv: // global
           _s8y2N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yCw; else goto c8yCx;
       c8yCx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yCz; else goto c8yCy;
       c8yCz: // global
           HpAlloc = 56;
           goto c8yCw;
       c8yCw: // global
           R1 = _s8y2N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yCy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y2N::P64;
           _s8xWK::I64 = I64[_s8y2N::P64 + 56];
           _s8y0l::I64 = I64[_s8y2N::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yCu; else goto c8yCt;
       c8yCu: // global
           _s8xWS::P64 = P64[_s8y2N::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yCt: // global
           _s8xWG::P64 = P64[_s8y2N::P64 + 16];
           _s8xWH::P64 = P64[_s8y2N::P64 + 24];
           _s8xWF::I64 = I64[_s8y2N::P64 + 40];
           _s8xWI::I64 = I64[_s8y2N::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y2S_entry() //  [R1]
         { info_tbl: [(c8yCQ,
                       label: sat_s8y2S_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yCQ: // global
           _s8y2S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yCR; else goto c8yCS;
       c8yCS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yCU; else goto c8yCT;
       c8yCU: // global
           HpAlloc = 56;
           goto c8yCR;
       c8yCR: // global
           R1 = _s8y2S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yCT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y2S::P64;
           _s8xWK::I64 = I64[_s8y2S::P64 + 56];
           _s8y0l::I64 = I64[_s8y2S::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yCP; else goto c8yCO;
       c8yCP: // global
           _s8xWS::P64 = P64[_s8y2S::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yCO: // global
           _s8xWG::P64 = P64[_s8y2S::P64 + 16];
           _s8xWH::P64 = P64[_s8y2S::P64 + 24];
           _s8xWF::I64 = I64[_s8y2S::P64 + 40];
           _s8xWI::I64 = I64[_s8y2S::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y2X_entry() //  [R1]
         { info_tbl: [(c8yDb,
                       label: sat_s8y2X_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yDb: // global
           _s8y2X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yDc; else goto c8yDd;
       c8yDd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yDf; else goto c8yDe;
       c8yDf: // global
           HpAlloc = 56;
           goto c8yDc;
       c8yDc: // global
           R1 = _s8y2X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yDe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y2X::P64;
           _s8xWK::I64 = I64[_s8y2X::P64 + 56];
           _s8y0l::I64 = I64[_s8y2X::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yDa; else goto c8yD9;
       c8yDa: // global
           _s8xWS::P64 = P64[_s8y2X::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yD9: // global
           _s8xWG::P64 = P64[_s8y2X::P64 + 16];
           _s8xWH::P64 = P64[_s8y2X::P64 + 24];
           _s8xWF::I64 = I64[_s8y2X::P64 + 40];
           _s8xWI::I64 = I64[_s8y2X::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8y3G_entry() //  [R1]
         { info_tbl: [(c8yDA,
                       label: sat_s8y3G_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yDA: // global
           _s8y3G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8yDB; else goto c8yDC;
       c8yDC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yDE; else goto c8yDD;
       c8yDE: // global
           HpAlloc = 56;
           goto c8yDB;
       c8yDB: // global
           R1 = _s8y3G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8yDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8y3G::P64;
           _s8xWK::I64 = I64[_s8y3G::P64 + 56];
           _s8y0l::I64 = I64[_s8y3G::P64 + 64];
           if (_s8y0l::I64 == _s8xWK::I64) goto c8yDz; else goto c8yDy;
       c8yDz: // global
           _s8xWS::P64 = P64[_s8y3G::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8xWS::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8yDy: // global
           _s8xWG::P64 = P64[_s8y3G::P64 + 16];
           _s8xWH::P64 = P64[_s8y3G::P64 + 24];
           _s8xWF::I64 = I64[_s8y3G::P64 + 40];
           _s8xWI::I64 = I64[_s8y3G::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8xWG::P64;
           P64[Hp - 32] = _s8xWH::P64;
           I64[Hp - 24] = _s8xWF::I64;
           I64[Hp - 16] = _s8xWI::I64;
           I64[Hp - 8] = _s8y0l::I64;
           I64[Hp] = _s8xWK::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF4_entry() //  [R2, R3]
         { info_tbl: [(c8yDH,
                       label: GHC.IO.Encoding.UTF8.mkUTF4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yDH: // global
           if ((Sp + -144) < SpLim) (likely: False) goto c8yDI; else goto c8yDJ;
       c8yDI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8yDJ: // global
           I64[Sp - 16] = block_c8yo0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ySp; else goto c8yo1;
       u8ySp: // global
           call _c8yo0(R1) args: 0, res: 0, upd: 0;
       c8yo1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yo0() //  [R1]
         { info_tbl: [(c8yo0,
                       label: block_c8yo0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yo0: // global
           I64[Sp - 40] = block_c8yo5_info;
           _s8xWG::P64 = P64[R1 + 7];
           _s8xWH::P64 = P64[R1 + 15];
           _s8xWF::I64 = I64[R1 + 23];
           _s8xWI::I64 = I64[R1 + 31];
           _s8xWJ::I64 = I64[R1 + 39];
           _s8xWK::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8xWH::P64;
           I64[Sp - 24] = _s8xWI::I64;
           I64[Sp - 16] = _s8xWJ::I64;
           I64[Sp - 8] = _s8xWK::I64;
           P64[Sp] = _s8xWG::P64;
           I64[Sp + 8] = _s8xWF::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8yRw; else goto c8yo6;
       u8yRw: // global
           call _c8yo5(R1) args: 0, res: 0, upd: 0;
       c8yo6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yo5() //  [R1]
         { info_tbl: [(c8yo5,
                       label: block_c8yo5_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yo5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8yDN; else goto c8yDM;
       c8yDN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8yDM: // global
           _s8xWN::P64 = P64[R1 + 7];
           _s8xWO::P64 = P64[R1 + 15];
           _s8xWM::I64 = I64[R1 + 23];
           _s8xWP::I64 = I64[R1 + 31];
           _s8xWQ::I64 = I64[R1 + 39];
           _s8xWR::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8xWN::P64;
           P64[Sp - 40] = _s8xWO::P64;
           I64[Sp - 32] = _s8xWP::I64;
           I64[Sp - 24] = _s8xWQ::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8xWR::I64;
           I64[Sp] = _s8xWM::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 56;
           call _c8yxm() args: 0, res: 0, upd: 0;
     }
 },
 _c8yxm() //  []
         { info_tbl: [(c8yxm,
                       label: block_c8yxm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yxm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yIs; else goto c8yIr;
       c8yIs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yxm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIr: // global
           _s8xWP::I64 = I64[Sp + 24];
           _s8y0l::I64 = I64[Sp + 40];
           _s8y0m::I64 = I64[Sp + 48];
           if (%MO_S_Lt_W64(_s8y0m::I64,
                            _s8xWP::I64)) goto c8yOt; else goto c8yOu;
       c8yOt: // global
           _s8xWK::I64 = I64[Sp + 88];
           if (%MO_S_Lt_W64(_s8y0l::I64,
                            _s8xWK::I64)) goto c8yOq; else goto c8yOr;
       c8yOq: // global
           _c8yoa::P64 = P64[Sp + 80];
           _s8xWF::I64 = I64[Sp + 104];
           _s8xWG::P64 = P64[Sp + 96];
           _s8xWH::P64 = P64[Sp + 64];
           _s8xWI::I64 = I64[Sp + 72];
           _s8xWM::I64 = I64[Sp + 56];
           _s8xWN::P64 = P64[Sp + 8];
           _s8xWO::P64 = P64[Sp + 16];
           _s8xWQ::I64 = I64[Sp + 32];
           _s8y0t::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + _s8y0l::I64]);
           call MO_Touch(_s8xWG::P64);
           if (_s8y0t::I64 > 127) goto c8yOn; else goto c8yOo;
       c8yOn: // global
           if (_s8y0t::I64 < 192) goto c8yOi; else goto c8yOl;
       c8yOl: // global
           if (_s8y0t::I64 > 193) goto c8yOi; else goto c8yOk;
       c8yOi: // global
           Hp = Hp - 160;
           if (_s8y0t::I64 < 194) goto s8y0x; else goto c8yOe;
       c8yOe: // global
           if (_s8y0t::I64 > 223) goto s8y0x; else goto c8yOd;
       s8y0x: // global
           if (_s8y0t::I64 < 224) goto s8y0y; else goto c8yNz;
       c8yNz: // global
           if (_s8y0t::I64 > 239) goto s8y0y; else goto c8yNy;
       s8y0y: // global
           if (_s8y0t::I64 < 240) goto c8yIx; else goto c8yL5;
       c8yIx: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yod() args: 0, res: 0, upd: 0;
       c8yL5: // global
           _s8y0A::I64 = _s8xWK::I64 - _s8y0l::I64;
           if (%MO_S_Lt_W64(_s8y0A::I64, 3)) goto u8yQy; else goto u8yQA;
       u8yQy: // global
           if (%MO_S_Lt_W64(_s8y0A::I64, 2)) goto u8yQz; else goto c8yKV;
       u8yQz: // global
           if (%MO_S_Lt_W64(_s8y0A::I64, 1)) goto c8yIz; else goto c8yKP;
       c8yKP: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yoz() args: 0, res: 0, upd: 0;
       c8yKV: // global
           _s8xXi::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           _s8xXc::I64 = _s8y0t::I64;
           _s8xXb::I64 = _s8y0m::I64;
           _s8xXa::I64 = _s8y0l::I64;
           if (_s8y0t::I64 != 240) goto s8xXp; else goto c8yEY;
       c8yEY: // global
           if (_s8xXi::I64 < 144) goto s8xXp; else goto c8yEX;
       c8yEX: // global
           if (_s8xXi::I64 > 191) goto s8xXp; else goto u8yQF;
       s8xXp: // global
           if (_s8xXc::I64 < 241) goto u8yQG; else goto c8yEG;
       u8yQG: // global
           I64[Sp - 8] = _s8xXi::I64;
           I64[Sp] = _s8xXc::I64;
           I64[Sp + 40] = _s8xXb::I64;
           I64[Sp + 48] = _s8xXa::I64;
           Sp = Sp - 16;
           goto u8yRI;
       c8yEG: // global
           if (_s8xXc::I64 > 243) goto u8yQH; else goto c8yEF;
       u8yQH: // global
           I64[Sp + 48] = _s8xXa::I64;
           I64[Sp + 40] = _s8xXb::I64;
           I64[Sp] = _s8xXc::I64;
           I64[Sp - 8] = _s8xXi::I64;
           Sp = Sp - 16;
           goto u8yRI;
       c8yEF: // global
           if (_s8xXi::I64 < 128) goto u8yQI; else goto c8yEE;
       u8yQI: // global
           I64[Sp + 48] = _s8xXa::I64;
           I64[Sp + 40] = _s8xXb::I64;
           I64[Sp] = _s8xXc::I64;
           I64[Sp - 8] = _s8xXi::I64;
           Sp = Sp - 16;
           goto u8yRI;
       c8yEE: // global
           if (_s8xXi::I64 > 191) goto u8yQK; else goto u8yQJ;
       u8yQK: // global
           I64[Sp + 48] = _s8xXa::I64;
           I64[Sp + 40] = _s8xXb::I64;
           I64[Sp] = _s8xXc::I64;
           I64[Sp - 8] = _s8xXi::I64;
           Sp = Sp - 16;
           goto u8yRI;
       u8yRI: // global
           call _c8ypz() args: 0, res: 0, upd: 0;
       u8yQJ: // global
           I64[Sp + 48] = _s8xXa::I64;
           I64[Sp + 40] = _s8xXb::I64;
           goto u8yRH;
       u8yQF: // global
           I64[Sp + 40] = _s8xXb::I64;
           I64[Sp + 48] = _s8xXa::I64;
           goto u8yRH;
       u8yRH: // global
           call _c8yp8() args: 0, res: 0, upd: 0;
       u8yQA: // global
           if (%MO_S_Ge_W64(_s8y0A::I64, 4)) goto c8yIz; else goto c8yL1;
       c8yIz: // global
           _s8y0F::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           _s8y0L::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 2)]);
           call MO_Touch(_s8xWG::P64);
           _s8y0R::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 3)]);
           call MO_Touch(_s8xWG::P64);
           if (_s8y0t::I64 != 240) goto s8y1d; else goto c8yKM;
       c8yKM: // global
           if (_s8y0F::I64 < 144) goto s8y1d; else goto c8yKL;
       c8yKL: // global
           if (_s8y0F::I64 > 191) goto s8y1d; else goto c8yKK;
       c8yKK: // global
           if (_s8y0L::I64 < 128) goto s8y1d; else goto c8yKJ;
       c8yKJ: // global
           if (_s8y0L::I64 > 191) goto s8y1d; else goto c8yKI;
       c8yKI: // global
           if (_s8y0R::I64 < 128) goto s8y1d; else goto c8yKH;
       c8yKH: // global
           if (_s8y0R::I64 > 191) goto s8y1d; else goto u8yQV;
       s8y1d: // global
           if (_s8y0t::I64 < 241) goto u8yQW; else goto c8yK2;
       u8yQW: // global
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           I64[Sp] = _s8y0t::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yK2: // global
           if (_s8y0t::I64 > 243) goto u8yQX; else goto c8yK1;
       u8yQX: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yK1: // global
           if (_s8y0F::I64 < 128) goto u8yQY; else goto c8yK0;
       u8yQY: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yK0: // global
           if (_s8y0F::I64 > 191) goto u8yQZ; else goto c8yJZ;
       u8yQZ: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yJZ: // global
           if (_s8y0L::I64 < 128) goto u8yR0; else goto c8yJY;
       u8yR0: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yJY: // global
           if (_s8y0L::I64 > 191) goto u8yR1; else goto c8yJX;
       u8yR1: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yJX: // global
           if (_s8y0R::I64 < 128) goto u8yR2; else goto c8yJW;
       u8yR2: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       c8yJW: // global
           if (_s8y0R::I64 > 191) goto u8yR4; else goto u8yR3;
       u8yR4: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 32;
           goto u8yS0;
       u8yS0: // global
           call _c8yyw() args: 0, res: 0, upd: 0;
       u8yR3: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           Sp = Sp - 24;
           goto u8yRZ;
       u8yQV: // global
           I64[Sp - 24] = _s8y0F::I64;
           I64[Sp - 16] = _s8y0L::I64;
           I64[Sp - 8] = _s8y0R::I64;
           I64[Sp] = _s8y0t::I64;
           Sp = Sp - 24;
           goto u8yRZ;
       u8yRZ: // global
           call _s8y0T() args: 0, res: 0, upd: 0;
       c8yL1: // global
           _s8xXW::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           _s8xY2::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 2)]);
           call MO_Touch(_s8xWG::P64);
           _s8xXQ::I64 = _s8y0t::I64;
           _s8xXP::I64 = _s8y0m::I64;
           _s8xXO::I64 = _s8y0l::I64;
           if (_s8y0t::I64 != 240) goto s8xY9; else goto c8yGB;
       c8yGB: // global
           if (_s8xXW::I64 < 144) goto s8xY9; else goto c8yGA;
       c8yGA: // global
           if (_s8xXW::I64 > 191) goto s8xY9; else goto c8yGz;
       c8yGz: // global
           if (_s8xY2::I64 < 128) goto s8xY9; else goto c8yGy;
       c8yGy: // global
           if (_s8xY2::I64 > 191) goto s8xY9; else goto u8yQM;
       s8xY9: // global
           if (_s8xXQ::I64 < 241) goto u8yQN; else goto c8yG5;
       u8yQN: // global
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp + 48] = _s8xXO::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       c8yG5: // global
           if (_s8xXQ::I64 > 243) goto u8yQO; else goto c8yG4;
       u8yQO: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       c8yG4: // global
           if (_s8xXW::I64 < 128) goto u8yQP; else goto c8yG3;
       u8yQP: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       c8yG3: // global
           if (_s8xXW::I64 > 191) goto u8yQQ; else goto c8yG2;
       u8yQQ: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       c8yG2: // global
           if (_s8xY2::I64 < 128) goto u8yQR; else goto c8yG1;
       u8yQR: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       c8yG1: // global
           if (_s8xY2::I64 > 191) goto u8yQT; else goto u8yQS;
       u8yQT: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp] = _s8xXQ::I64;
           I64[Sp - 16] = _s8xXW::I64;
           I64[Sp - 8] = _s8xY2::I64;
           Sp = Sp - 24;
           goto u8yRQ;
       u8yRQ: // global
           call _c8yrn() args: 0, res: 0, upd: 0;
       u8yQS: // global
           I64[Sp + 48] = _s8xXO::I64;
           I64[Sp + 40] = _s8xXP::I64;
           goto u8yRP;
       u8yQM: // global
           I64[Sp + 40] = _s8xXP::I64;
           I64[Sp + 48] = _s8xXO::I64;
           goto u8yRP;
       u8yRP: // global
           call _c8yqW() args: 0, res: 0, upd: 0;
       c8yNy: // global
           _s8y25::I64 = _s8xWK::I64 - _s8y0l::I64;
           if (_s8y25::I64 != 1) goto u8yQB; else goto c8yNo;
       u8yQB: // global
           if (_s8y25::I64 != 2) goto c8yLb; else goto c8yNu;
       c8yLb: // global
           _s8y2a::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           _s8y2g::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 2)]);
           call MO_Touch(_s8xWG::P64);
           if (_s8y0t::I64 != 224) goto s8y2y; else goto c8yNl;
       c8yNl: // global
           if (_s8y2a::I64 < 160) goto s8y2y; else goto c8yNk;
       c8yNk: // global
           if (_s8y2a::I64 > 191) goto s8y2y; else goto c8yNj;
       c8yNj: // global
           if (_s8y2g::I64 < 128) goto s8y2y; else goto c8yNi;
       c8yNi: // global
           if (_s8y2g::I64 > 191) goto s8y2y; else goto u8yR7;
       s8y2y: // global
           if (_s8y0t::I64 < 225) goto s8y2z; else goto c8yMP;
       c8yMP: // global
           if (_s8y0t::I64 > 236) goto s8y2z; else goto c8yMO;
       c8yMO: // global
           if (_s8y2a::I64 < 128) goto s8y2z; else goto c8yMN;
       c8yMN: // global
           if (_s8y2a::I64 > 191) goto s8y2z; else goto c8yMM;
       c8yMM: // global
           if (_s8y2g::I64 < 128) goto s8y2z; else goto c8yML;
       c8yML: // global
           if (_s8y2g::I64 > 191) goto s8y2z; else goto u8yR8;
       s8y2z: // global
           if (_s8y0t::I64 == 237) goto c8yMb; else goto u8yR9;
       c8yMb: // global
           if (_s8y2a::I64 < 128) goto u8yRa; else goto c8yMa;
       u8yRa: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 24;
           goto u8yS8;
       c8yMa: // global
           if (_s8y2a::I64 > 159) goto u8yRb; else goto c8yM9;
       u8yRb: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 24;
           goto u8yS8;
       c8yM9: // global
           if (_s8y2g::I64 < 128) goto u8yRc; else goto c8yM8;
       u8yRc: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 24;
           goto u8yS8;
       c8yM8: // global
           if (_s8y2g::I64 > 191) goto u8yRe; else goto u8yRd;
       u8yRe: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 24;
           goto u8yS8;
       u8yRd: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 16;
           goto u8yS7;
       u8yR9: // global
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           I64[Sp] = _s8y0t::I64;
           Sp = Sp - 24;
           goto u8yS8;
       u8yS8: // global
           call _c8yBA() args: 0, res: 0, upd: 0;
       u8yR8: // global
           I64[Sp] = _s8y0t::I64;
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           Sp = Sp - 16;
           goto u8yS7;
       u8yR7: // global
           I64[Sp - 16] = _s8y2a::I64;
           I64[Sp - 8] = _s8y2g::I64;
           I64[Sp] = _s8y0t::I64;
           Sp = Sp - 16;
           goto u8yS7;
       u8yS7: // global
           call _s8y2i() args: 0, res: 0, upd: 0;
       c8yNu: // global
           _s8xZ2::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           _s8xYW::I64 = _s8y0t::I64;
           _s8xYV::I64 = _s8y0m::I64;
           _s8xYU::I64 = _s8y0l::I64;
           if (_s8y0t::I64 != 224) goto s8xZ9; else goto c8yI5;
       c8yI5: // global
           if (_s8xZ2::I64 < 160) goto s8xZ9; else goto c8yI4;
       c8yI4: // global
           if (_s8xZ2::I64 > 191) goto s8xZ9; else goto u8yRh;
       s8xZ9: // global
           if (_s8xYW::I64 < 225) goto s8xZa; else goto c8yHN;
       c8yHN: // global
           if (_s8xYW::I64 > 236) goto s8xZa; else goto c8yHM;
       c8yHM: // global
           if (_s8xZ2::I64 < 128) goto s8xZa; else goto c8yHL;
       c8yHL: // global
           if (_s8xZ2::I64 > 191) goto s8xZa; else goto u8yRi;
       s8xZa: // global
           if (_s8xYW::I64 == 237) goto c8yHn; else goto u8yRj;
       c8yHn: // global
           if (_s8xZ2::I64 < 128) goto u8yRk; else goto c8yHm;
       u8yRk: // global
           I64[Sp + 48] = _s8xYU::I64;
           I64[Sp + 40] = _s8xYV::I64;
           I64[Sp] = _s8xYW::I64;
           I64[Sp - 8] = _s8xZ2::I64;
           Sp = Sp - 16;
           goto u8ySe;
       c8yHm: // global
           if (_s8xZ2::I64 > 159) goto u8yRm; else goto u8yRl;
       u8yRm: // global
           I64[Sp + 48] = _s8xYU::I64;
           I64[Sp + 40] = _s8xYV::I64;
           I64[Sp] = _s8xYW::I64;
           I64[Sp - 8] = _s8xZ2::I64;
           Sp = Sp - 16;
           goto u8ySe;
       u8yRl: // global
           I64[Sp + 48] = _s8xYU::I64;
           I64[Sp + 40] = _s8xYV::I64;
           goto u8ySd;
       u8yRj: // global
           I64[Sp - 8] = _s8xZ2::I64;
           I64[Sp] = _s8xYW::I64;
           I64[Sp + 40] = _s8xYV::I64;
           I64[Sp + 48] = _s8xYU::I64;
           Sp = Sp - 16;
           goto u8ySe;
       u8ySe: // global
           call _c8yub() args: 0, res: 0, upd: 0;
       u8yRi: // global
           I64[Sp + 48] = _s8xYU::I64;
           I64[Sp + 40] = _s8xYV::I64;
           goto u8ySd;
       u8yRh: // global
           I64[Sp + 40] = _s8xYV::I64;
           I64[Sp + 48] = _s8xYU::I64;
           goto u8ySd;
       u8ySd: // global
           call _c8ytF() args: 0, res: 0, upd: 0;
       c8yNo: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yt6() args: 0, res: 0, upd: 0;
       c8yOd: // global
           if (%MO_S_Ge_W64(_s8xWK::I64 - _s8y0l::I64,
                            2)) goto c8yOb; else goto c8yOc;
       c8yOb: // global
           _s8y3o::I64 = %MO_UU_Conv_W8_W64(I8[_s8xWF::I64 + (_s8y0l::I64 + 1)]);
           call MO_Touch(_s8xWG::P64);
           if (_s8y3o::I64 >= 128) goto c8yO8; else goto c8yO9;
       c8yO8: // global
           if (_s8y3o::I64 < 192) goto c8yO5; else goto c8yO6;
       c8yO5: // global
           I32[_s8xWM::I64 + (_s8y0m::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8y0t::I64 + -192) << 6) + (_s8y3o::I64 + -128));
           call MO_Touch(_s8xWN::P64);
           I64[Sp + 40] = _s8y0l::I64 + 2;
           I64[Sp + 48] = _s8y0m::I64 + 1;
           goto u8ySk;
       c8yO6: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yvA() args: 0, res: 0, upd: 0;
       c8yO9: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yvW() args: 0, res: 0, upd: 0;
       c8yOc: // global
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8ywi() args: 0, res: 0, upd: 0;
       c8yOk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y3G_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yOo: // global
           I32[_s8xWM::I64 + (_s8y0m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8y0t::I64);
           call MO_Touch(_s8xWN::P64);
           Hp = Hp - 160;
           I64[Sp + 40] = _s8y0l::I64 + 1;
           I64[Sp + 48] = _s8y0m::I64 + 1;
           goto u8ySk;
       u8ySk: // global
           call _c8yxm() args: 0, res: 0, upd: 0;
       c8yOr: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8ywE() args: 0, res: 0, upd: 0;
       c8yOu: // global
           Hp = Hp - 160;
           I64[Sp + 40] = _s8y0m::I64;
           I64[Sp + 48] = _s8y0l::I64;
           call _c8yx0() args: 0, res: 0, upd: 0;
     }
 },
 _c8yod() //  []
         { info_tbl: [(c8yod,
                       label: block_c8yod_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yod: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yDR; else goto c8yDQ;
       c8yDR: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yod_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yDQ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xWY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yoz() //  []
         { info_tbl: [(c8yoz,
                       label: block_c8yoz_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yoz: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yDV; else goto c8yDU;
       c8yDV: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yoz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yDU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xX6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ypz() //  []
         { info_tbl: [(c8ypz,
                       label: block_c8ypz_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ypz: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yE4; else goto c8yE3;
       c8yE4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8ypz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yE3: // global
           _c8yoa::P64 = P64[Sp + 96];
           _s8xWF::I64 = I64[Sp + 120];
           _s8xWG::P64 = P64[Sp + 112];
           _s8xWH::P64 = P64[Sp + 80];
           _s8xWI::I64 = I64[Sp + 88];
           _s8xWK::I64 = I64[Sp + 104];
           _s8xWM::I64 = I64[Sp + 72];
           _s8xWN::P64 = P64[Sp + 24];
           _s8xWO::P64 = P64[Sp + 32];
           _s8xWP::I64 = I64[Sp + 40];
           _s8xWQ::I64 = I64[Sp + 48];
           _s8xXa::I64 = I64[Sp + 64];
           _s8xXb::I64 = I64[Sp + 56];
           if (I64[Sp + 16] == 244) goto c8yEg; else goto c8yE7;
       c8yEg: // global
           _s8xXi::I64 = I64[Sp + 8];
           if (_s8xXi::I64 < 128) goto c8yEa; else goto c8yEf;
       c8yEa: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXb::I64;
           I64[Hp - 96] = sat_s8xXy_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yEf: // global
           if (_s8xXi::I64 > 143) goto c8yEd; else goto c8yEe;
       c8yEd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXb::I64;
           I64[Hp - 96] = sat_s8xXD_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yEe: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8yp8() args: 0, res: 0, upd: 0;
       c8yE7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXb::I64;
           I64[Hp - 96] = sat_s8xXt_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yp8() //  []
         { info_tbl: [(c8yp8,
                       label: block_c8yp8_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yp8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yE0; else goto c8yDZ;
       c8yE0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yp8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yDZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xXm_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yrn() //  []
         { info_tbl: [(c8yrn,
                       label: block_c8yrn_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yrn: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yF7; else goto c8yF6;
       c8yF7: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yrn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yF6: // global
           _c8yoa::P64 = P64[Sp + 104];
           _s8xWF::I64 = I64[Sp + 128];
           _s8xWG::P64 = P64[Sp + 120];
           _s8xWH::P64 = P64[Sp + 88];
           _s8xWI::I64 = I64[Sp + 96];
           _s8xWK::I64 = I64[Sp + 112];
           _s8xWM::I64 = I64[Sp + 80];
           _s8xWN::P64 = P64[Sp + 32];
           _s8xWO::P64 = P64[Sp + 40];
           _s8xWP::I64 = I64[Sp + 48];
           _s8xWQ::I64 = I64[Sp + 56];
           _s8xXO::I64 = I64[Sp + 72];
           _s8xXP::I64 = I64[Sp + 64];
           if (I64[Sp + 24] == 244) goto c8yFr; else goto c8yFa;
       c8yFr: // global
           _s8xXW::I64 = I64[Sp + 8];
           if (_s8xXW::I64 < 128) goto c8yFd; else goto c8yFq;
       c8yFd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXP::I64;
           I64[Hp - 96] = sat_s8xYi_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXO::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yFq: // global
           if (_s8xXW::I64 > 143) goto c8yFg; else goto c8yFp;
       c8yFg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXP::I64;
           I64[Hp - 96] = sat_s8xYn_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXO::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yFp: // global
           _s8xY2::I64 = I64[Sp + 16];
           if (_s8xY2::I64 < 128) goto c8yFj; else goto c8yFo;
       c8yFj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXP::I64;
           I64[Hp - 96] = sat_s8xYs_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXO::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yFo: // global
           if (_s8xY2::I64 > 191) goto c8yFm; else goto c8yFn;
       c8yFm: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXP::I64;
           I64[Hp - 96] = sat_s8xYx_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXO::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yFn: // global
           Hp = Hp - 160;
           Sp = Sp + 24;
           call _c8yqW() args: 0, res: 0, upd: 0;
       c8yFa: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xXP::I64;
           I64[Hp - 96] = sat_s8xYd_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xXO::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yqW() //  []
         { info_tbl: [(c8yqW,
                       label: block_c8yqW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yqW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yF3; else goto c8yF2;
       c8yF3: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yqW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yF2: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xY6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yyw() //  []
         { info_tbl: [(c8yyw,
                       label: block_c8yyw_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yyw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yII; else goto c8yIH;
       c8yII: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yyw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIH: // global
           _c8yoa::P64 = P64[Sp + 112];
           _s8xWF::I64 = I64[Sp + 136];
           _s8xWG::P64 = P64[Sp + 128];
           _s8xWH::P64 = P64[Sp + 96];
           _s8xWI::I64 = I64[Sp + 104];
           _s8xWK::I64 = I64[Sp + 120];
           _s8xWM::I64 = I64[Sp + 88];
           _s8xWN::P64 = P64[Sp + 40];
           _s8xWO::P64 = P64[Sp + 48];
           _s8xWP::I64 = I64[Sp + 56];
           _s8xWQ::I64 = I64[Sp + 64];
           _s8y0l::I64 = I64[Sp + 72];
           _s8y0m::I64 = I64[Sp + 80];
           if (I64[Sp + 32] == 244) goto c8yJa; else goto c8yIL;
       c8yJa: // global
           _s8y0F::I64 = I64[Sp + 8];
           if (_s8y0F::I64 < 128) goto c8yIO; else goto c8yJ9;
       c8yIO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1m_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ9: // global
           if (_s8y0F::I64 > 143) goto c8yIR; else goto c8yJ8;
       c8yIR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1r_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ8: // global
           _s8y0L::I64 = I64[Sp + 16];
           if (_s8y0L::I64 < 128) goto c8yIU; else goto c8yJ7;
       c8yIU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1w_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ7: // global
           if (_s8y0L::I64 > 191) goto c8yIX; else goto c8yJ6;
       c8yIX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1B_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ6: // global
           _s8y0R::I64 = I64[Sp + 24];
           if (_s8y0R::I64 < 128) goto c8yJ0; else goto c8yJ5;
       c8yJ0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1G_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ5: // global
           if (_s8y0R::I64 > 191) goto c8yJ3; else goto c8yJ4;
       c8yJ3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1L_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yJ4: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8y0T() args: 0, res: 0, upd: 0;
       c8yIL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y1h_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s8y0T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8y0T: // global
           _s8xWN::P64 = P64[Sp + 32];
           _s8y0l::I64 = I64[Sp + 64];
           _s8y0m::I64 = I64[Sp + 72];
           I32[I64[Sp + 80] + (_s8y0m::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 24] - 240 << 18) + ((I64[Sp] - 128 << 12) + ((I64[Sp + 8] - 128 << 6) + (I64[Sp + 16] - 128))));
           call MO_Touch(_s8xWN::P64);
           I64[Sp + 64] = _s8y0l::I64 + 4;
           I64[Sp + 72] = _s8y0m::I64 + 1;
           Sp = Sp + 24;
           call _c8yxm() args: 0, res: 0, upd: 0;
     }
 },
 _c8yBA() //  []
         { info_tbl: [(c8yBA,
                       label: block_c8yBA_info
                       rep:StackRep [True, True, True, False, False, True, True, True,
                                     True, True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yBA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yLl; else goto c8yLk;
       c8yLl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yBA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yLk: // global
           _c8yoa::P64 = P64[Sp + 104];
           _s8xWF::I64 = I64[Sp + 128];
           _s8xWG::P64 = P64[Sp + 120];
           _s8xWH::P64 = P64[Sp + 88];
           _s8xWI::I64 = I64[Sp + 96];
           _s8xWK::I64 = I64[Sp + 112];
           _s8xWM::I64 = I64[Sp + 80];
           _s8xWN::P64 = P64[Sp + 32];
           _s8xWO::P64 = P64[Sp + 40];
           _s8xWP::I64 = I64[Sp + 48];
           _s8xWQ::I64 = I64[Sp + 56];
           _s8y0l::I64 = I64[Sp + 64];
           _s8y0m::I64 = I64[Sp + 72];
           if (I64[Sp + 24] < 238) goto c8yLo; else goto c8yLF;
       c8yLo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y2D_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yLF: // global
           _s8y2a::I64 = I64[Sp + 8];
           if (_s8y2a::I64 < 128) goto c8yLr; else goto c8yLE;
       c8yLr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y2I_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yLE: // global
           if (_s8y2a::I64 > 191) goto c8yLu; else goto c8yLD;
       c8yLu: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y2N_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yLD: // global
           _s8y2g::I64 = I64[Sp + 16];
           if (_s8y2g::I64 < 128) goto c8yLx; else goto c8yLC;
       c8yLx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y2S_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yLC: // global
           if (_s8y2g::I64 > 191) goto c8yLA; else goto c8yLB;
       c8yLA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8y0m::I64;
           I64[Hp - 96] = sat_s8y2X_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8y0l::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yLB: // global
           Hp = Hp - 160;
           Sp = Sp + 8;
           call _s8y2i() args: 0, res: 0, upd: 0;
     }
 },
 _s8y2i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8y2i: // global
           _s8xWN::P64 = P64[Sp + 24];
           _s8y0l::I64 = I64[Sp + 56];
           _s8y0m::I64 = I64[Sp + 64];
           I32[I64[Sp + 72] + (_s8y0m::I64 << 2)] = %MO_UU_Conv_W64_W32((I64[Sp + 16] - 224 << 12) + ((I64[Sp] - 128 << 6) + (I64[Sp + 8] - 128)));
           call MO_Touch(_s8xWN::P64);
           I64[Sp + 56] = _s8y0l::I64 + 3;
           I64[Sp + 64] = _s8y0m::I64 + 1;
           Sp = Sp + 16;
           call _c8yxm() args: 0, res: 0, upd: 0;
     }
 },
 _c8yub() //  []
         { info_tbl: [(c8yub,
                       label: block_c8yub_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yub: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yGP; else goto c8yGO;
       c8yGP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yub_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yGO: // global
           _c8yoa::P64 = P64[Sp + 96];
           _s8xWF::I64 = I64[Sp + 120];
           _s8xWG::P64 = P64[Sp + 112];
           _s8xWH::P64 = P64[Sp + 80];
           _s8xWI::I64 = I64[Sp + 88];
           _s8xWK::I64 = I64[Sp + 104];
           _s8xWM::I64 = I64[Sp + 72];
           _s8xWN::P64 = P64[Sp + 24];
           _s8xWO::P64 = P64[Sp + 32];
           _s8xWP::I64 = I64[Sp + 40];
           _s8xWQ::I64 = I64[Sp + 48];
           _s8xYU::I64 = I64[Sp + 64];
           _s8xYV::I64 = I64[Sp + 56];
           _s8xYW::I64 = I64[Sp + 16];
           if (_s8xYW::I64 < 238) goto c8yGS; else goto c8yH5;
       c8yGS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xYV::I64;
           I64[Hp - 96] = sat_s8xZe_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xYU::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yH5: // global
           if (_s8xYW::I64 > 239) goto c8yGV; else goto c8yH4;
       c8yGV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xYV::I64;
           I64[Hp - 96] = sat_s8xZj_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xYU::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yH4: // global
           _s8xZ2::I64 = I64[Sp + 8];
           if (_s8xZ2::I64 < 128) goto c8yGY; else goto c8yH3;
       c8yGY: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xYV::I64;
           I64[Hp - 96] = sat_s8xZo_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xYU::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yH3: // global
           if (_s8xZ2::I64 > 191) goto c8yH1; else goto c8yH2;
       c8yH1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8xWN::P64;
           P64[Hp - 136] = _s8xWO::P64;
           I64[Hp - 128] = _s8xWM::I64;
           I64[Hp - 120] = _s8xWP::I64;
           I64[Hp - 112] = _s8xWQ::I64;
           I64[Hp - 104] = _s8xYV::I64;
           I64[Hp - 96] = sat_s8xZt_info;
           P64[Hp - 80] = _s8xWG::P64;
           P64[Hp - 72] = _s8xWH::P64;
           P64[Hp - 64] = _c8yoa::P64;
           I64[Hp - 56] = _s8xWF::I64;
           I64[Hp - 48] = _s8xWI::I64;
           I64[Hp - 40] = _s8xWK::I64;
           I64[Hp - 32] = _s8xYU::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8yH2: // global
           Hp = Hp - 160;
           Sp = Sp + 16;
           call _c8ytF() args: 0, res: 0, upd: 0;
     }
 },
 _c8ytF() //  []
         { info_tbl: [(c8ytF,
                       label: block_c8ytF_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ytF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yGK; else goto c8yGJ;
       c8yGK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8ytF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yGJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xZ6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yt6() //  []
         { info_tbl: [(c8yt6,
                       label: block_c8yt6_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yt6: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yGF; else goto c8yGE;
       c8yGF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yt6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yGE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xYQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yvA() //  []
         { info_tbl: [(c8yvA,
                       label: block_c8yvA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yvA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yI9; else goto c8yI8;
       c8yI9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yvA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yI8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xZL_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yvW() //  []
         { info_tbl: [(c8yvW,
                       label: block_c8yvW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yvW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yId; else goto c8yIc;
       c8yId: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yvW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8xZT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ywi() //  []
         { info_tbl: [(c8ywi,
                       label: block_c8ywi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ywi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yIh; else goto c8yIg;
       c8yIh: // global
           HpAlloc = 160;
           I64[Sp] = block_c8ywi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8y01_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ywE() //  []
         { info_tbl: [(c8ywE,
                       label: block_c8ywE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ywE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yIl; else goto c8yIk;
       c8yIl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8ywE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8y09_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yx0() //  []
         { info_tbl: [(c8yx0,
                       label: block_c8yx0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yx0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8yIp; else goto c8yIo;
       c8yIp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8yx0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8yIo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8y0h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.74283788 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes:
         I8[] [85,84,70,45,56,66,79,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.7448869 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom1_entry() //  [R1]
         { info_tbl: [(c8z6q,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8z6r; else goto c8z6s;
       c8z6r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8z6s: // global
           (_c8z6n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8z6n::I64 == 0) goto c8z6p; else goto c8z6o;
       c8z6p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8z6o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8z6n::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF8_bom2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.748955993 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF3_closure" {
     GHC.IO.Encoding.UTF8.mkUTF3_closure:
         const GHC.IO.Encoding.UTF8.mkUTF3_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF3_entry() //  []
         { info_tbl: [(c8z6F,
                       label: GHC.IO.Encoding.UTF8.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z6F: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.756926744 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_bom_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_bom_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_info;
         const 0;
 },
 sat_s8y5y_entry() //  [R1, R2]
         { info_tbl: [(c8z77,
                       label: sat_s8y5y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z77: // global
           _s8y4V::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8y4V::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y4V::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5u_entry() //  [R1]
         { info_tbl: [(c8z7g,
                       label: sat_s8y5u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z7g: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5s_entry() //  [R1, R2, R3]
         { info_tbl: [(c8z7o,
                       label: sat_s8y5s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z7o: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5r_entry() //  [R1, R2, R3]
         { info_tbl: [(c8z7z,
                       label: sat_s8y5r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z7z: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8z7A; else goto c8z7B;
       c8z7A: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8z7B: // global
           I64[Sp - 24] = block_c8z7w_info;
           _s8y4V::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8y4V::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8z8v; else goto c8z7x;
       u8z8v: // global
           call _c8z7w(R1) args: 0, res: 0, upd: 0;
       c8z7x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z7w() //  [R1]
         { info_tbl: [(c8z7w,
                       label: block_c8z7w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z7w: // global
           _s8y58::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8z7E_info;
           _s8y4Z::P64 = R1;
           _s8y51::P64 = P64[R1 + 7];
           _s8y52::P64 = P64[R1 + 15];
           _s8y50::I64 = I64[R1 + 23];
           _s8y53::I64 = I64[R1 + 31];
           _s8y54::I64 = I64[R1 + 39];
           _s8y55::I64 = I64[R1 + 47];
           R1 = _s8y58::P64;
           I64[Sp - 48] = _s8y50::I64;
           P64[Sp - 40] = _s8y51::P64;
           P64[Sp - 32] = _s8y52::P64;
           I64[Sp - 24] = _s8y53::I64;
           I64[Sp - 16] = _s8y54::I64;
           I64[Sp - 8] = _s8y55::I64;
           P64[Sp] = _s8y4Z::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8z8u; else goto c8z7G;
       u8z8u: // global
           call _c8z7E(R1) args: 0, res: 0, upd: 0;
       c8z7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z7E() //  [R1]
         { info_tbl: [(c8z7E,
                       label: block_c8z7E_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z7E: // global
           _s8y4W::P64 = P64[Sp + 72];
           _s8y4Z::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8z7M; else goto c8z7N;
       c8z7M: // global
           R3 = _s8y4Z::P64;
           R2 = _s8y4W::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8z7N: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8z7S; else goto c8z7R;
       c8z7S: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8z7R: // global
           _s8y53::I64 = I64[Sp + 32];
           _s8y55::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8y53::I64 - _s8y55::I64,
                            3)) goto c8z8p; else goto c8z8s;
       c8z8p: // global
           _s8y4V::P64 = P64[Sp + 64];
           _s8y50::I64 = I64[Sp + 8];
           _s8y51::P64 = P64[Sp + 16];
           _s8y52::P64 = P64[Sp + 24];
           _s8y54::I64 = I64[Sp + 40];
           call MO_WriteBarrier();
           P64[_s8y4V::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y4V::P64);
           I8[_s8y50::I64 + _s8y55::I64] = 239 :: W8;
           call MO_Touch(_s8y51::P64);
           I8[_s8y50::I64 + (_s8y55::I64 + 1)] = 187 :: W8;
           call MO_Touch(_s8y51::P64);
           I8[_s8y50::I64 + (_s8y55::I64 + 2)] = 191 :: W8;
           call MO_Touch(_s8y51::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8y51::P64;
           P64[Hp - 32] = _s8y52::P64;
           I64[Hp - 24] = _s8y50::I64;
           I64[Hp - 16] = _s8y53::I64;
           I64[Hp - 8] = _s8y54::I64;
           I64[Hp] = _s8y55::I64 + 3;
           R3 = Hp - 47;
           R2 = _s8y4W::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8z8s: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _s8y4W::P64;
           P64[Hp - 24] = _s8y4Z::P64;
           _c8z8r::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8z8r::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5A_entry() //  [R1]
         { info_tbl: [(c8z8x,
                       label: sat_s8y5A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z8x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8z8y; else goto c8z8z;
       c8z8y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8z8z: // global
           I64[Sp - 16] = block_c8z6X_info;
           _s8y3Q::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8y3Q::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z6X() //  [R1]
         { info_tbl: [(c8z6X,
                       label: block_c8z6X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z6X: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8z8C; else goto c8z8B;
       c8z8C: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8z8B: // global
           I64[Hp - 104] = sat_s8y5y_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8y5u_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8y5s_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8y5r_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y4P_entry() //  [R1, R2]
         { info_tbl: [(c8z8S,
                       label: sat_s8y4P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z8S: // global
           _s8y3U::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8y3U::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y3U::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y4L_entry() //  [R1]
         { info_tbl: [(c8z91,
                       label: sat_s8y4L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z91: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y4J_entry() //  [R1, R2, R3]
         { info_tbl: [(c8z99,
                       label: sat_s8y4J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z99: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y4I_entry() //  [R1, R2, R3]
         { info_tbl: [(c8z9k,
                       label: sat_s8y4I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z9k: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8z9l; else goto c8z9m;
       c8z9l: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8z9m: // global
           I64[Sp - 24] = block_c8z9h_info;
           _s8y3U::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8y3U::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8zb3; else goto c8z9i;
       u8zb3: // global
           call _c8z9h(R1) args: 0, res: 0, upd: 0;
       c8z9i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z9h() //  [R1]
         { info_tbl: [(c8z9h,
                       label: block_c8z9h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z9h: // global
           _s8y47::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp - 56] = block_c8z9p_info;
           _s8y3Y::P64 = R1;
           _s8y40::P64 = P64[R1 + 7];
           _s8y41::P64 = P64[R1 + 15];
           _s8y3Z::I64 = I64[R1 + 23];
           _s8y42::I64 = I64[R1 + 31];
           _s8y43::I64 = I64[R1 + 39];
           _s8y44::I64 = I64[R1 + 47];
           R1 = _s8y47::P64;
           I64[Sp - 48] = _s8y3Z::I64;
           P64[Sp - 40] = _s8y40::P64;
           P64[Sp - 32] = _s8y41::P64;
           I64[Sp - 24] = _s8y42::I64;
           I64[Sp - 16] = _s8y43::I64;
           I64[Sp - 8] = _s8y44::I64;
           P64[Sp] = _s8y3Y::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8zb2; else goto c8z9r;
       u8zb2: // global
           call _c8z9p(R1) args: 0, res: 0, upd: 0;
       c8z9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z9p() //  [R1]
         { info_tbl: [(c8z9p,
                       label: block_c8z9p_info
                       rep:StackRep [True, False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z9p: // global
           _s8y3W::P64 = P64[Sp + 72];
           _s8y3Y::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c8z9x; else goto c8z9y;
       c8z9x: // global
           R3 = _s8y3W::P64;
           R2 = _s8y3Y::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8z9y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8z9D; else goto c8z9C;
       c8z9D: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8z9C: // global
           _s8y43::I64 = I64[Sp + 40];
           _s8y44::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_s8y44::I64 - _s8y43::I64,
                            1)) goto c8zaO; else goto c8zaR;
       c8zaO: // global
           _s8y3U::P64 = P64[Sp + 64];
           _s8y3Z::I64 = I64[Sp + 8];
           _s8y40::P64 = P64[Sp + 16];
           _s8y41::P64 = P64[Sp + 24];
           _s8y42::I64 = I64[Sp + 32];
           _s8y4e::I64 = %MO_UU_Conv_W8_W64(I8[_s8y3Z::I64 + _s8y43::I64]);
           call MO_Touch(_s8y40::P64);
           if (_s8y4e::I64 == 239) goto c8zaM; else goto c8z9Q;
       c8zaM: // global
           if (%MO_S_Ge_W64(_s8y44::I64 - _s8y43::I64,
                            2)) goto c8zaI; else goto c8zaL;
       c8zaI: // global
           _s8y4o::I64 = %MO_UU_Conv_W8_W64(I8[_s8y3Z::I64 + (_s8y43::I64 + 1)]);
           call MO_Touch(_s8y40::P64);
           if (_s8y4o::I64 == 187) goto c8zaG; else goto c8za8;
       c8zaG: // global
           if (%MO_S_Ge_W64(_s8y44::I64 - _s8y43::I64,
                            3)) goto c8zaC; else goto c8zaF;
       c8zaC: // global
           _s8y4y::I64 = %MO_UU_Conv_W8_W64(I8[_s8y3Z::I64 + (_s8y43::I64 + 2)]);
           call MO_Touch(_s8y40::P64);
           if (_s8y4y::I64 == 191) goto c8zaA; else goto c8zaq;
       c8zaA: // global
           call MO_WriteBarrier();
           P64[_s8y3U::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y3U::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8y40::P64;
           P64[Hp - 32] = _s8y41::P64;
           I64[Hp - 24] = _s8y3Z::I64;
           I64[Hp - 16] = _s8y42::I64;
           I64[Hp - 8] = _s8y43::I64 + 3;
           I64[Hp] = _s8y44::I64;
           R3 = _s8y3W::P64;
           R2 = Hp - 47;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8zaq: // global
           call MO_WriteBarrier();
           P64[_s8y3U::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y3U::P64);
           Hp = Hp - 56;
           R3 = _s8y3W::P64;
           R2 = _s8y3Y::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8zaF: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8y3Y::P64;
           P64[Hp - 24] = _s8y3W::P64;
           _c8zaE::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8zaE::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8za8: // global
           call MO_WriteBarrier();
           P64[_s8y3U::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y3U::P64);
           Hp = Hp - 56;
           R3 = _s8y3W::P64;
           R2 = _s8y3Y::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8zaL: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8y3Y::P64;
           P64[Hp - 24] = _s8y3W::P64;
           _c8zaK::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8zaK::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8z9Q: // global
           call MO_WriteBarrier();
           P64[_s8y3U::P64 + 8] = GHC.Types.False_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8y3U::P64);
           Hp = Hp - 56;
           R3 = _s8y3W::P64;
           R2 = _s8y3Y::P64;
           Sp = Sp + 80;
           call GHC.IO.Encoding.UTF8.mkUTF4_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c8zaR: // global
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _s8y3Y::P64;
           P64[Hp - 24] = _s8y3W::P64;
           _c8zaQ::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c8zaQ::P64;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y4R_entry() //  [R1]
         { info_tbl: [(c8zb5,
                       label: sat_s8y4R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zb5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zb6; else goto c8zb7;
       c8zb6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8zb7: // global
           I64[Sp - 16] = block_c8z8I_info;
           _s8y3Q::P64 = P64[R1 + 7];
           R1 = GHC.Types.True_closure+2;
           P64[Sp - 8] = _s8y3Q::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z8I() //  [R1]
         { info_tbl: [(c8z8I,
                       label: block_c8z8I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z8I: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8zba; else goto c8zb9;
       c8zba: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8zb9: // global
           I64[Hp - 104] = sat_s8y4P_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8y4L_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8y4J_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8y4I_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_bom_entry() //  [R2]
         { info_tbl: [(c8zbc,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_bom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zbc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8zbg; else goto c8zbf;
       c8zbg: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8zbf: // global
           I64[Hp - 56] = sat_s8y5A_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8y4R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.799344949 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_bom_closure" {
     GHC.IO.Encoding.UTF8.utf8_bom_closure:
         const GHC.IO.Encoding.UTF8.utf8_bom_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf8_bom_entry() //  [R1]
         { info_tbl: [(c8ze0,
                       label: GHC.IO.Encoding.UTF8.utf8_bom_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ze0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ze1; else goto c8ze2;
       c8ze1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ze2: // global
           (_c8zdX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8zdX::I64 == 0) goto c8zdZ; else goto c8zdY;
       c8zdZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8zdY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8zdX::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF8.mkUTF8_bom_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.804117222 UTC

[section ""cstring" . GHC.IO.Encoding.UTF8.mkUTF6_bytes" {
     GHC.IO.Encoding.UTF8.mkUTF6_bytes:
         I8[] [85,84,70,45,56]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.806146432 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF5_closure" {
     GHC.IO.Encoding.UTF8.mkUTF5_closure:
         const GHC.IO.Encoding.UTF8.mkUTF5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF8.mkUTF5_entry() //  [R1]
         { info_tbl: [(c8zej,
                       label: GHC.IO.Encoding.UTF8.mkUTF5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zej: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zek; else goto c8zel;
       c8zek: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zel: // global
           (_c8zeg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8zeg::I64 == 0) goto c8zei; else goto c8zeh;
       c8zei: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8zeh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8zeg::I64;
           R2 = GHC.IO.Encoding.UTF8.mkUTF6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.810578985 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF2_closure" {
     GHC.IO.Encoding.UTF8.mkUTF2_closure:
         const GHC.IO.Encoding.UTF8.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF8.mkUTF2_entry() //  []
         { info_tbl: [(c8zey,
                       label: GHC.IO.Encoding.UTF8.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zey: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.814658647 UTC

[section ""data" . GHC.IO.Encoding.UTF8.mkUTF8_closure" {
     GHC.IO.Encoding.UTF8.mkUTF8_closure:
         const GHC.IO.Encoding.UTF8.mkUTF8_info;
         const 0;
 },
 sat_s8y5J_entry() //  [R1, R2, R3]
         { info_tbl: [(c8zeV,
                       label: sat_s8y5J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zeV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5L_entry() //  [R1]
         { info_tbl: [(c8zeZ,
                       label: sat_s8y5L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zeZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8zf3; else goto c8zf2;
       c8zf3: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8zf2: // global
           _s8y5D::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8y5J_info;
           P64[Hp - 48] = _s8y5D::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5F_entry() //  [R1, R2, R3]
         { info_tbl: [(c8zfe,
                       label: sat_s8y5F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zfe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8y5H_entry() //  [R1]
         { info_tbl: [(c8zfi,
                       label: sat_s8y5H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zfi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8zfm; else goto c8zfl;
       c8zfm: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8zfl: // global
           _s8y5D::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8y5F_info;
           P64[Hp - 48] = _s8y5D::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF8.mkUTF8_entry() //  [R2]
         { info_tbl: [(c8zfo,
                       label: GHC.IO.Encoding.UTF8.mkUTF8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zfo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8zfs; else goto c8zfr;
       c8zfs: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.mkUTF8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8zfr: // global
           I64[Hp - 56] = sat_s8y5L_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8y5H_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF8.mkUTF5_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.827048175 UTC

[section ""data" . lvl_r8uYu_closure" {
     lvl_r8uYu_closure:
         const lvl_r8uYu_info;
         const 0;
 },
 lvl_r8uYu_entry() //  [R2, R3]
         { info_tbl: [(c8zgd,
                       label: lvl_r8uYu_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zgd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zgh; else goto c8zgi;
       c8zgh: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8uYu_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zgi: // global
           I64[Sp - 16] = block_c8zga_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8zgq; else goto c8zgb;
       u8zgq: // global
           call _c8zga() args: 0, res: 0, upd: 0;
       c8zgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zga() //  []
         { info_tbl: [(c8zga,
                       label: block_c8zga_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zga: // global
           _s8y5N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8zgg_info;
           R1 = _s8y5N::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8zgp; else goto c8zgk;
       u8zgp: // global
           call _c8zgg() args: 0, res: 0, upd: 0;
       c8zgk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zgg() //  []
         { info_tbl: [(c8zgg,
                       label: block_c8zgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zgg: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.834316008 UTC

[section ""data" . lvl1_r8uYv_closure" {
     lvl1_r8uYv_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF4_closure+3;
         const lvl_r8uYu_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.836338185 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf3_closure" {
     GHC.IO.Encoding.UTF8.utf3_closure:
         const GHC.IO.Encoding.UTF8.utf3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf3_entry() //  []
         { info_tbl: [(c8zgL,
                       label: GHC.IO.Encoding.UTF8.utf3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zgL: // global
           R1 = lvl1_r8uYv_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.840691069 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf2_closure" {
     GHC.IO.Encoding.UTF8.utf2_closure:
         const GHC.IO.Encoding.UTF8.utf2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf2_entry() //  [R2, R3]
         { info_tbl: [(c8zh0,
                       label: GHC.IO.Encoding.UTF8.utf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zh0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8zh4; else goto c8zh5;
       c8zh4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF8.utf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zh5: // global
           I64[Sp - 16] = block_c8zgX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8zhe; else goto c8zgY;
       u8zhe: // global
           call _c8zgX(R1) args: 0, res: 0, upd: 0;
       c8zgY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zgX() //  [R1]
         { info_tbl: [(c8zgX,
                       label: block_c8zgX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zgX: // global
           I64[Sp - 16] = block_c8zh3_info;
           _s8y69::P64 = P64[R1 + 7];
           _s8y68::I64 = I64[R1 + 23];
           _s8y6c::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8y6c::I64;
           P64[Sp] = _s8y69::P64;
           I64[Sp + 8] = _s8y68::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8zhd; else goto c8zh7;
       u8zhd: // global
           call _c8zh3() args: 0, res: 0, upd: 0;
       c8zh7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zh3() //  []
         { info_tbl: [(c8zh3,
                       label: block_c8zh3_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zh3: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.848517527 UTC

[section ""data" . lvl2_r8uYw_closure" {
     lvl2_r8uYw_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF8.utf2_closure+3;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF3_closure+1;
         const GHC.IO.Encoding.UTF8.mkUTF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.850716063 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf1_closure" {
     GHC.IO.Encoding.UTF8.utf1_closure:
         const GHC.IO.Encoding.UTF8.utf1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF8.utf1_entry() //  []
         { info_tbl: [(c8zhz,
                       label: GHC.IO.Encoding.UTF8.utf1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zhz: // global
           R1 = lvl2_r8uYw_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.854256616 UTC

[section ""data" . GHC.IO.Encoding.UTF8.utf8_closure" {
     GHC.IO.Encoding.UTF8.utf8_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.UTF8.utf3_closure+1;
         const GHC.IO.Encoding.UTF8.utf1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:42.856135179 UTC

[section ""relreadonly" . S8zbh_srt" {
     S8zbh_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_bom1_closure;
         const GHC.IO.Encoding.UTF8.mkUTF8_closure;
         const GHC.IO.Encoding.UTF8.mkUTF5_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8uYu_closure;
         const lvl1_r8uYv_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF8.utf2_closure;
         const lvl2_r8uYw_closure;
 }]

