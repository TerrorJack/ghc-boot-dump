
==================== Raw Cmm ====================
2018-03-16 16:03:43.646991176 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:43.648137787 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.650024073 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.651718845 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.653608049 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.655246814 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.670303337 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8AWR_entry() //  [R1]
         { []
         }
     {offset
       c8Cg1: // global
           _s8AWR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cg2; else goto c8Cg3;
       c8Cg3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cg5; else goto c8Cg4;
       c8Cg5: // global
           HpAlloc = 56;
           goto c8Cg2;
       c8Cg2: // global
           R1 = _s8AWR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWR::P64;
           _s8AWD::I64 = I64[_s8AWR::P64 + 56];
           _s8AWN::I64 = I64[_s8AWR::P64 + 64];
           if (_s8AWN::I64 == _s8AWD::I64) goto c8Cg0; else goto c8CfZ;
       c8Cg0: // global
           _s8AWL::P64 = P64[_s8AWR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CfZ: // global
           _s8AWz::P64 = P64[_s8AWR::P64 + 16];
           _s8AWA::P64 = P64[_s8AWR::P64 + 24];
           _s8AWy::I64 = I64[_s8AWR::P64 + 40];
           _s8AWB::I64 = I64[_s8AWR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWN::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AWR_info" {
     sat_s8AWR_info:
         const sat_s8AWR_entry;
         const 17179869187;
         const 15;
 },
 sat_s8AWZ_entry() //  [R1]
         { []
         }
     {offset
       c8Cgn: // global
           _s8AWZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cgo; else goto c8Cgp;
       c8Cgp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cgr; else goto c8Cgq;
       c8Cgr: // global
           HpAlloc = 56;
           goto c8Cgo;
       c8Cgo: // global
           R1 = _s8AWZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cgq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWZ::P64;
           _s8AWD::I64 = I64[_s8AWZ::P64 + 56];
           _s8AWV::I64 = I64[_s8AWZ::P64 + 64];
           if (_s8AWV::I64 == _s8AWD::I64) goto c8Cgm; else goto c8Cgl;
       c8Cgm: // global
           _s8AWL::P64 = P64[_s8AWZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cgl: // global
           _s8AWz::P64 = P64[_s8AWZ::P64 + 16];
           _s8AWA::P64 = P64[_s8AWZ::P64 + 24];
           _s8AWy::I64 = I64[_s8AWZ::P64 + 40];
           _s8AWB::I64 = I64[_s8AWZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWV::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AWZ_info" {
     sat_s8AWZ_info:
         const sat_s8AWZ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8AX7_entry() //  [R1]
         { []
         }
     {offset
       c8CgJ: // global
           _s8AX7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CgK; else goto c8CgL;
       c8CgL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CgN; else goto c8CgM;
       c8CgN: // global
           HpAlloc = 56;
           goto c8CgK;
       c8CgK: // global
           R1 = _s8AX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AX7::P64;
           _s8AWD::I64 = I64[_s8AX7::P64 + 56];
           _s8AX3::I64 = I64[_s8AX7::P64 + 64];
           if (_s8AX3::I64 == _s8AWD::I64) goto c8CgI; else goto c8CgH;
       c8CgI: // global
           _s8AWL::P64 = P64[_s8AX7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CgH: // global
           _s8AWz::P64 = P64[_s8AX7::P64 + 16];
           _s8AWA::P64 = P64[_s8AX7::P64 + 24];
           _s8AWy::I64 = I64[_s8AX7::P64 + 40];
           _s8AWB::I64 = I64[_s8AX7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AX3::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AX7_info" {
     sat_s8AX7_info:
         const sat_s8AX7_entry;
         const 17179869187;
         const 15;
 },
 sat_s8AXf_entry() //  [R1]
         { []
         }
     {offset
       c8Ch5: // global
           _s8AXf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ch6; else goto c8Ch7;
       c8Ch7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ch9; else goto c8Ch8;
       c8Ch9: // global
           HpAlloc = 56;
           goto c8Ch6;
       c8Ch6: // global
           R1 = _s8AXf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ch8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXf::P64;
           _s8AWD::I64 = I64[_s8AXf::P64 + 56];
           _s8AXb::I64 = I64[_s8AXf::P64 + 64];
           if (_s8AXb::I64 == _s8AWD::I64) goto c8Ch4; else goto c8Ch3;
       c8Ch4: // global
           _s8AWL::P64 = P64[_s8AXf::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ch3: // global
           _s8AWz::P64 = P64[_s8AXf::P64 + 16];
           _s8AWA::P64 = P64[_s8AXf::P64 + 24];
           _s8AWy::I64 = I64[_s8AXf::P64 + 40];
           _s8AWB::I64 = I64[_s8AXf::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXb::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AXf_info" {
     sat_s8AXf_info:
         const sat_s8AXf_entry;
         const 17179869187;
         const 15;
 },
 sat_s8AXn_entry() //  [R1]
         { []
         }
     {offset
       c8Chr: // global
           _s8AXn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Chs; else goto c8Cht;
       c8Cht: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Chv; else goto c8Chu;
       c8Chv: // global
           HpAlloc = 56;
           goto c8Chs;
       c8Chs: // global
           R1 = _s8AXn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Chu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXn::P64;
           _s8AWD::I64 = I64[_s8AXn::P64 + 56];
           _s8AXj::I64 = I64[_s8AXn::P64 + 64];
           if (_s8AXj::I64 == _s8AWD::I64) goto c8Chq; else goto c8Chp;
       c8Chq: // global
           _s8AWL::P64 = P64[_s8AXn::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Chp: // global
           _s8AWz::P64 = P64[_s8AXn::P64 + 16];
           _s8AWA::P64 = P64[_s8AXn::P64 + 24];
           _s8AWy::I64 = I64[_s8AXn::P64 + 40];
           _s8AWB::I64 = I64[_s8AXn::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXj::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AXn_info" {
     sat_s8AXn_info:
         const sat_s8AXn_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Chy: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Chz; else goto c8ChA;
       c8Chz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ChA: // global
           I64[Sp - 16] = block_c8CfB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Cnc; else goto c8CfC;
       u8Cnc: // global
           call _c8CfB(R1) args: 0, res: 0, upd: 0;
       c8CfC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le1_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8CfB() //  [R1]
         { []
         }
     {offset
       c8CfB: // global
           I64[Sp - 40] = block_c8CfG_info;
           _s8AWz::P64 = P64[R1 + 7];
           _s8AWA::P64 = P64[R1 + 15];
           _s8AWy::I64 = I64[R1 + 23];
           _s8AWB::I64 = I64[R1 + 31];
           _s8AWC::I64 = I64[R1 + 39];
           _s8AWD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AWA::P64;
           I64[Sp - 24] = _s8AWB::I64;
           I64[Sp - 16] = _s8AWC::I64;
           I64[Sp - 8] = _s8AWD::I64;
           P64[Sp] = _s8AWz::P64;
           I64[Sp + 8] = _s8AWy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Cn6; else goto c8CfH;
       u8Cn6: // global
           call _c8CfG(R1) args: 0, res: 0, upd: 0;
       c8CfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CfB_info" {
     block_c8CfB_info:
         const _c8CfB;
         const 1;
         const 30;
 },
 _c8CfG() //  [R1]
         { []
         }
     {offset
       c8CfG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ChE; else goto c8ChD;
       c8ChE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ChD: // global
           _s8AWG::P64 = P64[R1 + 7];
           _s8AWH::P64 = P64[R1 + 15];
           _s8AWF::I64 = I64[R1 + 23];
           _s8AWI::I64 = I64[R1 + 31];
           _s8AWJ::I64 = I64[R1 + 39];
           _s8AWK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AWz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AWy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AWD::I64 = I64[Sp + 32];
           _c8CfL::P64 = Hp - 47;
           _s8AXs::I64 = _s8AWK::I64;
           _s8AXr::I64 = I64[Sp + 24];
           goto c8Ci1;
       c8Ci1: // global
           if (%MO_S_Lt_W64(_s8AXr::I64,
                            _s8AWD::I64)) goto c8CiX; else goto c8CiY;
       c8CiX: // global
           if (%MO_S_Ge_W64(_s8AWI::I64 - _s8AXs::I64,
                            4)) goto c8CiU; else goto c8CiV;
       c8CiU: // global
           _s8AXz::I64 = %MO_UU_Conv_W32_W64(I32[_s8AWy::I64 + (_s8AXr::I64 << 2)]);
           call MO_Touch(_s8AWz::P64);
           if (%MO_S_Gt_W64(55296, _s8AXz::I64)) goto c8Ciy; else goto c8CiS;
       c8Ciy: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8Cio; else goto c8Ciw;
       c8Cio: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8Ciw: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8Ciu; else goto c8Civ;
       c8Ciu: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8Civ: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8CfO() args: 0, res: 0, upd: 0;
       c8CiS: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 56319)) goto c8CiQ; else goto c8CiR;
       c8CiQ: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8CiG; else goto c8CiO;
       c8CiG: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8CiO: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8CiM; else goto c8CiN;
       c8CiM: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8CiN: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Cga() args: 0, res: 0, upd: 0;
       c8CiR: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Cgw() args: 0, res: 0, upd: 0;
       c8CiV: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8CgS() args: 0, res: 0, upd: 0;
       c8CiY: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Che() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8CfG_info" {
     block_c8CfG_info:
         const _c8CfG;
         const 2950;
         const 30;
 },
 _c8CfO() //  []
         { []
         }
     {offset
       c8CfO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChI; else goto c8ChH;
       c8ChI: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CfO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CfO_info" {
     block_c8CfO_info:
         const _c8CfO;
         const 352013;
         const 30;
 },
 _c8Cga() //  []
         { []
         }
     {offset
       c8Cga: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChM; else goto c8ChL;
       c8ChM: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cga_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cga_info" {
     block_c8Cga_info:
         const _c8Cga;
         const 352013;
         const 30;
 },
 _c8Cgw() //  []
         { []
         }
     {offset
       c8Cgw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChQ; else goto c8ChP;
       c8ChQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cgw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AX7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cgw_info" {
     block_c8Cgw_info:
         const _c8Cgw;
         const 352013;
         const 30;
 },
 _c8CgS() //  []
         { []
         }
     {offset
       c8CgS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChU; else goto c8ChT;
       c8ChU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CgS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXf_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CgS_info" {
     block_c8CgS_info:
         const _c8CgS;
         const 352013;
         const 30;
 },
 _c8Che() //  []
         { []
         }
     {offset
       c8Che: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChY; else goto c8ChX;
       c8ChY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Che_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXn_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Che_info" {
     block_c8Che_info:
         const _c8Che;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.705395991 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Cq5: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le_encode_info" {
     GHC.IO.Encoding.UTF32.utf32le_encode_info:
         const GHC.IO.Encoding.UTF32.utf32le_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.721911687 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8AZT_entry() //  [R1]
         { []
         }
     {offset
       c8CqG: // global
           _s8AZT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CqH; else goto c8CqI;
       c8CqI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CqK; else goto c8CqJ;
       c8CqK: // global
           HpAlloc = 56;
           goto c8CqH;
       c8CqH: // global
           R1 = _s8AZT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CqJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AZT::P64;
           _s8AZF::I64 = I64[_s8AZT::P64 + 56];
           _s8AZP::I64 = I64[_s8AZT::P64 + 64];
           if (_s8AZP::I64 == _s8AZF::I64) goto c8CqF; else goto c8CqE;
       c8CqF: // global
           _s8AZN::P64 = P64[_s8AZT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CqE: // global
           _s8AZB::P64 = P64[_s8AZT::P64 + 16];
           _s8AZC::P64 = P64[_s8AZT::P64 + 24];
           _s8AZA::I64 = I64[_s8AZT::P64 + 40];
           _s8AZD::I64 = I64[_s8AZT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZP::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8AZT_info" {
     sat_s8AZT_info:
         const sat_s8AZT_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B01_entry() //  [R1]
         { []
         }
     {offset
       c8Cr2: // global
           _s8B01::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cr3; else goto c8Cr4;
       c8Cr4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cr6; else goto c8Cr5;
       c8Cr6: // global
           HpAlloc = 56;
           goto c8Cr3;
       c8Cr3: // global
           R1 = _s8B01::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cr5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B01::P64;
           _s8AZF::I64 = I64[_s8B01::P64 + 56];
           _s8AZX::I64 = I64[_s8B01::P64 + 64];
           if (_s8AZX::I64 == _s8AZF::I64) goto c8Cr1; else goto c8Cr0;
       c8Cr1: // global
           _s8AZN::P64 = P64[_s8B01::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cr0: // global
           _s8AZB::P64 = P64[_s8B01::P64 + 16];
           _s8AZC::P64 = P64[_s8B01::P64 + 24];
           _s8AZA::I64 = I64[_s8B01::P64 + 40];
           _s8AZD::I64 = I64[_s8B01::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZX::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B01_info" {
     sat_s8B01_info:
         const sat_s8B01_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B09_entry() //  [R1]
         { []
         }
     {offset
       c8Cro: // global
           _s8B09::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Crp; else goto c8Crq;
       c8Crq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Crs; else goto c8Crr;
       c8Crs: // global
           HpAlloc = 56;
           goto c8Crp;
       c8Crp: // global
           R1 = _s8B09::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Crr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B09::P64;
           _s8AZF::I64 = I64[_s8B09::P64 + 56];
           _s8B05::I64 = I64[_s8B09::P64 + 64];
           if (_s8B05::I64 == _s8AZF::I64) goto c8Crn; else goto c8Crm;
       c8Crn: // global
           _s8AZN::P64 = P64[_s8B09::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Crm: // global
           _s8AZB::P64 = P64[_s8B09::P64 + 16];
           _s8AZC::P64 = P64[_s8B09::P64 + 24];
           _s8AZA::I64 = I64[_s8B09::P64 + 40];
           _s8AZD::I64 = I64[_s8B09::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B05::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B09_info" {
     sat_s8B09_info:
         const sat_s8B09_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B0h_entry() //  [R1]
         { []
         }
     {offset
       c8CrK: // global
           _s8B0h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CrL; else goto c8CrM;
       c8CrM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CrO; else goto c8CrN;
       c8CrO: // global
           HpAlloc = 56;
           goto c8CrL;
       c8CrL: // global
           R1 = _s8B0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CrN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0h::P64;
           _s8AZF::I64 = I64[_s8B0h::P64 + 56];
           _s8B0d::I64 = I64[_s8B0h::P64 + 64];
           if (_s8B0d::I64 == _s8AZF::I64) goto c8CrJ; else goto c8CrI;
       c8CrJ: // global
           _s8AZN::P64 = P64[_s8B0h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CrI: // global
           _s8AZB::P64 = P64[_s8B0h::P64 + 16];
           _s8AZC::P64 = P64[_s8B0h::P64 + 24];
           _s8AZA::I64 = I64[_s8B0h::P64 + 40];
           _s8AZD::I64 = I64[_s8B0h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0d::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B0h_info" {
     sat_s8B0h_info:
         const sat_s8B0h_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B0p_entry() //  [R1]
         { []
         }
     {offset
       c8Cs6: // global
           _s8B0p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cs7; else goto c8Cs8;
       c8Cs8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Csa; else goto c8Cs9;
       c8Csa: // global
           HpAlloc = 56;
           goto c8Cs7;
       c8Cs7: // global
           R1 = _s8B0p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cs9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0p::P64;
           _s8AZF::I64 = I64[_s8B0p::P64 + 56];
           _s8B0l::I64 = I64[_s8B0p::P64 + 64];
           if (_s8B0l::I64 == _s8AZF::I64) goto c8Cs5; else goto c8Cs4;
       c8Cs5: // global
           _s8AZN::P64 = P64[_s8B0p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cs4: // global
           _s8AZB::P64 = P64[_s8B0p::P64 + 16];
           _s8AZC::P64 = P64[_s8B0p::P64 + 24];
           _s8AZA::I64 = I64[_s8B0p::P64 + 40];
           _s8AZD::I64 = I64[_s8B0p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0l::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B0p_info" {
     sat_s8B0p_info:
         const sat_s8B0p_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Csd: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Cse; else goto c8Csf;
       c8Cse: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Csf: // global
           I64[Sp - 16] = block_c8Cqg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CxR; else goto c8Cqh;
       u8CxR: // global
           call _c8Cqg(R1) args: 0, res: 0, upd: 0;
       c8Cqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF1_info" {
     GHC.IO.Encoding.UTF32.mkUTF1_info:
         const GHC.IO.Encoding.UTF32.mkUTF1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Cqg() //  [R1]
         { []
         }
     {offset
       c8Cqg: // global
           I64[Sp - 40] = block_c8Cql_info;
           _s8AZB::P64 = P64[R1 + 7];
           _s8AZC::P64 = P64[R1 + 15];
           _s8AZA::I64 = I64[R1 + 23];
           _s8AZD::I64 = I64[R1 + 31];
           _s8AZE::I64 = I64[R1 + 39];
           _s8AZF::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AZC::P64;
           I64[Sp - 24] = _s8AZD::I64;
           I64[Sp - 16] = _s8AZE::I64;
           I64[Sp - 8] = _s8AZF::I64;
           P64[Sp] = _s8AZB::P64;
           I64[Sp + 8] = _s8AZA::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8CxL; else goto c8Cqm;
       u8CxL: // global
           call _c8Cql(R1) args: 0, res: 0, upd: 0;
       c8Cqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cqg_info" {
     block_c8Cqg_info:
         const _c8Cqg;
         const 1;
         const 30;
 },
 _c8Cql() //  [R1]
         { []
         }
     {offset
       c8Cql: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Csj; else goto c8Csi;
       c8Csj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Csi: // global
           _s8AZI::P64 = P64[R1 + 7];
           _s8AZJ::P64 = P64[R1 + 15];
           _s8AZH::I64 = I64[R1 + 23];
           _s8AZK::I64 = I64[R1 + 31];
           _s8AZL::I64 = I64[R1 + 39];
           _s8AZM::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AZB::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AZA::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AZF::I64 = I64[Sp + 32];
           _c8Cqq::P64 = Hp - 47;
           _s8B0u::I64 = _s8AZM::I64;
           _s8B0t::I64 = I64[Sp + 24];
           goto c8CsG;
       c8CsG: // global
           if (%MO_S_Lt_W64(_s8B0t::I64,
                            _s8AZF::I64)) goto c8CtC; else goto c8CtD;
       c8CtC: // global
           if (%MO_S_Ge_W64(_s8AZK::I64 - _s8B0u::I64,
                            4)) goto c8Ctz; else goto c8CtA;
       c8Ctz: // global
           _s8B0B::I64 = %MO_UU_Conv_W32_W64(I32[_s8AZA::I64 + (_s8B0t::I64 << 2)]);
           call MO_Touch(_s8AZB::P64);
           if (%MO_S_Gt_W64(55296, _s8B0B::I64)) goto c8Ctd; else goto c8Ctx;
       c8Ctd: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Ct3; else goto c8Ctb;
       c8Ct3: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Ctb: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Ct9; else goto c8Cta;
       c8Ct9: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Cta: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Cqt() args: 0, res: 0, upd: 0;
       c8Ctx: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 56319)) goto c8Ctv; else goto c8Ctw;
       c8Ctv: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Ctl; else goto c8Ctt;
       c8Ctl: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Ctt: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Ctr; else goto c8Cts;
       c8Ctr: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Cts: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8CqP() args: 0, res: 0, upd: 0;
       c8Ctw: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Crb() args: 0, res: 0, upd: 0;
       c8CtA: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Crx() args: 0, res: 0, upd: 0;
       c8CtD: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8CrT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Cql_info" {
     block_c8Cql_info:
         const _c8Cql;
         const 2950;
         const 30;
 },
 _c8Cqt() //  []
         { []
         }
     {offset
       c8Cqt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csn; else goto c8Csm;
       c8Csn: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cqt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csm: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AZT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cqt_info" {
     block_c8Cqt_info:
         const _c8Cqt;
         const 352013;
         const 30;
 },
 _c8CqP() //  []
         { []
         }
     {offset
       c8CqP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csr; else goto c8Csq;
       c8Csr: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CqP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B01_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CqP_info" {
     block_c8CqP_info:
         const _c8CqP;
         const 352013;
         const 30;
 },
 _c8Crb() //  []
         { []
         }
     {offset
       c8Crb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csv; else goto c8Csu;
       c8Csv: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Crb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csu: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B09_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Crb_info" {
     block_c8Crb_info:
         const _c8Crb;
         const 352013;
         const 30;
 },
 _c8Crx() //  []
         { []
         }
     {offset
       c8Crx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csz; else goto c8Csy;
       c8Csz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Crx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Crx_info" {
     block_c8Crx_info:
         const _c8Crx;
         const 352013;
         const 30;
 },
 _c8CrT() //  []
         { []
         }
     {offset
       c8CrT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CsD; else goto c8CsC;
       c8CsD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CrT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CsC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CrT_info" {
     block_c8CrT_info:
         const _c8CrT;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.756377092 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CAK: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be_encode_info" {
     GHC.IO.Encoding.UTF32.utf32be_encode_info:
         const GHC.IO.Encoding.UTF32.utf32be_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.768605893 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8B2V_entry() //  [R1]
         { []
         }
     {offset
       c8CBl: // global
           _s8B2V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CBm; else goto c8CBn;
       c8CBn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CBp; else goto c8CBo;
       c8CBp: // global
           HpAlloc = 56;
           goto c8CBm;
       c8CBm: // global
           R1 = _s8B2V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B2V::P64;
           _s8B2H::I64 = I64[_s8B2V::P64 + 56];
           _s8B2R::I64 = I64[_s8B2V::P64 + 64];
           if (_s8B2R::I64 == _s8B2H::I64) goto c8CBk; else goto c8CBj;
       c8CBk: // global
           _s8B2P::P64 = P64[_s8B2V::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CBj: // global
           _s8B2D::P64 = P64[_s8B2V::P64 + 16];
           _s8B2E::P64 = P64[_s8B2V::P64 + 24];
           _s8B2C::I64 = I64[_s8B2V::P64 + 40];
           _s8B2F::I64 = I64[_s8B2V::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2R::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B2V_info" {
     sat_s8B2V_info:
         const sat_s8B2V_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B33_entry() //  [R1]
         { []
         }
     {offset
       c8CBH: // global
           _s8B33::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CBI; else goto c8CBJ;
       c8CBJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CBL; else goto c8CBK;
       c8CBL: // global
           HpAlloc = 56;
           goto c8CBI;
       c8CBI: // global
           R1 = _s8B33::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CBK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B33::P64;
           _s8B2H::I64 = I64[_s8B33::P64 + 56];
           _s8B2Z::I64 = I64[_s8B33::P64 + 64];
           if (_s8B2Z::I64 == _s8B2H::I64) goto c8CBG; else goto c8CBF;
       c8CBG: // global
           _s8B2P::P64 = P64[_s8B33::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CBF: // global
           _s8B2D::P64 = P64[_s8B33::P64 + 16];
           _s8B2E::P64 = P64[_s8B33::P64 + 24];
           _s8B2C::I64 = I64[_s8B33::P64 + 40];
           _s8B2F::I64 = I64[_s8B33::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2Z::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B33_info" {
     sat_s8B33_info:
         const sat_s8B33_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B3U_entry() //  [R1]
         { []
         }
     {offset
       c8CDl: // global
           _s8B3U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CDm; else goto c8CDn;
       c8CDn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDp; else goto c8CDo;
       c8CDp: // global
           HpAlloc = 56;
           goto c8CDm;
       c8CDm: // global
           R1 = _s8B3U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CDo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3U::P64;
           _s8B2H::I64 = I64[_s8B3U::P64 + 56];
           _s8B37::I64 = I64[_s8B3U::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8CDk; else goto c8CDj;
       c8CDk: // global
           _s8B2P::P64 = P64[_s8B3U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CDj: // global
           _s8B2D::P64 = P64[_s8B3U::P64 + 16];
           _s8B2E::P64 = P64[_s8B3U::P64 + 24];
           _s8B2C::I64 = I64[_s8B3U::P64 + 40];
           _s8B2F::I64 = I64[_s8B3U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B3U_info" {
     sat_s8B3U_info:
         const sat_s8B3U_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B3Z_entry() //  [R1]
         { []
         }
     {offset
       c8CDG: // global
           _s8B3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CDH; else goto c8CDI;
       c8CDI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDK; else goto c8CDJ;
       c8CDK: // global
           HpAlloc = 56;
           goto c8CDH;
       c8CDH: // global
           R1 = _s8B3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CDJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3Z::P64;
           _s8B2H::I64 = I64[_s8B3Z::P64 + 56];
           _s8B37::I64 = I64[_s8B3Z::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8CDF; else goto c8CDE;
       c8CDF: // global
           _s8B2P::P64 = P64[_s8B3Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CDE: // global
           _s8B2D::P64 = P64[_s8B3Z::P64 + 16];
           _s8B2E::P64 = P64[_s8B3Z::P64 + 24];
           _s8B2C::I64 = I64[_s8B3Z::P64 + 40];
           _s8B2F::I64 = I64[_s8B3Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B3Z_info" {
     sat_s8B3Z_info:
         const sat_s8B3Z_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CDN: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8CDO; else goto c8CDP;
       c8CDO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CDP: // global
           I64[Sp - 16] = block_c8CAV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CEV; else goto c8CAW;
       u8CEV: // global
           call _c8CAV(R1) args: 0, res: 0, upd: 0;
       c8CAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF3_info" {
     GHC.IO.Encoding.UTF32.mkUTF3_info:
         const GHC.IO.Encoding.UTF32.mkUTF3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8CAV() //  [R1]
         { []
         }
     {offset
       c8CAV: // global
           I64[Sp - 40] = block_c8CB0_info;
           _s8B2D::P64 = P64[R1 + 7];
           _s8B2E::P64 = P64[R1 + 15];
           _s8B2C::I64 = I64[R1 + 23];
           _s8B2F::I64 = I64[R1 + 31];
           _s8B2G::I64 = I64[R1 + 39];
           _s8B2H::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B2E::P64;
           I64[Sp - 24] = _s8B2F::I64;
           I64[Sp - 16] = _s8B2G::I64;
           I64[Sp - 8] = _s8B2H::I64;
           P64[Sp] = _s8B2D::P64;
           I64[Sp + 8] = _s8B2C::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8CEN; else goto c8CB1;
       u8CEN: // global
           call _c8CB0(R1) args: 0, res: 0, upd: 0;
       c8CB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CAV_info" {
     block_c8CAV_info:
         const _c8CAV;
         const 1;
         const 30;
 },
 _c8CB0() //  [R1]
         { []
         }
     {offset
       c8CB0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDT; else goto c8CDS;
       c8CDT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CDS: // global
           _s8B2K::P64 = P64[R1 + 7];
           _s8B2L::P64 = P64[R1 + 15];
           _s8B2J::I64 = I64[R1 + 23];
           _s8B2M::I64 = I64[R1 + 31];
           _s8B2N::I64 = I64[R1 + 39];
           _s8B2O::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B2K::P64;
           P64[Sp - 40] = _s8B2L::P64;
           I64[Sp - 32] = _s8B2M::I64;
           I64[Sp - 24] = _s8B2N::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B2O::I64;
           I64[Sp] = _s8B2J::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8CBQ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8CB0_info" {
     block_c8CB0_info:
         const _c8CB0;
         const 2950;
         const 30;
 },
 _c8CBQ() //  []
         { []
         }
     {offset
       c8CBQ: // global
           _s8B37::I64 = I64[Sp + 32];
           _s8B38::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B38::I64,
                            I64[Sp + 16])) goto c8CEy; else goto c8CEz;
       c8CEy: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B37::I64,
                            4)) goto c8CEv; else goto c8CEw;
       c8CEv: // global
           _s8B2C::I64 = I64[Sp + 96];
           _s8B2D::P64 = P64[Sp + 88];
           _s8B3g::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + _s8B37::I64]);
           call MO_Touch(_s8B2D::P64);
           _s8B3m::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 1)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3s::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 2)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3y::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 3)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3A::I64 = (_s8B3y::I64 << 24) + ((_s8B3s::I64 << 16) + ((_s8B3m::I64 << 8) + _s8B3g::I64));
           if (%MO_S_Lt_W64(_s8B3A::I64, 0)) goto u8CEG; else goto c8CEt;
       u8CEG: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8CER;
       c8CEt: // global
           if (%MO_S_Ge_W64(_s8B3A::I64, 55296)) goto u8CEI; else goto u8CEH;
       u8CEI: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8CER;
       u8CER: // global
           call _c8CD6() args: 0, res: 0, upd: 0;
       u8CEH: // global
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 8;
           call _s8B3M() args: 0, res: 0, upd: 0;
       c8CEw: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8CB8() args: 0, res: 0, upd: 0;
       c8CEz: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8CBu() args: 0, res: 0, upd: 0;
     }
 },
 _c8CD6() //  []
         { []
         }
     {offset
       c8CD6: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CE9; else goto c8CE8;
       c8CE9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CD6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CE8: // global
           _c8CB5::P64 = P64[Sp + 96];
           _s8B2C::I64 = I64[Sp + 120];
           _s8B2D::P64 = P64[Sp + 112];
           _s8B2E::P64 = P64[Sp + 80];
           _s8B2F::I64 = I64[Sp + 88];
           _s8B2H::I64 = I64[Sp + 104];
           _s8B2J::I64 = I64[Sp + 72];
           _s8B2K::P64 = P64[Sp + 24];
           _s8B2L::P64 = P64[Sp + 32];
           _s8B2M::I64 = I64[Sp + 40];
           _s8B2N::I64 = I64[Sp + 48];
           _s8B37::I64 = I64[Sp + 56];
           _s8B38::I64 = I64[Sp + 64];
           _s8B3L::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B3L::I64, 57343)) goto c8CEc; else goto c8CEh;
       c8CEc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3U_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8CB5::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CEh: // global
           if (%MO_S_Gt_W64(_s8B3L::I64,
                            1114111)) goto c8CEf; else goto c8CEg;
       c8CEf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3Z_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8CB5::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CEg: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B3M() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8CD6_info" {
     block_c8CD6_info:
         const _c8CD6;
         const 1408207;
         const 30;
 },
 _s8B3M() //  []
         { []
         }
     {offset
       s8B3M: // global
           _s8B2K::P64 = P64[Sp + 8];
           _s8B37::I64 = I64[Sp + 40];
           _s8B38::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B38::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B2K::P64);
           I64[Sp + 40] = _s8B37::I64 + 4;
           I64[Sp + 48] = _s8B38::I64 + 1;
           Sp = Sp + 8;
           call _c8CBQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8CB8() //  []
         { []
         }
     {offset
       c8CB8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CDX; else goto c8CDW;
       c8CDX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CB8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CDW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B2V_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CB8_info" {
     block_c8CB8_info:
         const _c8CB8;
         const 352013;
         const 30;
 },
 _c8CBu() //  []
         { []
         }
     {offset
       c8CBu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CE1; else goto c8CE0;
       c8CE1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CBu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CE0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B33_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CBu_info" {
     block_c8CBu_info:
         const _c8CBu;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.798483856 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CGM: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le_decode_info" {
     GHC.IO.Encoding.UTF32.utf32le_decode_info:
         const GHC.IO.Encoding.UTF32.utf32le_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.802310477 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.80495203 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { []
         }
     {offset
       c8CH0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CH1; else goto c8CH2;
       c8CH1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CH2: // global
           (_c8CGX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CGX::I64 == 0) goto c8CGZ; else goto c8CGY;
       c8CGZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CGY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CGX::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le2_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.809872249 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { []
         }
     {offset
       c8CHe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF2_info" {
     GHC.IO.Encoding.UTF32.mkUTF2_info:
         const GHC.IO.Encoding.UTF32.mkUTF2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.813665005 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { []
         }
     {offset
       c8CHq: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be1_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.820052079 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8B4d_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CHM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B4d_info" {
     sat_s8B4d_info:
         const sat_s8B4d_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt;
 },
 sat_s8B4f_entry() //  [R1]
         { []
         }
     {offset
       c8CHQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CHU; else goto c8CHT;
       c8CHU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CHT: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B4d_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B4f_info" {
     sat_s8B4f_info:
         const sat_s8B4f_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt;
 },
 sat_s8B49_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CI5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B49_info" {
     sat_s8B49_info:
         const sat_s8B49_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt+8;
 },
 sat_s8B4b_entry() //  [R1]
         { []
         }
     {offset
       c8CI9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CId; else goto c8CIc;
       c8CId: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CIc: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B49_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B4b_info" {
     sat_s8B4b_info:
         const sat_s8B4b_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { []
         }
     {offset
       c8CIf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CIj; else goto c8CIi;
       c8CIj: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8CIi: // global
           I64[Hp - 56] = sat_s8B4f_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B4b_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8Bun_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.832293513 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CIS; else goto c8CIT;
       c8CIS: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CIT: // global
           I64[Sp - 16] = block_c8CIL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJ1; else goto c8CIM;
       u8CJ1: // global
           call _c8CIL() args: 0, res: 0, upd: 0;
       c8CIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8AWo_info" {
     lvl_r8AWo_info:
         const lvl_r8AWo_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8Bun_srt+32;
 },
 _c8CIL() //  []
         { []
         }
     {offset
       c8CIL: // global
           _s8B4h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8CIR_info;
           R1 = _s8B4h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8CJ0; else goto c8CIV;
       u8CJ0: // global
           call _c8CIR() args: 0, res: 0, upd: 0;
       c8CIV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CIL_info" {
     block_c8CIL_info:
         const _c8CIL;
         const 1;
         const 4294967326;
         const S8Bun_srt+32;
 },
 _c8CIR() //  []
         { []
         }
     {offset
       c8CIR: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CIR_info" {
     block_c8CIR_info:
         const _c8CIR;
         const 0;
         const 4294967326;
         const S8Bun_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.839689371 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.841779119 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { []
         }
     {offset
       c8CJk: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le2_info" {
     GHC.IO.Encoding.UTF32.utf32le2_info:
         const GHC.IO.Encoding.UTF32.utf32le2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8Bun_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.846617235 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CJz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8CJD; else goto c8CJE;
       c8CJD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CJE: // global
           I64[Sp - 16] = block_c8CJw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJN; else goto c8CJx;
       u8CJN: // global
           call _c8CJw(R1) args: 0, res: 0, upd: 0;
       c8CJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be2_info" {
     GHC.IO.Encoding.UTF32.utf32be2_info:
         const GHC.IO.Encoding.UTF32.utf32be2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8Bun_srt+56;
 },
 _c8CJw() //  [R1]
         { []
         }
     {offset
       c8CJw: // global
           I64[Sp - 16] = block_c8CJC_info;
           _s8B4D::P64 = P64[R1 + 7];
           _s8B4C::I64 = I64[R1 + 23];
           _s8B4G::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8B4G::I64;
           P64[Sp] = _s8B4D::P64;
           I64[Sp + 8] = _s8B4C::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJM; else goto c8CJG;
       u8CJM: // global
           call _c8CJC() args: 0, res: 0, upd: 0;
       c8CJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CJw_info" {
     block_c8CJw_info:
         const _c8CJw;
         const 1;
         const 4294967326;
         const S8Bun_srt+56;
 },
 _c8CJC() //  []
         { []
         }
     {offset
       c8CJC: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CJC_info" {
     block_c8CJC_info:
         const _c8CJC;
         const 323;
         const 4294967326;
         const S8Bun_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.853493272 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.855587055 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { []
         }
     {offset
       c8CK6: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le1_info" {
     GHC.IO.Encoding.UTF32.utf32le1_info:
         const GHC.IO.Encoding.UTF32.utf32le1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8Bun_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.858799358 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.870263605 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8B5h_entry() //  [R1]
         { []
         }
     {offset
       c8CKJ: // global
           _s8B5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CKK; else goto c8CKL;
       c8CKL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CKN; else goto c8CKM;
       c8CKN: // global
           HpAlloc = 56;
           goto c8CKK;
       c8CKK: // global
           R1 = _s8B5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5h::P64;
           _s8B53::I64 = I64[_s8B5h::P64 + 56];
           _s8B5d::I64 = I64[_s8B5h::P64 + 64];
           if (_s8B5d::I64 == _s8B53::I64) goto c8CKI; else goto c8CKH;
       c8CKI: // global
           _s8B5b::P64 = P64[_s8B5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CKH: // global
           _s8B4Z::P64 = P64[_s8B5h::P64 + 16];
           _s8B50::P64 = P64[_s8B5h::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5h::P64 + 40];
           _s8B51::I64 = I64[_s8B5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5d::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B5h_info" {
     sat_s8B5h_info:
         const sat_s8B5h_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B5p_entry() //  [R1]
         { []
         }
     {offset
       c8CL5: // global
           _s8B5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CL6; else goto c8CL7;
       c8CL7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CL9; else goto c8CL8;
       c8CL9: // global
           HpAlloc = 56;
           goto c8CL6;
       c8CL6: // global
           R1 = _s8B5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5p::P64;
           _s8B53::I64 = I64[_s8B5p::P64 + 56];
           _s8B5l::I64 = I64[_s8B5p::P64 + 64];
           if (_s8B5l::I64 == _s8B53::I64) goto c8CL4; else goto c8CL3;
       c8CL4: // global
           _s8B5b::P64 = P64[_s8B5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CL3: // global
           _s8B4Z::P64 = P64[_s8B5p::P64 + 16];
           _s8B50::P64 = P64[_s8B5p::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5p::P64 + 40];
           _s8B51::I64 = I64[_s8B5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5l::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B5p_info" {
     sat_s8B5p_info:
         const sat_s8B5p_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B6g_entry() //  [R1]
         { []
         }
     {offset
       c8CMJ: // global
           _s8B6g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CMK; else goto c8CML;
       c8CML: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CMN; else goto c8CMM;
       c8CMN: // global
           HpAlloc = 56;
           goto c8CMK;
       c8CMK: // global
           R1 = _s8B6g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6g::P64;
           _s8B53::I64 = I64[_s8B6g::P64 + 56];
           _s8B5t::I64 = I64[_s8B6g::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8CMI; else goto c8CMH;
       c8CMI: // global
           _s8B5b::P64 = P64[_s8B6g::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CMH: // global
           _s8B4Z::P64 = P64[_s8B6g::P64 + 16];
           _s8B50::P64 = P64[_s8B6g::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6g::P64 + 40];
           _s8B51::I64 = I64[_s8B6g::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B6g_info" {
     sat_s8B6g_info:
         const sat_s8B6g_entry;
         const 17179869187;
         const 15;
 },
 sat_s8B6l_entry() //  [R1]
         { []
         }
     {offset
       c8CN4: // global
           _s8B6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CN5; else goto c8CN6;
       c8CN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CN8; else goto c8CN7;
       c8CN8: // global
           HpAlloc = 56;
           goto c8CN5;
       c8CN5: // global
           R1 = _s8B6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6l::P64;
           _s8B53::I64 = I64[_s8B6l::P64 + 56];
           _s8B5t::I64 = I64[_s8B6l::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8CN3; else goto c8CN2;
       c8CN3: // global
           _s8B5b::P64 = P64[_s8B6l::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CN2: // global
           _s8B4Z::P64 = P64[_s8B6l::P64 + 16];
           _s8B50::P64 = P64[_s8B6l::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6l::P64 + 40];
           _s8B51::I64 = I64[_s8B6l::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8B6l_info" {
     sat_s8B6l_info:
         const sat_s8B6l_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CNb: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8CNc; else goto c8CNd;
       c8CNc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CNd: // global
           I64[Sp - 16] = block_c8CKj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8COj; else goto c8CKk;
       u8COj: // global
           call _c8CKj(R1) args: 0, res: 0, upd: 0;
       c8CKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF5_info" {
     GHC.IO.Encoding.UTF32.mkUTF5_info:
         const GHC.IO.Encoding.UTF32.mkUTF5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8CKj() //  [R1]
         { []
         }
     {offset
       c8CKj: // global
           I64[Sp - 40] = block_c8CKo_info;
           _s8B4Z::P64 = P64[R1 + 7];
           _s8B50::P64 = P64[R1 + 15];
           _s8B4Y::I64 = I64[R1 + 23];
           _s8B51::I64 = I64[R1 + 31];
           _s8B52::I64 = I64[R1 + 39];
           _s8B53::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B50::P64;
           I64[Sp - 24] = _s8B51::I64;
           I64[Sp - 16] = _s8B52::I64;
           I64[Sp - 8] = _s8B53::I64;
           P64[Sp] = _s8B4Z::P64;
           I64[Sp + 8] = _s8B4Y::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8COb; else goto c8CKp;
       u8COb: // global
           call _c8CKo(R1) args: 0, res: 0, upd: 0;
       c8CKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CKj_info" {
     block_c8CKj_info:
         const _c8CKj;
         const 1;
         const 30;
 },
 _c8CKo() //  [R1]
         { []
         }
     {offset
       c8CKo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CNh; else goto c8CNg;
       c8CNh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CNg: // global
           _s8B56::P64 = P64[R1 + 7];
           _s8B57::P64 = P64[R1 + 15];
           _s8B55::I64 = I64[R1 + 23];
           _s8B58::I64 = I64[R1 + 31];
           _s8B59::I64 = I64[R1 + 39];
           _s8B5a::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B56::P64;
           P64[Sp - 40] = _s8B57::P64;
           I64[Sp - 32] = _s8B58::I64;
           I64[Sp - 24] = _s8B59::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B5a::I64;
           I64[Sp] = _s8B55::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8CLe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8CKo_info" {
     block_c8CKo_info:
         const _c8CKo;
         const 2950;
         const 30;
 },
 _c8CLe() //  []
         { []
         }
     {offset
       c8CLe: // global
           _s8B5t::I64 = I64[Sp + 32];
           _s8B5u::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B5u::I64,
                            I64[Sp + 16])) goto c8CNW; else goto c8CNX;
       c8CNW: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B5t::I64,
                            4)) goto c8CNT; else goto c8CNU;
       c8CNT: // global
           _s8B4Y::I64 = I64[Sp + 96];
           _s8B4Z::P64 = P64[Sp + 88];
           _s8B5C::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + _s8B5t::I64]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5I::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 1)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5O::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 2)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5U::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 3)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5W::I64 = (_s8B5C::I64 << 24) + ((_s8B5I::I64 << 16) + ((_s8B5O::I64 << 8) + _s8B5U::I64));
           if (%MO_S_Lt_W64(_s8B5W::I64, 0)) goto u8CO4; else goto c8CNR;
       u8CO4: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8COf;
       c8CNR: // global
           if (%MO_S_Ge_W64(_s8B5W::I64, 55296)) goto u8CO6; else goto u8CO5;
       u8CO6: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8COf;
       u8COf: // global
           call _c8CMu() args: 0, res: 0, upd: 0;
       u8CO5: // global
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 8;
           call _s8B68() args: 0, res: 0, upd: 0;
       c8CNU: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8CKw() args: 0, res: 0, upd: 0;
       c8CNX: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8CKS() args: 0, res: 0, upd: 0;
     }
 },
 _c8CMu() //  []
         { []
         }
     {offset
       c8CMu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNx; else goto c8CNw;
       c8CNx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CMu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNw: // global
           _c8CKt::P64 = P64[Sp + 96];
           _s8B4Y::I64 = I64[Sp + 120];
           _s8B4Z::P64 = P64[Sp + 112];
           _s8B50::P64 = P64[Sp + 80];
           _s8B51::I64 = I64[Sp + 88];
           _s8B53::I64 = I64[Sp + 104];
           _s8B55::I64 = I64[Sp + 72];
           _s8B56::P64 = P64[Sp + 24];
           _s8B57::P64 = P64[Sp + 32];
           _s8B58::I64 = I64[Sp + 40];
           _s8B59::I64 = I64[Sp + 48];
           _s8B5t::I64 = I64[Sp + 56];
           _s8B5u::I64 = I64[Sp + 64];
           _s8B67::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B67::I64, 57343)) goto c8CNA; else goto c8CNF;
       c8CNA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6g_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8CKt::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CNF: // global
           if (%MO_S_Gt_W64(_s8B67::I64,
                            1114111)) goto c8CND; else goto c8CNE;
       c8CND: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6l_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8CKt::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CNE: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B68() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8CMu_info" {
     block_c8CMu_info:
         const _c8CMu;
         const 1408207;
         const 30;
 },
 _s8B68() //  []
         { []
         }
     {offset
       s8B68: // global
           _s8B56::P64 = P64[Sp + 8];
           _s8B5t::I64 = I64[Sp + 40];
           _s8B5u::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B5u::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B56::P64);
           I64[Sp + 40] = _s8B5t::I64 + 4;
           I64[Sp + 48] = _s8B5u::I64 + 1;
           Sp = Sp + 8;
           call _c8CLe() args: 0, res: 0, upd: 0;
     }
 },
 _c8CKw() //  []
         { []
         }
     {offset
       c8CKw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNl; else goto c8CNk;
       c8CNl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CKw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CKw_info" {
     block_c8CKw_info:
         const _c8CKw;
         const 352013;
         const 30;
 },
 _c8CKS() //  []
         { []
         }
     {offset
       c8CKS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNp; else goto c8CNo;
       c8CNp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CKS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CKS_info" {
     block_c8CKS_info:
         const _c8CKS;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.898110392 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CQa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be_decode_info" {
     GHC.IO.Encoding.UTF32.utf32be_decode_info:
         const GHC.IO.Encoding.UTF32.utf32be_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.901296271 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.903546815 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { []
         }
     {offset
       c8CQo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CQp; else goto c8CQq;
       c8CQp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CQq: // global
           (_c8CQl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CQl::I64 == 0) goto c8CQn; else goto c8CQm;
       c8CQn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CQm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CQl::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be2_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.90921074 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8B6w_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CQM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B6w_info" {
     sat_s8B6w_info:
         const sat_s8B6w_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt;
 },
 sat_s8B6y_entry() //  [R1]
         { []
         }
     {offset
       c8CQQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CQU; else goto c8CQT;
       c8CQU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CQT: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6w_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B6y_info" {
     sat_s8B6y_info:
         const sat_s8B6y_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt;
 },
 sat_s8B6s_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CR5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B6s_info" {
     sat_s8B6s_info:
         const sat_s8B6s_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt+8;
 },
 sat_s8B6u_entry() //  [R1]
         { []
         }
     {offset
       c8CR9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CRd; else goto c8CRc;
       c8CRd: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CRc: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6s_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B6u_info" {
     sat_s8B6u_info:
         const sat_s8B6u_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { []
         }
     {offset
       c8CRf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CRj; else goto c8CRi;
       c8CRj: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8CRi: // global
           I64[Hp - 56] = sat_s8B6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B6u_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8Bun_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.919613797 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.921750804 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { []
         }
     {offset
       c8CRM: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be3_info" {
     GHC.IO.Encoding.UTF32.utf32be3_info:
         const GHC.IO.Encoding.UTF32.utf32be3_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8Bun_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.924957193 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.927121038 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { []
         }
     {offset
       c8CRZ: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be1_info" {
     GHC.IO.Encoding.UTF32.utf32be1_info:
         const GHC.IO.Encoding.UTF32.utf32be1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8Bun_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.930839542 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.932663133 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.934505921 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.94240386 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { []
         }
     {offset
       c8CSb: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8CSm: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8CSn; else goto c8CSo;
       c8CSn: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8CSo: // global
           I64[Sp - 48] = block_c8CSf_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8CUB; else goto c8CSg;
       u8CUB: // global
           call _c8CSf(R1) args: 0, res: 0, upd: 0;
       c8CSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.$wutf32_decode_info" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_info:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 7304;
         const GHC.IO.Encoding.UTF32.$wutf32_decode_slow;
 },
 _c8CSf() //  [R1]
         { []
         }
     {offset
       c8CSf: // global
           _s8B6C::I64 = I64[Sp + 16];
           _s8B6D::P64 = P64[Sp + 24];
           _s8B6E::P64 = P64[Sp + 32];
           _s8B6F::I64 = I64[Sp + 40];
           _s8B6G::I64 = I64[Sp + 48];
           _s8B6H::I64 = I64[Sp + 56];
           _s8B6I::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8CSj; else goto c8CSk;
       c8CSj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8CSt; else goto c8CSs;
       c8CSt: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CSs: // global
           if (%MO_S_Ge_W64(_s8B6H::I64 - _s8B6G::I64,
                            4)) goto c8CUo; else goto c8CUs;
       c8CUo: // global
           _s8B6B::P64 = P64[Sp + 8];
           _s8B6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + _s8B6G::I64]);
           call MO_Touch(_s8B6D::P64);
           _s8B6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 1)]);
           call MO_Touch(_s8B6D::P64);
           _s8B75::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 2)]);
           call MO_Touch(_s8B6D::P64);
           _s8B7b::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 3)]);
           call MO_Touch(_s8B6D::P64);
           if (_s8B6T::I64 != 0) goto c8CU9; else goto c8CUm;
       c8CUm: // global
           if (_s8B6Z::I64 != 0) goto c8CU9; else goto c8CUl;
       c8CUl: // global
           if (_s8B75::I64 != 254) goto c8CU9; else goto c8CUk;
       c8CUk: // global
           if (_s8B7b::I64 != 255) goto c8CU9; else goto c8CUj;
       c8CU9: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8B6Z::I64;
           I64[Sp - 16] = _s8B75::I64;
           I64[Sp - 8] = _s8B7b::I64;
           I64[Sp] = _s8B6T::I64;
           Sp = Sp - 32;
           call _c8CT2() args: 0, res: 0, upd: 0;
       c8CUj: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64 + 4;
           I64[Hp - 32] = _s8B6H::I64;
           _c8CUi::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8B6I::P64;
           R2 = _c8CUi::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CUs: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64;
           I64[Hp - 32] = _s8B6H::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8B6I::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CSk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CUy; else goto c8CUx;
       c8CUy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CUx: // global
           _s8B7C::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           R1 = _s8B7C::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CSf_info" {
     block_c8CSf_info:
         const _c8CSf;
         const 7304;
         const 30;
 },
 _c8CT2() //  []
         { []
         }
     {offset
       c8CT2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CT6; else goto c8CT5;
       c8CT6: // global
           HpAlloc = 56;
           I64[Sp] = block_c8CT2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CT5: // global
           _s8B6B::P64 = P64[Sp + 40];
           _s8B6C::I64 = I64[Sp + 48];
           _s8B6D::P64 = P64[Sp + 56];
           _s8B6E::P64 = P64[Sp + 64];
           _s8B6F::I64 = I64[Sp + 72];
           _s8B6G::I64 = I64[Sp + 80];
           _s8B6H::I64 = I64[Sp + 88];
           _s8B6I::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8CTR; else goto c8CTe;
       c8CTR: // global
           if (I64[Sp + 8] == 254) goto c8CTQ; else goto c8CTn;
       c8CTQ: // global
           if (I64[Sp + 16] == 0) goto c8CTP; else goto c8CTw;
       c8CTP: // global
           if (I64[Sp + 24] == 0) goto c8CTO; else goto c8CTF;
       c8CTO: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64 + 4;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTF: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTw: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTn: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTe: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CT2_info" {
     block_c8CT2_info:
         const _c8CT2;
         const 117708;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.956797142 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8CVe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CVi; else goto c8CVj;
       c8CVi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CVj: // global
           I64[Sp - 24] = block_c8CVb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CVr; else goto c8CVc;
       u8CVr: // global
           call _c8CVb(R1) args: 0, res: 0, upd: 0;
       c8CVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_decode1_info" {
     GHC.IO.Encoding.UTF32.utf32_decode1_info:
         const GHC.IO.Encoding.UTF32.utf32_decode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8CVb() //  [R1]
         { []
         }
     {offset
       c8CVb: // global
           I64[Sp] = block_c8CVh_info;
           _s8B7J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8B7J::P64;
           if (R1 & 7 != 0) goto u8CVq; else goto c8CVl;
       u8CVq: // global
           call _c8CVh(R1) args: 0, res: 0, upd: 0;
       c8CVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CVb_info" {
     block_c8CVb_info:
         const _c8CVb;
         const 2;
         const 30;
 },
 _c8CVh() //  [R1]
         { []
         }
     {offset
       c8CVh: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CVh_info" {
     block_c8CVh_info:
         const _c8CVh;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.963609345 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8CVL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_decode_info" {
     GHC.IO.Encoding.UTF32.utf32_decode_info:
         const GHC.IO.Encoding.UTF32.utf32_decode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.969405542 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { []
         }
     {offset
       c8CVT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8CW4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8CW5; else goto c8CW6;
       c8CW5: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8CW6: // global
           I64[Sp - 48] = block_c8CVX_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8CX0; else goto c8CVY;
       u8CX0: // global
           call _c8CVX(R1) args: 0, res: 0, upd: 0;
       c8CVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.$wutf32_encode_info" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_info:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 14600;
         const GHC.IO.Encoding.UTF32.$wutf32_encode_slow;
 },
 _c8CVX() //  [R1]
         { []
         }
     {offset
       c8CVX: // global
           _s8B7S::P64 = P64[Sp + 16];
           _s8B7T::I64 = I64[Sp + 24];
           _s8B7U::P64 = P64[Sp + 32];
           _s8B7V::P64 = P64[Sp + 40];
           _s8B7W::I64 = I64[Sp + 48];
           _s8B7X::I64 = I64[Sp + 56];
           _s8B7Y::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8CW1; else goto c8CW2;
       c8CW1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8CWb; else goto c8CWa;
       c8CWb: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CWa: // global
           if (%MO_S_Ge_W64(_s8B7W::I64 - _s8B7Y::I64,
                            4)) goto c8CWP; else goto c8CWT;
       c8CWP: // global
           _s8B7R::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8B7R::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B7R::P64);
           I8[_s8B7T::I64 + _s8B7Y::I64] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8B7U::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64 + 4;
           _c8CWN::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8CWN::P64;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CWT: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8B7S::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CW2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CWZ; else goto c8CWY;
       c8CWZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CWY: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B7U::P64;
           P64[Hp - 32] = _s8B7V::P64;
           I64[Hp - 24] = _s8B7T::I64;
           I64[Hp - 16] = _s8B7W::I64;
           I64[Hp - 8] = _s8B7X::I64;
           I64[Hp] = _s8B7Y::I64;
           R3 = Hp - 47;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CVX_info" {
     block_c8CVX_info:
         const _c8CVX;
         const 14600;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.979432434 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8CXu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CXy; else goto c8CXz;
       c8CXy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CXz: // global
           I64[Sp - 24] = block_c8CXr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CXH; else goto c8CXs;
       u8CXH: // global
           call _c8CXr(R1) args: 0, res: 0, upd: 0;
       c8CXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_encode1_info" {
     GHC.IO.Encoding.UTF32.utf32_encode1_info:
         const GHC.IO.Encoding.UTF32.utf32_encode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8CXr() //  [R1]
         { []
         }
     {offset
       c8CXr: // global
           I64[Sp] = block_c8CXx_info;
           _s8B8w::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8B8w::P64;
           if (R1 & 7 != 0) goto u8CXG; else goto c8CXB;
       u8CXG: // global
           call _c8CXx(R1) args: 0, res: 0, upd: 0;
       c8CXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CXr_info" {
     block_c8CXr_info:
         const _c8CXr;
         const 2;
         const 30;
 },
 _c8CXx() //  [R1]
         { []
         }
     {offset
       c8CXx: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CXx_info" {
     block_c8CXx_info:
         const _c8CXx;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.986359712 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8CY2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_encode_info" {
     GHC.IO.Encoding.UTF32.utf32_encode_info:
         const GHC.IO.Encoding.UTF32.utf32_encode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.990119905 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:43.992561103 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { []
         }
     {offset
       c8CYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CYh; else goto c8CYi;
       c8CYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CYi: // global
           (_c8CYd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CYd::I64 == 0) goto c8CYf; else goto c8CYe;
       c8CYf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CYe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CYd::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF7_info" {
     GHC.IO.Encoding.UTF32.mkUTF7_info:
         const GHC.IO.Encoding.UTF32.mkUTF7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:44.00190885 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8B9o_entry() //  [R1, R2]
         { []
         }
     {offset
       c8CYJ: // global
           _s8B96::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B96::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B96::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B9o_info" {
     sat_s8B9o_info:
         const sat_s8B9o_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8B9k_entry() //  [R1]
         { []
         }
     {offset
       c8CYS: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B9k_info" {
     sat_s8B9k_info:
         const sat_s8B9k_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8B9i_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CZ0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B9i_info" {
     sat_s8B9i_info:
         const sat_s8B9i_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt;
 },
 sat_s8B9h_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CZb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CZc; else goto c8CZd;
       c8CZc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CZd: // global
           I64[Sp - 24] = block_c8CZ8_info;
           _s8B96::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8B96::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CZh; else goto c8CZ9;
       u8CZh: // global
           call _c8CZ8(R1) args: 0, res: 0, upd: 0;
       c8CZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B9h_info" {
     sat_s8B9h_info:
         const sat_s8B9h_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8CZ8() //  [R1]
         { []
         }
     {offset
       c8CZ8: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CZ8_info" {
     block_c8CZ8_info:
         const _c8CZ8;
         const 2;
         const 30;
 },
 sat_s8B9q_entry() //  [R1]
         { []
         }
     {offset
       c8CZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CZk; else goto c8CZl;
       c8CZk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CZl: // global
           I64[Sp - 16] = block_c8CYz_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B9q_info" {
     sat_s8B9q_info:
         const sat_s8B9q_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt;
 },
 _c8CYz() //  [R1]
         { []
         }
     {offset
       c8CYz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8CZo; else goto c8CZn;
       c8CZo: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CZn: // global
           I64[Hp - 104] = sat_s8B9o_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B9k_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B9i_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B9h_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CYz_info" {
     block_c8CYz_info:
         const _c8CYz;
         const 1;
         const 4294967326;
         const S8Bun_srt;
 },
 sat_s8B90_entry() //  [R1, R2]
         { []
         }
     {offset
       c8CZE: // global
           _s8B8I::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B8I::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B8I::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B90_info" {
     sat_s8B90_info:
         const sat_s8B90_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8B8W_entry() //  [R1]
         { []
         }
     {offset
       c8CZN: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B8W_info" {
     sat_s8B8W_info:
         const sat_s8B8W_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8B8U_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8CZV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B8U_info" {
     sat_s8B8U_info:
         const sat_s8B8U_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8Bun_srt+8;
 },
 sat_s8B8T_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8D06: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8D07; else goto c8D08;
       c8D07: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8D08: // global
           I64[Sp - 24] = block_c8D03_info;
           _s8B8I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8B8I::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8D0c; else goto c8D04;
       u8D0c: // global
           call _c8D03(R1) args: 0, res: 0, upd: 0;
       c8D04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B8T_info" {
     sat_s8B8T_info:
         const sat_s8B8T_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8D03() //  [R1]
         { []
         }
     {offset
       c8D03: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8D03_info" {
     block_c8D03_info:
         const _c8D03;
         const 2;
         const 30;
 },
 sat_s8B92_entry() //  [R1]
         { []
         }
     {offset
       c8D0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8D0f; else goto c8D0g;
       c8D0f: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8D0g: // global
           I64[Sp - 16] = block_c8CZu_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8B92_info" {
     sat_s8B92_info:
         const sat_s8B92_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8Bun_srt+8;
 },
 _c8CZu() //  [R1]
         { []
         }
     {offset
       c8CZu: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8D0j; else goto c8D0i;
       c8D0j: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8D0i: // global
           I64[Hp - 104] = sat_s8B90_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B8W_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B8U_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B8T_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8CZu_info" {
     block_c8CZu_info:
         const _c8CZu;
         const 1;
         const 4294967326;
         const S8Bun_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { []
         }
     {offset
       c8D0l: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8D0p; else goto c8D0o;
       c8D0p: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8D0o: // global
           I64[Hp - 56] = sat_s8B9q_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B92_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32_info" {
     GHC.IO.Encoding.UTF32.mkUTF32_info:
         const GHC.IO.Encoding.UTF32.mkUTF32_entry;
         const 0;
         const 211119117434894;
         const 4294967301;
         const S8Bun_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:44.029171688 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { []
         }
     {offset
       c8D1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8D1P; else goto c8D1Q;
       c8D1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8D1Q: // global
           (_c8D1L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8D1L::I64 == 0) goto c8D1N; else goto c8D1M;
       c8D1N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8D1M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8D1L::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_info" {
     GHC.IO.Encoding.UTF32.utf32_info:
         const GHC.IO.Encoding.UTF32.utf32_entry;
         const 0;
         const 4294967317;
         const S8Bun_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:44.033143224 UTC

[section ""relreadonly" . S8Bun_srt" {
     S8Bun_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.600105915 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:47.601197676 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.602988531 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.604710545 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.606446896 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.60825339 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.624711412 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8D2m_entry() //  [R1]
         { []
         }
     {offset
       c8Dfv: // global
           _s8D2m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dfw; else goto c8Dfx;
       c8Dfx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dfz; else goto c8Dfy;
       c8Dfz: // global
           HpAlloc = 56;
           goto c8Dfw;
       c8Dfw: // global
           R1 = _s8D2m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dfy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2m::P64;
           _s8D28::I64 = I64[_s8D2m::P64 + 56];
           _s8D2i::I64 = I64[_s8D2m::P64 + 64];
           if (_s8D2i::I64 == _s8D28::I64) goto c8Dfu; else goto c8Dft;
       c8Dfu: // global
           _s8D2g::P64 = P64[_s8D2m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dft: // global
           _s8D24::P64 = P64[_s8D2m::P64 + 16];
           _s8D25::P64 = P64[_s8D2m::P64 + 24];
           _s8D23::I64 = I64[_s8D2m::P64 + 40];
           _s8D26::I64 = I64[_s8D2m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2i::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D2m_info" {
     sat_s8D2m_info:
         const sat_s8D2m_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D2u_entry() //  [R1]
         { []
         }
     {offset
       c8DfR: // global
           _s8D2u::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DfS; else goto c8DfT;
       c8DfT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DfV; else goto c8DfU;
       c8DfV: // global
           HpAlloc = 56;
           goto c8DfS;
       c8DfS: // global
           R1 = _s8D2u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DfU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2u::P64;
           _s8D28::I64 = I64[_s8D2u::P64 + 56];
           _s8D2q::I64 = I64[_s8D2u::P64 + 64];
           if (_s8D2q::I64 == _s8D28::I64) goto c8DfQ; else goto c8DfP;
       c8DfQ: // global
           _s8D2g::P64 = P64[_s8D2u::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DfP: // global
           _s8D24::P64 = P64[_s8D2u::P64 + 16];
           _s8D25::P64 = P64[_s8D2u::P64 + 24];
           _s8D23::I64 = I64[_s8D2u::P64 + 40];
           _s8D26::I64 = I64[_s8D2u::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2q::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D2u_info" {
     sat_s8D2u_info:
         const sat_s8D2u_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D2C_entry() //  [R1]
         { []
         }
     {offset
       c8Dgd: // global
           _s8D2C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dge; else goto c8Dgf;
       c8Dgf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dgh; else goto c8Dgg;
       c8Dgh: // global
           HpAlloc = 56;
           goto c8Dge;
       c8Dge: // global
           R1 = _s8D2C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dgg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2C::P64;
           _s8D28::I64 = I64[_s8D2C::P64 + 56];
           _s8D2y::I64 = I64[_s8D2C::P64 + 64];
           if (_s8D2y::I64 == _s8D28::I64) goto c8Dgc; else goto c8Dgb;
       c8Dgc: // global
           _s8D2g::P64 = P64[_s8D2C::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dgb: // global
           _s8D24::P64 = P64[_s8D2C::P64 + 16];
           _s8D25::P64 = P64[_s8D2C::P64 + 24];
           _s8D23::I64 = I64[_s8D2C::P64 + 40];
           _s8D26::I64 = I64[_s8D2C::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2y::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D2C_info" {
     sat_s8D2C_info:
         const sat_s8D2C_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D2K_entry() //  [R1]
         { []
         }
     {offset
       c8Dgz: // global
           _s8D2K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DgA; else goto c8DgB;
       c8DgB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DgD; else goto c8DgC;
       c8DgD: // global
           HpAlloc = 56;
           goto c8DgA;
       c8DgA: // global
           R1 = _s8D2K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2K::P64;
           _s8D28::I64 = I64[_s8D2K::P64 + 56];
           _s8D2G::I64 = I64[_s8D2K::P64 + 64];
           if (_s8D2G::I64 == _s8D28::I64) goto c8Dgy; else goto c8Dgx;
       c8Dgy: // global
           _s8D2g::P64 = P64[_s8D2K::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dgx: // global
           _s8D24::P64 = P64[_s8D2K::P64 + 16];
           _s8D25::P64 = P64[_s8D2K::P64 + 24];
           _s8D23::I64 = I64[_s8D2K::P64 + 40];
           _s8D26::I64 = I64[_s8D2K::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2G::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D2K_info" {
     sat_s8D2K_info:
         const sat_s8D2K_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D2S_entry() //  [R1]
         { []
         }
     {offset
       c8DgV: // global
           _s8D2S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DgW; else goto c8DgX;
       c8DgX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DgZ; else goto c8DgY;
       c8DgZ: // global
           HpAlloc = 56;
           goto c8DgW;
       c8DgW: // global
           R1 = _s8D2S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DgY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2S::P64;
           _s8D28::I64 = I64[_s8D2S::P64 + 56];
           _s8D2O::I64 = I64[_s8D2S::P64 + 64];
           if (_s8D2O::I64 == _s8D28::I64) goto c8DgU; else goto c8DgT;
       c8DgU: // global
           _s8D2g::P64 = P64[_s8D2S::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DgT: // global
           _s8D24::P64 = P64[_s8D2S::P64 + 16];
           _s8D25::P64 = P64[_s8D2S::P64 + 24];
           _s8D23::I64 = I64[_s8D2S::P64 + 40];
           _s8D26::I64 = I64[_s8D2S::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2O::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D2S_info" {
     sat_s8D2S_info:
         const sat_s8D2S_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Dh2: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Dh3; else goto c8Dh4;
       c8Dh3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Dh4: // global
           I64[Sp - 16] = block_c8Df5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DmG; else goto c8Df6;
       u8DmG: // global
           call _c8Df5(R1) args: 0, res: 0, upd: 0;
       c8Df6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le1_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Df5() //  [R1]
         { []
         }
     {offset
       c8Df5: // global
           I64[Sp - 40] = block_c8Dfa_info;
           _s8D24::P64 = P64[R1 + 7];
           _s8D25::P64 = P64[R1 + 15];
           _s8D23::I64 = I64[R1 + 23];
           _s8D26::I64 = I64[R1 + 31];
           _s8D27::I64 = I64[R1 + 39];
           _s8D28::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D25::P64;
           I64[Sp - 24] = _s8D26::I64;
           I64[Sp - 16] = _s8D27::I64;
           I64[Sp - 8] = _s8D28::I64;
           P64[Sp] = _s8D24::P64;
           I64[Sp + 8] = _s8D23::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DmA; else goto c8Dfb;
       u8DmA: // global
           call _c8Dfa(R1) args: 0, res: 0, upd: 0;
       c8Dfb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Df5_info" {
     block_c8Df5_info:
         const _c8Df5;
         const 1;
         const 30;
 },
 _c8Dfa() //  [R1]
         { []
         }
     {offset
       c8Dfa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dh8; else goto c8Dh7;
       c8Dh8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Dh7: // global
           _s8D2b::P64 = P64[R1 + 7];
           _s8D2c::P64 = P64[R1 + 15];
           _s8D2a::I64 = I64[R1 + 23];
           _s8D2d::I64 = I64[R1 + 31];
           _s8D2e::I64 = I64[R1 + 39];
           _s8D2f::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8D24::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8D23::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8D28::I64 = I64[Sp + 32];
           _c8Dff::P64 = Hp - 47;
           _s8D2X::I64 = _s8D2f::I64;
           _s8D2W::I64 = I64[Sp + 24];
           goto c8Dhv;
       c8Dhv: // global
           if (%MO_S_Lt_W64(_s8D2W::I64,
                            _s8D28::I64)) goto c8Dir; else goto c8Dis;
       c8Dir: // global
           if (%MO_S_Ge_W64(_s8D2d::I64 - _s8D2X::I64,
                            4)) goto c8Dio; else goto c8Dip;
       c8Dio: // global
           _s8D34::I64 = %MO_UU_Conv_W32_W64(I32[_s8D23::I64 + (_s8D2W::I64 << 2)]);
           call MO_Touch(_s8D24::P64);
           if (%MO_S_Gt_W64(55296, _s8D34::I64)) goto c8Di2; else goto c8Dim;
       c8Di2: // global
           if (%MO_S_Gt_W64(56320, _s8D34::I64)) goto c8DhS; else goto c8Di0;
       c8DhS: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Di0: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 57343)) goto c8DhY; else goto c8DhZ;
       c8DhY: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8DhZ: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dfi() args: 0, res: 0, upd: 0;
       c8Dim: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 56319)) goto c8Dik; else goto c8Dil;
       c8Dik: // global
           if (%MO_S_Gt_W64(56320, _s8D34::I64)) goto c8Dia; else goto c8Dii;
       c8Dia: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Dii: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 57343)) goto c8Dig; else goto c8Dih;
       c8Dig: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Dih: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8DfE() args: 0, res: 0, upd: 0;
       c8Dil: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dg0() args: 0, res: 0, upd: 0;
       c8Dip: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dgm() args: 0, res: 0, upd: 0;
       c8Dis: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8DgI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Dfa_info" {
     block_c8Dfa_info:
         const _c8Dfa;
         const 2950;
         const 30;
 },
 _c8Dfi() //  []
         { []
         }
     {offset
       c8Dfi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhc; else goto c8Dhb;
       c8Dhc: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dfi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhb: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2m_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Dfi_info" {
     block_c8Dfi_info:
         const _c8Dfi;
         const 352013;
         const 30;
 },
 _c8DfE() //  []
         { []
         }
     {offset
       c8DfE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhg; else goto c8Dhf;
       c8Dhg: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DfE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2u_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DfE_info" {
     block_c8DfE_info:
         const _c8DfE;
         const 352013;
         const 30;
 },
 _c8Dg0() //  []
         { []
         }
     {offset
       c8Dg0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhk; else goto c8Dhj;
       c8Dhk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dg0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2C_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Dg0_info" {
     block_c8Dg0_info:
         const _c8Dg0;
         const 352013;
         const 30;
 },
 _c8Dgm() //  []
         { []
         }
     {offset
       c8Dgm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dho; else goto c8Dhn;
       c8Dho: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dgm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2K_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Dgm_info" {
     block_c8Dgm_info:
         const _c8Dgm;
         const 352013;
         const 30;
 },
 _c8DgI() //  []
         { []
         }
     {offset
       c8DgI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhs; else goto c8Dhr;
       c8Dhs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DgI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2S_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DgI_info" {
     block_c8DgI_info:
         const _c8DgI;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.674864806 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Dqg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le_encode_info" {
     GHC.IO.Encoding.UTF32.utf32le_encode_info:
         const GHC.IO.Encoding.UTF32.utf32le_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.691160854 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8D5o_entry() //  [R1]
         { []
         }
     {offset
       c8DqR: // global
           _s8D5o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DqS; else goto c8DqT;
       c8DqT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DqV; else goto c8DqU;
       c8DqV: // global
           HpAlloc = 56;
           goto c8DqS;
       c8DqS: // global
           R1 = _s8D5o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DqU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5o::P64;
           _s8D5a::I64 = I64[_s8D5o::P64 + 56];
           _s8D5k::I64 = I64[_s8D5o::P64 + 64];
           if (_s8D5k::I64 == _s8D5a::I64) goto c8DqQ; else goto c8DqP;
       c8DqQ: // global
           _s8D5i::P64 = P64[_s8D5o::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DqP: // global
           _s8D56::P64 = P64[_s8D5o::P64 + 16];
           _s8D57::P64 = P64[_s8D5o::P64 + 24];
           _s8D55::I64 = I64[_s8D5o::P64 + 40];
           _s8D58::I64 = I64[_s8D5o::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5k::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D5o_info" {
     sat_s8D5o_info:
         const sat_s8D5o_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D5w_entry() //  [R1]
         { []
         }
     {offset
       c8Drd: // global
           _s8D5w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dre; else goto c8Drf;
       c8Drf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Drh; else goto c8Drg;
       c8Drh: // global
           HpAlloc = 56;
           goto c8Dre;
       c8Dre: // global
           R1 = _s8D5w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Drg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5w::P64;
           _s8D5a::I64 = I64[_s8D5w::P64 + 56];
           _s8D5s::I64 = I64[_s8D5w::P64 + 64];
           if (_s8D5s::I64 == _s8D5a::I64) goto c8Drc; else goto c8Drb;
       c8Drc: // global
           _s8D5i::P64 = P64[_s8D5w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Drb: // global
           _s8D56::P64 = P64[_s8D5w::P64 + 16];
           _s8D57::P64 = P64[_s8D5w::P64 + 24];
           _s8D55::I64 = I64[_s8D5w::P64 + 40];
           _s8D58::I64 = I64[_s8D5w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5s::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D5w_info" {
     sat_s8D5w_info:
         const sat_s8D5w_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D5E_entry() //  [R1]
         { []
         }
     {offset
       c8Drz: // global
           _s8D5E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DrA; else goto c8DrB;
       c8DrB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DrD; else goto c8DrC;
       c8DrD: // global
           HpAlloc = 56;
           goto c8DrA;
       c8DrA: // global
           R1 = _s8D5E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5E::P64;
           _s8D5a::I64 = I64[_s8D5E::P64 + 56];
           _s8D5A::I64 = I64[_s8D5E::P64 + 64];
           if (_s8D5A::I64 == _s8D5a::I64) goto c8Dry; else goto c8Drx;
       c8Dry: // global
           _s8D5i::P64 = P64[_s8D5E::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Drx: // global
           _s8D56::P64 = P64[_s8D5E::P64 + 16];
           _s8D57::P64 = P64[_s8D5E::P64 + 24];
           _s8D55::I64 = I64[_s8D5E::P64 + 40];
           _s8D58::I64 = I64[_s8D5E::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5A::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D5E_info" {
     sat_s8D5E_info:
         const sat_s8D5E_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D5M_entry() //  [R1]
         { []
         }
     {offset
       c8DrV: // global
           _s8D5M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DrW; else goto c8DrX;
       c8DrX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DrZ; else goto c8DrY;
       c8DrZ: // global
           HpAlloc = 56;
           goto c8DrW;
       c8DrW: // global
           R1 = _s8D5M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5M::P64;
           _s8D5a::I64 = I64[_s8D5M::P64 + 56];
           _s8D5I::I64 = I64[_s8D5M::P64 + 64];
           if (_s8D5I::I64 == _s8D5a::I64) goto c8DrU; else goto c8DrT;
       c8DrU: // global
           _s8D5i::P64 = P64[_s8D5M::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DrT: // global
           _s8D56::P64 = P64[_s8D5M::P64 + 16];
           _s8D57::P64 = P64[_s8D5M::P64 + 24];
           _s8D55::I64 = I64[_s8D5M::P64 + 40];
           _s8D58::I64 = I64[_s8D5M::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5I::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D5M_info" {
     sat_s8D5M_info:
         const sat_s8D5M_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D5U_entry() //  [R1]
         { []
         }
     {offset
       c8Dsh: // global
           _s8D5U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dsi; else goto c8Dsj;
       c8Dsj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dsl; else goto c8Dsk;
       c8Dsl: // global
           HpAlloc = 56;
           goto c8Dsi;
       c8Dsi: // global
           R1 = _s8D5U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dsk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5U::P64;
           _s8D5a::I64 = I64[_s8D5U::P64 + 56];
           _s8D5Q::I64 = I64[_s8D5U::P64 + 64];
           if (_s8D5Q::I64 == _s8D5a::I64) goto c8Dsg; else goto c8Dsf;
       c8Dsg: // global
           _s8D5i::P64 = P64[_s8D5U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dsf: // global
           _s8D56::P64 = P64[_s8D5U::P64 + 16];
           _s8D57::P64 = P64[_s8D5U::P64 + 24];
           _s8D55::I64 = I64[_s8D5U::P64 + 40];
           _s8D58::I64 = I64[_s8D5U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5Q::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D5U_info" {
     sat_s8D5U_info:
         const sat_s8D5U_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Dso: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Dsp; else goto c8Dsq;
       c8Dsp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Dsq: // global
           I64[Sp - 16] = block_c8Dqr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Dy2; else goto c8Dqs;
       u8Dy2: // global
           call _c8Dqr(R1) args: 0, res: 0, upd: 0;
       c8Dqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF1_info" {
     GHC.IO.Encoding.UTF32.mkUTF1_info:
         const GHC.IO.Encoding.UTF32.mkUTF1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Dqr() //  [R1]
         { []
         }
     {offset
       c8Dqr: // global
           I64[Sp - 40] = block_c8Dqw_info;
           _s8D56::P64 = P64[R1 + 7];
           _s8D57::P64 = P64[R1 + 15];
           _s8D55::I64 = I64[R1 + 23];
           _s8D58::I64 = I64[R1 + 31];
           _s8D59::I64 = I64[R1 + 39];
           _s8D5a::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D57::P64;
           I64[Sp - 24] = _s8D58::I64;
           I64[Sp - 16] = _s8D59::I64;
           I64[Sp - 8] = _s8D5a::I64;
           P64[Sp] = _s8D56::P64;
           I64[Sp + 8] = _s8D55::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DxW; else goto c8Dqx;
       u8DxW: // global
           call _c8Dqw(R1) args: 0, res: 0, upd: 0;
       c8Dqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Dqr_info" {
     block_c8Dqr_info:
         const _c8Dqr;
         const 1;
         const 30;
 },
 _c8Dqw() //  [R1]
         { []
         }
     {offset
       c8Dqw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dsu; else goto c8Dst;
       c8Dsu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Dst: // global
           _s8D5d::P64 = P64[R1 + 7];
           _s8D5e::P64 = P64[R1 + 15];
           _s8D5c::I64 = I64[R1 + 23];
           _s8D5f::I64 = I64[R1 + 31];
           _s8D5g::I64 = I64[R1 + 39];
           _s8D5h::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8D56::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8D55::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8D5a::I64 = I64[Sp + 32];
           _c8DqB::P64 = Hp - 47;
           _s8D5Z::I64 = _s8D5h::I64;
           _s8D5Y::I64 = I64[Sp + 24];
           goto c8DsR;
       c8DsR: // global
           if (%MO_S_Lt_W64(_s8D5Y::I64,
                            _s8D5a::I64)) goto c8DtN; else goto c8DtO;
       c8DtN: // global
           if (%MO_S_Ge_W64(_s8D5f::I64 - _s8D5Z::I64,
                            4)) goto c8DtK; else goto c8DtL;
       c8DtK: // global
           _s8D66::I64 = %MO_UU_Conv_W32_W64(I32[_s8D55::I64 + (_s8D5Y::I64 << 2)]);
           call MO_Touch(_s8D56::P64);
           if (%MO_S_Gt_W64(55296, _s8D66::I64)) goto c8Dto; else goto c8DtI;
       c8Dto: // global
           if (%MO_S_Gt_W64(56320, _s8D66::I64)) goto c8Dte; else goto c8Dtm;
       c8Dte: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8Dtm: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 57343)) goto c8Dtk; else goto c8Dtl;
       c8Dtk: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8Dtl: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8DqE() args: 0, res: 0, upd: 0;
       c8DtI: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 56319)) goto c8DtG; else goto c8DtH;
       c8DtG: // global
           if (%MO_S_Gt_W64(56320, _s8D66::I64)) goto c8Dtw; else goto c8DtE;
       c8Dtw: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8DtE: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 57343)) goto c8DtC; else goto c8DtD;
       c8DtC: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8DtD: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Dr0() args: 0, res: 0, upd: 0;
       c8DtH: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Drm() args: 0, res: 0, upd: 0;
       c8DtL: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8DrI() args: 0, res: 0, upd: 0;
       c8DtO: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Ds4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Dqw_info" {
     block_c8Dqw_info:
         const _c8Dqw;
         const 2950;
         const 30;
 },
 _c8DqE() //  []
         { []
         }
     {offset
       c8DqE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dsy; else goto c8Dsx;
       c8Dsy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DqE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dsx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5o_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DqE_info" {
     block_c8DqE_info:
         const _c8DqE;
         const 352013;
         const 30;
 },
 _c8Dr0() //  []
         { []
         }
     {offset
       c8Dr0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsC; else goto c8DsB;
       c8DsC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dr0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5w_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Dr0_info" {
     block_c8Dr0_info:
         const _c8Dr0;
         const 352013;
         const 30;
 },
 _c8Drm() //  []
         { []
         }
     {offset
       c8Drm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsG; else goto c8DsF;
       c8DsG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Drm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5E_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Drm_info" {
     block_c8Drm_info:
         const _c8Drm;
         const 352013;
         const 30;
 },
 _c8DrI() //  []
         { []
         }
     {offset
       c8DrI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsK; else goto c8DsJ;
       c8DsK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DrI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5M_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DrI_info" {
     block_c8DrI_info:
         const _c8DrI;
         const 352013;
         const 30;
 },
 _c8Ds4() //  []
         { []
         }
     {offset
       c8Ds4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsO; else goto c8DsN;
       c8DsO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ds4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5U_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ds4_info" {
     block_c8Ds4_info:
         const _c8Ds4;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.725731941 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DBC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be_encode_info" {
     GHC.IO.Encoding.UTF32.utf32be_encode_info:
         const GHC.IO.Encoding.UTF32.utf32be_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.739219215 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8D8q_entry() //  [R1]
         { []
         }
     {offset
       c8DCd: // global
           _s8D8q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DCe; else goto c8DCf;
       c8DCf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DCh; else goto c8DCg;
       c8DCh: // global
           HpAlloc = 56;
           goto c8DCe;
       c8DCe: // global
           R1 = _s8D8q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DCg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D8q::P64;
           _s8D8c::I64 = I64[_s8D8q::P64 + 56];
           _s8D8m::I64 = I64[_s8D8q::P64 + 64];
           if (_s8D8m::I64 == _s8D8c::I64) goto c8DCc; else goto c8DCb;
       c8DCc: // global
           _s8D8k::P64 = P64[_s8D8q::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DCb: // global
           _s8D88::P64 = P64[_s8D8q::P64 + 16];
           _s8D89::P64 = P64[_s8D8q::P64 + 24];
           _s8D87::I64 = I64[_s8D8q::P64 + 40];
           _s8D8a::I64 = I64[_s8D8q::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8m::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D8q_info" {
     sat_s8D8q_info:
         const sat_s8D8q_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D8y_entry() //  [R1]
         { []
         }
     {offset
       c8DCz: // global
           _s8D8y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DCA; else goto c8DCB;
       c8DCB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DCD; else goto c8DCC;
       c8DCD: // global
           HpAlloc = 56;
           goto c8DCA;
       c8DCA: // global
           R1 = _s8D8y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DCC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D8y::P64;
           _s8D8c::I64 = I64[_s8D8y::P64 + 56];
           _s8D8u::I64 = I64[_s8D8y::P64 + 64];
           if (_s8D8u::I64 == _s8D8c::I64) goto c8DCy; else goto c8DCx;
       c8DCy: // global
           _s8D8k::P64 = P64[_s8D8y::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DCx: // global
           _s8D88::P64 = P64[_s8D8y::P64 + 16];
           _s8D89::P64 = P64[_s8D8y::P64 + 24];
           _s8D87::I64 = I64[_s8D8y::P64 + 40];
           _s8D8a::I64 = I64[_s8D8y::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8u::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D8y_info" {
     sat_s8D8y_info:
         const sat_s8D8y_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D9p_entry() //  [R1]
         { []
         }
     {offset
       c8DEd: // global
           _s8D9p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DEe; else goto c8DEf;
       c8DEf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEh; else goto c8DEg;
       c8DEh: // global
           HpAlloc = 56;
           goto c8DEe;
       c8DEe: // global
           R1 = _s8D9p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DEg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D9p::P64;
           _s8D8c::I64 = I64[_s8D9p::P64 + 56];
           _s8D8C::I64 = I64[_s8D9p::P64 + 64];
           if (_s8D8C::I64 == _s8D8c::I64) goto c8DEc; else goto c8DEb;
       c8DEc: // global
           _s8D8k::P64 = P64[_s8D9p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DEb: // global
           _s8D88::P64 = P64[_s8D9p::P64 + 16];
           _s8D89::P64 = P64[_s8D9p::P64 + 24];
           _s8D87::I64 = I64[_s8D9p::P64 + 40];
           _s8D8a::I64 = I64[_s8D9p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8C::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D9p_info" {
     sat_s8D9p_info:
         const sat_s8D9p_entry;
         const 17179869187;
         const 15;
 },
 sat_s8D9u_entry() //  [R1]
         { []
         }
     {offset
       c8DEy: // global
           _s8D9u::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DEz; else goto c8DEA;
       c8DEA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEC; else goto c8DEB;
       c8DEC: // global
           HpAlloc = 56;
           goto c8DEz;
       c8DEz: // global
           R1 = _s8D9u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D9u::P64;
           _s8D8c::I64 = I64[_s8D9u::P64 + 56];
           _s8D8C::I64 = I64[_s8D9u::P64 + 64];
           if (_s8D8C::I64 == _s8D8c::I64) goto c8DEx; else goto c8DEw;
       c8DEx: // global
           _s8D8k::P64 = P64[_s8D9u::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DEw: // global
           _s8D88::P64 = P64[_s8D9u::P64 + 16];
           _s8D89::P64 = P64[_s8D9u::P64 + 24];
           _s8D87::I64 = I64[_s8D9u::P64 + 40];
           _s8D8a::I64 = I64[_s8D9u::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8C::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8D9u_info" {
     sat_s8D9u_info:
         const sat_s8D9u_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DEF: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8DEG; else goto c8DEH;
       c8DEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DEH: // global
           I64[Sp - 16] = block_c8DBN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DFN; else goto c8DBO;
       u8DFN: // global
           call _c8DBN(R1) args: 0, res: 0, upd: 0;
       c8DBO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF3_info" {
     GHC.IO.Encoding.UTF32.mkUTF3_info:
         const GHC.IO.Encoding.UTF32.mkUTF3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8DBN() //  [R1]
         { []
         }
     {offset
       c8DBN: // global
           I64[Sp - 40] = block_c8DBS_info;
           _s8D88::P64 = P64[R1 + 7];
           _s8D89::P64 = P64[R1 + 15];
           _s8D87::I64 = I64[R1 + 23];
           _s8D8a::I64 = I64[R1 + 31];
           _s8D8b::I64 = I64[R1 + 39];
           _s8D8c::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D89::P64;
           I64[Sp - 24] = _s8D8a::I64;
           I64[Sp - 16] = _s8D8b::I64;
           I64[Sp - 8] = _s8D8c::I64;
           P64[Sp] = _s8D88::P64;
           I64[Sp + 8] = _s8D87::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DFF; else goto c8DBT;
       u8DFF: // global
           call _c8DBS(R1) args: 0, res: 0, upd: 0;
       c8DBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DBN_info" {
     block_c8DBN_info:
         const _c8DBN;
         const 1;
         const 30;
 },
 _c8DBS() //  [R1]
         { []
         }
     {offset
       c8DBS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEL; else goto c8DEK;
       c8DEL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DEK: // global
           _s8D8f::P64 = P64[R1 + 7];
           _s8D8g::P64 = P64[R1 + 15];
           _s8D8e::I64 = I64[R1 + 23];
           _s8D8h::I64 = I64[R1 + 31];
           _s8D8i::I64 = I64[R1 + 39];
           _s8D8j::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8D8f::P64;
           P64[Sp - 40] = _s8D8g::P64;
           I64[Sp - 32] = _s8D8h::I64;
           I64[Sp - 24] = _s8D8i::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8D8j::I64;
           I64[Sp] = _s8D8e::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8DCI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8DBS_info" {
     block_c8DBS_info:
         const _c8DBS;
         const 2950;
         const 30;
 },
 _c8DCI() //  []
         { []
         }
     {offset
       c8DCI: // global
           _s8D8C::I64 = I64[Sp + 32];
           _s8D8D::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8D8D::I64,
                            I64[Sp + 16])) goto c8DFq; else goto c8DFr;
       c8DFq: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8D8C::I64,
                            4)) goto c8DFn; else goto c8DFo;
       c8DFn: // global
           _s8D87::I64 = I64[Sp + 96];
           _s8D88::P64 = P64[Sp + 88];
           _s8D8L::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + _s8D8C::I64]);
           call MO_Touch(_s8D88::P64);
           _s8D8R::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 1)]);
           call MO_Touch(_s8D88::P64);
           _s8D8X::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 2)]);
           call MO_Touch(_s8D88::P64);
           _s8D93::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 3)]);
           call MO_Touch(_s8D88::P64);
           _s8D95::I64 = (_s8D93::I64 << 24) + ((_s8D8X::I64 << 16) + ((_s8D8R::I64 << 8) + _s8D8L::I64));
           if (%MO_S_Lt_W64(_s8D95::I64, 0)) goto u8DFy; else goto c8DFl;
       u8DFy: // global
           I64[Sp - 16] = _s8D95::I64;
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 24;
           goto u8DFJ;
       c8DFl: // global
           if (%MO_S_Ge_W64(_s8D95::I64, 55296)) goto u8DFA; else goto u8DFz;
       u8DFA: // global
           I64[Sp - 16] = _s8D95::I64;
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 24;
           goto u8DFJ;
       u8DFJ: // global
           call _c8DDY() args: 0, res: 0, upd: 0;
       u8DFz: // global
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 8;
           call _s8D9h() args: 0, res: 0, upd: 0;
       c8DFo: // global
           I64[Sp + 32] = _s8D8D::I64;
           I64[Sp + 40] = _s8D8C::I64;
           Sp = Sp - 8;
           call _c8DC0() args: 0, res: 0, upd: 0;
       c8DFr: // global
           I64[Sp + 32] = _s8D8D::I64;
           I64[Sp + 40] = _s8D8C::I64;
           Sp = Sp - 8;
           call _c8DCm() args: 0, res: 0, upd: 0;
     }
 },
 _c8DDY() //  []
         { []
         }
     {offset
       c8DDY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DF1; else goto c8DF0;
       c8DF1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DDY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DF0: // global
           _c8DBX::P64 = P64[Sp + 96];
           _s8D87::I64 = I64[Sp + 120];
           _s8D88::P64 = P64[Sp + 112];
           _s8D89::P64 = P64[Sp + 80];
           _s8D8a::I64 = I64[Sp + 88];
           _s8D8c::I64 = I64[Sp + 104];
           _s8D8e::I64 = I64[Sp + 72];
           _s8D8f::P64 = P64[Sp + 24];
           _s8D8g::P64 = P64[Sp + 32];
           _s8D8h::I64 = I64[Sp + 40];
           _s8D8i::I64 = I64[Sp + 48];
           _s8D8C::I64 = I64[Sp + 56];
           _s8D8D::I64 = I64[Sp + 64];
           _s8D9g::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8D9g::I64, 57343)) goto c8DF4; else goto c8DF9;
       c8DF4: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8D8f::P64;
           P64[Hp - 136] = _s8D8g::P64;
           I64[Hp - 128] = _s8D8e::I64;
           I64[Hp - 120] = _s8D8h::I64;
           I64[Hp - 112] = _s8D8i::I64;
           I64[Hp - 104] = _s8D8D::I64;
           I64[Hp - 96] = sat_s8D9p_info;
           P64[Hp - 80] = _s8D88::P64;
           P64[Hp - 72] = _s8D89::P64;
           P64[Hp - 64] = _c8DBX::P64;
           I64[Hp - 56] = _s8D87::I64;
           I64[Hp - 48] = _s8D8a::I64;
           I64[Hp - 40] = _s8D8c::I64;
           I64[Hp - 32] = _s8D8C::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DF9: // global
           if (%MO_S_Gt_W64(_s8D9g::I64,
                            1114111)) goto c8DF7; else goto c8DF8;
       c8DF7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8D8f::P64;
           P64[Hp - 136] = _s8D8g::P64;
           I64[Hp - 128] = _s8D8e::I64;
           I64[Hp - 120] = _s8D8h::I64;
           I64[Hp - 112] = _s8D8i::I64;
           I64[Hp - 104] = _s8D8D::I64;
           I64[Hp - 96] = sat_s8D9u_info;
           P64[Hp - 80] = _s8D88::P64;
           P64[Hp - 72] = _s8D89::P64;
           P64[Hp - 64] = _c8DBX::P64;
           I64[Hp - 56] = _s8D87::I64;
           I64[Hp - 48] = _s8D8a::I64;
           I64[Hp - 40] = _s8D8c::I64;
           I64[Hp - 32] = _s8D8C::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DF8: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8D9h() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8DDY_info" {
     block_c8DDY_info:
         const _c8DDY;
         const 1408207;
         const 30;
 },
 _s8D9h() //  []
         { []
         }
     {offset
       s8D9h: // global
           _s8D8f::P64 = P64[Sp + 8];
           _s8D8C::I64 = I64[Sp + 40];
           _s8D8D::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8D8D::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8D8f::P64);
           I64[Sp + 40] = _s8D8C::I64 + 4;
           I64[Sp + 48] = _s8D8D::I64 + 1;
           Sp = Sp + 8;
           call _c8DCI() args: 0, res: 0, upd: 0;
     }
 },
 _c8DC0() //  []
         { []
         }
     {offset
       c8DC0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DEP; else goto c8DEO;
       c8DEP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DC0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DEO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8D8q_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DC0_info" {
     block_c8DC0_info:
         const _c8DC0;
         const 352013;
         const 30;
 },
 _c8DCm() //  []
         { []
         }
     {offset
       c8DCm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DET; else goto c8DES;
       c8DET: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DCm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DES: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8D8y_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DCm_info" {
     block_c8DCm_info:
         const _c8DCm;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.767393431 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DIc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le_decode_info" {
     GHC.IO.Encoding.UTF32.utf32le_decode_info:
         const GHC.IO.Encoding.UTF32.utf32le_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.770446457 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.772744989 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { []
         }
     {offset
       c8DIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DIr; else goto c8DIs;
       c8DIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DIs: // global
           (_c8DIn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8DIn::I64 == 0) goto c8DIp; else goto c8DIo;
       c8DIp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8DIo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8DIn::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le2_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.77662661 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { []
         }
     {offset
       c8DIF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF2_info" {
     GHC.IO.Encoding.UTF32.mkUTF2_info:
         const GHC.IO.Encoding.UTF32.mkUTF2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.780265508 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { []
         }
     {offset
       c8DIS: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be1_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.785621254 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8D9I_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8DJf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8D9I_info" {
     sat_s8D9I_info:
         const sat_s8D9I_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt;
 },
 sat_s8D9K_entry() //  [R1]
         { []
         }
     {offset
       c8DJj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJn; else goto c8DJm;
       c8DJn: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DJm: // global
           _s8D9C::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8D9I_info;
           P64[Hp - 48] = _s8D9C::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8D9K_info" {
     sat_s8D9K_info:
         const sat_s8D9K_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt;
 },
 sat_s8D9E_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8DJy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8D9E_info" {
     sat_s8D9E_info:
         const sat_s8D9E_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt+8;
 },
 sat_s8D9G_entry() //  [R1]
         { []
         }
     {offset
       c8DJC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJG; else goto c8DJF;
       c8DJG: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DJF: // global
           _s8D9C::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8D9E_info;
           P64[Hp - 48] = _s8D9C::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8D9G_info" {
     sat_s8D9G_info:
         const sat_s8D9G_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { []
         }
     {offset
       c8DJI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJM; else goto c8DJL;
       c8DJM: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8DJL: // global
           I64[Hp - 56] = sat_s8D9K_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8D9G_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32le_info" {
     GHC.IO.Encoding.UTF32.mkUTF32le_info:
         const GHC.IO.Encoding.UTF32.mkUTF32le_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8DJN_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.797824636 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DKC; else goto c8DKD;
       c8DKC: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DKD: // global
           I64[Sp - 16] = block_c8DKv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DKL; else goto c8DKw;
       u8DKL: // global
           call _c8DKv() args: 0, res: 0, upd: 0;
       c8DKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8AWo_info" {
     lvl_r8AWo_info:
         const lvl_r8AWo_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8DJN_srt+32;
 },
 _c8DKv() //  []
         { []
         }
     {offset
       c8DKv: // global
           _s8D9M::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8DKB_info;
           R1 = _s8D9M::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8DKK; else goto c8DKF;
       u8DKK: // global
           call _c8DKB() args: 0, res: 0, upd: 0;
       c8DKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DKv_info" {
     block_c8DKv_info:
         const _c8DKv;
         const 1;
         const 4294967326;
         const S8DJN_srt+32;
 },
 _c8DKB() //  []
         { []
         }
     {offset
       c8DKB: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DKB_info" {
     block_c8DKB_info:
         const _c8DKB;
         const 0;
         const 4294967326;
         const S8DJN_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.804258266 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.806244685 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { []
         }
     {offset
       c8DL6: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le2_info" {
     GHC.IO.Encoding.UTF32.utf32le2_info:
         const GHC.IO.Encoding.UTF32.utf32le2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8DJN_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.810499978 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DLl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8DLp; else goto c8DLq;
       c8DLp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DLq: // global
           I64[Sp - 16] = block_c8DLi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DLz; else goto c8DLj;
       u8DLz: // global
           call _c8DLi(R1) args: 0, res: 0, upd: 0;
       c8DLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be2_info" {
     GHC.IO.Encoding.UTF32.utf32be2_info:
         const GHC.IO.Encoding.UTF32.utf32be2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8DJN_srt+56;
 },
 _c8DLi() //  [R1]
         { []
         }
     {offset
       c8DLi: // global
           I64[Sp - 16] = block_c8DLo_info;
           _s8Da8::P64 = P64[R1 + 7];
           _s8Da7::I64 = I64[R1 + 23];
           _s8Dab::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Dab::I64;
           P64[Sp] = _s8Da8::P64;
           I64[Sp + 8] = _s8Da7::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DLy; else goto c8DLs;
       u8DLy: // global
           call _c8DLo() args: 0, res: 0, upd: 0;
       c8DLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DLi_info" {
     block_c8DLi_info:
         const _c8DLi;
         const 1;
         const 4294967326;
         const S8DJN_srt+56;
 },
 _c8DLo() //  []
         { []
         }
     {offset
       c8DLo: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DLo_info" {
     block_c8DLo_info:
         const _c8DLo;
         const 323;
         const 4294967326;
         const S8DJN_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.817401915 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.819390679 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { []
         }
     {offset
       c8DLU: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32le1_info" {
     GHC.IO.Encoding.UTF32.utf32le1_info:
         const GHC.IO.Encoding.UTF32.utf32le1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8DJN_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.822576382 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.834147482 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8DaM_entry() //  [R1]
         { []
         }
     {offset
       c8DMx: // global
           _s8DaM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DMy; else goto c8DMz;
       c8DMz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DMB; else goto c8DMA;
       c8DMB: // global
           HpAlloc = 56;
           goto c8DMy;
       c8DMy: // global
           R1 = _s8DaM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DMA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DaM::P64;
           _s8Day::I64 = I64[_s8DaM::P64 + 56];
           _s8DaI::I64 = I64[_s8DaM::P64 + 64];
           if (_s8DaI::I64 == _s8Day::I64) goto c8DMw; else goto c8DMv;
       c8DMw: // global
           _s8DaG::P64 = P64[_s8DaM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DMv: // global
           _s8Dau::P64 = P64[_s8DaM::P64 + 16];
           _s8Dav::P64 = P64[_s8DaM::P64 + 24];
           _s8Dat::I64 = I64[_s8DaM::P64 + 40];
           _s8Daw::I64 = I64[_s8DaM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaI::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8DaM_info" {
     sat_s8DaM_info:
         const sat_s8DaM_entry;
         const 17179869187;
         const 15;
 },
 sat_s8DaU_entry() //  [R1]
         { []
         }
     {offset
       c8DMT: // global
           _s8DaU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DMU; else goto c8DMV;
       c8DMV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DMX; else goto c8DMW;
       c8DMX: // global
           HpAlloc = 56;
           goto c8DMU;
       c8DMU: // global
           R1 = _s8DaU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DMW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DaU::P64;
           _s8Day::I64 = I64[_s8DaU::P64 + 56];
           _s8DaQ::I64 = I64[_s8DaU::P64 + 64];
           if (_s8DaQ::I64 == _s8Day::I64) goto c8DMS; else goto c8DMR;
       c8DMS: // global
           _s8DaG::P64 = P64[_s8DaU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DMR: // global
           _s8Dau::P64 = P64[_s8DaU::P64 + 16];
           _s8Dav::P64 = P64[_s8DaU::P64 + 24];
           _s8Dat::I64 = I64[_s8DaU::P64 + 40];
           _s8Daw::I64 = I64[_s8DaU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaQ::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8DaU_info" {
     sat_s8DaU_info:
         const sat_s8DaU_entry;
         const 17179869187;
         const 15;
 },
 sat_s8DbL_entry() //  [R1]
         { []
         }
     {offset
       c8DOx: // global
           _s8DbL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DOy; else goto c8DOz;
       c8DOz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DOB; else goto c8DOA;
       c8DOB: // global
           HpAlloc = 56;
           goto c8DOy;
       c8DOy: // global
           R1 = _s8DbL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DOA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DbL::P64;
           _s8Day::I64 = I64[_s8DbL::P64 + 56];
           _s8DaY::I64 = I64[_s8DbL::P64 + 64];
           if (_s8DaY::I64 == _s8Day::I64) goto c8DOw; else goto c8DOv;
       c8DOw: // global
           _s8DaG::P64 = P64[_s8DbL::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DOv: // global
           _s8Dau::P64 = P64[_s8DbL::P64 + 16];
           _s8Dav::P64 = P64[_s8DbL::P64 + 24];
           _s8Dat::I64 = I64[_s8DbL::P64 + 40];
           _s8Daw::I64 = I64[_s8DbL::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaY::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8DbL_info" {
     sat_s8DbL_info:
         const sat_s8DbL_entry;
         const 17179869187;
         const 15;
 },
 sat_s8DbQ_entry() //  [R1]
         { []
         }
     {offset
       c8DOS: // global
           _s8DbQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DOT; else goto c8DOU;
       c8DOU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DOW; else goto c8DOV;
       c8DOW: // global
           HpAlloc = 56;
           goto c8DOT;
       c8DOT: // global
           R1 = _s8DbQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DOV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DbQ::P64;
           _s8Day::I64 = I64[_s8DbQ::P64 + 56];
           _s8DaY::I64 = I64[_s8DbQ::P64 + 64];
           if (_s8DaY::I64 == _s8Day::I64) goto c8DOR; else goto c8DOQ;
       c8DOR: // global
           _s8DaG::P64 = P64[_s8DbQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DOQ: // global
           _s8Dau::P64 = P64[_s8DbQ::P64 + 16];
           _s8Dav::P64 = P64[_s8DbQ::P64 + 24];
           _s8Dat::I64 = I64[_s8DbQ::P64 + 40];
           _s8Daw::I64 = I64[_s8DbQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaY::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8DbQ_info" {
     sat_s8DbQ_info:
         const sat_s8DbQ_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DOZ: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8DP0; else goto c8DP1;
       c8DP0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DP1: // global
           I64[Sp - 16] = block_c8DM7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DQ7; else goto c8DM8;
       u8DQ7: // global
           call _c8DM7(R1) args: 0, res: 0, upd: 0;
       c8DM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF5_info" {
     GHC.IO.Encoding.UTF32.mkUTF5_info:
         const GHC.IO.Encoding.UTF32.mkUTF5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8DM7() //  [R1]
         { []
         }
     {offset
       c8DM7: // global
           I64[Sp - 40] = block_c8DMc_info;
           _s8Dau::P64 = P64[R1 + 7];
           _s8Dav::P64 = P64[R1 + 15];
           _s8Dat::I64 = I64[R1 + 23];
           _s8Daw::I64 = I64[R1 + 31];
           _s8Dax::I64 = I64[R1 + 39];
           _s8Day::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Dav::P64;
           I64[Sp - 24] = _s8Daw::I64;
           I64[Sp - 16] = _s8Dax::I64;
           I64[Sp - 8] = _s8Day::I64;
           P64[Sp] = _s8Dau::P64;
           I64[Sp + 8] = _s8Dat::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DPZ; else goto c8DMd;
       u8DPZ: // global
           call _c8DMc(R1) args: 0, res: 0, upd: 0;
       c8DMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DM7_info" {
     block_c8DM7_info:
         const _c8DM7;
         const 1;
         const 30;
 },
 _c8DMc() //  [R1]
         { []
         }
     {offset
       c8DMc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DP5; else goto c8DP4;
       c8DP5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DP4: // global
           _s8DaB::P64 = P64[R1 + 7];
           _s8DaC::P64 = P64[R1 + 15];
           _s8DaA::I64 = I64[R1 + 23];
           _s8DaD::I64 = I64[R1 + 31];
           _s8DaE::I64 = I64[R1 + 39];
           _s8DaF::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8DaB::P64;
           P64[Sp - 40] = _s8DaC::P64;
           I64[Sp - 32] = _s8DaD::I64;
           I64[Sp - 24] = _s8DaE::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8DaF::I64;
           I64[Sp] = _s8DaA::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8DN2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8DMc_info" {
     block_c8DMc_info:
         const _c8DMc;
         const 2950;
         const 30;
 },
 _c8DN2() //  []
         { []
         }
     {offset
       c8DN2: // global
           _s8DaY::I64 = I64[Sp + 32];
           _s8DaZ::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8DaZ::I64,
                            I64[Sp + 16])) goto c8DPK; else goto c8DPL;
       c8DPK: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8DaY::I64,
                            4)) goto c8DPH; else goto c8DPI;
       c8DPH: // global
           _s8Dat::I64 = I64[Sp + 96];
           _s8Dau::P64 = P64[Sp + 88];
           _s8Db7::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + _s8DaY::I64]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbd::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 1)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbj::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 2)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbp::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 3)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbr::I64 = (_s8Db7::I64 << 24) + ((_s8Dbd::I64 << 16) + ((_s8Dbj::I64 << 8) + _s8Dbp::I64));
           if (%MO_S_Lt_W64(_s8Dbr::I64, 0)) goto u8DPS; else goto c8DPF;
       u8DPS: // global
           I64[Sp - 16] = _s8Dbr::I64;
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 24;
           goto u8DQ3;
       c8DPF: // global
           if (%MO_S_Ge_W64(_s8Dbr::I64, 55296)) goto u8DPU; else goto u8DPT;
       u8DPU: // global
           I64[Sp - 16] = _s8Dbr::I64;
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 24;
           goto u8DQ3;
       u8DQ3: // global
           call _c8DOi() args: 0, res: 0, upd: 0;
       u8DPT: // global
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 8;
           call _s8DbD() args: 0, res: 0, upd: 0;
       c8DPI: // global
           I64[Sp + 32] = _s8DaZ::I64;
           I64[Sp + 40] = _s8DaY::I64;
           Sp = Sp - 8;
           call _c8DMk() args: 0, res: 0, upd: 0;
       c8DPL: // global
           I64[Sp + 32] = _s8DaZ::I64;
           I64[Sp + 40] = _s8DaY::I64;
           Sp = Sp - 8;
           call _c8DMG() args: 0, res: 0, upd: 0;
     }
 },
 _c8DOi() //  []
         { []
         }
     {offset
       c8DOi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DPl; else goto c8DPk;
       c8DPl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DOi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DPk: // global
           _c8DMh::P64 = P64[Sp + 96];
           _s8Dat::I64 = I64[Sp + 120];
           _s8Dau::P64 = P64[Sp + 112];
           _s8Dav::P64 = P64[Sp + 80];
           _s8Daw::I64 = I64[Sp + 88];
           _s8Day::I64 = I64[Sp + 104];
           _s8DaA::I64 = I64[Sp + 72];
           _s8DaB::P64 = P64[Sp + 24];
           _s8DaC::P64 = P64[Sp + 32];
           _s8DaD::I64 = I64[Sp + 40];
           _s8DaE::I64 = I64[Sp + 48];
           _s8DaY::I64 = I64[Sp + 56];
           _s8DaZ::I64 = I64[Sp + 64];
           _s8DbC::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8DbC::I64, 57343)) goto c8DPo; else goto c8DPt;
       c8DPo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8DaB::P64;
           P64[Hp - 136] = _s8DaC::P64;
           I64[Hp - 128] = _s8DaA::I64;
           I64[Hp - 120] = _s8DaD::I64;
           I64[Hp - 112] = _s8DaE::I64;
           I64[Hp - 104] = _s8DaZ::I64;
           I64[Hp - 96] = sat_s8DbL_info;
           P64[Hp - 80] = _s8Dau::P64;
           P64[Hp - 72] = _s8Dav::P64;
           P64[Hp - 64] = _c8DMh::P64;
           I64[Hp - 56] = _s8Dat::I64;
           I64[Hp - 48] = _s8Daw::I64;
           I64[Hp - 40] = _s8Day::I64;
           I64[Hp - 32] = _s8DaY::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DPt: // global
           if (%MO_S_Gt_W64(_s8DbC::I64,
                            1114111)) goto c8DPr; else goto c8DPs;
       c8DPr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8DaB::P64;
           P64[Hp - 136] = _s8DaC::P64;
           I64[Hp - 128] = _s8DaA::I64;
           I64[Hp - 120] = _s8DaD::I64;
           I64[Hp - 112] = _s8DaE::I64;
           I64[Hp - 104] = _s8DaZ::I64;
           I64[Hp - 96] = sat_s8DbQ_info;
           P64[Hp - 80] = _s8Dau::P64;
           P64[Hp - 72] = _s8Dav::P64;
           P64[Hp - 64] = _c8DMh::P64;
           I64[Hp - 56] = _s8Dat::I64;
           I64[Hp - 48] = _s8Daw::I64;
           I64[Hp - 40] = _s8Day::I64;
           I64[Hp - 32] = _s8DaY::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DPs: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8DbD() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8DOi_info" {
     block_c8DOi_info:
         const _c8DOi;
         const 1408207;
         const 30;
 },
 _s8DbD() //  []
         { []
         }
     {offset
       s8DbD: // global
           _s8DaB::P64 = P64[Sp + 8];
           _s8DaY::I64 = I64[Sp + 40];
           _s8DaZ::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8DaZ::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8DaB::P64);
           I64[Sp + 40] = _s8DaY::I64 + 4;
           I64[Sp + 48] = _s8DaZ::I64 + 1;
           Sp = Sp + 8;
           call _c8DN2() args: 0, res: 0, upd: 0;
     }
 },
 _c8DMk() //  []
         { []
         }
     {offset
       c8DMk: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DP9; else goto c8DP8;
       c8DP9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DMk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DP8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8DaM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DMk_info" {
     block_c8DMk_info:
         const _c8DMk;
         const 352013;
         const 30;
 },
 _c8DMG() //  []
         { []
         }
     {offset
       c8DMG: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DPd; else goto c8DPc;
       c8DPd: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DMG_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DPc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8DaU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DMG_info" {
     block_c8DMG_info:
         const _c8DMG;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.862268646 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DSw: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be_decode_info" {
     GHC.IO.Encoding.UTF32.utf32be_decode_info:
         const GHC.IO.Encoding.UTF32.utf32be_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.865759129 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.868077105 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { []
         }
     {offset
       c8DSK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DSL; else goto c8DSM;
       c8DSL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DSM: // global
           (_c8DSH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8DSH::I64 == 0) goto c8DSJ; else goto c8DSI;
       c8DSJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8DSI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8DSH::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be2_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.874137826 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8Dc1_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8DT9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Dc1_info" {
     sat_s8Dc1_info:
         const sat_s8Dc1_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt;
 },
 sat_s8Dc3_entry() //  [R1]
         { []
         }
     {offset
       c8DTd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTh; else goto c8DTg;
       c8DTh: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DTg: // global
           _s8DbV::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Dc1_info;
           P64[Hp - 48] = _s8DbV::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Dc3_info" {
     sat_s8Dc3_info:
         const sat_s8Dc3_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt;
 },
 sat_s8DbX_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8DTs: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DbX_info" {
     sat_s8DbX_info:
         const sat_s8DbX_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt+8;
 },
 sat_s8DbZ_entry() //  [R1]
         { []
         }
     {offset
       c8DTw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTA; else goto c8DTz;
       c8DTA: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DTz: // global
           _s8DbV::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8DbX_info;
           P64[Hp - 48] = _s8DbV::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DbZ_info" {
     sat_s8DbZ_info:
         const sat_s8DbZ_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { []
         }
     {offset
       c8DTC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTG; else goto c8DTF;
       c8DTG: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8DTF: // global
           I64[Hp - 56] = sat_s8Dc3_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8DbZ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32be_info" {
     GHC.IO.Encoding.UTF32.mkUTF32be_info:
         const GHC.IO.Encoding.UTF32.mkUTF32be_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8DJN_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.885045003 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.887130567 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { []
         }
     {offset
       c8DUp: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be3_info" {
     GHC.IO.Encoding.UTF32.utf32be3_info:
         const GHC.IO.Encoding.UTF32.utf32be3_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8DJN_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.890343076 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.892381941 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { []
         }
     {offset
       c8DUC: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32be1_info" {
     GHC.IO.Encoding.UTF32.utf32be1_info:
         const GHC.IO.Encoding.UTF32.utf32be1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8DJN_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.895735775 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.897520053 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.899278549 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.906865833 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { []
         }
     {offset
       c8DUO: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8DUZ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8DV0; else goto c8DV1;
       c8DV0: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8DV1: // global
           I64[Sp - 48] = block_c8DUS_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8DXe; else goto c8DUT;
       u8DXe: // global
           call _c8DUS(R1) args: 0, res: 0, upd: 0;
       c8DUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.$wutf32_decode_info" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_info:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 7304;
         const GHC.IO.Encoding.UTF32.$wutf32_decode_slow;
 },
 _c8DUS() //  [R1]
         { []
         }
     {offset
       c8DUS: // global
           _s8Dc7::I64 = I64[Sp + 16];
           _s8Dc8::P64 = P64[Sp + 24];
           _s8Dc9::P64 = P64[Sp + 32];
           _s8Dca::I64 = I64[Sp + 40];
           _s8Dcb::I64 = I64[Sp + 48];
           _s8Dcc::I64 = I64[Sp + 56];
           _s8Dcd::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8DUW; else goto c8DUX;
       c8DUW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8DV6; else goto c8DV5;
       c8DV6: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DV5: // global
           if (%MO_S_Ge_W64(_s8Dcc::I64 - _s8Dcb::I64,
                            4)) goto c8DX1; else goto c8DX5;
       c8DX1: // global
           _s8Dc6::P64 = P64[Sp + 8];
           _s8Dco::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + _s8Dcb::I64]);
           call MO_Touch(_s8Dc8::P64);
           _s8Dcu::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 1)]);
           call MO_Touch(_s8Dc8::P64);
           _s8DcA::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 2)]);
           call MO_Touch(_s8Dc8::P64);
           _s8DcG::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 3)]);
           call MO_Touch(_s8Dc8::P64);
           if (_s8Dco::I64 != 0) goto c8DWM; else goto c8DWZ;
       c8DWZ: // global
           if (_s8Dcu::I64 != 0) goto c8DWM; else goto c8DWY;
       c8DWY: // global
           if (_s8DcA::I64 != 254) goto c8DWM; else goto c8DWX;
       c8DWX: // global
           if (_s8DcG::I64 != 255) goto c8DWM; else goto c8DWW;
       c8DWM: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8Dcu::I64;
           I64[Sp - 16] = _s8DcA::I64;
           I64[Sp - 8] = _s8DcG::I64;
           I64[Sp] = _s8Dco::I64;
           Sp = Sp - 32;
           call _c8DVF() args: 0, res: 0, upd: 0;
       c8DWW: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Dc8::P64;
           P64[Hp - 64] = _s8Dc9::P64;
           I64[Hp - 56] = _s8Dc7::I64;
           I64[Hp - 48] = _s8Dca::I64;
           I64[Hp - 40] = _s8Dcb::I64 + 4;
           I64[Hp - 32] = _s8Dcc::I64;
           _c8DWV::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Dcd::P64;
           R2 = _c8DWV::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DX5: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Dc8::P64;
           P64[Hp - 64] = _s8Dc9::P64;
           I64[Hp - 56] = _s8Dc7::I64;
           I64[Hp - 48] = _s8Dca::I64;
           I64[Hp - 40] = _s8Dcb::I64;
           I64[Hp - 32] = _s8Dcc::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Dcd::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DUX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DXb; else goto c8DXa;
       c8DXb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DXa: // global
           _s8Dd7::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           R1 = _s8Dd7::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DUS_info" {
     block_c8DUS_info:
         const _c8DUS;
         const 7304;
         const 30;
 },
 _c8DVF() //  []
         { []
         }
     {offset
       c8DVF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DVJ; else goto c8DVI;
       c8DVJ: // global
           HpAlloc = 56;
           I64[Sp] = block_c8DVF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DVI: // global
           _s8Dc6::P64 = P64[Sp + 40];
           _s8Dc7::I64 = I64[Sp + 48];
           _s8Dc8::P64 = P64[Sp + 56];
           _s8Dc9::P64 = P64[Sp + 64];
           _s8Dca::I64 = I64[Sp + 72];
           _s8Dcb::I64 = I64[Sp + 80];
           _s8Dcc::I64 = I64[Sp + 88];
           _s8Dcd::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8DWu; else goto c8DVR;
       c8DWu: // global
           if (I64[Sp + 8] == 254) goto c8DWt; else goto c8DW0;
       c8DWt: // global
           if (I64[Sp + 16] == 0) goto c8DWs; else goto c8DW9;
       c8DWs: // global
           if (I64[Sp + 24] == 0) goto c8DWr; else goto c8DWi;
       c8DWr: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64 + 4;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DWi: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DW9: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DW0: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DVR: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DVF_info" {
     block_c8DVF_info:
         const _c8DVF;
         const 117708;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.921497304 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8DYa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8DYe; else goto c8DYf;
       c8DYe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DYf: // global
           I64[Sp - 24] = block_c8DY7_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8DYn; else goto c8DY8;
       u8DYn: // global
           call _c8DY7(R1) args: 0, res: 0, upd: 0;
       c8DY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_decode1_info" {
     GHC.IO.Encoding.UTF32.utf32_decode1_info:
         const GHC.IO.Encoding.UTF32.utf32_decode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8DY7() //  [R1]
         { []
         }
     {offset
       c8DY7: // global
           I64[Sp] = block_c8DYd_info;
           _s8Dde::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Dde::P64;
           if (R1 & 7 != 0) goto u8DYm; else goto c8DYh;
       u8DYm: // global
           call _c8DYd(R1) args: 0, res: 0, upd: 0;
       c8DYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DY7_info" {
     block_c8DY7_info:
         const _c8DY7;
         const 2;
         const 30;
 },
 _c8DYd() //  [R1]
         { []
         }
     {offset
       c8DYd: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DYd_info" {
     block_c8DYd_info:
         const _c8DYd;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.929212034 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8DYJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_decode_info" {
     GHC.IO.Encoding.UTF32.utf32_decode_info:
         const GHC.IO.Encoding.UTF32.utf32_decode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.935047236 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { []
         }
     {offset
       c8DYR: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8DZ2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8DZ3; else goto c8DZ4;
       c8DZ3: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8DZ4: // global
           I64[Sp - 48] = block_c8DYV_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8DZY; else goto c8DYW;
       u8DZY: // global
           call _c8DYV(R1) args: 0, res: 0, upd: 0;
       c8DYW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.$wutf32_encode_info" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_info:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 14600;
         const GHC.IO.Encoding.UTF32.$wutf32_encode_slow;
 },
 _c8DYV() //  [R1]
         { []
         }
     {offset
       c8DYV: // global
           _s8Ddn::P64 = P64[Sp + 16];
           _s8Ddo::I64 = I64[Sp + 24];
           _s8Ddp::P64 = P64[Sp + 32];
           _s8Ddq::P64 = P64[Sp + 40];
           _s8Ddr::I64 = I64[Sp + 48];
           _s8Dds::I64 = I64[Sp + 56];
           _s8Ddt::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8DYZ; else goto c8DZ0;
       c8DYZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8DZ9; else goto c8DZ8;
       c8DZ9: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DZ8: // global
           if (%MO_S_Ge_W64(_s8Ddr::I64 - _s8Ddt::I64,
                            4)) goto c8DZN; else goto c8DZR;
       c8DZN: // global
           _s8Ddm::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8Ddm::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ddm::P64);
           I8[_s8Ddo::I64 + _s8Ddt::I64] = 0 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ddp::P64;
           P64[Hp - 64] = _s8Ddq::P64;
           I64[Hp - 56] = _s8Ddo::I64;
           I64[Hp - 48] = _s8Ddr::I64;
           I64[Hp - 40] = _s8Dds::I64;
           I64[Hp - 32] = _s8Ddt::I64 + 4;
           _c8DZL::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8DZL::P64;
           R2 = _s8Ddn::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DZR: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ddp::P64;
           P64[Hp - 64] = _s8Ddq::P64;
           I64[Hp - 56] = _s8Ddo::I64;
           I64[Hp - 48] = _s8Ddr::I64;
           I64[Hp - 40] = _s8Dds::I64;
           I64[Hp - 32] = _s8Ddt::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8Ddn::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DZ0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DZX; else goto c8DZW;
       c8DZX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DZW: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Ddp::P64;
           P64[Hp - 32] = _s8Ddq::P64;
           I64[Hp - 24] = _s8Ddo::I64;
           I64[Hp - 16] = _s8Ddr::I64;
           I64[Hp - 8] = _s8Dds::I64;
           I64[Hp] = _s8Ddt::I64;
           R3 = Hp - 47;
           R2 = _s8Ddn::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DYV_info" {
     block_c8DYV_info:
         const _c8DYV;
         const 14600;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.944565481 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8E0B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E0F; else goto c8E0G;
       c8E0F: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E0G: // global
           I64[Sp - 24] = block_c8E0y_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E0O; else goto c8E0z;
       u8E0O: // global
           call _c8E0y(R1) args: 0, res: 0, upd: 0;
       c8E0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_encode1_info" {
     GHC.IO.Encoding.UTF32.utf32_encode1_info:
         const GHC.IO.Encoding.UTF32.utf32_encode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8E0y() //  [R1]
         { []
         }
     {offset
       c8E0y: // global
           I64[Sp] = block_c8E0E_info;
           _s8De1::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8De1::P64;
           if (R1 & 7 != 0) goto u8E0N; else goto c8E0I;
       u8E0N: // global
           call _c8E0E(R1) args: 0, res: 0, upd: 0;
       c8E0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E0y_info" {
     block_c8E0y_info:
         const _c8E0y;
         const 2;
         const 30;
 },
 _c8E0E() //  [R1]
         { []
         }
     {offset
       c8E0E: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E0E_info" {
     block_c8E0E_info:
         const _c8E0E;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.951389907 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8E1b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_encode_info" {
     GHC.IO.Encoding.UTF32.utf32_encode_info:
         const GHC.IO.Encoding.UTF32.utf32_encode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.954388701 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.956645663 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { []
         }
     {offset
       c8E1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E1q; else goto c8E1r;
       c8E1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8E1r: // global
           (_c8E1m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8E1m::I64 == 0) goto c8E1o; else goto c8E1n;
       c8E1o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8E1n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8E1m::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF7_info" {
     GHC.IO.Encoding.UTF32.mkUTF7_info:
         const GHC.IO.Encoding.UTF32.mkUTF7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.965995777 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8DeT_entry() //  [R1, R2]
         { []
         }
     {offset
       c8E1T: // global
           _s8DeB::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8DeB::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8DeB::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DeT_info" {
     sat_s8DeT_info:
         const sat_s8DeT_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8DeP_entry() //  [R1]
         { []
         }
     {offset
       c8E22: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DeP_info" {
     sat_s8DeP_info:
         const sat_s8DeP_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8DeN_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8E2a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DeN_info" {
     sat_s8DeN_info:
         const sat_s8DeN_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt;
 },
 sat_s8DeM_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8E2l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E2m; else goto c8E2n;
       c8E2m: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E2n: // global
           I64[Sp - 24] = block_c8E2i_info;
           _s8DeB::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8DeB::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E2r; else goto c8E2j;
       u8E2r: // global
           call _c8E2i(R1) args: 0, res: 0, upd: 0;
       c8E2j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DeM_info" {
     sat_s8DeM_info:
         const sat_s8DeM_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8E2i() //  [R1]
         { []
         }
     {offset
       c8E2i: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E2i_info" {
     block_c8E2i_info:
         const _c8E2i;
         const 2;
         const 30;
 },
 sat_s8DeV_entry() //  [R1]
         { []
         }
     {offset
       c8E2t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E2u; else goto c8E2v;
       c8E2u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8E2v: // global
           I64[Sp - 16] = block_c8E1J_info;
           _s8De9::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8De9::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8DeV_info" {
     sat_s8DeV_info:
         const sat_s8DeV_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt;
 },
 _c8E1J() //  [R1]
         { []
         }
     {offset
       c8E1J: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8E2y; else goto c8E2x;
       c8E2y: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8E2x: // global
           I64[Hp - 104] = sat_s8DeT_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8DeP_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8DeN_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8DeM_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E1J_info" {
     block_c8E1J_info:
         const _c8E1J;
         const 1;
         const 4294967326;
         const S8DJN_srt;
 },
 sat_s8Dev_entry() //  [R1, R2]
         { []
         }
     {offset
       c8E2O: // global
           _s8Ded::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Ded::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ded::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Dev_info" {
     sat_s8Dev_info:
         const sat_s8Dev_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8Der_entry() //  [R1]
         { []
         }
     {offset
       c8E2X: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Der_info" {
     sat_s8Der_info:
         const sat_s8Der_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8Dep_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8E35: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Dep_info" {
     sat_s8Dep_info:
         const sat_s8Dep_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8DJN_srt+8;
 },
 sat_s8Deo_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8E3g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E3h; else goto c8E3i;
       c8E3h: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E3i: // global
           I64[Sp - 24] = block_c8E3d_info;
           _s8Ded::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8Ded::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E3m; else goto c8E3e;
       u8E3m: // global
           call _c8E3d(R1) args: 0, res: 0, upd: 0;
       c8E3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Deo_info" {
     sat_s8Deo_info:
         const sat_s8Deo_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8E3d() //  [R1]
         { []
         }
     {offset
       c8E3d: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E3d_info" {
     block_c8E3d_info:
         const _c8E3d;
         const 2;
         const 30;
 },
 sat_s8Dex_entry() //  [R1]
         { []
         }
     {offset
       c8E3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E3p; else goto c8E3q;
       c8E3p: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8E3q: // global
           I64[Sp - 16] = block_c8E2E_info;
           _s8De9::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8De9::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Dex_info" {
     sat_s8Dex_info:
         const sat_s8Dex_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8DJN_srt+8;
 },
 _c8E2E() //  [R1]
         { []
         }
     {offset
       c8E2E: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8E3t; else goto c8E3s;
       c8E3t: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8E3s: // global
           I64[Hp - 104] = sat_s8Dev_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Der_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Dep_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Deo_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E2E_info" {
     block_c8E2E_info:
         const _c8E2E;
         const 1;
         const 4294967326;
         const S8DJN_srt+8;
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { []
         }
     {offset
       c8E3v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8E3z; else goto c8E3y;
       c8E3z: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8E3y: // global
           I64[Hp - 56] = sat_s8DeV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Dex_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.mkUTF32_info" {
     GHC.IO.Encoding.UTF32.mkUTF32_info:
         const GHC.IO.Encoding.UTF32.mkUTF32_entry;
         const 0;
         const 211119117434894;
         const 4294967301;
         const S8DJN_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.993820031 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { []
         }
     {offset
       c8E5m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E5n; else goto c8E5o;
       c8E5n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8E5o: // global
           (_c8E5j::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8E5j::I64 == 0) goto c8E5l; else goto c8E5k;
       c8E5l: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8E5k: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8E5j::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF32.utf32_info" {
     GHC.IO.Encoding.UTF32.utf32_info:
         const GHC.IO.Encoding.UTF32.utf32_entry;
         const 0;
         const 4294967317;
         const S8DJN_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:47.997489301 UTC

[section ""relreadonly" . S8DJN_srt" {
     S8DJN_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]

