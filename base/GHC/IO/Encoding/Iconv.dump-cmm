
==================== Output Cmm ====================
2018-03-16 16:04:59.984816889 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:59.985459951 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.98600724 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.986582509 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.987153484 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.987744254 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.988351042 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.989234631 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { info_tbl: [(c9VbT,
                       label: lvl1_r9V6z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VbT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VbU; else goto c9VbV;
       c9VbU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VbV: // global
           (_c9VbQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VbQ::I64 == 0) goto c9VbS; else goto c9VbR;
       c9VbS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VbR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VbQ::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.990441197 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { info_tbl: [(c9Vc2,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vc2: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.991352266 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { info_tbl: [(c9Vca,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding15_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vca: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.992887663 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { info_tbl: [(c9Vch,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding14_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vch: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.993569085 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.994247613 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { info_tbl: [(c9Vcq,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vcq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vcr; else goto c9Vcs;
       c9Vcr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vcs: // global
           (_c9Vcn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Vcn::I64 == 0) goto c9Vcp; else goto c9Vco;
       c9Vcp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Vco: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Vcn::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:59.997621717 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9V7x_entry() //  [R1]
         { info_tbl: [(c9Vdo,
                       label: sat_s9V7x_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vdo: // global
           (_s9V7q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7q::I64) == (-1) :: W32) goto c9Vdn; else goto c9Vdm;
       c9Vdn: // global
           (_s9V7v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7v::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9Vdm: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9V7l_entry() //  [R1]
         { info_tbl: [(c9VdH,
                       label: sat_s9V7l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VdH: // global
           _s9V7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VdI; else goto c9VdJ;
       c9VdJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VdL; else goto c9VdK;
       c9VdL: // global
           HpAlloc = 16;
           goto c9VdI;
       c9VdI: // global
           R1 = _s9V7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VdK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V7l::P64;
           _s9V6L::P64 = P64[_s9V7l::P64 + 16];
           _s9V7h::I64 = I64[_s9V7l::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9V7h::I64;
           R2 = Hp - 7;
           R1 = _s9V6L::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9V7S_entry() //  [R1]
         { info_tbl: [(c9VdZ,
                       label: sat_s9V7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VdZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Ve0; else goto c9Ve1;
       c9Ve0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ve1: // global
           I64[Sp - 8] = block_c9VdW_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Ven; else goto c9VdX;
       u9Ven: // global
           call _c9VdW(R1) args: 0, res: 0, upd: 0;
       c9VdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VdW() //  [R1]
         { info_tbl: [(c9VdW,
                       label: block_c9VdW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VdW: // global
           (_s9V7L::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7L::I64) == (-1) :: W32) goto c9Vei; else goto c9Vec;
       c9Vei: // global
           (_s9V7Q::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7Q::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9Vec: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9Veo,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding11_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Veo: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9Vep; else goto c9Veq;
       c9Vep: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Veq: // global
           I64[Sp - 40] = block_c9Vcx_info;
           _s9V6J::P64 = R3;
           R3 = 0;
           _s9V6I::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9V6I::P64;
           P64[Sp - 24] = _s9V6J::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vcx() //  [R1]
         { info_tbl: [(c9Vcx,
                       label: block_c9Vcx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vcx: // global
           I64[Sp] = block_c9VcE_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VcE() //  [R1]
         { info_tbl: [(c9VcE,
                       label: block_c9VcE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VcE: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9Vf8() args: 0, res: 0, upd: 0;
     }
 },
 _c9Vf8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vf8: // global
           _s9V88::P64 = P64[Sp];
           I64[Sp] = block_c9Vfb_info;
           R1 = _s9V88::P64;
           if (R1 & 7 != 0) goto u9VfX; else goto c9Vfd;
       u9VfX: // global
           call _c9Vfb(R1) args: 0, res: 0, upd: 0;
       c9Vfd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vfb() //  [R1]
         { info_tbl: [(c9Vfb,
                       label: block_c9Vfb_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vfb: // global
           if (R1 & 7 == 1) goto c9Vfj; else goto c9Vfo;
       c9Vfj: // global
           _s9V6J::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9VcO_info;
           R3 = 0;
           R2 = _s9V6J::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9Vfo: // global
           I64[Sp - 8] = block_c9Vfm_info;
           _s9V8d::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V8d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VfY; else goto c9Vfp;
       u9VfY: // global
           call _c9Vfm(R1) args: 0, res: 0, upd: 0;
       c9Vfp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VcO() //  [R1]
         { info_tbl: [(c9VcO,
                       label: block_c9VcO_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VcO: // global
           I64[Sp] = block_c9VcV_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VcV() //  [R1]
         { info_tbl: [(c9VcV,
                       label: block_c9VcV_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VcV: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9VeK() args: 0, res: 0, upd: 0;
     }
 },
 _c9VeK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VeK: // global
           _s9V7V::P64 = P64[Sp];
           I64[Sp] = block_c9VeN_info;
           R1 = _s9V7V::P64;
           if (R1 & 7 != 0) goto u9VfT; else goto c9VeP;
       u9VfT: // global
           call _c9VeN(R1) args: 0, res: 0, upd: 0;
       c9VeP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VeN() //  [R1]
         { info_tbl: [(c9VeN,
                       label: block_c9VeN_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VeN: // global
           if (R1 & 7 == 1) goto c9VeV; else goto c9Vf0;
       c9VeV: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9Vd3() args: 0, res: 0, upd: 0;
       c9Vf0: // global
           I64[Sp - 8] = block_c9VeY_info;
           _s9V80::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V80::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VfU; else goto c9Vf1;
       u9VfU: // global
           call _c9VeY(R1) args: 0, res: 0, upd: 0;
       c9Vf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vd3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vd3: // global
           Hp = Hp + 96;
           _s9V7a::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9Vey; else goto c9Vex;
       c9Vey: // global
           HpAlloc = 96;
           I64[Sp] = block_c9Vd2_info;
           R1 = _s9V7a::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Vex: // global
           _s9V6K::P64 = P64[Sp + 40];
           _s9V6L::P64 = P64[Sp + 48];
           _s9V6U::P64 = P64[Sp + 24];
           _s9V6V::I64 = I64[Sp + 16];
           _s9V77::P64 = P64[Sp + 32];
           _s9V78::I64 = I64[Sp + 8];
           I8[_s9V78::I64 + _s9V7a::I64] = 0 :: W8;
           (_s9V7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9V78::I64, _s9V6V::I64);
           if (_s9V7g::I64 == (-1)) goto c9VeE; else goto c9VeB;
       c9VeE: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9VdN_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VeB: // global
           call MO_Touch(_s9V77::P64);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7x_info;
           I64[Hp - 80] = _s9V7g::I64;
           I64[Hp - 72] = sat_s9V7l_info;
           P64[Hp - 56] = _s9V6L::P64;
           I64[Hp - 48] = _s9V7g::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Vd2() //  [R1]
         { info_tbl: [(c9Vd2,
                       label: block_c9Vd2_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vd2: // global
           I64[Sp] = R1;
           call _c9Vd3() args: 0, res: 0, upd: 0;
     }
 },
 _c9VdN() //  [R1]
         { info_tbl: [(c9VdN,
                       label: block_c9VdN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VdN: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9VeH; else goto c9VeG;
       c9VeH: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VeG: // global
           _s9V6K::P64 = P64[Sp + 24];
           _s9V6L::P64 = P64[Sp + 32];
           _s9V6U::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7S_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9V6L::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VeY() //  [R1]
         { info_tbl: [(c9VeY,
                       label: block_c9VeY_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VeY: // global
           _s9V7W::I64 = I64[Sp + 16];
           _s9V80::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V7W::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V80::P64;
           I64[Sp + 16] = _s9V7W::I64 + 1;
           Sp = Sp + 8;
           call _c9VeK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Vfm() //  [R1]
         { info_tbl: [(c9Vfm,
                       label: block_c9Vfm_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vfm: // global
           _s9V89::I64 = I64[Sp + 16];
           _s9V8d::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V89::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V8d::P64;
           I64[Sp + 16] = _s9V89::I64 + 1;
           Sp = Sp + 8;
           call _c9Vf8() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.002993445 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { info_tbl: [(c9Vg7,
                       label: lvl2_r9V6A_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vg7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Vg8; else goto c9Vg9;
       c9Vg8: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Vg9: // global
           I64[Sp - 8] = block_c9Vg4_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Vg4() //  []
         { info_tbl: [(c9Vg4,
                       label: block_c9Vg4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vg4: // global
           (_s9V8p::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9V8p::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.004040947 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { info_tbl: [(c9Vgj,
                       label: GHC.IO.Encoding.Iconv.localeEncodingName_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vgj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Vgk; else goto c9Vgl;
       c9Vgk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vgl: // global
           (_c9Vge::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Vge::I64 == 0) goto c9Vgg; else goto c9Vgf;
       c9Vgg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Vgf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Vge::I64;
           I64[Sp - 24] = block_c9Vgh_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9Vgh() //  [R1]
         { info_tbl: [(c9Vgh,
                       label: block_c9Vgh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vgh: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.004967202 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.005532501 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.006186379 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { info_tbl: [(c9Vgt,
                       label: GHC.IO.Encoding.Iconv.haskellChar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vgt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vgu; else goto c9Vgv;
       c9Vgu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vgv: // global
           (_c9Vgq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Vgq::I64 == 0) goto c9Vgs; else goto c9Vgr;
       c9Vgs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Vgr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Vgq::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.007062228 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.007585797 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.008135187 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.008826553 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { info_tbl: [(c9VgC,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VgC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VgD; else goto c9VgE;
       c9VgD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VgE: // global
           (_c9Vgz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Vgz::I64 == 0) goto c9VgB; else goto c9VgA;
       c9VgB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VgA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Vgz::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.014532988 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9V9L_entry() //  [R1]
         { info_tbl: [(c9Vid,
                       label: new_outleft'_s9V9L_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vid: // global
           _s9V9L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vie; else goto c9Vif;
       c9Vif: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Vih; else goto c9Vig;
       c9Vih: // global
           HpAlloc = 16;
           goto c9Vie;
       c9Vie: // global
           R1 = _s9V9L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9L::P64;
           _s9V97::I64 = I64[_s9V9L::P64 + 16];
           _s9V9K::I64 = I64[_s9V9L::P64 + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vib; else goto c9Vic;
       c9Vib: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9V9K::I64, _s9V97::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vic: // global
           if (%MO_S_Ge_W64(_s9V9K::I64, 0)) goto c9Vix; else goto c9Viy;
       c9Vix: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Viy: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 new_input_s9V9R_entry() //  [R1]
         { info_tbl: [(c9ViH,
                       label: new_input_s9V9R_info
                       rep:HeapRep 2 ptrs 5 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ViH: // global
           _s9V9R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9ViI; else goto c9ViJ;
       c9ViJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9ViL; else goto c9ViK;
       c9ViL: // global
           HpAlloc = 56;
           goto c9ViI;
       c9ViI: // global
           R1 = _s9V9R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9ViK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9R::P64;
           _s9V8B::P64 = P64[_s9V9R::P64 + 16];
           _s9V8C::P64 = P64[_s9V9R::P64 + 24];
           _s9V8A::I64 = I64[_s9V9R::P64 + 32];
           _s9V8D::I64 = I64[_s9V9R::P64 + 40];
           _s9V9S::I64 = I64[_s9V9R::P64 + 64];
           if (_s9V9S::I64 != 0) goto c9ViF; else goto c9ViG;
       c9ViF: // global
           _s9V8F::I64 = I64[_s9V9R::P64 + 48];
           _s9V8U::I64 = I64[_s9V9R::P64 + 56];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9Vj1; else goto c9Vji;
       c9Vj1: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 - %MO_S_Shr_W64(_s9V9S::I64,
                                                     _s9V8U::I64);
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vji: // global
           if (%MO_S_Ge_W64(_s9V9S::I64, 0)) goto c9Vjb; else goto c9Vjh;
       c9Vjb: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vjh: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 + 1;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9ViG: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaa_entry() //  [R1]
         { info_tbl: [(c9VjA,
                       label: sat_s9Vaa_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VjA: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VjH; else goto c9VjI;
       c9VjH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VjI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Vjx_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VjM; else goto c9Vjy;
       u9VjM: // global
           call _c9Vjx(R1) args: 0, res: 0, upd: 0;
       c9Vjy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vjx() //  [R1]
         { info_tbl: [(c9Vjx,
                       label: block_c9Vjx_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vjx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VjL; else goto c9VjK;
       c9VjL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VjK: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Va9::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Va9::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaz_entry() //  [R1]
         { info_tbl: [(c9Vk6,
                       label: sat_s9Vaz_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vk6: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vkd; else goto c9Vke;
       c9Vkd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vke: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Vk3_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Vki; else goto c9Vk4;
       u9Vki: // global
           call _c9Vk3(R1) args: 0, res: 0, upd: 0;
       c9Vk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vk3() //  [R1]
         { info_tbl: [(c9Vk3,
                       label: block_c9Vk3_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vk3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vkh; else goto c9Vkg;
       c9Vkh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Vkg: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Vay::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Vay::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaK_entry() //  [R1]
         { info_tbl: [(c9Vkx,
                       label: sat_s9VaK_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vkx: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VkE; else goto c9VkF;
       c9VkE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VkF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Vku_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VkJ; else goto c9Vkv;
       u9VkJ: // global
           call _c9Vku(R1) args: 0, res: 0, upd: 0;
       c9Vkv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vku() //  [R1]
         { info_tbl: [(c9Vku,
                       label: block_c9Vku_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vku: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VkI; else goto c9VkH;
       c9VkI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VkH: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaJ::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaZ_entry() //  [R1]
         { info_tbl: [(c9VkY,
                       label: sat_s9VaZ_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VkY: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vl5; else goto c9Vl6;
       c9Vl5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vl6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VkV_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Vla; else goto c9VkW;
       u9Vla: // global
           call _c9VkV(R1) args: 0, res: 0, upd: 0;
       c9VkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VkV() //  [R1]
         { info_tbl: [(c9VkV,
                       label: block_c9VkV_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VkV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vl9; else goto c9Vl8;
       c9Vl9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Vl8: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaY::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaY::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaV_entry() //  [R1]
         { info_tbl: [(c9Vli,
                       label: sat_s9VaV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vli: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Vlj; else goto c9Vlk;
       c9Vlj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9Vlf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Vls; else goto c9Vlg;
       u9Vls: // global
           call _c9Vlf(R1) args: 0, res: 0, upd: 0;
       c9Vlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vlf() //  [R1]
         { info_tbl: [(c9Vlf,
                       label: block_c9Vlf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vlf: // global
           if (I64[R1 + 7] == 0) goto c9Vlr; else goto c9Vlq;
       c9Vlr: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vlq: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c9Vlt,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vlt: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9Vlu; else goto c9Vlv;
       c9Vlu: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Vlv: // global
           I64[Sp - 40] = block_c9VgJ_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VmL; else goto c9VgK;
       u9VmL: // global
           call _c9VgJ(R1) args: 0, res: 0, upd: 0;
       c9VgK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VgJ() //  [R1]
         { info_tbl: [(c9VgJ,
                       label: block_c9VgJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VgJ: // global
           I64[Sp - 40] = block_c9VgO_info;
           _s9V8B::P64 = P64[R1 + 7];
           _s9V8C::P64 = P64[R1 + 15];
           _s9V8A::I64 = I64[R1 + 23];
           _s9V8D::I64 = I64[R1 + 31];
           _s9V8E::I64 = I64[R1 + 39];
           _s9V8F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9V8C::P64;
           I64[Sp - 24] = _s9V8D::I64;
           I64[Sp - 16] = _s9V8E::I64;
           I64[Sp - 8] = _s9V8F::I64;
           P64[Sp] = _s9V8B::P64;
           I64[Sp + 24] = _s9V8A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VmH; else goto c9VgP;
       u9VmH: // global
           call _c9VgO(R1) args: 0, res: 0, upd: 0;
       c9VgP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VgO() //  [R1]
         { info_tbl: [(c9VgO,
                       label: block_c9VgO_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VgO: // global
           I64[Sp - 48] = block_c9VgT_info;
           R2 = 8;
           _s9V8I::P64 = P64[R1 + 7];
           _s9V8J::P64 = P64[R1 + 15];
           _s9V8H::I64 = I64[R1 + 23];
           _s9V8K::I64 = I64[R1 + 31];
           _s9V8L::I64 = I64[R1 + 39];
           _s9V8M::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9V8I::P64;
           P64[Sp - 32] = _s9V8J::P64;
           I64[Sp - 24] = _s9V8K::I64;
           I64[Sp - 16] = _s9V8L::I64;
           I64[Sp - 8] = _s9V8M::I64;
           I64[Sp] = _s9V8H::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VgT() //  [R1]
         { info_tbl: [(c9VgT,
                       label: block_c9VgT_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VgT: // global
           I64[Sp] = block_c9VgV_info;
           _s9V8S::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9V8S::P64;
           if (R1 & 7 != 0) goto u9VmI; else goto c9VgW;
       u9VmI: // global
           call _c9VgV(R1) args: 0, res: 0, upd: 0;
       c9VgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VgV() //  [R1]
         { info_tbl: [(c9VgV,
                       label: block_c9VgV_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VgV: // global
           _s9V8A::I64 = I64[Sp + 112];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V8U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9Vmi; else goto c9Vmj;
       c9Vmi: // global
           _s9V8W::I64 = I64[Sp + 72] << _s9V8U::I64;
           goto s9V8V;
       c9Vmj: // global
           _s9V8W::I64 = 0;
           goto s9V8V;
       s9V8V: // global
           _s9V8X::I64 = _s9V8S::P64 + 16;
           I64[_s9V8X::I64] = _s9V8A::I64 + _s9V8W::I64;
           I64[Sp - 16] = block_c9Vhb_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V8X::I64;
           I64[Sp] = _s9V8U::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vhb() //  [R1]
         { info_tbl: [(c9Vhb,
                       label: block_c9Vhb_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vhb: // global
           I64[Sp] = block_c9Vhd_info;
           _s9V95::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9V95::P64;
           if (R1 & 7 != 0) goto u9VmJ; else goto c9Vhe;
       u9VmJ: // global
           call _c9Vhd(R1) args: 0, res: 0, upd: 0;
       c9Vhe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vhd() //  [R1]
         { info_tbl: [(c9Vhd,
                       label: block_c9Vhd_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vhd: // global
           _s9V8H::I64 = I64[Sp + 64];
           _s9V95::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vmd; else goto c9Vme;
       c9Vmd: // global
           _s9V99::I64 = I64[Sp + 56] << _s9V97::I64;
           goto s9V98;
       c9Vme: // global
           _s9V99::I64 = 0;
           goto s9V98;
       s9V98: // global
           _s9V9a::I64 = _s9V95::P64 + 16;
           I64[_s9V9a::I64] = _s9V8H::I64 + _s9V99::I64;
           I64[Sp - 16] = block_c9Vht_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V9a::I64;
           I64[Sp] = _s9V97::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vht() //  [R1]
         { info_tbl: [(c9Vht,
                       label: block_c9Vht_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vht: // global
           _s9V8U::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9Vm8; else goto c9Vm9;
       c9Vm8: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9V8U::I64;
           goto s9V9j;
       c9Vm9: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = 0;
           goto s9V9j;
       s9V9j: // global
           _s9V9l::I64 = _s9V9i::P64 + 16;
           I64[_s9V9l::I64] = _s9V9k::I64;
           I64[Sp - 8] = block_c9VhG_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9V9l::I64;
           P64[Sp + 104] = _s9V9i::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VhG() //  [R1]
         { info_tbl: [(c9VhG,
                       label: block_c9VhG_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VhG: // global
           _s9V8t::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vm3; else goto c9Vm4;
       c9Vm3: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9V97::I64;
           goto s9V9u;
       c9Vm4: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = 0;
           goto s9V9u;
       s9V9u: // global
           _s9V9w::I64 = _s9V9t::P64 + 16;
           I64[_s9V9w::I64] = _s9V9v::I64;
           I64[Sp] = block_c9VhT_info;
           R1 = _s9V8t::P64;
           I64[Sp + 80] = _s9V9w::I64;
           P64[Sp + 136] = _s9V9t::P64;
           if (R1 & 7 != 0) goto u9VmK; else goto c9VhU;
       u9VmK: // global
           call _c9VhT(R1) args: 0, res: 0, upd: 0;
       c9VhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VhT() //  [R1]
         { info_tbl: [(c9VhT,
                       label: block_c9VhT_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VhT: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9VlK; else goto c9VlJ;
       c9VlK: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VlJ: // global
           _s9V8A::I64 = I64[Sp + 152];
           _s9V8B::P64 = P64[Sp + 128];
           _s9V8C::P64 = P64[Sp + 96];
           _s9V8D::I64 = I64[Sp + 104];
           _s9V8F::I64 = I64[Sp + 120];
           _s9V8H::I64 = I64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 48];
           _s9V8J::P64 = P64[Sp + 56];
           _s9V8K::I64 = I64[Sp + 64];
           _s9V8L::I64 = I64[Sp + 72];
           _s9V8S::P64 = P64[Sp + 144];
           _s9V8U::I64 = I64[Sp + 40];
           _s9V95::P64 = P64[Sp + 160];
           _s9V97::I64 = I64[Sp + 24];
           _s9V9i::P64 = P64[Sp + 112];
           _s9V9l::I64 = I64[Sp + 8];
           _s9V9t::P64 = P64[Sp + 136];
           _s9V9w::I64 = I64[Sp + 80];
           (_s9V9E::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9V9l::I64, I64[Sp + 16], _s9V9w::I64);
           _s9V9H::I64 = I64[_s9V9l::I64];
           _s9V9K::I64 = I64[_s9V9w::I64];
           I64[Hp - 216] = new_outleft'_s9V9L_info;
           I64[Hp - 200] = _s9V97::I64;
           I64[Hp - 192] = _s9V9K::I64;
           I64[Hp - 184] = new_input_s9V9R_info;
           P64[Hp - 168] = _s9V8B::P64;
           P64[Hp - 160] = _s9V8C::P64;
           I64[Hp - 152] = _s9V8A::I64;
           I64[Hp - 144] = _s9V8D::I64;
           I64[Hp - 136] = _s9V8F::I64;
           I64[Hp - 128] = _s9V8U::I64;
           I64[Hp - 120] = _s9V9H::I64;
           _c9Vi4::P64 = Hp - 216;
           _c9Viz::P64 = Hp - 184;
           if (_s9V9E::I64 == 18446744073709551615) goto c9VlZ; else goto c9VlN;
       c9VlZ: // global
           (_s9Vaf::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9Vag::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9Vaf::I64));
           if (%MO_S_Lt_W64(_s9Vag::I64, 23)) goto u9VmE; else goto u9VmG;
       u9VmE: // global
           if (%MO_S_Lt_W64(_s9Vag::I64, 22)) goto u9VmF; else goto c9VlW;
       u9VmF: // global
           if (_s9Vag::I64 != 7) goto c9VlQ; else goto c9VlU;
       c9VlU: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaz_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vi4::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9Viz::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VlT::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VlT::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VlW: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaK_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vi4::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Viz::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VlV::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VlV::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9VmG: // global
           if (_s9Vag::I64 != 84) goto c9VlQ; else goto c9VlY;
       c9VlQ: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9VlO_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VlY: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaZ_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vi4::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = sat_s9VaV_info;
           P64[Hp - 32] = _c9Vi4::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9Viz::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VlN: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaa_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vi4::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Viz::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VlL::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VlL::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VlO() //  [R1]
         { info_tbl: [(c9VlO,
                       label: block_c9VlO_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VlO: // global
           _s9V8B::P64 = P64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 8];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V95::P64 = P64[Sp + 120];
           _s9V9i::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.025510763 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VmQ,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding10_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VmQ: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.026410585 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VmX,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VmX: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.027464128 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { info_tbl: [(c9Vn7,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vn7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Vn8; else goto c9Vn9;
       c9Vn8: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Vn9: // global
           I64[Sp - 8] = block_c9Vn4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Vnh; else goto c9Vn5;
       u9Vnh: // global
           call _c9Vn4(R1) args: 0, res: 0, upd: 0;
       c9Vn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vn4() //  [R1]
         { info_tbl: [(c9Vn4,
                       label: block_c9Vn4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vn4: // global
           if (I64[R1 + 7] == 47) goto c9Vng; else goto c9Vnf;
       c9Vng: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Vnf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.028535589 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.030708173 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9Vbq_entry() //  [R1]
         { info_tbl: [(c9Vnt,
                       label: ds_s9Vbq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vnt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Vnu; else goto c9Vnv;
       c9Vnu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vnv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9Vnq_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vnq() //  [R1, R2]
         { info_tbl: [(c9Vnq,
                       label: block_c9Vnq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vnq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Vny; else goto c9Vnx;
       c9Vny: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9Vnx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 enc_s9Vby_entry() //  [R1]
         { info_tbl: [(c9VnF,
                       label: enc_s9Vby_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VnF: // global
           _s9Vby::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VnG; else goto c9VnH;
       c9VnH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VnJ; else goto c9VnI;
       c9VnJ: // global
           HpAlloc = 24;
           goto c9VnG;
       c9VnG: // global
           R1 = _s9Vby::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VnI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9Vby::P64;
           _s9Vbq::P64 = P64[_s9Vby::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9Vbq::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 enc1_s9VbD_entry() //  [R1, R2, R3]
         { info_tbl: [(c9VnP,
                       label: enc1_s9VbD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VnP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc2_s9VbE_entry() //  [R1]
         { info_tbl: [(c9VnX,
                       label: enc2_s9VbE_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VnX: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 enc3_s9VbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Vo5,
                       label: enc3_s9VbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vo5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc4_s9VbG_entry() //  [R1]
         { info_tbl: [(c9Vod,
                       label: enc4_s9VbG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vod: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9VbM_entry() //  [R1]
         { info_tbl: [(c9Vou,
                       label: sat_s9VbM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vou: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Vov; else goto c9Vow;
       c9Vov: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vow: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9Von_info;
           _s9VbH::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9VbH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9VoG; else goto c9Voo;
       u9VoG: // global
           call _c9Von(R1) args: 0, res: 0, upd: 0;
       c9Voo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Von() //  [R1]
         { info_tbl: [(c9Von,
                       label: block_c9Von_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Von: // global
           if (R1 & 7 == 1) goto c9Vor; else goto c9Vos;
       c9Vor: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vos: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VoF; else goto c9VoE;
       c9VoF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VoE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { info_tbl: [(c9VoH,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VoH: // global
           _s9Vbo::P64 = R3;
           _s9Vbn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VoI; else goto c9VoJ;
       c9VoJ: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9VoL; else goto c9VoK;
       c9VoL: // global
           HpAlloc = 192;
           goto c9VoI;
       c9VoI: // global
           R3 = _s9Vbo::P64;
           R2 = _s9Vbn::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VoK: // global
           I64[Hp - 184] = ds_s9Vbq_info;
           P64[Hp - 168] = _s9Vbo::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9Vnm::P64 = Hp - 184;
           P64[Hp - 144] = _c9Vnm::P64;
           I64[Hp - 136] = enc_s9Vby_info;
           P64[Hp - 120] = _c9Vnm::P64;
           I64[Hp - 112] = enc1_s9VbD_info;
           P64[Hp - 104] = _s9Vbn::P64;
           I64[Hp - 96] = enc2_s9VbE_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9VbF_info;
           P64[Hp - 56] = _s9Vbn::P64;
           I64[Hp - 48] = enc4_s9VbG_info;
           P64[Hp - 40] = _s9Vbo::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9Vbo::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9Voh_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9Vog::P64 = Hp - 23;
           R2 = _c9Vog::P64;
           P64[Sp - 8] = _c9Vog::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Voh() //  [R1]
         { info_tbl: [(c9Voh,
                       label: block_c9Voh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Voh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9VoO; else goto c9VoN;
       c9VoO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VoN: // global
           I64[Hp - 24] = sat_s9VbM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.035736779 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { info_tbl: [(c9VoT,
                       label: GHC.IO.Encoding.Iconv.mkIconvEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VoT: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.036534897 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { info_tbl: [(c9Vp0,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vp0: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.037653013 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { info_tbl: [(c9Vp7,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vp7: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.038338966 UTC

[section ""relreadonly" . S9Vc5_srt" {
     S9Vc5_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.038931417 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:00.039464303 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.040051274 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.040576144 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.041089412 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.041668079 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.042203641 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.042971043 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { info_tbl: [(c9Vpg,
                       label: lvl1_r9V6z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vpg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vph; else goto c9Vpi;
       c9Vph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vpi: // global
           (_c9Vpd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Vpd::I64 == 0) goto c9Vpf; else goto c9Vpe;
       c9Vpf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Vpe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Vpd::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.04400527 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { info_tbl: [(c9Vpp,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vpp: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.044809153 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { info_tbl: [(c9Vpw,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding15_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vpw: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.045602242 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { info_tbl: [(c9VpD,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding14_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VpD: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.04630749 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.04701275 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { info_tbl: [(c9VpM,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VpM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VpN; else goto c9VpO;
       c9VpN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VpO: // global
           (_c9VpJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VpJ::I64 == 0) goto c9VpL; else goto c9VpK;
       c9VpL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VpK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VpJ::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.050579059 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9V7x_entry() //  [R1]
         { info_tbl: [(c9VqK,
                       label: sat_s9V7x_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VqK: // global
           (_s9V7q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7q::I64) == (-1) :: W32) goto c9VqJ; else goto c9VqI;
       c9VqJ: // global
           (_s9V7v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7v::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9VqI: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9V7l_entry() //  [R1]
         { info_tbl: [(c9Vr3,
                       label: sat_s9V7l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vr3: // global
           _s9V7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vr4; else goto c9Vr5;
       c9Vr5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Vr7; else goto c9Vr6;
       c9Vr7: // global
           HpAlloc = 16;
           goto c9Vr4;
       c9Vr4: // global
           R1 = _s9V7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vr6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V7l::P64;
           _s9V6L::P64 = P64[_s9V7l::P64 + 16];
           _s9V7h::I64 = I64[_s9V7l::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9V7h::I64;
           R2 = Hp - 7;
           R1 = _s9V6L::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9V7S_entry() //  [R1]
         { info_tbl: [(c9Vrl,
                       label: sat_s9V7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vrl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Vrm; else goto c9Vrn;
       c9Vrm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Vrn: // global
           I64[Sp - 8] = block_c9Vri_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VrJ; else goto c9Vrj;
       u9VrJ: // global
           call _c9Vri(R1) args: 0, res: 0, upd: 0;
       c9Vrj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vri() //  [R1]
         { info_tbl: [(c9Vri,
                       label: block_c9Vri_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vri: // global
           (_s9V7L::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7L::I64) == (-1) :: W32) goto c9VrE; else goto c9Vry;
       c9VrE: // global
           (_s9V7Q::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7Q::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9Vry: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9VrK,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding11_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VrK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9VrL; else goto c9VrM;
       c9VrL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VrM: // global
           I64[Sp - 40] = block_c9VpT_info;
           _s9V6J::P64 = R3;
           R3 = 0;
           _s9V6I::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9V6I::P64;
           P64[Sp - 24] = _s9V6J::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9VpT() //  [R1]
         { info_tbl: [(c9VpT,
                       label: block_c9VpT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VpT: // global
           I64[Sp] = block_c9Vq0_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vq0() //  [R1]
         { info_tbl: [(c9Vq0,
                       label: block_c9Vq0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vq0: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9Vsu() args: 0, res: 0, upd: 0;
     }
 },
 _c9Vsu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vsu: // global
           _s9V88::P64 = P64[Sp];
           I64[Sp] = block_c9Vsx_info;
           R1 = _s9V88::P64;
           if (R1 & 7 != 0) goto u9Vtj; else goto c9Vsz;
       u9Vtj: // global
           call _c9Vsx(R1) args: 0, res: 0, upd: 0;
       c9Vsz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vsx() //  [R1]
         { info_tbl: [(c9Vsx,
                       label: block_c9Vsx_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vsx: // global
           if (R1 & 7 == 1) goto c9VsF; else goto c9VsK;
       c9VsF: // global
           _s9V6J::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9Vqa_info;
           R3 = 0;
           R2 = _s9V6J::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9VsK: // global
           I64[Sp - 8] = block_c9VsI_info;
           _s9V8d::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V8d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Vtk; else goto c9VsL;
       u9Vtk: // global
           call _c9VsI(R1) args: 0, res: 0, upd: 0;
       c9VsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vqa() //  [R1]
         { info_tbl: [(c9Vqa,
                       label: block_c9Vqa_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vqa: // global
           I64[Sp] = block_c9Vqh_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vqh() //  [R1]
         { info_tbl: [(c9Vqh,
                       label: block_c9Vqh_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vqh: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9Vs6() args: 0, res: 0, upd: 0;
     }
 },
 _c9Vs6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vs6: // global
           _s9V7V::P64 = P64[Sp];
           I64[Sp] = block_c9Vs9_info;
           R1 = _s9V7V::P64;
           if (R1 & 7 != 0) goto u9Vtf; else goto c9Vsb;
       u9Vtf: // global
           call _c9Vs9(R1) args: 0, res: 0, upd: 0;
       c9Vsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vs9() //  [R1]
         { info_tbl: [(c9Vs9,
                       label: block_c9Vs9_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vs9: // global
           if (R1 & 7 == 1) goto c9Vsh; else goto c9Vsm;
       c9Vsh: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9Vqp() args: 0, res: 0, upd: 0;
       c9Vsm: // global
           I64[Sp - 8] = block_c9Vsk_info;
           _s9V80::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V80::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Vtg; else goto c9Vsn;
       u9Vtg: // global
           call _c9Vsk(R1) args: 0, res: 0, upd: 0;
       c9Vsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vqp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vqp: // global
           Hp = Hp + 96;
           _s9V7a::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9VrU; else goto c9VrT;
       c9VrU: // global
           HpAlloc = 96;
           I64[Sp] = block_c9Vqo_info;
           R1 = _s9V7a::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9VrT: // global
           _s9V6K::P64 = P64[Sp + 40];
           _s9V6L::P64 = P64[Sp + 48];
           _s9V6U::P64 = P64[Sp + 24];
           _s9V6V::I64 = I64[Sp + 16];
           _s9V77::P64 = P64[Sp + 32];
           _s9V78::I64 = I64[Sp + 8];
           I8[_s9V78::I64 + _s9V7a::I64] = 0 :: W8;
           (_s9V7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9V78::I64, _s9V6V::I64);
           if (_s9V7g::I64 == (-1)) goto c9Vs0; else goto c9VrX;
       c9Vs0: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9Vr9_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VrX: // global
           call MO_Touch(_s9V77::P64);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7x_info;
           I64[Hp - 80] = _s9V7g::I64;
           I64[Hp - 72] = sat_s9V7l_info;
           P64[Hp - 56] = _s9V6L::P64;
           I64[Hp - 48] = _s9V7g::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Vqo() //  [R1]
         { info_tbl: [(c9Vqo,
                       label: block_c9Vqo_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vqo: // global
           I64[Sp] = R1;
           call _c9Vqp() args: 0, res: 0, upd: 0;
     }
 },
 _c9Vr9() //  [R1]
         { info_tbl: [(c9Vr9,
                       label: block_c9Vr9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vr9: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9Vs3; else goto c9Vs2;
       c9Vs3: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Vs2: // global
           _s9V6K::P64 = P64[Sp + 24];
           _s9V6L::P64 = P64[Sp + 32];
           _s9V6U::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7S_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9V6L::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Vsk() //  [R1]
         { info_tbl: [(c9Vsk,
                       label: block_c9Vsk_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vsk: // global
           _s9V7W::I64 = I64[Sp + 16];
           _s9V80::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V7W::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V80::P64;
           I64[Sp + 16] = _s9V7W::I64 + 1;
           Sp = Sp + 8;
           call _c9Vs6() args: 0, res: 0, upd: 0;
     }
 },
 _c9VsI() //  [R1]
         { info_tbl: [(c9VsI,
                       label: block_c9VsI_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VsI: // global
           _s9V89::I64 = I64[Sp + 16];
           _s9V8d::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V89::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V8d::P64;
           I64[Sp + 16] = _s9V89::I64 + 1;
           Sp = Sp + 8;
           call _c9Vsu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.055797883 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { info_tbl: [(c9Vtt,
                       label: lvl2_r9V6A_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vtt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Vtu; else goto c9Vtv;
       c9Vtu: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Vtv: // global
           I64[Sp - 8] = block_c9Vtq_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Vtq() //  []
         { info_tbl: [(c9Vtq,
                       label: block_c9Vtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vtq: // global
           (_s9V8p::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9V8p::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.056948829 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { info_tbl: [(c9VtF,
                       label: GHC.IO.Encoding.Iconv.localeEncodingName_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VtF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VtG; else goto c9VtH;
       c9VtG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VtH: // global
           (_c9VtA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VtA::I64 == 0) goto c9VtC; else goto c9VtB;
       c9VtC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VtB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VtA::I64;
           I64[Sp - 24] = block_c9VtD_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9VtD() //  [R1]
         { info_tbl: [(c9VtD,
                       label: block_c9VtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VtD: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.058020203 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.058580879 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.059289702 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { info_tbl: [(c9VtP,
                       label: GHC.IO.Encoding.Iconv.haskellChar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VtP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VtQ; else goto c9VtR;
       c9VtQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VtR: // global
           (_c9VtM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VtM::I64 == 0) goto c9VtO; else goto c9VtN;
       c9VtO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VtN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VtM::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.060160647 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.060727313 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.061799575 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.062530743 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { info_tbl: [(c9VtY,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VtY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VtZ; else goto c9Vu0;
       c9VtZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vu0: // global
           (_c9VtV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VtV::I64 == 0) goto c9VtX; else goto c9VtW;
       c9VtX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VtW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VtV::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.068197533 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9V9L_entry() //  [R1]
         { info_tbl: [(c9Vvz,
                       label: new_outleft'_s9V9L_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vvz: // global
           _s9V9L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VvA; else goto c9VvB;
       c9VvB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VvD; else goto c9VvC;
       c9VvD: // global
           HpAlloc = 16;
           goto c9VvA;
       c9VvA: // global
           R1 = _s9V9L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9L::P64;
           _s9V97::I64 = I64[_s9V9L::P64 + 16];
           _s9V9K::I64 = I64[_s9V9L::P64 + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vvx; else goto c9Vvy;
       c9Vvx: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9V9K::I64, _s9V97::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vvy: // global
           if (%MO_S_Ge_W64(_s9V9K::I64, 0)) goto c9VvT; else goto c9VvU;
       c9VvT: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VvU: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 new_input_s9V9R_entry() //  [R1]
         { info_tbl: [(c9Vw3,
                       label: new_input_s9V9R_info
                       rep:HeapRep 2 ptrs 5 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vw3: // global
           _s9V9R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vw4; else goto c9Vw5;
       c9Vw5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vw7; else goto c9Vw6;
       c9Vw7: // global
           HpAlloc = 56;
           goto c9Vw4;
       c9Vw4: // global
           R1 = _s9V9R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vw6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9R::P64;
           _s9V8B::P64 = P64[_s9V9R::P64 + 16];
           _s9V8C::P64 = P64[_s9V9R::P64 + 24];
           _s9V8A::I64 = I64[_s9V9R::P64 + 32];
           _s9V8D::I64 = I64[_s9V9R::P64 + 40];
           _s9V9S::I64 = I64[_s9V9R::P64 + 64];
           if (_s9V9S::I64 != 0) goto c9Vw1; else goto c9Vw2;
       c9Vw1: // global
           _s9V8F::I64 = I64[_s9V9R::P64 + 48];
           _s9V8U::I64 = I64[_s9V9R::P64 + 56];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9Vwn; else goto c9VwE;
       c9Vwn: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 - %MO_S_Shr_W64(_s9V9S::I64,
                                                     _s9V8U::I64);
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VwE: // global
           if (%MO_S_Ge_W64(_s9V9S::I64, 0)) goto c9Vwx; else goto c9VwD;
       c9Vwx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VwD: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 + 1;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Vw2: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaa_entry() //  [R1]
         { info_tbl: [(c9VwW,
                       label: sat_s9Vaa_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VwW: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vx3; else goto c9Vx4;
       c9Vx3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VwT_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Vx8; else goto c9VwU;
       u9Vx8: // global
           call _c9VwT(R1) args: 0, res: 0, upd: 0;
       c9VwU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VwT() //  [R1]
         { info_tbl: [(c9VwT,
                       label: block_c9VwT_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VwT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vx7; else goto c9Vx6;
       c9Vx7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Vx6: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Va9::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Va9::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaz_entry() //  [R1]
         { info_tbl: [(c9Vxs,
                       label: sat_s9Vaz_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vxs: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vxz; else goto c9VxA;
       c9Vxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VxA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Vxp_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VxE; else goto c9Vxq;
       u9VxE: // global
           call _c9Vxp(R1) args: 0, res: 0, upd: 0;
       c9Vxq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vxp() //  [R1]
         { info_tbl: [(c9Vxp,
                       label: block_c9Vxp_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vxp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VxD; else goto c9VxC;
       c9VxD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VxC: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Vay::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Vay::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaK_entry() //  [R1]
         { info_tbl: [(c9VxT,
                       label: sat_s9VaK_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VxT: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vy0; else goto c9Vy1;
       c9Vy0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VxQ_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Vy5; else goto c9VxR;
       u9Vy5: // global
           call _c9VxQ(R1) args: 0, res: 0, upd: 0;
       c9VxR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VxQ() //  [R1]
         { info_tbl: [(c9VxQ,
                       label: block_c9VxQ_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VxQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vy4; else goto c9Vy3;
       c9Vy4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Vy3: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaJ::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaZ_entry() //  [R1]
         { info_tbl: [(c9Vyk,
                       label: sat_s9VaZ_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vyk: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Vyr; else goto c9Vys;
       c9Vyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Vyh_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Vyw; else goto c9Vyi;
       u9Vyw: // global
           call _c9Vyh(R1) args: 0, res: 0, upd: 0;
       c9Vyi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Vyh() //  [R1]
         { info_tbl: [(c9Vyh,
                       label: block_c9Vyh_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vyh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Vyv; else goto c9Vyu;
       c9Vyv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Vyu: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaY::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaY::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaV_entry() //  [R1]
         { info_tbl: [(c9VyE,
                       label: sat_s9VaV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VyE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VyF; else goto c9VyG;
       c9VyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VyB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9VyO; else goto c9VyC;
       u9VyO: // global
           call _c9VyB(R1) args: 0, res: 0, upd: 0;
       c9VyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VyB() //  [R1]
         { info_tbl: [(c9VyB,
                       label: block_c9VyB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VyB: // global
           if (I64[R1 + 7] == 0) goto c9VyN; else goto c9VyM;
       c9VyN: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VyM: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c9VyP,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VyP: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9VyQ; else goto c9VyR;
       c9VyQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VyR: // global
           I64[Sp - 40] = block_c9Vu5_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VA7; else goto c9Vu6;
       u9VA7: // global
           call _c9Vu5(R1) args: 0, res: 0, upd: 0;
       c9Vu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vu5() //  [R1]
         { info_tbl: [(c9Vu5,
                       label: block_c9Vu5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vu5: // global
           I64[Sp - 40] = block_c9Vua_info;
           _s9V8B::P64 = P64[R1 + 7];
           _s9V8C::P64 = P64[R1 + 15];
           _s9V8A::I64 = I64[R1 + 23];
           _s9V8D::I64 = I64[R1 + 31];
           _s9V8E::I64 = I64[R1 + 39];
           _s9V8F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9V8C::P64;
           I64[Sp - 24] = _s9V8D::I64;
           I64[Sp - 16] = _s9V8E::I64;
           I64[Sp - 8] = _s9V8F::I64;
           P64[Sp] = _s9V8B::P64;
           I64[Sp + 24] = _s9V8A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VA3; else goto c9Vub;
       u9VA3: // global
           call _c9Vua(R1) args: 0, res: 0, upd: 0;
       c9Vub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vua() //  [R1]
         { info_tbl: [(c9Vua,
                       label: block_c9Vua_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vua: // global
           I64[Sp - 48] = block_c9Vuf_info;
           R2 = 8;
           _s9V8I::P64 = P64[R1 + 7];
           _s9V8J::P64 = P64[R1 + 15];
           _s9V8H::I64 = I64[R1 + 23];
           _s9V8K::I64 = I64[R1 + 31];
           _s9V8L::I64 = I64[R1 + 39];
           _s9V8M::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9V8I::P64;
           P64[Sp - 32] = _s9V8J::P64;
           I64[Sp - 24] = _s9V8K::I64;
           I64[Sp - 16] = _s9V8L::I64;
           I64[Sp - 8] = _s9V8M::I64;
           I64[Sp] = _s9V8H::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vuf() //  [R1]
         { info_tbl: [(c9Vuf,
                       label: block_c9Vuf_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vuf: // global
           I64[Sp] = block_c9Vuh_info;
           _s9V8S::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9V8S::P64;
           if (R1 & 7 != 0) goto u9VA4; else goto c9Vui;
       u9VA4: // global
           call _c9Vuh(R1) args: 0, res: 0, upd: 0;
       c9Vui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vuh() //  [R1]
         { info_tbl: [(c9Vuh,
                       label: block_c9Vuh_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vuh: // global
           _s9V8A::I64 = I64[Sp + 112];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V8U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VzE; else goto c9VzF;
       c9VzE: // global
           _s9V8W::I64 = I64[Sp + 72] << _s9V8U::I64;
           goto s9V8V;
       c9VzF: // global
           _s9V8W::I64 = 0;
           goto s9V8V;
       s9V8V: // global
           _s9V8X::I64 = _s9V8S::P64 + 16;
           I64[_s9V8X::I64] = _s9V8A::I64 + _s9V8W::I64;
           I64[Sp - 16] = block_c9Vux_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V8X::I64;
           I64[Sp] = _s9V8U::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vux() //  [R1]
         { info_tbl: [(c9Vux,
                       label: block_c9Vux_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vux: // global
           I64[Sp] = block_c9Vuz_info;
           _s9V95::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9V95::P64;
           if (R1 & 7 != 0) goto u9VA5; else goto c9VuA;
       u9VA5: // global
           call _c9Vuz(R1) args: 0, res: 0, upd: 0;
       c9VuA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vuz() //  [R1]
         { info_tbl: [(c9Vuz,
                       label: block_c9Vuz_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vuz: // global
           _s9V8H::I64 = I64[Sp + 64];
           _s9V95::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vzz; else goto c9VzA;
       c9Vzz: // global
           _s9V99::I64 = I64[Sp + 56] << _s9V97::I64;
           goto s9V98;
       c9VzA: // global
           _s9V99::I64 = 0;
           goto s9V98;
       s9V98: // global
           _s9V9a::I64 = _s9V95::P64 + 16;
           I64[_s9V9a::I64] = _s9V8H::I64 + _s9V99::I64;
           I64[Sp - 16] = block_c9VuP_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V9a::I64;
           I64[Sp] = _s9V97::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VuP() //  [R1]
         { info_tbl: [(c9VuP,
                       label: block_c9VuP_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VuP: // global
           _s9V8U::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9Vzu; else goto c9Vzv;
       c9Vzu: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9V8U::I64;
           goto s9V9j;
       c9Vzv: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = 0;
           goto s9V9j;
       s9V9j: // global
           _s9V9l::I64 = _s9V9i::P64 + 16;
           I64[_s9V9l::I64] = _s9V9k::I64;
           I64[Sp - 8] = block_c9Vv2_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9V9l::I64;
           P64[Sp + 104] = _s9V9i::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vv2() //  [R1]
         { info_tbl: [(c9Vv2,
                       label: block_c9Vv2_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vv2: // global
           _s9V8t::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9Vzp; else goto c9Vzq;
       c9Vzp: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9V97::I64;
           goto s9V9u;
       c9Vzq: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = 0;
           goto s9V9u;
       s9V9u: // global
           _s9V9w::I64 = _s9V9t::P64 + 16;
           I64[_s9V9w::I64] = _s9V9v::I64;
           I64[Sp] = block_c9Vvf_info;
           R1 = _s9V8t::P64;
           I64[Sp + 80] = _s9V9w::I64;
           P64[Sp + 136] = _s9V9t::P64;
           if (R1 & 7 != 0) goto u9VA6; else goto c9Vvg;
       u9VA6: // global
           call _c9Vvf(R1) args: 0, res: 0, upd: 0;
       c9Vvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Vvf() //  [R1]
         { info_tbl: [(c9Vvf,
                       label: block_c9Vvf_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vvf: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9Vz6; else goto c9Vz5;
       c9Vz6: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Vz5: // global
           _s9V8A::I64 = I64[Sp + 152];
           _s9V8B::P64 = P64[Sp + 128];
           _s9V8C::P64 = P64[Sp + 96];
           _s9V8D::I64 = I64[Sp + 104];
           _s9V8F::I64 = I64[Sp + 120];
           _s9V8H::I64 = I64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 48];
           _s9V8J::P64 = P64[Sp + 56];
           _s9V8K::I64 = I64[Sp + 64];
           _s9V8L::I64 = I64[Sp + 72];
           _s9V8S::P64 = P64[Sp + 144];
           _s9V8U::I64 = I64[Sp + 40];
           _s9V95::P64 = P64[Sp + 160];
           _s9V97::I64 = I64[Sp + 24];
           _s9V9i::P64 = P64[Sp + 112];
           _s9V9l::I64 = I64[Sp + 8];
           _s9V9t::P64 = P64[Sp + 136];
           _s9V9w::I64 = I64[Sp + 80];
           (_s9V9E::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9V9l::I64, I64[Sp + 16], _s9V9w::I64);
           _s9V9H::I64 = I64[_s9V9l::I64];
           _s9V9K::I64 = I64[_s9V9w::I64];
           I64[Hp - 216] = new_outleft'_s9V9L_info;
           I64[Hp - 200] = _s9V97::I64;
           I64[Hp - 192] = _s9V9K::I64;
           I64[Hp - 184] = new_input_s9V9R_info;
           P64[Hp - 168] = _s9V8B::P64;
           P64[Hp - 160] = _s9V8C::P64;
           I64[Hp - 152] = _s9V8A::I64;
           I64[Hp - 144] = _s9V8D::I64;
           I64[Hp - 136] = _s9V8F::I64;
           I64[Hp - 128] = _s9V8U::I64;
           I64[Hp - 120] = _s9V9H::I64;
           _c9Vvq::P64 = Hp - 216;
           _c9VvV::P64 = Hp - 184;
           if (_s9V9E::I64 == 18446744073709551615) goto c9Vzl; else goto c9Vz9;
       c9Vzl: // global
           (_s9Vaf::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9Vag::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9Vaf::I64));
           if (%MO_S_Lt_W64(_s9Vag::I64, 23)) goto u9VA0; else goto u9VA2;
       u9VA0: // global
           if (%MO_S_Lt_W64(_s9Vag::I64, 22)) goto u9VA1; else goto c9Vzi;
       u9VA1: // global
           if (_s9Vag::I64 != 7) goto c9Vzc; else goto c9Vzg;
       c9Vzg: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaz_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vvq::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9VvV::P64;
           P64[Hp - 24] = Hp - 112;
           _c9Vzf::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9Vzf::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Vzi: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaK_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vvq::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VvV::P64;
           P64[Hp - 24] = Hp - 112;
           _c9Vzh::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9Vzh::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9VA2: // global
           if (_s9Vag::I64 != 84) goto c9Vzc; else goto c9Vzk;
       c9Vzc: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9Vza_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9Vzk: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaZ_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vvq::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = sat_s9VaV_info;
           P64[Hp - 32] = _c9Vvq::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9VvV::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Vz9: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaa_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9Vvq::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VvV::P64;
           P64[Hp - 24] = Hp - 112;
           _c9Vz7::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9Vz7::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Vza() //  [R1]
         { info_tbl: [(c9Vza,
                       label: block_c9Vza_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vza: // global
           _s9V8B::P64 = P64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 8];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V95::P64 = P64[Sp + 120];
           _s9V9i::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.080799192 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VAc,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding10_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAc: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.081887877 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VAj,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAj: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.082971926 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { info_tbl: [(c9VAt,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VAu; else goto c9VAv;
       c9VAu: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9VAv: // global
           I64[Sp - 8] = block_c9VAq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VAD; else goto c9VAr;
       u9VAD: // global
           call _c9VAq(R1) args: 0, res: 0, upd: 0;
       c9VAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VAq() //  [R1]
         { info_tbl: [(c9VAq,
                       label: block_c9VAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAq: // global
           if (I64[R1 + 7] == 47) goto c9VAC; else goto c9VAB;
       c9VAC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VAB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.084001782 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.086073011 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9Vbq_entry() //  [R1]
         { info_tbl: [(c9VAP,
                       label: ds_s9Vbq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VAQ; else goto c9VAR;
       c9VAQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VAR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VAM_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9VAM() //  [R1, R2]
         { info_tbl: [(c9VAM,
                       label: block_c9VAM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VAM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VAU; else goto c9VAT;
       c9VAU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9VAT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 enc_s9Vby_entry() //  [R1]
         { info_tbl: [(c9VB1,
                       label: enc_s9Vby_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VB1: // global
           _s9Vby::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VB2; else goto c9VB3;
       c9VB3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VB5; else goto c9VB4;
       c9VB5: // global
           HpAlloc = 24;
           goto c9VB2;
       c9VB2: // global
           R1 = _s9Vby::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VB4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9Vby::P64;
           _s9Vbq::P64 = P64[_s9Vby::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9Vbq::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 enc1_s9VbD_entry() //  [R1, R2, R3]
         { info_tbl: [(c9VBb,
                       label: enc1_s9VbD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc2_s9VbE_entry() //  [R1]
         { info_tbl: [(c9VBj,
                       label: enc2_s9VbE_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBj: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 enc3_s9VbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c9VBr,
                       label: enc3_s9VbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc4_s9VbG_entry() //  [R1]
         { info_tbl: [(c9VBz,
                       label: enc4_s9VbG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBz: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9VbM_entry() //  [R1]
         { info_tbl: [(c9VBQ,
                       label: sat_s9VbM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9VBR; else goto c9VBS;
       c9VBR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VBS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9VBJ_info;
           _s9VbH::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9VbH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9VC2; else goto c9VBK;
       u9VC2: // global
           call _c9VBJ(R1) args: 0, res: 0, upd: 0;
       c9VBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VBJ() //  [R1]
         { info_tbl: [(c9VBJ,
                       label: block_c9VBJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBJ: // global
           if (R1 & 7 == 1) goto c9VBN; else goto c9VBO;
       c9VBN: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VBO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VC1; else goto c9VC0;
       c9VC1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VC0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { info_tbl: [(c9VC3,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VC3: // global
           _s9Vbo::P64 = R3;
           _s9Vbn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VC4; else goto c9VC5;
       c9VC5: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9VC7; else goto c9VC6;
       c9VC7: // global
           HpAlloc = 192;
           goto c9VC4;
       c9VC4: // global
           R3 = _s9Vbo::P64;
           R2 = _s9Vbn::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VC6: // global
           I64[Hp - 184] = ds_s9Vbq_info;
           P64[Hp - 168] = _s9Vbo::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9VAI::P64 = Hp - 184;
           P64[Hp - 144] = _c9VAI::P64;
           I64[Hp - 136] = enc_s9Vby_info;
           P64[Hp - 120] = _c9VAI::P64;
           I64[Hp - 112] = enc1_s9VbD_info;
           P64[Hp - 104] = _s9Vbn::P64;
           I64[Hp - 96] = enc2_s9VbE_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9VbF_info;
           P64[Hp - 56] = _s9Vbn::P64;
           I64[Hp - 48] = enc4_s9VbG_info;
           P64[Hp - 40] = _s9Vbo::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9Vbo::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9VBD_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9VBC::P64 = Hp - 23;
           R2 = _c9VBC::P64;
           P64[Sp - 8] = _c9VBC::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9VBD() //  [R1]
         { info_tbl: [(c9VBD,
                       label: block_c9VBD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VBD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9VCa; else goto c9VC9;
       c9VCa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VC9: // global
           I64[Hp - 24] = sat_s9VbM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.089704985 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { info_tbl: [(c9VCf,
                       label: GHC.IO.Encoding.Iconv.mkIconvEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VCf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.090548349 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { info_tbl: [(c9VCm,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VCm: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.091376743 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { info_tbl: [(c9VCt,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VCt: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.092071814 UTC

[section ""relreadonly" . S9Vc5_srt" {
     S9Vc5_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.09295137 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:00.094102615 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.095782757 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.097493465 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.099110668 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.100781087 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.102527992 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.104475964 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { info_tbl: [(c9VCI,
                       label: lvl1_r9V6z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VCI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VCJ; else goto c9VCK;
       c9VCJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VCK: // global
           (_c9VCF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VCF::I64 == 0) goto c9VCH; else goto c9VCG;
       c9VCH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VCG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VCF::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.108524685 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { info_tbl: [(c9VCY,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VCY: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.112008707 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { info_tbl: [(c9VD9,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding15_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VD9: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.116525771 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { info_tbl: [(c9VDl,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding14_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VDl: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.119661659 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.121576 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { info_tbl: [(c9VDA,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VDA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VDB; else goto c9VDC;
       c9VDB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VDC: // global
           (_c9VDx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VDx::I64 == 0) goto c9VDz; else goto c9VDy;
       c9VDz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VDy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VDx::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.128152707 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9V7x_entry() //  [R1]
         { info_tbl: [(c9VEF,
                       label: sat_s9V7x_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VEF: // global
           (_s9V7q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7q::I64) == (-1) :: W32) goto c9VEE; else goto c9VED;
       c9VEE: // global
           (_s9V7v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7v::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9VED: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9V7l_entry() //  [R1]
         { info_tbl: [(c9VEY,
                       label: sat_s9V7l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VEY: // global
           _s9V7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VEZ; else goto c9VF0;
       c9VF0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VF2; else goto c9VF1;
       c9VF2: // global
           HpAlloc = 16;
           goto c9VEZ;
       c9VEZ: // global
           R1 = _s9V7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VF1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V7l::P64;
           _s9V6L::P64 = P64[_s9V7l::P64 + 16];
           _s9V7h::I64 = I64[_s9V7l::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9V7h::I64;
           R2 = Hp - 7;
           R1 = _s9V6L::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9V7S_entry() //  [R1]
         { info_tbl: [(c9VFg,
                       label: sat_s9V7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VFg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VFh; else goto c9VFi;
       c9VFh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9VFi: // global
           I64[Sp - 8] = block_c9VFd_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VFE; else goto c9VFe;
       u9VFE: // global
           call _c9VFd(R1) args: 0, res: 0, upd: 0;
       c9VFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VFd() //  [R1]
         { info_tbl: [(c9VFd,
                       label: block_c9VFd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VFd: // global
           (_s9V7L::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7L::I64) == (-1) :: W32) goto c9VFz; else goto c9VFt;
       c9VFz: // global
           (_s9V7Q::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7Q::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9VFt: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9VFF,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding11_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VFF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9VFG; else goto c9VFH;
       c9VFG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VFH: // global
           I64[Sp - 40] = block_c9VDO_info;
           _s9V6J::P64 = R3;
           R3 = 0;
           _s9V6I::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9V6I::P64;
           P64[Sp - 24] = _s9V6J::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9VDO() //  [R1]
         { info_tbl: [(c9VDO,
                       label: block_c9VDO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VDO: // global
           I64[Sp] = block_c9VDV_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VDV() //  [R1]
         { info_tbl: [(c9VDV,
                       label: block_c9VDV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VDV: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9VGp() args: 0, res: 0, upd: 0;
     }
 },
 _c9VGp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VGp: // global
           _s9V88::P64 = P64[Sp];
           I64[Sp] = block_c9VGs_info;
           R1 = _s9V88::P64;
           if (R1 & 7 != 0) goto u9VHe; else goto c9VGu;
       u9VHe: // global
           call _c9VGs(R1) args: 0, res: 0, upd: 0;
       c9VGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VGs() //  [R1]
         { info_tbl: [(c9VGs,
                       label: block_c9VGs_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VGs: // global
           if (R1 & 7 == 1) goto c9VGA; else goto c9VGF;
       c9VGA: // global
           _s9V6J::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9VE5_info;
           R3 = 0;
           R2 = _s9V6J::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9VGF: // global
           I64[Sp - 8] = block_c9VGD_info;
           _s9V8d::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V8d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VHf; else goto c9VGG;
       u9VHf: // global
           call _c9VGD(R1) args: 0, res: 0, upd: 0;
       c9VGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VE5() //  [R1]
         { info_tbl: [(c9VE5,
                       label: block_c9VE5_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VE5: // global
           I64[Sp] = block_c9VEc_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VEc() //  [R1]
         { info_tbl: [(c9VEc,
                       label: block_c9VEc_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VEc: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9VG1() args: 0, res: 0, upd: 0;
     }
 },
 _c9VG1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VG1: // global
           _s9V7V::P64 = P64[Sp];
           I64[Sp] = block_c9VG4_info;
           R1 = _s9V7V::P64;
           if (R1 & 7 != 0) goto u9VHa; else goto c9VG6;
       u9VHa: // global
           call _c9VG4(R1) args: 0, res: 0, upd: 0;
       c9VG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VG4() //  [R1]
         { info_tbl: [(c9VG4,
                       label: block_c9VG4_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VG4: // global
           if (R1 & 7 == 1) goto c9VGc; else goto c9VGh;
       c9VGc: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9VEk() args: 0, res: 0, upd: 0;
       c9VGh: // global
           I64[Sp - 8] = block_c9VGf_info;
           _s9V80::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V80::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VHb; else goto c9VGi;
       u9VHb: // global
           call _c9VGf(R1) args: 0, res: 0, upd: 0;
       c9VGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VEk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VEk: // global
           Hp = Hp + 96;
           _s9V7a::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9VFP; else goto c9VFO;
       c9VFP: // global
           HpAlloc = 96;
           I64[Sp] = block_c9VEj_info;
           R1 = _s9V7a::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9VFO: // global
           _s9V6K::P64 = P64[Sp + 40];
           _s9V6L::P64 = P64[Sp + 48];
           _s9V6U::P64 = P64[Sp + 24];
           _s9V6V::I64 = I64[Sp + 16];
           _s9V77::P64 = P64[Sp + 32];
           _s9V78::I64 = I64[Sp + 8];
           I8[_s9V78::I64 + _s9V7a::I64] = 0 :: W8;
           (_s9V7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9V78::I64, _s9V6V::I64);
           if (_s9V7g::I64 == (-1)) goto c9VFV; else goto c9VFS;
       c9VFV: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9VF4_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VFS: // global
           call MO_Touch(_s9V77::P64);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7x_info;
           I64[Hp - 80] = _s9V7g::I64;
           I64[Hp - 72] = sat_s9V7l_info;
           P64[Hp - 56] = _s9V6L::P64;
           I64[Hp - 48] = _s9V7g::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VEj() //  [R1]
         { info_tbl: [(c9VEj,
                       label: block_c9VEj_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VEj: // global
           I64[Sp] = R1;
           call _c9VEk() args: 0, res: 0, upd: 0;
     }
 },
 _c9VF4() //  [R1]
         { info_tbl: [(c9VF4,
                       label: block_c9VF4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VF4: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9VFY; else goto c9VFX;
       c9VFY: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VFX: // global
           _s9V6K::P64 = P64[Sp + 24];
           _s9V6L::P64 = P64[Sp + 32];
           _s9V6U::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7S_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9V6L::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VGf() //  [R1]
         { info_tbl: [(c9VGf,
                       label: block_c9VGf_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VGf: // global
           _s9V7W::I64 = I64[Sp + 16];
           _s9V80::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V7W::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V80::P64;
           I64[Sp + 16] = _s9V7W::I64 + 1;
           Sp = Sp + 8;
           call _c9VG1() args: 0, res: 0, upd: 0;
     }
 },
 _c9VGD() //  [R1]
         { info_tbl: [(c9VGD,
                       label: block_c9VGD_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VGD: // global
           _s9V89::I64 = I64[Sp + 16];
           _s9V8d::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V89::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V8d::P64;
           I64[Sp + 16] = _s9V89::I64 + 1;
           Sp = Sp + 8;
           call _c9VGp() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.163587775 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { info_tbl: [(c9VIM,
                       label: lvl2_r9V6A_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VIM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VIN; else goto c9VIO;
       c9VIN: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9VIO: // global
           I64[Sp - 8] = block_c9VIJ_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9VIJ() //  []
         { info_tbl: [(c9VIJ,
                       label: block_c9VIJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VIJ: // global
           (_s9V8p::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9V8p::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.168976643 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { info_tbl: [(c9VJ6,
                       label: GHC.IO.Encoding.Iconv.localeEncodingName_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VJ6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VJ7; else goto c9VJ8;
       c9VJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJ8: // global
           (_c9VJ1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJ1::I64 == 0) goto c9VJ3; else goto c9VJ2;
       c9VJ3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJ2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJ1::I64;
           I64[Sp - 24] = block_c9VJ4_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9VJ4() //  [R1]
         { info_tbl: [(c9VJ4,
                       label: block_c9VJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VJ4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.174272922 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.175977311 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.177867423 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { info_tbl: [(c9VJu,
                       label: GHC.IO.Encoding.Iconv.haskellChar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VJu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VJv; else goto c9VJw;
       c9VJv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJw: // global
           (_c9VJr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJr::I64 == 0) goto c9VJt; else goto c9VJs;
       c9VJt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJr::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.182146983 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.183921603 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.185998569 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.187832596 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { info_tbl: [(c9VJN,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VJO; else goto c9VJP;
       c9VJO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJP: // global
           (_c9VJK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJK::I64 == 0) goto c9VJM; else goto c9VJL;
       c9VJM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJK::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.197038433 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9V9L_entry() //  [R1]
         { info_tbl: [(c9VLv,
                       label: new_outleft'_s9V9L_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VLv: // global
           _s9V9L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VLw; else goto c9VLx;
       c9VLx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VLz; else goto c9VLy;
       c9VLz: // global
           HpAlloc = 16;
           goto c9VLw;
       c9VLw: // global
           R1 = _s9V9L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VLy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9L::P64;
           _s9V97::I64 = I64[_s9V9L::P64 + 16];
           _s9V9K::I64 = I64[_s9V9L::P64 + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VLt; else goto c9VLu;
       c9VLt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9V9K::I64, _s9V97::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLu: // global
           if (%MO_S_Ge_W64(_s9V9K::I64, 0)) goto c9VLP; else goto c9VLQ;
       c9VLP: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLQ: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 new_input_s9V9R_entry() //  [R1]
         { info_tbl: [(c9VLZ,
                       label: new_input_s9V9R_info
                       rep:HeapRep 2 ptrs 5 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VLZ: // global
           _s9V9R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VM0; else goto c9VM1;
       c9VM1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VM3; else goto c9VM2;
       c9VM3: // global
           HpAlloc = 56;
           goto c9VM0;
       c9VM0: // global
           R1 = _s9V9R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VM2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9R::P64;
           _s9V8B::P64 = P64[_s9V9R::P64 + 16];
           _s9V8C::P64 = P64[_s9V9R::P64 + 24];
           _s9V8A::I64 = I64[_s9V9R::P64 + 32];
           _s9V8D::I64 = I64[_s9V9R::P64 + 40];
           _s9V9S::I64 = I64[_s9V9R::P64 + 64];
           if (_s9V9S::I64 != 0) goto c9VLX; else goto c9VLY;
       c9VLX: // global
           _s9V8F::I64 = I64[_s9V9R::P64 + 48];
           _s9V8U::I64 = I64[_s9V9R::P64 + 56];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VMj; else goto c9VMA;
       c9VMj: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 - %MO_S_Shr_W64(_s9V9S::I64,
                                                     _s9V8U::I64);
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VMA: // global
           if (%MO_S_Ge_W64(_s9V9S::I64, 0)) goto c9VMt; else goto c9VMz;
       c9VMt: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VMz: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 + 1;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLY: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaa_entry() //  [R1]
         { info_tbl: [(c9VMS,
                       label: sat_s9Vaa_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VMS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VMZ; else goto c9VN0;
       c9VMZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VMP_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VN4; else goto c9VMQ;
       u9VN4: // global
           call _c9VMP(R1) args: 0, res: 0, upd: 0;
       c9VMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VMP() //  [R1]
         { info_tbl: [(c9VMP,
                       label: block_c9VMP_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VMP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VN3; else goto c9VN2;
       c9VN3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VN2: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Va9::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Va9::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9Vaz_entry() //  [R1]
         { info_tbl: [(c9VNo,
                       label: sat_s9Vaz_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VNo: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VNv; else goto c9VNw;
       c9VNv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VNw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VNl_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VNA; else goto c9VNm;
       u9VNA: // global
           call _c9VNl(R1) args: 0, res: 0, upd: 0;
       c9VNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VNl() //  [R1]
         { info_tbl: [(c9VNl,
                       label: block_c9VNl_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VNl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VNz; else goto c9VNy;
       c9VNz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VNy: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Vay::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Vay::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaK_entry() //  [R1]
         { info_tbl: [(c9VNP,
                       label: sat_s9VaK_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VNP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VNW; else goto c9VNX;
       c9VNW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VNX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VNM_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VO1; else goto c9VNN;
       u9VO1: // global
           call _c9VNM(R1) args: 0, res: 0, upd: 0;
       c9VNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VNM() //  [R1]
         { info_tbl: [(c9VNM,
                       label: block_c9VNM_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VNM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VO0; else goto c9VNZ;
       c9VO0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VNZ: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaJ::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaZ_entry() //  [R1]
         { info_tbl: [(c9VOg,
                       label: sat_s9VaZ_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VOg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VOn; else goto c9VOo;
       c9VOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VOd_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VOs; else goto c9VOe;
       u9VOs: // global
           call _c9VOd(R1) args: 0, res: 0, upd: 0;
       c9VOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VOd() //  [R1]
         { info_tbl: [(c9VOd,
                       label: block_c9VOd_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VOd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VOr; else goto c9VOq;
       c9VOr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VOq: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaY::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaY::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VaV_entry() //  [R1]
         { info_tbl: [(c9VOA,
                       label: sat_s9VaV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VOA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VOB; else goto c9VOC;
       c9VOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VOC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VOx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9VOK; else goto c9VOy;
       u9VOK: // global
           call _c9VOx(R1) args: 0, res: 0, upd: 0;
       c9VOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VOx() //  [R1]
         { info_tbl: [(c9VOx,
                       label: block_c9VOx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VOx: // global
           if (I64[R1 + 7] == 0) goto c9VOJ; else goto c9VOI;
       c9VOJ: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VOI: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c9VOL,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VOL: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9VOM; else goto c9VON;
       c9VOM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VON: // global
           I64[Sp - 40] = block_c9VK1_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VQ3; else goto c9VK2;
       u9VQ3: // global
           call _c9VK1(R1) args: 0, res: 0, upd: 0;
       c9VK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VK1() //  [R1]
         { info_tbl: [(c9VK1,
                       label: block_c9VK1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VK1: // global
           I64[Sp - 40] = block_c9VK6_info;
           _s9V8B::P64 = P64[R1 + 7];
           _s9V8C::P64 = P64[R1 + 15];
           _s9V8A::I64 = I64[R1 + 23];
           _s9V8D::I64 = I64[R1 + 31];
           _s9V8E::I64 = I64[R1 + 39];
           _s9V8F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9V8C::P64;
           I64[Sp - 24] = _s9V8D::I64;
           I64[Sp - 16] = _s9V8E::I64;
           I64[Sp - 8] = _s9V8F::I64;
           P64[Sp] = _s9V8B::P64;
           I64[Sp + 24] = _s9V8A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VPZ; else goto c9VK7;
       u9VPZ: // global
           call _c9VK6(R1) args: 0, res: 0, upd: 0;
       c9VK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VK6() //  [R1]
         { info_tbl: [(c9VK6,
                       label: block_c9VK6_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VK6: // global
           I64[Sp - 48] = block_c9VKb_info;
           R2 = 8;
           _s9V8I::P64 = P64[R1 + 7];
           _s9V8J::P64 = P64[R1 + 15];
           _s9V8H::I64 = I64[R1 + 23];
           _s9V8K::I64 = I64[R1 + 31];
           _s9V8L::I64 = I64[R1 + 39];
           _s9V8M::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9V8I::P64;
           P64[Sp - 32] = _s9V8J::P64;
           I64[Sp - 24] = _s9V8K::I64;
           I64[Sp - 16] = _s9V8L::I64;
           I64[Sp - 8] = _s9V8M::I64;
           I64[Sp] = _s9V8H::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKb() //  [R1]
         { info_tbl: [(c9VKb,
                       label: block_c9VKb_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKb: // global
           I64[Sp] = block_c9VKd_info;
           _s9V8S::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9V8S::P64;
           if (R1 & 7 != 0) goto u9VQ0; else goto c9VKe;
       u9VQ0: // global
           call _c9VKd(R1) args: 0, res: 0, upd: 0;
       c9VKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKd() //  [R1]
         { info_tbl: [(c9VKd,
                       label: block_c9VKd_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKd: // global
           _s9V8A::I64 = I64[Sp + 112];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V8U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VPA; else goto c9VPB;
       c9VPA: // global
           _s9V8W::I64 = I64[Sp + 72] << _s9V8U::I64;
           goto s9V8V;
       c9VPB: // global
           _s9V8W::I64 = 0;
           goto s9V8V;
       s9V8V: // global
           _s9V8X::I64 = _s9V8S::P64 + 16;
           I64[_s9V8X::I64] = _s9V8A::I64 + _s9V8W::I64;
           I64[Sp - 16] = block_c9VKt_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V8X::I64;
           I64[Sp] = _s9V8U::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKt() //  [R1]
         { info_tbl: [(c9VKt,
                       label: block_c9VKt_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKt: // global
           I64[Sp] = block_c9VKv_info;
           _s9V95::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9V95::P64;
           if (R1 & 7 != 0) goto u9VQ1; else goto c9VKw;
       u9VQ1: // global
           call _c9VKv(R1) args: 0, res: 0, upd: 0;
       c9VKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKv() //  [R1]
         { info_tbl: [(c9VKv,
                       label: block_c9VKv_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKv: // global
           _s9V8H::I64 = I64[Sp + 64];
           _s9V95::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VPv; else goto c9VPw;
       c9VPv: // global
           _s9V99::I64 = I64[Sp + 56] << _s9V97::I64;
           goto s9V98;
       c9VPw: // global
           _s9V99::I64 = 0;
           goto s9V98;
       s9V98: // global
           _s9V9a::I64 = _s9V95::P64 + 16;
           I64[_s9V9a::I64] = _s9V8H::I64 + _s9V99::I64;
           I64[Sp - 16] = block_c9VKL_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V9a::I64;
           I64[Sp] = _s9V97::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKL() //  [R1]
         { info_tbl: [(c9VKL,
                       label: block_c9VKL_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKL: // global
           _s9V8U::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VPq; else goto c9VPr;
       c9VPq: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9V8U::I64;
           goto s9V9j;
       c9VPr: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = 0;
           goto s9V9j;
       s9V9j: // global
           _s9V9l::I64 = _s9V9i::P64 + 16;
           I64[_s9V9l::I64] = _s9V9k::I64;
           I64[Sp - 8] = block_c9VKY_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9V9l::I64;
           P64[Sp + 104] = _s9V9i::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VKY() //  [R1]
         { info_tbl: [(c9VKY,
                       label: block_c9VKY_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VKY: // global
           _s9V8t::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VPl; else goto c9VPm;
       c9VPl: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9V97::I64;
           goto s9V9u;
       c9VPm: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = 0;
           goto s9V9u;
       s9V9u: // global
           _s9V9w::I64 = _s9V9t::P64 + 16;
           I64[_s9V9w::I64] = _s9V9v::I64;
           I64[Sp] = block_c9VLb_info;
           R1 = _s9V8t::P64;
           I64[Sp + 80] = _s9V9w::I64;
           P64[Sp + 136] = _s9V9t::P64;
           if (R1 & 7 != 0) goto u9VQ2; else goto c9VLc;
       u9VQ2: // global
           call _c9VLb(R1) args: 0, res: 0, upd: 0;
       c9VLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VLb() //  [R1]
         { info_tbl: [(c9VLb,
                       label: block_c9VLb_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VLb: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9VP2; else goto c9VP1;
       c9VP2: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VP1: // global
           _s9V8A::I64 = I64[Sp + 152];
           _s9V8B::P64 = P64[Sp + 128];
           _s9V8C::P64 = P64[Sp + 96];
           _s9V8D::I64 = I64[Sp + 104];
           _s9V8F::I64 = I64[Sp + 120];
           _s9V8H::I64 = I64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 48];
           _s9V8J::P64 = P64[Sp + 56];
           _s9V8K::I64 = I64[Sp + 64];
           _s9V8L::I64 = I64[Sp + 72];
           _s9V8S::P64 = P64[Sp + 144];
           _s9V8U::I64 = I64[Sp + 40];
           _s9V95::P64 = P64[Sp + 160];
           _s9V97::I64 = I64[Sp + 24];
           _s9V9i::P64 = P64[Sp + 112];
           _s9V9l::I64 = I64[Sp + 8];
           _s9V9t::P64 = P64[Sp + 136];
           _s9V9w::I64 = I64[Sp + 80];
           (_s9V9E::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9V9l::I64, I64[Sp + 16], _s9V9w::I64);
           _s9V9H::I64 = I64[_s9V9l::I64];
           _s9V9K::I64 = I64[_s9V9w::I64];
           I64[Hp - 216] = new_outleft'_s9V9L_info;
           I64[Hp - 200] = _s9V97::I64;
           I64[Hp - 192] = _s9V9K::I64;
           I64[Hp - 184] = new_input_s9V9R_info;
           P64[Hp - 168] = _s9V8B::P64;
           P64[Hp - 160] = _s9V8C::P64;
           I64[Hp - 152] = _s9V8A::I64;
           I64[Hp - 144] = _s9V8D::I64;
           I64[Hp - 136] = _s9V8F::I64;
           I64[Hp - 128] = _s9V8U::I64;
           I64[Hp - 120] = _s9V9H::I64;
           _c9VLm::P64 = Hp - 216;
           _c9VLR::P64 = Hp - 184;
           if (_s9V9E::I64 == 18446744073709551615) goto c9VPh; else goto c9VP5;
       c9VPh: // global
           (_s9Vaf::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9Vag::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9Vaf::I64));
           if (%MO_S_Lt_W64(_s9Vag::I64, 23)) goto u9VPW; else goto u9VPY;
       u9VPW: // global
           if (%MO_S_Lt_W64(_s9Vag::I64, 22)) goto u9VPX; else goto c9VPe;
       u9VPX: // global
           if (_s9Vag::I64 != 7) goto c9VP8; else goto c9VPc;
       c9VPc: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaz_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VPb::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VPb::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VPe: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaK_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VPd::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VPd::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9VPY: // global
           if (_s9Vag::I64 != 84) goto c9VP8; else goto c9VPg;
       c9VP8: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9VP6_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VPg: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaZ_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = sat_s9VaV_info;
           P64[Hp - 32] = _c9VLm::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9VLR::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VP5: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaa_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VP3::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VP3::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VP6() //  [R1]
         { info_tbl: [(c9VP6,
                       label: block_c9VP6_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VP6: // global
           _s9V8B::P64 = P64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 8];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V95::P64 = P64[Sp + 120];
           _s9V9i::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.256776489 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VSD,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding10_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VSD: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.260350379 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VSO,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VSO: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.264168957 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { info_tbl: [(c9VT2,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VT2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VT3; else goto c9VT4;
       c9VT3: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9VT4: // global
           I64[Sp - 8] = block_c9VSZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VTc; else goto c9VT0;
       u9VTc: // global
           call _c9VSZ(R1) args: 0, res: 0, upd: 0;
       c9VT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VSZ() //  [R1]
         { info_tbl: [(c9VSZ,
                       label: block_c9VSZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VSZ: // global
           if (I64[R1 + 7] == 47) goto c9VTb; else goto c9VTa;
       c9VTb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VTa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.269785482 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.27302127 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9Vbq_entry() //  [R1]
         { info_tbl: [(c9VTA,
                       label: ds_s9Vbq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VTA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VTB; else goto c9VTC;
       c9VTB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VTC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VTx_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9VTx() //  [R1, R2]
         { info_tbl: [(c9VTx,
                       label: block_c9VTx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VTx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VTF; else goto c9VTE;
       c9VTF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9VTE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 enc_s9Vby_entry() //  [R1]
         { info_tbl: [(c9VTM,
                       label: enc_s9Vby_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VTM: // global
           _s9Vby::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VTN; else goto c9VTO;
       c9VTO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VTQ; else goto c9VTP;
       c9VTQ: // global
           HpAlloc = 24;
           goto c9VTN;
       c9VTN: // global
           R1 = _s9Vby::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VTP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9Vby::P64;
           _s9Vbq::P64 = P64[_s9Vby::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9Vbq::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 enc1_s9VbD_entry() //  [R1, R2, R3]
         { info_tbl: [(c9VTW,
                       label: enc1_s9VbD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VTW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc2_s9VbE_entry() //  [R1]
         { info_tbl: [(c9VU4,
                       label: enc2_s9VbE_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VU4: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 enc3_s9VbF_entry() //  [R1, R2, R3]
         { info_tbl: [(c9VUc,
                       label: enc3_s9VbF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc4_s9VbG_entry() //  [R1]
         { info_tbl: [(c9VUk,
                       label: enc4_s9VbG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUk: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9VbM_entry() //  [R1]
         { info_tbl: [(c9VUB,
                       label: sat_s9VbM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9VUC; else goto c9VUD;
       c9VUC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VUD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9VUu_info;
           _s9VbH::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9VbH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9VUN; else goto c9VUv;
       u9VUN: // global
           call _c9VUu(R1) args: 0, res: 0, upd: 0;
       c9VUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9VUu() //  [R1]
         { info_tbl: [(c9VUu,
                       label: block_c9VUu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUu: // global
           if (R1 & 7 == 1) goto c9VUy; else goto c9VUz;
       c9VUy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VUz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VUM; else goto c9VUL;
       c9VUM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VUL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { info_tbl: [(c9VUO,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUO: // global
           _s9Vbo::P64 = R3;
           _s9Vbn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VUP; else goto c9VUQ;
       c9VUQ: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9VUS; else goto c9VUR;
       c9VUS: // global
           HpAlloc = 192;
           goto c9VUP;
       c9VUP: // global
           R3 = _s9Vbo::P64;
           R2 = _s9Vbn::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VUR: // global
           I64[Hp - 184] = ds_s9Vbq_info;
           P64[Hp - 168] = _s9Vbo::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9VTt::P64 = Hp - 184;
           P64[Hp - 144] = _c9VTt::P64;
           I64[Hp - 136] = enc_s9Vby_info;
           P64[Hp - 120] = _c9VTt::P64;
           I64[Hp - 112] = enc1_s9VbD_info;
           P64[Hp - 104] = _s9Vbn::P64;
           I64[Hp - 96] = enc2_s9VbE_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9VbF_info;
           P64[Hp - 56] = _s9Vbn::P64;
           I64[Hp - 48] = enc4_s9VbG_info;
           P64[Hp - 40] = _s9Vbo::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9Vbo::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9VUo_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9VUn::P64 = Hp - 23;
           R2 = _c9VUn::P64;
           P64[Sp - 8] = _c9VUn::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9VUo() //  [R1]
         { info_tbl: [(c9VUo,
                       label: block_c9VUo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VUo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9VUV; else goto c9VUU;
       c9VUV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VUU: // global
           I64[Hp - 24] = sat_s9VbM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.297664521 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { info_tbl: [(c9VVR,
                       label: GHC.IO.Encoding.Iconv.mkIconvEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VVR: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.301014829 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { info_tbl: [(c9VW2,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VW2: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.304425621 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { info_tbl: [(c9VWd,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VWd: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:00.307698235 UTC

[section ""relreadonly" . S9Vc5_srt" {
     S9Vc5_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.598398677 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:01.599492551 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.601161939 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.602901552 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.604594534 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.606327815 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.608127468 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.610184103 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { info_tbl: [(c9W1I,
                       label: lvl1_r9V6z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W1J; else goto c9W1K;
       c9W1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W1K: // global
           (_c9W1F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W1F::I64 == 0) goto c9W1H; else goto c9W1G;
       c9W1H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W1G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W1F::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.614507825 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { info_tbl: [(c9W1Z,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W1Z: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.618085298 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { info_tbl: [(c9W2b,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding15_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W2b: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.621624687 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { info_tbl: [(c9W2o,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding14_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W2o: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.626579653 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.628447613 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { info_tbl: [(c9W2E,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W2E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W2F; else goto c9W2G;
       c9W2F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W2G: // global
           (_c9W2B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W2B::I64 == 0) goto c9W2D; else goto c9W2C;
       c9W2D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W2C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W2B::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.634921461 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9VXg_entry() //  [R1]
         { info_tbl: [(c9W3K,
                       label: sat_s9VXg_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W3K: // global
           (_s9VX9::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9VX9::I64) == (-1) :: W32) goto c9W3J; else goto c9W3I;
       c9W3J: // global
           (_s9VXe::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9VXe::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9W3I: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9VX4_entry() //  [R1]
         { info_tbl: [(c9W43,
                       label: sat_s9VX4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W43: // global
           _s9VX4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9W44; else goto c9W45;
       c9W45: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9W47; else goto c9W46;
       c9W47: // global
           HpAlloc = 16;
           goto c9W44;
       c9W44: // global
           R1 = _s9VX4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W46: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VX4::P64;
           _s9VWu::P64 = P64[_s9VX4::P64 + 16];
           _s9VX0::I64 = I64[_s9VX4::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9VX0::I64;
           R2 = Hp - 7;
           R1 = _s9VWu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VXB_entry() //  [R1]
         { info_tbl: [(c9W4l,
                       label: sat_s9VXB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W4l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9W4m; else goto c9W4n;
       c9W4m: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9W4n: // global
           I64[Sp - 8] = block_c9W4i_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W4J; else goto c9W4j;
       u9W4J: // global
           call _c9W4i(R1) args: 0, res: 0, upd: 0;
       c9W4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W4i() //  [R1]
         { info_tbl: [(c9W4i,
                       label: block_c9W4i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W4i: // global
           (_s9VXu::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9VXu::I64) == (-1) :: W32) goto c9W4E; else goto c9W4y;
       c9W4E: // global
           (_s9VXz::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9VXz::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9W4y: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9W4K,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding11_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W4K: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9W4L; else goto c9W4M;
       c9W4L: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9W4M: // global
           I64[Sp - 40] = block_c9W2T_info;
           _s9VWs::P64 = R3;
           R3 = 0;
           _s9VWr::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9VWr::P64;
           P64[Sp - 24] = _s9VWs::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9W2T() //  [R1]
         { info_tbl: [(c9W2T,
                       label: block_c9W2T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W2T: // global
           I64[Sp] = block_c9W30_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W30() //  [R1]
         { info_tbl: [(c9W30,
                       label: block_c9W30_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W30: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9W5u() args: 0, res: 0, upd: 0;
     }
 },
 _c9W5u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W5u: // global
           _s9VXR::P64 = P64[Sp];
           I64[Sp] = block_c9W5x_info;
           R1 = _s9VXR::P64;
           if (R1 & 7 != 0) goto u9W6j; else goto c9W5z;
       u9W6j: // global
           call _c9W5x(R1) args: 0, res: 0, upd: 0;
       c9W5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W5x() //  [R1]
         { info_tbl: [(c9W5x,
                       label: block_c9W5x_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W5x: // global
           if (R1 & 7 == 1) goto c9W5F; else goto c9W5K;
       c9W5F: // global
           _s9VWs::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9W3a_info;
           R3 = 0;
           R2 = _s9VWs::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9W5K: // global
           I64[Sp - 8] = block_c9W5I_info;
           _s9VXW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9VXW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W6k; else goto c9W5L;
       u9W6k: // global
           call _c9W5I(R1) args: 0, res: 0, upd: 0;
       c9W5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W3a() //  [R1]
         { info_tbl: [(c9W3a,
                       label: block_c9W3a_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W3a: // global
           I64[Sp] = block_c9W3h_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W3h() //  [R1]
         { info_tbl: [(c9W3h,
                       label: block_c9W3h_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W3h: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9W56() args: 0, res: 0, upd: 0;
     }
 },
 _c9W56() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W56: // global
           _s9VXE::P64 = P64[Sp];
           I64[Sp] = block_c9W59_info;
           R1 = _s9VXE::P64;
           if (R1 & 7 != 0) goto u9W6f; else goto c9W5b;
       u9W6f: // global
           call _c9W59(R1) args: 0, res: 0, upd: 0;
       c9W5b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W59() //  [R1]
         { info_tbl: [(c9W59,
                       label: block_c9W59_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W59: // global
           if (R1 & 7 == 1) goto c9W5h; else goto c9W5m;
       c9W5h: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9W3p() args: 0, res: 0, upd: 0;
       c9W5m: // global
           I64[Sp - 8] = block_c9W5k_info;
           _s9VXJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9VXJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W6g; else goto c9W5n;
       u9W6g: // global
           call _c9W5k(R1) args: 0, res: 0, upd: 0;
       c9W5n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W3p() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W3p: // global
           Hp = Hp + 96;
           _s9VWT::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9W4U; else goto c9W4T;
       c9W4U: // global
           HpAlloc = 96;
           I64[Sp] = block_c9W3o_info;
           R1 = _s9VWT::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9W4T: // global
           _s9VWt::P64 = P64[Sp + 40];
           _s9VWu::P64 = P64[Sp + 48];
           _s9VWD::P64 = P64[Sp + 24];
           _s9VWE::I64 = I64[Sp + 16];
           _s9VWQ::P64 = P64[Sp + 32];
           _s9VWR::I64 = I64[Sp + 8];
           I8[_s9VWR::I64 + _s9VWT::I64] = 0 :: W8;
           (_s9VWZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9VWR::I64, _s9VWE::I64);
           if (_s9VWZ::I64 == (-1)) goto c9W50; else goto c9W4X;
       c9W50: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9W49_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9W4X: // global
           call MO_Touch(_s9VWQ::P64);
           call MO_Touch(_s9VWD::P64);
           I64[Hp - 88] = sat_s9VXg_info;
           I64[Hp - 80] = _s9VWZ::I64;
           I64[Hp - 72] = sat_s9VX4_info;
           P64[Hp - 56] = _s9VWu::P64;
           I64[Hp - 48] = _s9VWZ::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9VWt::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9W3o() //  [R1]
         { info_tbl: [(c9W3o,
                       label: block_c9W3o_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W3o: // global
           I64[Sp] = R1;
           call _c9W3p() args: 0, res: 0, upd: 0;
     }
 },
 _c9W49() //  [R1]
         { info_tbl: [(c9W49,
                       label: block_c9W49_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W49: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9W53; else goto c9W52;
       c9W53: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9W52: // global
           _s9VWt::P64 = P64[Sp + 24];
           _s9VWu::P64 = P64[Sp + 32];
           _s9VWD::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9VWD::P64);
           I64[Hp - 88] = sat_s9VXB_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9VWu::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9VWt::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9W5k() //  [R1]
         { info_tbl: [(c9W5k,
                       label: block_c9W5k_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W5k: // global
           _s9VXF::I64 = I64[Sp + 16];
           _s9VXJ::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9VXF::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9VXJ::P64;
           I64[Sp + 16] = _s9VXF::I64 + 1;
           Sp = Sp + 8;
           call _c9W56() args: 0, res: 0, upd: 0;
     }
 },
 _c9W5I() //  [R1]
         { info_tbl: [(c9W5I,
                       label: block_c9W5I_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W5I: // global
           _s9VXS::I64 = I64[Sp + 16];
           _s9VXW::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9VXS::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9VXW::P64;
           I64[Sp + 16] = _s9VXS::I64 + 1;
           Sp = Sp + 8;
           call _c9W5u() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.670707958 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { info_tbl: [(c9W8g,
                       label: lvl2_r9V6A_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W8g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9W8h; else goto c9W8i;
       c9W8h: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9W8i: // global
           I64[Sp - 8] = block_c9W8d_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9W8d() //  []
         { info_tbl: [(c9W8d,
                       label: block_c9W8d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W8d: // global
           (_s9VY8::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9VY8::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.675948641 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { info_tbl: [(c9W8B,
                       label: GHC.IO.Encoding.Iconv.localeEncodingName_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W8B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9W8C; else goto c9W8D;
       c9W8C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W8D: // global
           (_c9W8w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W8w::I64 == 0) goto c9W8y; else goto c9W8x;
       c9W8y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W8x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W8w::I64;
           I64[Sp - 24] = block_c9W8z_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9W8z() //  [R1]
         { info_tbl: [(c9W8z,
                       label: block_c9W8z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W8z: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.681568605 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.683204759 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.685144549 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { info_tbl: [(c9W91,
                       label: GHC.IO.Encoding.Iconv.haskellChar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W91: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W92; else goto c9W93;
       c9W92: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W93: // global
           (_c9W8Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W8Y::I64 == 0) goto c9W90; else goto c9W8Z;
       c9W90: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W8Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W8Y::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.689146325 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.691421813 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.693129599 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.695053827 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { info_tbl: [(c9W9l,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W9l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W9m; else goto c9W9n;
       c9W9m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W9n: // global
           (_c9W9i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W9i::I64 == 0) goto c9W9k; else goto c9W9j;
       c9W9k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W9j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W9i::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.704075652 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9VZu_entry() //  [R1]
         { info_tbl: [(c9Wb4,
                       label: new_outleft'_s9VZu_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wb4: // global
           _s9VZu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wb5; else goto c9Wb6;
       c9Wb6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Wb8; else goto c9Wb7;
       c9Wb8: // global
           HpAlloc = 16;
           goto c9Wb5;
       c9Wb5: // global
           R1 = _s9VZu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wb7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VZu::P64;
           _s9VYQ::I64 = I64[_s9VZu::P64 + 16];
           _s9VZt::I64 = I64[_s9VZu::P64 + 24];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9Wb2; else goto c9Wb3;
       c9Wb2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9VZt::I64, _s9VYQ::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wb3: // global
           if (%MO_S_Ge_W64(_s9VZt::I64, 0)) goto c9Wbo; else goto c9Wbp;
       c9Wbo: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wbp: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 new_input_s9VZA_entry() //  [R1]
         { info_tbl: [(c9Wby,
                       label: new_input_s9VZA_info
                       rep:HeapRep 2 ptrs 5 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wby: // global
           _s9VZA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wbz; else goto c9WbA;
       c9WbA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9WbC; else goto c9WbB;
       c9WbC: // global
           HpAlloc = 56;
           goto c9Wbz;
       c9Wbz: // global
           R1 = _s9VZA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WbB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VZA::P64;
           _s9VYk::P64 = P64[_s9VZA::P64 + 16];
           _s9VYl::P64 = P64[_s9VZA::P64 + 24];
           _s9VYj::I64 = I64[_s9VZA::P64 + 32];
           _s9VYm::I64 = I64[_s9VZA::P64 + 40];
           _s9VZB::I64 = I64[_s9VZA::P64 + 64];
           if (_s9VZB::I64 != 0) goto c9Wbw; else goto c9Wbx;
       c9Wbw: // global
           _s9VYo::I64 = I64[_s9VZA::P64 + 48];
           _s9VYD::I64 = I64[_s9VZA::P64 + 56];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9WbS; else goto c9Wc9;
       c9WbS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64 - %MO_S_Shr_W64(_s9VZB::I64,
                                                     _s9VYD::I64);
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wc9: // global
           if (%MO_S_Ge_W64(_s9VZB::I64, 0)) goto c9Wc2; else goto c9Wc8;
       c9Wc2: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64;
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wc8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64 + 1;
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wbx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9VZT_entry() //  [R1]
         { info_tbl: [(c9Wcr,
                       label: sat_s9VZT_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wcr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wcy; else goto c9Wcz;
       c9Wcy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wcz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Wco_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9WcD; else goto c9Wcp;
       u9WcD: // global
           call _c9Wco(R1) args: 0, res: 0, upd: 0;
       c9Wcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Wco() //  [R1]
         { info_tbl: [(c9Wco,
                       label: block_c9Wco_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wco: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9WcC; else goto c9WcB;
       c9WcC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9WcB: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9VZS::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VZS::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9W0i_entry() //  [R1]
         { info_tbl: [(c9WcX,
                       label: sat_s9W0i_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WcX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wd4; else goto c9Wd5;
       c9Wd4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wd5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9WcU_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Wd9; else goto c9WcV;
       u9Wd9: // global
           call _c9WcU(R1) args: 0, res: 0, upd: 0;
       c9WcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9WcU() //  [R1]
         { info_tbl: [(c9WcU,
                       label: block_c9WcU_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WcU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Wd8; else goto c9Wd7;
       c9Wd8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wd7: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0h::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0h::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9W0t_entry() //  [R1]
         { info_tbl: [(c9Wdo,
                       label: sat_s9W0t_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wdo: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wdv; else goto c9Wdw;
       c9Wdv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wdw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Wdl_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9WdA; else goto c9Wdm;
       u9WdA: // global
           call _c9Wdl(R1) args: 0, res: 0, upd: 0;
       c9Wdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Wdl() //  [R1]
         { info_tbl: [(c9Wdl,
                       label: block_c9Wdl_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wdl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Wdz; else goto c9Wdy;
       c9Wdz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wdy: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0s::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0s::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9W0I_entry() //  [R1]
         { info_tbl: [(c9WdP,
                       label: sat_s9W0I_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WdP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9WdW; else goto c9WdX;
       c9WdW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WdX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9WdM_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9We1; else goto c9WdN;
       u9We1: // global
           call _c9WdM(R1) args: 0, res: 0, upd: 0;
       c9WdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9WdM() //  [R1]
         { info_tbl: [(c9WdM,
                       label: block_c9WdM_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WdM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9We0; else goto c9WdZ;
       c9We0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9WdZ: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0H::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0H::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9W0E_entry() //  [R1]
         { info_tbl: [(c9We9,
                       label: sat_s9W0E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9We9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Wea; else goto c9Web;
       c9Wea: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Web: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9We6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Wej; else goto c9We7;
       u9Wej: // global
           call _c9We6(R1) args: 0, res: 0, upd: 0;
       c9We7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9We6() //  [R1]
         { info_tbl: [(c9We6,
                       label: block_c9We6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9We6: // global
           if (I64[R1 + 7] == 0) goto c9Wei; else goto c9Weh;
       c9Wei: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Weh: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c9Wek,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wek: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9Wel; else goto c9Wem;
       c9Wel: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wem: // global
           I64[Sp - 40] = block_c9W9A_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9WfC; else goto c9W9B;
       u9WfC: // global
           call _c9W9A(R1) args: 0, res: 0, upd: 0;
       c9W9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W9A() //  [R1]
         { info_tbl: [(c9W9A,
                       label: block_c9W9A_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W9A: // global
           I64[Sp - 40] = block_c9W9F_info;
           _s9VYk::P64 = P64[R1 + 7];
           _s9VYl::P64 = P64[R1 + 15];
           _s9VYj::I64 = I64[R1 + 23];
           _s9VYm::I64 = I64[R1 + 31];
           _s9VYn::I64 = I64[R1 + 39];
           _s9VYo::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9VYl::P64;
           I64[Sp - 24] = _s9VYm::I64;
           I64[Sp - 16] = _s9VYn::I64;
           I64[Sp - 8] = _s9VYo::I64;
           P64[Sp] = _s9VYk::P64;
           I64[Sp + 24] = _s9VYj::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9Wfy; else goto c9W9G;
       u9Wfy: // global
           call _c9W9F(R1) args: 0, res: 0, upd: 0;
       c9W9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W9F() //  [R1]
         { info_tbl: [(c9W9F,
                       label: block_c9W9F_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W9F: // global
           I64[Sp - 48] = block_c9W9K_info;
           R2 = 8;
           _s9VYr::P64 = P64[R1 + 7];
           _s9VYs::P64 = P64[R1 + 15];
           _s9VYq::I64 = I64[R1 + 23];
           _s9VYt::I64 = I64[R1 + 31];
           _s9VYu::I64 = I64[R1 + 39];
           _s9VYv::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9VYr::P64;
           P64[Sp - 32] = _s9VYs::P64;
           I64[Sp - 24] = _s9VYt::I64;
           I64[Sp - 16] = _s9VYu::I64;
           I64[Sp - 8] = _s9VYv::I64;
           I64[Sp] = _s9VYq::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W9K() //  [R1]
         { info_tbl: [(c9W9K,
                       label: block_c9W9K_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W9K: // global
           I64[Sp] = block_c9W9M_info;
           _s9VYB::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9VYB::P64;
           if (R1 & 7 != 0) goto u9Wfz; else goto c9W9N;
       u9Wfz: // global
           call _c9W9M(R1) args: 0, res: 0, upd: 0;
       c9W9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W9M() //  [R1]
         { info_tbl: [(c9W9M,
                       label: block_c9W9M_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W9M: // global
           _s9VYj::I64 = I64[Sp + 112];
           _s9VYB::P64 = P64[Sp + 104];
           _s9VYD::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9Wf9; else goto c9Wfa;
       c9Wf9: // global
           _s9VYF::I64 = I64[Sp + 72] << _s9VYD::I64;
           goto s9VYE;
       c9Wfa: // global
           _s9VYF::I64 = 0;
           goto s9VYE;
       s9VYE: // global
           _s9VYG::I64 = _s9VYB::P64 + 16;
           I64[_s9VYG::I64] = _s9VYj::I64 + _s9VYF::I64;
           I64[Sp - 16] = block_c9Wa2_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9VYG::I64;
           I64[Sp] = _s9VYD::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wa2() //  [R1]
         { info_tbl: [(c9Wa2,
                       label: block_c9Wa2_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wa2: // global
           I64[Sp] = block_c9Wa4_info;
           _s9VYO::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9VYO::P64;
           if (R1 & 7 != 0) goto u9WfA; else goto c9Wa5;
       u9WfA: // global
           call _c9Wa4(R1) args: 0, res: 0, upd: 0;
       c9Wa5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wa4() //  [R1]
         { info_tbl: [(c9Wa4,
                       label: block_c9Wa4_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     False, True, True, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wa4: // global
           _s9VYq::I64 = I64[Sp + 64];
           _s9VYO::P64 = P64[Sp + 136];
           _s9VYQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9Wf4; else goto c9Wf5;
       c9Wf4: // global
           _s9VYS::I64 = I64[Sp + 56] << _s9VYQ::I64;
           goto s9VYR;
       c9Wf5: // global
           _s9VYS::I64 = 0;
           goto s9VYR;
       s9VYR: // global
           _s9VYT::I64 = _s9VYO::P64 + 16;
           I64[_s9VYT::I64] = _s9VYq::I64 + _s9VYS::I64;
           I64[Sp - 16] = block_c9Wak_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9VYT::I64;
           I64[Sp] = _s9VYQ::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wak() //  [R1]
         { info_tbl: [(c9Wak,
                       label: block_c9Wak_info
                       rep:StackRep [True, True, True, True, False, False, True, True,
                                     True, True, False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wak: // global
           _s9VYD::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9WeZ; else goto c9Wf0;
       c9WeZ: // global
           _s9VZ1::P64 = R1;
           _s9VZ3::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9VYD::I64;
           goto s9VZ2;
       c9Wf0: // global
           _s9VZ1::P64 = R1;
           _s9VZ3::I64 = 0;
           goto s9VZ2;
       s9VZ2: // global
           _s9VZ4::I64 = _s9VZ1::P64 + 16;
           I64[_s9VZ4::I64] = _s9VZ3::I64;
           I64[Sp - 8] = block_c9Wax_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9VZ4::I64;
           P64[Sp + 104] = _s9VZ1::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wax() //  [R1]
         { info_tbl: [(c9Wax,
                       label: block_c9Wax_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wax: // global
           _s9VYc::P64 = P64[Sp + 136];
           _s9VYQ::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9WeU; else goto c9WeV;
       c9WeU: // global
           _s9VZc::P64 = R1;
           _s9VZe::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9VYQ::I64;
           goto s9VZd;
       c9WeV: // global
           _s9VZc::P64 = R1;
           _s9VZe::I64 = 0;
           goto s9VZd;
       s9VZd: // global
           _s9VZf::I64 = _s9VZc::P64 + 16;
           I64[_s9VZf::I64] = _s9VZe::I64;
           I64[Sp] = block_c9WaK_info;
           R1 = _s9VYc::P64;
           I64[Sp + 80] = _s9VZf::I64;
           P64[Sp + 136] = _s9VZc::P64;
           if (R1 & 7 != 0) goto u9WfB; else goto c9WaL;
       u9WfB: // global
           call _c9WaK(R1) args: 0, res: 0, upd: 0;
       c9WaL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9WaK() //  [R1]
         { info_tbl: [(c9WaK,
                       label: block_c9WaK_info
                       rep:StackRep [True, True, True, True, True, False, False, True,
                                     True, True, True, False, True, False, True, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WaK: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9WeB; else goto c9WeA;
       c9WeB: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9WeA: // global
           _s9VYj::I64 = I64[Sp + 152];
           _s9VYk::P64 = P64[Sp + 128];
           _s9VYl::P64 = P64[Sp + 96];
           _s9VYm::I64 = I64[Sp + 104];
           _s9VYo::I64 = I64[Sp + 120];
           _s9VYq::I64 = I64[Sp + 88];
           _s9VYr::P64 = P64[Sp + 48];
           _s9VYs::P64 = P64[Sp + 56];
           _s9VYt::I64 = I64[Sp + 64];
           _s9VYu::I64 = I64[Sp + 72];
           _s9VYB::P64 = P64[Sp + 144];
           _s9VYD::I64 = I64[Sp + 40];
           _s9VYO::P64 = P64[Sp + 160];
           _s9VYQ::I64 = I64[Sp + 24];
           _s9VZ1::P64 = P64[Sp + 112];
           _s9VZ4::I64 = I64[Sp + 8];
           _s9VZc::P64 = P64[Sp + 136];
           _s9VZf::I64 = I64[Sp + 80];
           (_s9VZn::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9VZ4::I64, I64[Sp + 16], _s9VZf::I64);
           _s9VZq::I64 = I64[_s9VZ4::I64];
           _s9VZt::I64 = I64[_s9VZf::I64];
           I64[Hp - 216] = new_outleft'_s9VZu_info;
           I64[Hp - 200] = _s9VYQ::I64;
           I64[Hp - 192] = _s9VZt::I64;
           I64[Hp - 184] = new_input_s9VZA_info;
           P64[Hp - 168] = _s9VYk::P64;
           P64[Hp - 160] = _s9VYl::P64;
           I64[Hp - 152] = _s9VYj::I64;
           I64[Hp - 144] = _s9VYm::I64;
           I64[Hp - 136] = _s9VYo::I64;
           I64[Hp - 128] = _s9VYD::I64;
           I64[Hp - 120] = _s9VZq::I64;
           _c9WaV::P64 = Hp - 216;
           _c9Wbq::P64 = Hp - 184;
           if (_s9VZn::I64 == 18446744073709551615) goto c9WeQ; else goto c9WeE;
       c9WeQ: // global
           (_s9VZY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9VZZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9VZY::I64));
           if (%MO_S_Lt_W64(_s9VZZ::I64, 23)) goto u9Wfv; else goto u9Wfx;
       u9Wfv: // global
           if (%MO_S_Lt_W64(_s9VZZ::I64, 22)) goto u9Wfw; else goto c9WeN;
       u9Wfw: // global
           if (_s9VZZ::I64 != 7) goto c9WeH; else goto c9WeL;
       c9WeL: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0i_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeK::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeK::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WeN: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0t_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeM::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeM::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9Wfx: // global
           if (_s9VZZ::I64 != 84) goto c9WeH; else goto c9WeP;
       c9WeH: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9WeF_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9WeP: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0I_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = sat_s9W0E_info;
           P64[Hp - 32] = _c9WaV::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9Wbq::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WeE: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9VZT_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeC::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeC::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9WeF() //  [R1]
         { info_tbl: [(c9WeF,
                       label: block_c9WeF_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WeF: // global
           _s9VYk::P64 = P64[Sp + 88];
           _s9VYr::P64 = P64[Sp + 8];
           _s9VYB::P64 = P64[Sp + 104];
           _s9VYO::P64 = P64[Sp + 120];
           _s9VZ1::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.763656212 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Wj0,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding10_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wj0: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.767151053 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Wjb,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wjb: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.771099583 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { info_tbl: [(c9Wjp,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wjp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Wjq; else goto c9Wjr;
       c9Wjq: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Wjr: // global
           I64[Sp - 8] = block_c9Wjm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Wjz; else goto c9Wjn;
       u9Wjz: // global
           call _c9Wjm(R1) args: 0, res: 0, upd: 0;
       c9Wjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wjm() //  [R1]
         { info_tbl: [(c9Wjm,
                       label: block_c9Wjm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wjm: // global
           if (I64[R1 + 7] == 47) goto c9Wjy; else goto c9Wjx;
       c9Wjy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Wjx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.776503944 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.779758715 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9W19_entry() //  [R1]
         { info_tbl: [(c9Wk0,
                       label: ds_s9W19_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wk0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Wk1; else goto c9Wk2;
       c9Wk1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wk2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9WjX_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9WjX() //  [R1, R2]
         { info_tbl: [(c9WjX,
                       label: block_c9WjX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WjX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Wk5; else goto c9Wk4;
       c9Wk5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9Wk4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 enc_s9W1h_entry() //  [R1]
         { info_tbl: [(c9Wkc,
                       label: enc_s9W1h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wkc: // global
           _s9W1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wkd; else goto c9Wke;
       c9Wke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Wkg; else goto c9Wkf;
       c9Wkg: // global
           HpAlloc = 24;
           goto c9Wkd;
       c9Wkd: // global
           R1 = _s9W1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wkf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9W1h::P64;
           _s9W19::P64 = P64[_s9W1h::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9W19::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 enc1_s9W1m_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Wkm,
                       label: enc1_s9W1m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wkm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc2_s9W1n_entry() //  [R1]
         { info_tbl: [(c9Wku,
                       label: enc2_s9W1n_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wku: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 enc3_s9W1o_entry() //  [R1, R2, R3]
         { info_tbl: [(c9WkC,
                       label: enc3_s9W1o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WkC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 enc4_s9W1p_entry() //  [R1]
         { info_tbl: [(c9WkK,
                       label: enc4_s9W1p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WkK: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9W1v_entry() //  [R1]
         { info_tbl: [(c9Wl1,
                       label: sat_s9W1v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wl1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Wl2; else goto c9Wl3;
       c9Wl2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wl3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9WkU_info;
           _s9W1q::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9W1q::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9Wld; else goto c9WkV;
       u9Wld: // global
           call _c9WkU(R1) args: 0, res: 0, upd: 0;
       c9WkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9WkU() //  [R1]
         { info_tbl: [(c9WkU,
                       label: block_c9WkU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WkU: // global
           if (R1 & 7 == 1) goto c9WkY; else goto c9WkZ;
       c9WkY: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9WkZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Wlc; else goto c9Wlb;
       c9Wlc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wlb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { info_tbl: [(c9Wle,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wle: // global
           _s9W17::P64 = R3;
           _s9W16::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wlf; else goto c9Wlg;
       c9Wlg: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9Wli; else goto c9Wlh;
       c9Wli: // global
           HpAlloc = 192;
           goto c9Wlf;
       c9Wlf: // global
           R3 = _s9W17::P64;
           R2 = _s9W16::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wlh: // global
           I64[Hp - 184] = ds_s9W19_info;
           P64[Hp - 168] = _s9W17::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9WjT::P64 = Hp - 184;
           P64[Hp - 144] = _c9WjT::P64;
           I64[Hp - 136] = enc_s9W1h_info;
           P64[Hp - 120] = _c9WjT::P64;
           I64[Hp - 112] = enc1_s9W1m_info;
           P64[Hp - 104] = _s9W16::P64;
           I64[Hp - 96] = enc2_s9W1n_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9W1o_info;
           P64[Hp - 56] = _s9W16::P64;
           I64[Hp - 48] = enc4_s9W1p_info;
           P64[Hp - 40] = _s9W17::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9W17::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9WkO_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9WkN::P64 = Hp - 23;
           R2 = _c9WkN::P64;
           P64[Sp - 8] = _c9WkN::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9WkO() //  [R1]
         { info_tbl: [(c9WkO,
                       label: block_c9WkO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WkO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9Wll; else goto c9Wlk;
       c9Wll: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Wlk: // global
           I64[Hp - 24] = sat_s9W1v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.803936466 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { info_tbl: [(c9WmA,
                       label: GHC.IO.Encoding.Iconv.mkIconvEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WmA: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.807532502 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { info_tbl: [(c9WmL,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WmL: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.810866964 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { info_tbl: [(c9WmX,
                       label: GHC.IO.Encoding.Iconv.iconvEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WmX: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:01.814062056 UTC

[section ""relreadonly" . S9W22_srt" {
     S9W22_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]

