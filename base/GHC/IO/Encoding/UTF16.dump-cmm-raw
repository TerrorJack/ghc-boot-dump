
==================== Raw Cmm ====================
2018-03-16 16:03:48.897924402 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:48.913071473 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8G24_entry() //  [R1]
         { []
         }
     {offset
       c8HuH: // global
           _s8G24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HuI; else goto c8HuJ;
       c8HuJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HuL; else goto c8HuK;
       c8HuL: // global
           HpAlloc = 56;
           goto c8HuI;
       c8HuI: // global
           R1 = _s8G24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G24::P64;
           _s8G1Q::I64 = I64[_s8G24::P64 + 56];
           _s8G20::I64 = I64[_s8G24::P64 + 64];
           if (_s8G20::I64 == _s8G1Q::I64) goto c8HuG; else goto c8HuF;
       c8HuG: // global
           _s8G1Y::P64 = P64[_s8G24::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HuF: // global
           _s8G1M::P64 = P64[_s8G24::P64 + 16];
           _s8G1N::P64 = P64[_s8G24::P64 + 24];
           _s8G1L::I64 = I64[_s8G24::P64 + 40];
           _s8G1O::I64 = I64[_s8G24::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G20::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G24_info" {
     sat_s8G24_info:
         const sat_s8G24_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G2c_entry() //  [R1]
         { []
         }
     {offset
       c8Hv3: // global
           _s8G2c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hv4; else goto c8Hv5;
       c8Hv5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hv7; else goto c8Hv6;
       c8Hv7: // global
           HpAlloc = 56;
           goto c8Hv4;
       c8Hv4: // global
           R1 = _s8G2c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hv6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2c::P64;
           _s8G1Q::I64 = I64[_s8G2c::P64 + 56];
           _s8G28::I64 = I64[_s8G2c::P64 + 64];
           if (_s8G28::I64 == _s8G1Q::I64) goto c8Hv2; else goto c8Hv1;
       c8Hv2: // global
           _s8G1Y::P64 = P64[_s8G2c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hv1: // global
           _s8G1M::P64 = P64[_s8G2c::P64 + 16];
           _s8G1N::P64 = P64[_s8G2c::P64 + 24];
           _s8G1L::I64 = I64[_s8G2c::P64 + 40];
           _s8G1O::I64 = I64[_s8G2c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G28::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G2c_info" {
     sat_s8G2c_info:
         const sat_s8G2c_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G2k_entry() //  [R1]
         { []
         }
     {offset
       c8Hvp: // global
           _s8G2k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hvq; else goto c8Hvr;
       c8Hvr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hvt; else goto c8Hvs;
       c8Hvt: // global
           HpAlloc = 56;
           goto c8Hvq;
       c8Hvq: // global
           R1 = _s8G2k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hvs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2k::P64;
           _s8G1Q::I64 = I64[_s8G2k::P64 + 56];
           _s8G2g::I64 = I64[_s8G2k::P64 + 64];
           if (_s8G2g::I64 == _s8G1Q::I64) goto c8Hvo; else goto c8Hvn;
       c8Hvo: // global
           _s8G1Y::P64 = P64[_s8G2k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hvn: // global
           _s8G1M::P64 = P64[_s8G2k::P64 + 16];
           _s8G1N::P64 = P64[_s8G2k::P64 + 24];
           _s8G1L::I64 = I64[_s8G2k::P64 + 40];
           _s8G1O::I64 = I64[_s8G2k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2g::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G2k_info" {
     sat_s8G2k_info:
         const sat_s8G2k_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G2s_entry() //  [R1]
         { []
         }
     {offset
       c8HvL: // global
           _s8G2s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HvM; else goto c8HvN;
       c8HvN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HvP; else goto c8HvO;
       c8HvP: // global
           HpAlloc = 56;
           goto c8HvM;
       c8HvM: // global
           R1 = _s8G2s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HvO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2s::P64;
           _s8G1Q::I64 = I64[_s8G2s::P64 + 56];
           _s8G2o::I64 = I64[_s8G2s::P64 + 64];
           if (_s8G2o::I64 == _s8G1Q::I64) goto c8HvK; else goto c8HvJ;
       c8HvK: // global
           _s8G1Y::P64 = P64[_s8G2s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HvJ: // global
           _s8G1M::P64 = P64[_s8G2s::P64 + 16];
           _s8G1N::P64 = P64[_s8G2s::P64 + 24];
           _s8G1L::I64 = I64[_s8G2s::P64 + 40];
           _s8G1O::I64 = I64[_s8G2s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2o::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G2s_info" {
     sat_s8G2s_info:
         const sat_s8G2s_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G2A_entry() //  [R1]
         { []
         }
     {offset
       c8Hw7: // global
           _s8G2A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hw8; else goto c8Hw9;
       c8Hw9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hwb; else goto c8Hwa;
       c8Hwb: // global
           HpAlloc = 56;
           goto c8Hw8;
       c8Hw8: // global
           R1 = _s8G2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2A::P64;
           _s8G1Q::I64 = I64[_s8G2A::P64 + 56];
           _s8G2w::I64 = I64[_s8G2A::P64 + 64];
           if (_s8G2w::I64 == _s8G1Q::I64) goto c8Hw6; else goto c8Hw5;
       c8Hw6: // global
           _s8G1Y::P64 = P64[_s8G2A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hw5: // global
           _s8G1M::P64 = P64[_s8G2A::P64 + 16];
           _s8G1N::P64 = P64[_s8G2A::P64 + 24];
           _s8G1L::I64 = I64[_s8G2A::P64 + 40];
           _s8G1O::I64 = I64[_s8G2A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2w::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G2A_info" {
     sat_s8G2A_info:
         const sat_s8G2A_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G2I_entry() //  [R1]
         { []
         }
     {offset
       c8Hwt: // global
           _s8G2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hwu; else goto c8Hwv;
       c8Hwv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hwx; else goto c8Hww;
       c8Hwx: // global
           HpAlloc = 56;
           goto c8Hwu;
       c8Hwu: // global
           R1 = _s8G2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2I::P64;
           _s8G1Q::I64 = I64[_s8G2I::P64 + 56];
           _s8G2E::I64 = I64[_s8G2I::P64 + 64];
           if (_s8G2E::I64 == _s8G1Q::I64) goto c8Hws; else goto c8Hwr;
       c8Hws: // global
           _s8G1Y::P64 = P64[_s8G2I::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hwr: // global
           _s8G1M::P64 = P64[_s8G2I::P64 + 16];
           _s8G1N::P64 = P64[_s8G2I::P64 + 24];
           _s8G1L::I64 = I64[_s8G2I::P64 + 40];
           _s8G1O::I64 = I64[_s8G2I::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2E::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G2I_info" {
     sat_s8G2I_info:
         const sat_s8G2I_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HwA: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HwB; else goto c8HwC;
       c8HwB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HwC: // global
           I64[Sp - 16] = block_c8Huh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HBI; else goto c8Hui;
       u8HBI: // global
           call _c8Huh(R1) args: 0, res: 0, upd: 0;
       c8Hui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF1_info" {
     GHC.IO.Encoding.UTF16.mkUTF1_info:
         const GHC.IO.Encoding.UTF16.mkUTF1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Huh() //  [R1]
         { []
         }
     {offset
       c8Huh: // global
           I64[Sp - 40] = block_c8Hum_info;
           _s8G1M::P64 = P64[R1 + 7];
           _s8G1N::P64 = P64[R1 + 15];
           _s8G1L::I64 = I64[R1 + 23];
           _s8G1O::I64 = I64[R1 + 31];
           _s8G1P::I64 = I64[R1 + 39];
           _s8G1Q::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G1N::P64;
           I64[Sp - 24] = _s8G1O::I64;
           I64[Sp - 16] = _s8G1P::I64;
           I64[Sp - 8] = _s8G1Q::I64;
           P64[Sp] = _s8G1M::P64;
           I64[Sp + 8] = _s8G1L::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HBB; else goto c8Hun;
       u8HBB: // global
           call _c8Hum(R1) args: 0, res: 0, upd: 0;
       c8Hun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Huh_info" {
     block_c8Huh_info:
         const _c8Huh;
         const 1;
         const 30;
 },
 _c8Hum() //  [R1]
         { []
         }
     {offset
       c8Hum: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HwG; else goto c8HwF;
       c8HwG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HwF: // global
           _s8G1T::P64 = P64[R1 + 7];
           _s8G1U::P64 = P64[R1 + 15];
           _s8G1S::I64 = I64[R1 + 23];
           _s8G1V::I64 = I64[R1 + 31];
           _s8G1W::I64 = I64[R1 + 39];
           _s8G1X::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G1M::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G1L::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G1Q::I64 = I64[Sp + 32];
           _c8Hur::P64 = Hp - 47;
           _s8G2N::I64 = _s8G1X::I64;
           _s8G2M::I64 = I64[Sp + 24];
           goto c8Hx7;
       c8Hx7: // global
           if (%MO_S_Lt_W64(_s8G2M::I64,
                            _s8G1Q::I64)) goto c8Hyi; else goto c8Hyj;
       c8Hyi: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            2)) goto c8Hyf; else goto c8Hyg;
       c8Hyf: // global
           _s8G2U::I64 = %MO_UU_Conv_W32_W64(I32[_s8G1L::I64 + (_s8G2M::I64 << 2)]);
           call MO_Touch(_s8G1M::P64);
           if (%MO_S_Ge_W64(_s8G2U::I64, 65536)) goto c8HxA; else goto c8Hyd;
       c8HxA: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            4)) goto c8Hxx; else goto c8Hxy;
       c8Hxx: // global
           _s8G30::I64 = _s8G2U::I64 - 65536;
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                            18) + 216);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                                  10));
           call MO_Touch(_s8G1T::P64);
           _s8G3f::I64 = _s8G30::I64 & 1023;
           I8[_s8G1S::I64 + (_s8G2N::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G3f::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8G3f::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 4;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hxy: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Huu() args: 0, res: 0, upd: 0;
       c8Hyd: // global
           if (%MO_S_Gt_W64(55296, _s8G2U::I64)) goto c8HxS; else goto c8Hyc;
       c8HxS: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8HxI; else goto c8HxQ;
       c8HxI: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8HxQ: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8HxO; else goto c8HxP;
       c8HxO: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8HxP: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8HuQ() args: 0, res: 0, upd: 0;
       c8Hyc: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 56319)) goto c8Hya; else goto c8Hyb;
       c8Hya: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8Hy0; else goto c8Hy8;
       c8Hy0: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hy8: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8Hy6; else goto c8Hy7;
       c8Hy6: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hy7: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hvc() args: 0, res: 0, upd: 0;
       c8Hyb: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hvy() args: 0, res: 0, upd: 0;
       c8Hyg: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8HvU() args: 0, res: 0, upd: 0;
       c8Hyj: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hwg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Hum_info" {
     block_c8Hum_info:
         const _c8Hum;
         const 2950;
         const 30;
 },
 _c8Huu() //  []
         { []
         }
     {offset
       c8Huu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwK; else goto c8HwJ;
       c8HwK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Huu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G24_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Huu_info" {
     block_c8Huu_info:
         const _c8Huu;
         const 352013;
         const 30;
 },
 _c8HuQ() //  []
         { []
         }
     {offset
       c8HuQ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwO; else goto c8HwN;
       c8HwO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HuQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HuQ_info" {
     block_c8HuQ_info:
         const _c8HuQ;
         const 352013;
         const 30;
 },
 _c8Hvc() //  []
         { []
         }
     {offset
       c8Hvc: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwS; else goto c8HwR;
       c8HwS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hvc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Hvc_info" {
     block_c8Hvc_info:
         const _c8Hvc;
         const 352013;
         const 30;
 },
 _c8Hvy() //  []
         { []
         }
     {offset
       c8Hvy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwW; else goto c8HwV;
       c8HwW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hvy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2s_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Hvy_info" {
     block_c8Hvy_info:
         const _c8Hvy;
         const 352013;
         const 30;
 },
 _c8HvU() //  []
         { []
         }
     {offset
       c8HvU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hx0; else goto c8HwZ;
       c8Hx0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HvU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HvU_info" {
     block_c8HvU_info:
         const _c8HvU;
         const 352013;
         const 30;
 },
 _c8Hwg() //  []
         { []
         }
     {offset
       c8Hwg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hx4; else goto c8Hx3;
       c8Hx4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hwg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hx3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2I_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Hwg_info" {
     block_c8Hwg_info:
         const _c8Hwg;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:48.951772783 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HEX: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be_encode_info" {
     GHC.IO.Encoding.UTF16.utf16be_encode_info:
         const GHC.IO.Encoding.UTF16.utf16be_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:48.970887384 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8G4T_entry() //  [R1]
         { []
         }
     {offset
       c8HFy: // global
           _s8G4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HFz; else goto c8HFA;
       c8HFA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HFC; else goto c8HFB;
       c8HFC: // global
           HpAlloc = 56;
           goto c8HFz;
       c8HFz: // global
           R1 = _s8G4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HFB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G4T::P64;
           _s8G4F::I64 = I64[_s8G4T::P64 + 56];
           _s8G4P::I64 = I64[_s8G4T::P64 + 64];
           if (_s8G4P::I64 == _s8G4F::I64) goto c8HFx; else goto c8HFw;
       c8HFx: // global
           _s8G4N::P64 = P64[_s8G4T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HFw: // global
           _s8G4B::P64 = P64[_s8G4T::P64 + 16];
           _s8G4C::P64 = P64[_s8G4T::P64 + 24];
           _s8G4A::I64 = I64[_s8G4T::P64 + 40];
           _s8G4D::I64 = I64[_s8G4T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4P::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G4T_info" {
     sat_s8G4T_info:
         const sat_s8G4T_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G51_entry() //  [R1]
         { []
         }
     {offset
       c8HFU: // global
           _s8G51::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HFV; else goto c8HFW;
       c8HFW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HFY; else goto c8HFX;
       c8HFY: // global
           HpAlloc = 56;
           goto c8HFV;
       c8HFV: // global
           R1 = _s8G51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HFX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G51::P64;
           _s8G4F::I64 = I64[_s8G51::P64 + 56];
           _s8G4X::I64 = I64[_s8G51::P64 + 64];
           if (_s8G4X::I64 == _s8G4F::I64) goto c8HFT; else goto c8HFS;
       c8HFT: // global
           _s8G4N::P64 = P64[_s8G51::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HFS: // global
           _s8G4B::P64 = P64[_s8G51::P64 + 16];
           _s8G4C::P64 = P64[_s8G51::P64 + 24];
           _s8G4A::I64 = I64[_s8G51::P64 + 40];
           _s8G4D::I64 = I64[_s8G51::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4X::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G51_info" {
     sat_s8G51_info:
         const sat_s8G51_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G59_entry() //  [R1]
         { []
         }
     {offset
       c8HGg: // global
           _s8G59::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGh; else goto c8HGi;
       c8HGi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HGk; else goto c8HGj;
       c8HGk: // global
           HpAlloc = 56;
           goto c8HGh;
       c8HGh: // global
           R1 = _s8G59::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HGj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G59::P64;
           _s8G4F::I64 = I64[_s8G59::P64 + 56];
           _s8G55::I64 = I64[_s8G59::P64 + 64];
           if (_s8G55::I64 == _s8G4F::I64) goto c8HGf; else goto c8HGe;
       c8HGf: // global
           _s8G4N::P64 = P64[_s8G59::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGe: // global
           _s8G4B::P64 = P64[_s8G59::P64 + 16];
           _s8G4C::P64 = P64[_s8G59::P64 + 24];
           _s8G4A::I64 = I64[_s8G59::P64 + 40];
           _s8G4D::I64 = I64[_s8G59::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G55::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G59_info" {
     sat_s8G59_info:
         const sat_s8G59_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G5h_entry() //  [R1]
         { []
         }
     {offset
       c8HGC: // global
           _s8G5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGD; else goto c8HGE;
       c8HGE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HGG; else goto c8HGF;
       c8HGG: // global
           HpAlloc = 56;
           goto c8HGD;
       c8HGD: // global
           R1 = _s8G5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5h::P64;
           _s8G4F::I64 = I64[_s8G5h::P64 + 56];
           _s8G5d::I64 = I64[_s8G5h::P64 + 64];
           if (_s8G5d::I64 == _s8G4F::I64) goto c8HGB; else goto c8HGA;
       c8HGB: // global
           _s8G4N::P64 = P64[_s8G5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGA: // global
           _s8G4B::P64 = P64[_s8G5h::P64 + 16];
           _s8G4C::P64 = P64[_s8G5h::P64 + 24];
           _s8G4A::I64 = I64[_s8G5h::P64 + 40];
           _s8G4D::I64 = I64[_s8G5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5d::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G5h_info" {
     sat_s8G5h_info:
         const sat_s8G5h_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G5p_entry() //  [R1]
         { []
         }
     {offset
       c8HGY: // global
           _s8G5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGZ; else goto c8HH0;
       c8HH0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HH2; else goto c8HH1;
       c8HH2: // global
           HpAlloc = 56;
           goto c8HGZ;
       c8HGZ: // global
           R1 = _s8G5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HH1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5p::P64;
           _s8G4F::I64 = I64[_s8G5p::P64 + 56];
           _s8G5l::I64 = I64[_s8G5p::P64 + 64];
           if (_s8G5l::I64 == _s8G4F::I64) goto c8HGX; else goto c8HGW;
       c8HGX: // global
           _s8G4N::P64 = P64[_s8G5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGW: // global
           _s8G4B::P64 = P64[_s8G5p::P64 + 16];
           _s8G4C::P64 = P64[_s8G5p::P64 + 24];
           _s8G4A::I64 = I64[_s8G5p::P64 + 40];
           _s8G4D::I64 = I64[_s8G5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5l::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G5p_info" {
     sat_s8G5p_info:
         const sat_s8G5p_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G5x_entry() //  [R1]
         { []
         }
     {offset
       c8HHk: // global
           _s8G5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HHl; else goto c8HHm;
       c8HHm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HHo; else goto c8HHn;
       c8HHo: // global
           HpAlloc = 56;
           goto c8HHl;
       c8HHl: // global
           R1 = _s8G5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HHn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5x::P64;
           _s8G4F::I64 = I64[_s8G5x::P64 + 56];
           _s8G5t::I64 = I64[_s8G5x::P64 + 64];
           if (_s8G5t::I64 == _s8G4F::I64) goto c8HHj; else goto c8HHi;
       c8HHj: // global
           _s8G4N::P64 = P64[_s8G5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HHi: // global
           _s8G4B::P64 = P64[_s8G5x::P64 + 16];
           _s8G4C::P64 = P64[_s8G5x::P64 + 24];
           _s8G4A::I64 = I64[_s8G5x::P64 + 40];
           _s8G4D::I64 = I64[_s8G5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5t::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G5x_info" {
     sat_s8G5x_info:
         const sat_s8G5x_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HHr: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HHs; else goto c8HHt;
       c8HHs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HHt: // global
           I64[Sp - 16] = block_c8HF8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HMz; else goto c8HF9;
       u8HMz: // global
           call _c8HF8(R1) args: 0, res: 0, upd: 0;
       c8HF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le1_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8HF8() //  [R1]
         { []
         }
     {offset
       c8HF8: // global
           I64[Sp - 40] = block_c8HFd_info;
           _s8G4B::P64 = P64[R1 + 7];
           _s8G4C::P64 = P64[R1 + 15];
           _s8G4A::I64 = I64[R1 + 23];
           _s8G4D::I64 = I64[R1 + 31];
           _s8G4E::I64 = I64[R1 + 39];
           _s8G4F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G4C::P64;
           I64[Sp - 24] = _s8G4D::I64;
           I64[Sp - 16] = _s8G4E::I64;
           I64[Sp - 8] = _s8G4F::I64;
           P64[Sp] = _s8G4B::P64;
           I64[Sp + 8] = _s8G4A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HMs; else goto c8HFe;
       u8HMs: // global
           call _c8HFd(R1) args: 0, res: 0, upd: 0;
       c8HFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HF8_info" {
     block_c8HF8_info:
         const _c8HF8;
         const 1;
         const 30;
 },
 _c8HFd() //  [R1]
         { []
         }
     {offset
       c8HFd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HHx; else goto c8HHw;
       c8HHx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HHw: // global
           _s8G4I::P64 = P64[R1 + 7];
           _s8G4J::P64 = P64[R1 + 15];
           _s8G4H::I64 = I64[R1 + 23];
           _s8G4K::I64 = I64[R1 + 31];
           _s8G4L::I64 = I64[R1 + 39];
           _s8G4M::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G4B::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G4A::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G4F::I64 = I64[Sp + 32];
           _c8HFi::P64 = Hp - 47;
           _s8G5C::I64 = _s8G4M::I64;
           _s8G5B::I64 = I64[Sp + 24];
           goto c8HHY;
       c8HHY: // global
           if (%MO_S_Lt_W64(_s8G5B::I64,
                            _s8G4F::I64)) goto c8HJ9; else goto c8HJa;
       c8HJ9: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            2)) goto c8HJ6; else goto c8HJ7;
       c8HJ6: // global
           _s8G5J::I64 = %MO_UU_Conv_W32_W64(I32[_s8G4A::I64 + (_s8G5B::I64 << 2)]);
           call MO_Touch(_s8G4B::P64);
           if (%MO_S_Ge_W64(_s8G5J::I64, 65536)) goto c8HIr; else goto c8HJ4;
       c8HIr: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            4)) goto c8HIo; else goto c8HIp;
       c8HIo: // global
           _s8G5P::I64 = _s8G5J::I64 - 65536;
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                            10));
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8G4I::P64);
           _s8G64::I64 = _s8G5P::I64 & 1023;
           I8[_s8G4H::I64 + (_s8G5C::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8G64::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G64::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 4;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIp: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HFl() args: 0, res: 0, upd: 0;
       c8HJ4: // global
           if (%MO_S_Gt_W64(55296, _s8G5J::I64)) goto c8HIJ; else goto c8HJ3;
       c8HIJ: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8HIz; else goto c8HIH;
       c8HIz: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIH: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8HIF; else goto c8HIG;
       c8HIF: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIG: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HFH() args: 0, res: 0, upd: 0;
       c8HJ3: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 56319)) goto c8HJ1; else goto c8HJ2;
       c8HJ1: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8HIR; else goto c8HIZ;
       c8HIR: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIZ: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8HIX; else goto c8HIY;
       c8HIX: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIY: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HG3() args: 0, res: 0, upd: 0;
       c8HJ2: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HGp() args: 0, res: 0, upd: 0;
       c8HJ7: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HGL() args: 0, res: 0, upd: 0;
       c8HJa: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HH7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8HFd_info" {
     block_c8HFd_info:
         const _c8HFd;
         const 2950;
         const 30;
 },
 _c8HFl() //  []
         { []
         }
     {offset
       c8HFl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHB; else goto c8HHA;
       c8HHB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HFl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G4T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HFl_info" {
     block_c8HFl_info:
         const _c8HFl;
         const 352013;
         const 30;
 },
 _c8HFH() //  []
         { []
         }
     {offset
       c8HFH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHF; else goto c8HHE;
       c8HHF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HFH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G51_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HFH_info" {
     block_c8HFH_info:
         const _c8HFH;
         const 352013;
         const 30;
 },
 _c8HG3() //  []
         { []
         }
     {offset
       c8HG3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHJ; else goto c8HHI;
       c8HHJ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HG3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHI: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G59_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HG3_info" {
     block_c8HG3_info:
         const _c8HG3;
         const 352013;
         const 30;
 },
 _c8HGp() //  []
         { []
         }
     {offset
       c8HGp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHN; else goto c8HHM;
       c8HHN: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HGp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHM: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HGp_info" {
     block_c8HGp_info:
         const _c8HGp;
         const 352013;
         const 30;
 },
 _c8HGL() //  []
         { []
         }
     {offset
       c8HGL: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHR; else goto c8HHQ;
       c8HHR: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HGL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHQ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HGL_info" {
     block_c8HGL_info:
         const _c8HGL;
         const 352013;
         const 30;
 },
 _c8HH7() //  []
         { []
         }
     {offset
       c8HH7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHV; else goto c8HHU;
       c8HHV: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HH7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5x_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HH7_info" {
     block_c8HH7_info:
         const _c8HH7;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.009421804 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HPO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le_encode_info" {
     GHC.IO.Encoding.UTF16.utf16le_encode_info:
         const GHC.IO.Encoding.UTF16.utf16le_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.012451147 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.014208524 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.016374021 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.018350802 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.02001623 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.024374843 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { []
         }
     {offset
       c8HQ1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8HQc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8HQd; else goto c8HQe;
       c8HQd: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8HQe: // global
           I64[Sp - 48] = block_c8HQ5_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8HQU; else goto c8HQ6;
       u8HQU: // global
           call _c8HQ5(R1) args: 0, res: 0, upd: 0;
       c8HQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.$wutf16_encode_info" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_info:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 14600;
         const GHC.IO.Encoding.UTF16.$wutf16_encode_slow;
 },
 _c8HQ5() //  [R1]
         { []
         }
     {offset
       c8HQ5: // global
           _s8G7m::P64 = P64[Sp + 16];
           _s8G7n::I64 = I64[Sp + 24];
           _s8G7o::P64 = P64[Sp + 32];
           _s8G7p::P64 = P64[Sp + 40];
           _s8G7q::I64 = I64[Sp + 48];
           _s8G7r::I64 = I64[Sp + 56];
           _s8G7s::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8HQ9; else goto c8HQa;
       c8HQ9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8HQj; else goto c8HQi;
       c8HQj: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HQi: // global
           if (%MO_S_Ge_W64(_s8G7q::I64 - _s8G7s::I64,
                            2)) goto c8HQJ; else goto c8HQN;
       c8HQJ: // global
           _s8G7l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8G7l::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8G7l::P64);
           I8[_s8G7n::I64 + _s8G7s::I64] = 254 :: W8;
           call MO_Touch(_s8G7o::P64);
           I8[_s8G7n::I64 + (_s8G7s::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8G7o::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64 + 2;
           _c8HQH::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8HQH::P64;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8HQN: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8G7m::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8HQa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HQT; else goto c8HQS;
       c8HQT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HQS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G7o::P64;
           P64[Hp - 32] = _s8G7p::P64;
           I64[Hp - 24] = _s8G7n::I64;
           I64[Hp - 16] = _s8G7q::I64;
           I64[Hp - 8] = _s8G7r::I64;
           I64[Hp] = _s8G7s::I64;
           R3 = Hp - 47;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HQ5_info" {
     block_c8HQ5_info:
         const _c8HQ5;
         const 14600;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.033203715 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8HRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HRq; else goto c8HRr;
       c8HRq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HRr: // global
           I64[Sp - 24] = block_c8HRj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HRz; else goto c8HRk;
       u8HRz: // global
           call _c8HRj(R1) args: 0, res: 0, upd: 0;
       c8HRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_encode1_info" {
     GHC.IO.Encoding.UTF16.utf16_encode1_info:
         const GHC.IO.Encoding.UTF16.utf16_encode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8HRj() //  [R1]
         { []
         }
     {offset
       c8HRj: // global
           I64[Sp] = block_c8HRp_info;
           _s8G7S::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8G7S::P64;
           if (R1 & 7 != 0) goto u8HRy; else goto c8HRt;
       u8HRy: // global
           call _c8HRp(R1) args: 0, res: 0, upd: 0;
       c8HRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HRj_info" {
     block_c8HRj_info:
         const _c8HRj;
         const 2;
         const 30;
 },
 _c8HRp() //  [R1]
         { []
         }
     {offset
       c8HRp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HRp_info" {
     block_c8HRp_info:
         const _c8HRp;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.039913928 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8HRU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_encode_info" {
     GHC.IO.Encoding.UTF16.utf16_encode_info:
         const GHC.IO.Encoding.UTF16.utf16_encode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.061829074 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8G8n_entry() //  [R1]
         { []
         }
     {offset
       c8HSv: // global
           _s8G8n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HSw; else goto c8HSx;
       c8HSx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HSz; else goto c8HSy;
       c8HSz: // global
           HpAlloc = 56;
           goto c8HSw;
       c8HSw: // global
           R1 = _s8G8n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8n::P64;
           _s8G89::I64 = I64[_s8G8n::P64 + 56];
           _s8G8j::I64 = I64[_s8G8n::P64 + 64];
           if (_s8G8j::I64 == _s8G89::I64) goto c8HSu; else goto c8HSt;
       c8HSu: // global
           _s8G8h::P64 = P64[_s8G8n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HSt: // global
           _s8G85::P64 = P64[_s8G8n::P64 + 16];
           _s8G86::P64 = P64[_s8G8n::P64 + 24];
           _s8G84::I64 = I64[_s8G8n::P64 + 40];
           _s8G87::I64 = I64[_s8G8n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8j::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G8n_info" {
     sat_s8G8n_info:
         const sat_s8G8n_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G8v_entry() //  [R1]
         { []
         }
     {offset
       c8HSR: // global
           _s8G8v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HSS; else goto c8HST;
       c8HST: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HSV; else goto c8HSU;
       c8HSV: // global
           HpAlloc = 56;
           goto c8HSS;
       c8HSS: // global
           R1 = _s8G8v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HSU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8v::P64;
           _s8G89::I64 = I64[_s8G8v::P64 + 56];
           _s8G8r::I64 = I64[_s8G8v::P64 + 64];
           if (_s8G8r::I64 == _s8G89::I64) goto c8HSQ; else goto c8HSP;
       c8HSQ: // global
           _s8G8h::P64 = P64[_s8G8v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HSP: // global
           _s8G85::P64 = P64[_s8G8v::P64 + 16];
           _s8G86::P64 = P64[_s8G8v::P64 + 24];
           _s8G84::I64 = I64[_s8G8v::P64 + 40];
           _s8G87::I64 = I64[_s8G8v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8r::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G8v_info" {
     sat_s8G8v_info:
         const sat_s8G8v_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G8D_entry() //  [R1]
         { []
         }
     {offset
       c8HTd: // global
           _s8G8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTe; else goto c8HTf;
       c8HTf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTh; else goto c8HTg;
       c8HTh: // global
           HpAlloc = 56;
           goto c8HTe;
       c8HTe: // global
           R1 = _s8G8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8D::P64;
           _s8G89::I64 = I64[_s8G8D::P64 + 56];
           _s8G8z::I64 = I64[_s8G8D::P64 + 64];
           if (_s8G8z::I64 == _s8G89::I64) goto c8HTc; else goto c8HTb;
       c8HTc: // global
           _s8G8h::P64 = P64[_s8G8D::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTb: // global
           _s8G85::P64 = P64[_s8G8D::P64 + 16];
           _s8G86::P64 = P64[_s8G8D::P64 + 24];
           _s8G84::I64 = I64[_s8G8D::P64 + 40];
           _s8G87::I64 = I64[_s8G8D::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8z::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G8D_info" {
     sat_s8G8D_info:
         const sat_s8G8D_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G8L_entry() //  [R1]
         { []
         }
     {offset
       c8HTz: // global
           _s8G8L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTA; else goto c8HTB;
       c8HTB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTD; else goto c8HTC;
       c8HTD: // global
           HpAlloc = 56;
           goto c8HTA;
       c8HTA: // global
           R1 = _s8G8L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8L::P64;
           _s8G89::I64 = I64[_s8G8L::P64 + 56];
           _s8G8H::I64 = I64[_s8G8L::P64 + 64];
           if (_s8G8H::I64 == _s8G89::I64) goto c8HTy; else goto c8HTx;
       c8HTy: // global
           _s8G8h::P64 = P64[_s8G8L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTx: // global
           _s8G85::P64 = P64[_s8G8L::P64 + 16];
           _s8G86::P64 = P64[_s8G8L::P64 + 24];
           _s8G84::I64 = I64[_s8G8L::P64 + 40];
           _s8G87::I64 = I64[_s8G8L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8H::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G8L_info" {
     sat_s8G8L_info:
         const sat_s8G8L_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G8T_entry() //  [R1]
         { []
         }
     {offset
       c8HTV: // global
           _s8G8T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTW; else goto c8HTX;
       c8HTX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTZ; else goto c8HTY;
       c8HTZ: // global
           HpAlloc = 56;
           goto c8HTW;
       c8HTW: // global
           R1 = _s8G8T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8T::P64;
           _s8G89::I64 = I64[_s8G8T::P64 + 56];
           _s8G8P::I64 = I64[_s8G8T::P64 + 64];
           if (_s8G8P::I64 == _s8G89::I64) goto c8HTU; else goto c8HTT;
       c8HTU: // global
           _s8G8h::P64 = P64[_s8G8T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTT: // global
           _s8G85::P64 = P64[_s8G8T::P64 + 16];
           _s8G86::P64 = P64[_s8G8T::P64 + 24];
           _s8G84::I64 = I64[_s8G8T::P64 + 40];
           _s8G87::I64 = I64[_s8G8T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8P::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G8T_info" {
     sat_s8G8T_info:
         const sat_s8G8T_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G91_entry() //  [R1]
         { []
         }
     {offset
       c8HUh: // global
           _s8G91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HUi; else goto c8HUj;
       c8HUj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HUl; else goto c8HUk;
       c8HUl: // global
           HpAlloc = 56;
           goto c8HUi;
       c8HUi: // global
           R1 = _s8G91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G91::P64;
           _s8G89::I64 = I64[_s8G91::P64 + 56];
           _s8G8X::I64 = I64[_s8G91::P64 + 64];
           if (_s8G8X::I64 == _s8G89::I64) goto c8HUg; else goto c8HUf;
       c8HUg: // global
           _s8G8h::P64 = P64[_s8G91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUf: // global
           _s8G85::P64 = P64[_s8G91::P64 + 16];
           _s8G86::P64 = P64[_s8G91::P64 + 24];
           _s8G84::I64 = I64[_s8G91::P64 + 40];
           _s8G87::I64 = I64[_s8G91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8X::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G91_info" {
     sat_s8G91_info:
         const sat_s8G91_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G99_entry() //  [R1]
         { []
         }
     {offset
       c8HUD: // global
           _s8G99::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HUE; else goto c8HUF;
       c8HUF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HUH; else goto c8HUG;
       c8HUH: // global
           HpAlloc = 56;
           goto c8HUE;
       c8HUE: // global
           R1 = _s8G99::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HUG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G99::P64;
           _s8G89::I64 = I64[_s8G99::P64 + 56];
           _s8G95::I64 = I64[_s8G99::P64 + 64];
           if (_s8G95::I64 == _s8G89::I64) goto c8HUC; else goto c8HUB;
       c8HUC: // global
           _s8G8h::P64 = P64[_s8G99::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUB: // global
           _s8G85::P64 = P64[_s8G99::P64 + 16];
           _s8G86::P64 = P64[_s8G99::P64 + 24];
           _s8G84::I64 = I64[_s8G99::P64 + 40];
           _s8G87::I64 = I64[_s8G99::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G95::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G99_info" {
     sat_s8G99_info:
         const sat_s8G99_entry;
         const 17179869187;
         const 15;
 },
 sat_s8G9h_entry() //  [R1]
         { []
         }
     {offset
       c8HUZ: // global
           _s8G9h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HV0; else goto c8HV1;
       c8HV1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HV3; else goto c8HV2;
       c8HV3: // global
           HpAlloc = 56;
           goto c8HV0;
       c8HV0: // global
           R1 = _s8G9h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HV2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G9h::P64;
           _s8G89::I64 = I64[_s8G9h::P64 + 56];
           _s8G9d::I64 = I64[_s8G9h::P64 + 64];
           if (_s8G9d::I64 == _s8G89::I64) goto c8HUY; else goto c8HUX;
       c8HUY: // global
           _s8G8h::P64 = P64[_s8G9h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUX: // global
           _s8G85::P64 = P64[_s8G9h::P64 + 16];
           _s8G86::P64 = P64[_s8G9h::P64 + 24];
           _s8G84::I64 = I64[_s8G9h::P64 + 40];
           _s8G87::I64 = I64[_s8G9h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G9d::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8G9h_info" {
     sat_s8G9h_info:
         const sat_s8G9h_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HV6: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HV7; else goto c8HV8;
       c8HV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HV8: // global
           I64[Sp - 16] = block_c8HS5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HYS; else goto c8HS6;
       u8HYS: // global
           call _c8HS5(R1) args: 0, res: 0, upd: 0;
       c8HS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF3_info" {
     GHC.IO.Encoding.UTF16.mkUTF3_info:
         const GHC.IO.Encoding.UTF16.mkUTF3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8HS5() //  [R1]
         { []
         }
     {offset
       c8HS5: // global
           I64[Sp - 40] = block_c8HSa_info;
           _s8G85::P64 = P64[R1 + 7];
           _s8G86::P64 = P64[R1 + 15];
           _s8G84::I64 = I64[R1 + 23];
           _s8G87::I64 = I64[R1 + 31];
           _s8G88::I64 = I64[R1 + 39];
           _s8G89::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G86::P64;
           I64[Sp - 24] = _s8G87::I64;
           I64[Sp - 16] = _s8G88::I64;
           I64[Sp - 8] = _s8G89::I64;
           P64[Sp] = _s8G85::P64;
           I64[Sp + 8] = _s8G84::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HYJ; else goto c8HSb;
       u8HYJ: // global
           call _c8HSa(R1) args: 0, res: 0, upd: 0;
       c8HSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HS5_info" {
     block_c8HS5_info:
         const _c8HS5;
         const 1;
         const 30;
 },
 _c8HSa() //  [R1]
         { []
         }
     {offset
       c8HSa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HVc; else goto c8HVb;
       c8HVc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HVb: // global
           _s8G8c::P64 = P64[R1 + 7];
           _s8G8d::P64 = P64[R1 + 15];
           _s8G8b::I64 = I64[R1 + 23];
           _s8G8e::I64 = I64[R1 + 31];
           _s8G8f::I64 = I64[R1 + 39];
           _s8G8g::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G85::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G84::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G89::I64 = I64[Sp + 32];
           _c8HSf::P64 = Hp - 47;
           _s8G9m::I64 = _s8G8g::I64;
           _s8G9l::I64 = I64[Sp + 24];
           goto c8HVL;
       c8HVL: // global
           if (%MO_S_Lt_W64(_s8G9m::I64,
                            _s8G8e::I64)) goto c8HXG; else goto c8HXH;
       c8HXG: // global
           if (%MO_S_Lt_W64(_s8G9l::I64,
                            _s8G89::I64)) goto c8HXD; else goto c8HXE;
       c8HXD: // global
           if ((_s8G9l::I64 + 1) == _s8G89::I64) goto c8HXB; else goto c8HXA;
       c8HXB: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HU4() args: 0, res: 0, upd: 0;
       c8HXA: // global
           _s8G9v::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + _s8G9l::I64]);
           call MO_Touch(_s8G85::P64);
           _s8G9B::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 1)]);
           call MO_Touch(_s8G85::P64);
           _s8G9D::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9B::I64 << 8)) + _s8G9v::I64));
           if (_s8G9D::I64 >= 55296) goto c8HXx; else goto c8HXy;
       c8HXx: // global
           if (_s8G9D::I64 <= 57343) goto c8HXu; else goto c8HXv;
       c8HXu: // global
           if (%MO_S_Ge_W64(_s8G89::I64 - _s8G9l::I64,
                            4)) goto c8HXr; else goto c8HXs;
       c8HXr: // global
           _s8G9P::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 2)]);
           call MO_Touch(_s8G85::P64);
           _s8G9V::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 3)]);
           call MO_Touch(_s8G85::P64);
           if (_s8G9D::I64 < 55296) goto c8HWR; else goto c8HXp;
       c8HWR: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HSi() args: 0, res: 0, upd: 0;
       c8HXp: // global
           if (_s8G9D::I64 > 56319) goto c8HWX; else goto c8HXo;
       c8HWX: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HSE() args: 0, res: 0, upd: 0;
       c8HXo: // global
           _s8G9Z::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9V::I64 << 8)) + _s8G9P::I64));
           if (_s8G9Z::I64 < 56320) goto c8HXf; else goto c8HXn;
       c8HXf: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HT0() args: 0, res: 0, upd: 0;
       c8HXn: // global
           if (_s8G9Z::I64 > 57343) goto c8HXl; else goto c8HXm;
       c8HXl: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HTm() args: 0, res: 0, upd: 0;
       c8HXm: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8G9D::I64 + -55296) << 10) + (_s8G9Z::I64 + -56320) + 65536);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 4;
           goto c8HVL;
       c8HXs: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HTI() args: 0, res: 0, upd: 0;
       c8HXv: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8HVL;
       c8HXy: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8HVL;
       c8HXE: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HUq() args: 0, res: 0, upd: 0;
       c8HXH: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HUM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8HSa_info" {
     block_c8HSa_info:
         const _c8HSa;
         const 2950;
         const 30;
 },
 _c8HU4() //  []
         { []
         }
     {offset
       c8HU4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVA; else goto c8HVz;
       c8HVA: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HU4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVz: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G91_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HU4_info" {
     block_c8HU4_info:
         const _c8HU4;
         const 352013;
         const 30;
 },
 _c8HSi() //  []
         { []
         }
     {offset
       c8HSi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVg; else goto c8HVf;
       c8HVg: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HSi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HSi_info" {
     block_c8HSi_info:
         const _c8HSi;
         const 352013;
         const 30;
 },
 _c8HSE() //  []
         { []
         }
     {offset
       c8HSE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVk; else goto c8HVj;
       c8HVk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HSE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HSE_info" {
     block_c8HSE_info:
         const _c8HSE;
         const 352013;
         const 30;
 },
 _c8HT0() //  []
         { []
         }
     {offset
       c8HT0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVo; else goto c8HVn;
       c8HVo: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HT0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8D_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HT0_info" {
     block_c8HT0_info:
         const _c8HT0;
         const 352013;
         const 30;
 },
 _c8HTm() //  []
         { []
         }
     {offset
       c8HTm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVs; else goto c8HVr;
       c8HVs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HTm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8L_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HTm_info" {
     block_c8HTm_info:
         const _c8HTm;
         const 352013;
         const 30;
 },
 _c8HTI() //  []
         { []
         }
     {offset
       c8HTI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVw; else goto c8HVv;
       c8HVw: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HTI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVv: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HTI_info" {
     block_c8HTI_info:
         const _c8HTI;
         const 352013;
         const 30;
 },
 _c8HUq() //  []
         { []
         }
     {offset
       c8HUq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVE; else goto c8HVD;
       c8HVE: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HUq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVD: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G99_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HUq_info" {
     block_c8HUq_info:
         const _c8HUq;
         const 352013;
         const 30;
 },
 _c8HUM() //  []
         { []
         }
     {offset
       c8HUM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVI; else goto c8HVH;
       c8HVI: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HUM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G9h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HUM_info" {
     block_c8HUM_info:
         const _c8HUM;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.109621078 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8I2J: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le_decode_info" {
     GHC.IO.Encoding.UTF16.utf16le_decode_info:
         const GHC.IO.Encoding.UTF16.utf16le_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.112723999 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.115445521 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { []
         }
     {offset
       c8I2X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8I2Y; else goto c8I2Z;
       c8I2Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I2Z: // global
           (_c8I2U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8I2U::I64 == 0) goto c8I2W; else goto c8I2V;
       c8I2W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8I2V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8I2U::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le2_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.119504531 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { []
         }
     {offset
       c8I3b: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF2_info" {
     GHC.IO.Encoding.UTF16.mkUTF2_info:
         const GHC.IO.Encoding.UTF16.mkUTF2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.122957535 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { []
         }
     {offset
       c8I3n: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be1_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.128618524 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8GaC_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8I3J: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GaC_info" {
     sat_s8GaC_info:
         const sat_s8GaC_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt;
 },
 sat_s8GaE_entry() //  [R1]
         { []
         }
     {offset
       c8I3N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I3R; else goto c8I3Q;
       c8I3R: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8I3Q: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GaC_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GaE_info" {
     sat_s8GaE_info:
         const sat_s8GaE_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt;
 },
 sat_s8Gay_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8I42: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gay_info" {
     sat_s8Gay_info:
         const sat_s8Gay_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt+8;
 },
 sat_s8GaA_entry() //  [R1]
         { []
         }
     {offset
       c8I46: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I4a; else goto c8I49;
       c8I4a: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8I49: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Gay_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GaA_info" {
     sat_s8GaA_info:
         const sat_s8GaA_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { []
         }
     {offset
       c8I4c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I4g; else goto c8I4f;
       c8I4g: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8I4f: // global
           I64[Hp - 56] = sat_s8GaE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GaA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8GEr_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.141025307 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { []
         }
     {offset
       c8I4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8I4P; else goto c8I4Q;
       c8I4P: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I4Q: // global
           I64[Sp - 16] = block_c8I4I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I4Y; else goto c8I4J;
       u8I4Y: // global
           call _c8I4I() args: 0, res: 0, upd: 0;
       c8I4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8G1B_info" {
     lvl_r8G1B_info:
         const lvl_r8G1B_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8GEr_srt+32;
 },
 _c8I4I() //  []
         { []
         }
     {offset
       c8I4I: // global
           _s8GaG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8I4O_info;
           R1 = _s8GaG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8I4X; else goto c8I4S;
       u8I4X: // global
           call _c8I4O() args: 0, res: 0, upd: 0;
       c8I4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I4I_info" {
     block_c8I4I_info:
         const _c8I4I;
         const 1;
         const 4294967326;
         const S8GEr_srt+32;
 },
 _c8I4O() //  []
         { []
         }
     {offset
       c8I4O: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I4O_info" {
     block_c8I4O_info:
         const _c8I4O;
         const 0;
         const 4294967326;
         const S8GEr_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.147322258 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.149782218 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { []
         }
     {offset
       c8I5h: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le2_info" {
     GHC.IO.Encoding.UTF16.utf16le2_info:
         const GHC.IO.Encoding.UTF16.utf16le2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8GEr_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.154284985 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8I5w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8I5A; else goto c8I5B;
       c8I5A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I5B: // global
           I64[Sp - 16] = block_c8I5t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I5K; else goto c8I5u;
       u8I5K: // global
           call _c8I5t(R1) args: 0, res: 0, upd: 0;
       c8I5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be2_info" {
     GHC.IO.Encoding.UTF16.utf16be2_info:
         const GHC.IO.Encoding.UTF16.utf16be2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8GEr_srt+56;
 },
 _c8I5t() //  [R1]
         { []
         }
     {offset
       c8I5t: // global
           I64[Sp - 16] = block_c8I5z_info;
           _s8Gb2::P64 = P64[R1 + 7];
           _s8Gb1::I64 = I64[R1 + 23];
           _s8Gb5::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Gb5::I64;
           P64[Sp] = _s8Gb2::P64;
           I64[Sp + 8] = _s8Gb1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I5J; else goto c8I5D;
       u8I5J: // global
           call _c8I5z() args: 0, res: 0, upd: 0;
       c8I5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I5t_info" {
     block_c8I5t_info:
         const _c8I5t;
         const 1;
         const 4294967326;
         const S8GEr_srt+56;
 },
 _c8I5z() //  []
         { []
         }
     {offset
       c8I5z: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I5z_info" {
     block_c8I5z_info:
         const _c8I5z;
         const 323;
         const 4294967326;
         const S8GEr_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.160903395 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.163540851 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { []
         }
     {offset
       c8I63: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le1_info" {
     GHC.IO.Encoding.UTF16.utf16le1_info:
         const GHC.IO.Encoding.UTF16.utf16le1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8GEr_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.166889362 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.188265252 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8GbG_entry() //  [R1]
         { []
         }
     {offset
       c8I6G: // global
           _s8GbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I6H; else goto c8I6I;
       c8I6I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I6K; else goto c8I6J;
       c8I6K: // global
           HpAlloc = 56;
           goto c8I6H;
       c8I6H: // global
           R1 = _s8GbG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbG::P64;
           _s8Gbs::I64 = I64[_s8GbG::P64 + 56];
           _s8GbC::I64 = I64[_s8GbG::P64 + 64];
           if (_s8GbC::I64 == _s8Gbs::I64) goto c8I6F; else goto c8I6E;
       c8I6F: // global
           _s8GbA::P64 = P64[_s8GbG::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I6E: // global
           _s8Gbo::P64 = P64[_s8GbG::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbG::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbG::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbG::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbC::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8GbG_info" {
     sat_s8GbG_info:
         const sat_s8GbG_entry;
         const 17179869187;
         const 15;
 },
 sat_s8GbO_entry() //  [R1]
         { []
         }
     {offset
       c8I72: // global
           _s8GbO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I73; else goto c8I74;
       c8I74: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I76; else goto c8I75;
       c8I76: // global
           HpAlloc = 56;
           goto c8I73;
       c8I73: // global
           R1 = _s8GbO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbO::P64;
           _s8Gbs::I64 = I64[_s8GbO::P64 + 56];
           _s8GbK::I64 = I64[_s8GbO::P64 + 64];
           if (_s8GbK::I64 == _s8Gbs::I64) goto c8I71; else goto c8I70;
       c8I71: // global
           _s8GbA::P64 = P64[_s8GbO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I70: // global
           _s8Gbo::P64 = P64[_s8GbO::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbO::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbO::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbK::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8GbO_info" {
     sat_s8GbO_info:
         const sat_s8GbO_entry;
         const 17179869187;
         const 15;
 },
 sat_s8GbW_entry() //  [R1]
         { []
         }
     {offset
       c8I7o: // global
           _s8GbW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I7p; else goto c8I7q;
       c8I7q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I7s; else goto c8I7r;
       c8I7s: // global
           HpAlloc = 56;
           goto c8I7p;
       c8I7p: // global
           R1 = _s8GbW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbW::P64;
           _s8Gbs::I64 = I64[_s8GbW::P64 + 56];
           _s8GbS::I64 = I64[_s8GbW::P64 + 64];
           if (_s8GbS::I64 == _s8Gbs::I64) goto c8I7n; else goto c8I7m;
       c8I7n: // global
           _s8GbA::P64 = P64[_s8GbW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I7m: // global
           _s8Gbo::P64 = P64[_s8GbW::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbW::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbW::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbS::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8GbW_info" {
     sat_s8GbW_info:
         const sat_s8GbW_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Gc4_entry() //  [R1]
         { []
         }
     {offset
       c8I7K: // global
           _s8Gc4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I7L; else goto c8I7M;
       c8I7M: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I7O; else goto c8I7N;
       c8I7O: // global
           HpAlloc = 56;
           goto c8I7L;
       c8I7L: // global
           R1 = _s8Gc4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gc4::P64;
           _s8Gbs::I64 = I64[_s8Gc4::P64 + 56];
           _s8Gc0::I64 = I64[_s8Gc4::P64 + 64];
           if (_s8Gc0::I64 == _s8Gbs::I64) goto c8I7J; else goto c8I7I;
       c8I7J: // global
           _s8GbA::P64 = P64[_s8Gc4::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I7I: // global
           _s8Gbo::P64 = P64[_s8Gc4::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gc4::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gc4::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gc4::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc0::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Gc4_info" {
     sat_s8Gc4_info:
         const sat_s8Gc4_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Gcc_entry() //  [R1]
         { []
         }
     {offset
       c8I86: // global
           _s8Gcc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I87; else goto c8I88;
       c8I88: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8a; else goto c8I89;
       c8I8a: // global
           HpAlloc = 56;
           goto c8I87;
       c8I87: // global
           R1 = _s8Gcc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcc::P64;
           _s8Gbs::I64 = I64[_s8Gcc::P64 + 56];
           _s8Gc8::I64 = I64[_s8Gcc::P64 + 64];
           if (_s8Gc8::I64 == _s8Gbs::I64) goto c8I85; else goto c8I84;
       c8I85: // global
           _s8GbA::P64 = P64[_s8Gcc::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I84: // global
           _s8Gbo::P64 = P64[_s8Gcc::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcc::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcc::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcc::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc8::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Gcc_info" {
     sat_s8Gcc_info:
         const sat_s8Gcc_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Gck_entry() //  [R1]
         { []
         }
     {offset
       c8I8s: // global
           _s8Gck::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I8t; else goto c8I8u;
       c8I8u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8w; else goto c8I8v;
       c8I8w: // global
           HpAlloc = 56;
           goto c8I8t;
       c8I8t: // global
           R1 = _s8Gck::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I8v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gck::P64;
           _s8Gbs::I64 = I64[_s8Gck::P64 + 56];
           _s8Gcg::I64 = I64[_s8Gck::P64 + 64];
           if (_s8Gcg::I64 == _s8Gbs::I64) goto c8I8r; else goto c8I8q;
       c8I8r: // global
           _s8GbA::P64 = P64[_s8Gck::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I8q: // global
           _s8Gbo::P64 = P64[_s8Gck::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gck::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gck::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gck::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcg::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Gck_info" {
     sat_s8Gck_info:
         const sat_s8Gck_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Gcs_entry() //  [R1]
         { []
         }
     {offset
       c8I8O: // global
           _s8Gcs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I8P; else goto c8I8Q;
       c8I8Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8S; else goto c8I8R;
       c8I8S: // global
           HpAlloc = 56;
           goto c8I8P;
       c8I8P: // global
           R1 = _s8Gcs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I8R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcs::P64;
           _s8Gbs::I64 = I64[_s8Gcs::P64 + 56];
           _s8Gco::I64 = I64[_s8Gcs::P64 + 64];
           if (_s8Gco::I64 == _s8Gbs::I64) goto c8I8N; else goto c8I8M;
       c8I8N: // global
           _s8GbA::P64 = P64[_s8Gcs::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I8M: // global
           _s8Gbo::P64 = P64[_s8Gcs::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcs::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcs::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcs::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gco::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Gcs_info" {
     sat_s8Gcs_info:
         const sat_s8Gcs_entry;
         const 17179869187;
         const 15;
 },
 sat_s8GcA_entry() //  [R1]
         { []
         }
     {offset
       c8I9a: // global
           _s8GcA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I9b; else goto c8I9c;
       c8I9c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I9e; else goto c8I9d;
       c8I9e: // global
           HpAlloc = 56;
           goto c8I9b;
       c8I9b: // global
           R1 = _s8GcA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GcA::P64;
           _s8Gbs::I64 = I64[_s8GcA::P64 + 56];
           _s8Gcw::I64 = I64[_s8GcA::P64 + 64];
           if (_s8Gcw::I64 == _s8Gbs::I64) goto c8I99; else goto c8I98;
       c8I99: // global
           _s8GbA::P64 = P64[_s8GcA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I98: // global
           _s8Gbo::P64 = P64[_s8GcA::P64 + 16];
           _s8Gbp::P64 = P64[_s8GcA::P64 + 24];
           _s8Gbn::I64 = I64[_s8GcA::P64 + 40];
           _s8Gbq::I64 = I64[_s8GcA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcw::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8GcA_info" {
     sat_s8GcA_info:
         const sat_s8GcA_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8I9h: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8I9i; else goto c8I9j;
       c8I9i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I9j: // global
           I64[Sp - 16] = block_c8I6g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Id3; else goto c8I6h;
       u8Id3: // global
           call _c8I6g(R1) args: 0, res: 0, upd: 0;
       c8I6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF5_info" {
     GHC.IO.Encoding.UTF16.mkUTF5_info:
         const GHC.IO.Encoding.UTF16.mkUTF5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8I6g() //  [R1]
         { []
         }
     {offset
       c8I6g: // global
           I64[Sp - 40] = block_c8I6l_info;
           _s8Gbo::P64 = P64[R1 + 7];
           _s8Gbp::P64 = P64[R1 + 15];
           _s8Gbn::I64 = I64[R1 + 23];
           _s8Gbq::I64 = I64[R1 + 31];
           _s8Gbr::I64 = I64[R1 + 39];
           _s8Gbs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Gbp::P64;
           I64[Sp - 24] = _s8Gbq::I64;
           I64[Sp - 16] = _s8Gbr::I64;
           I64[Sp - 8] = _s8Gbs::I64;
           P64[Sp] = _s8Gbo::P64;
           I64[Sp + 8] = _s8Gbn::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IcU; else goto c8I6m;
       u8IcU: // global
           call _c8I6l(R1) args: 0, res: 0, upd: 0;
       c8I6m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I6g_info" {
     block_c8I6g_info:
         const _c8I6g;
         const 1;
         const 30;
 },
 _c8I6l() //  [R1]
         { []
         }
     {offset
       c8I6l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I9n; else goto c8I9m;
       c8I9n: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8I9m: // global
           _s8Gbv::P64 = P64[R1 + 7];
           _s8Gbw::P64 = P64[R1 + 15];
           _s8Gbu::I64 = I64[R1 + 23];
           _s8Gbx::I64 = I64[R1 + 31];
           _s8Gby::I64 = I64[R1 + 39];
           _s8Gbz::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Gbo::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Gbn::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Gbs::I64 = I64[Sp + 32];
           _c8I6q::P64 = Hp - 47;
           _s8GcF::I64 = _s8Gbz::I64;
           _s8GcE::I64 = I64[Sp + 24];
           goto c8I9W;
       c8I9W: // global
           if (%MO_S_Lt_W64(_s8GcF::I64,
                            _s8Gbx::I64)) goto c8IbR; else goto c8IbS;
       c8IbR: // global
           if (%MO_S_Lt_W64(_s8GcE::I64,
                            _s8Gbs::I64)) goto c8IbO; else goto c8IbP;
       c8IbO: // global
           if ((_s8GcE::I64 + 1) == _s8Gbs::I64) goto c8IbM; else goto c8IbL;
       c8IbM: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8f() args: 0, res: 0, upd: 0;
       c8IbL: // global
           _s8GcO::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + _s8GcE::I64]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcU::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 1)]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8GcO::I64 << 8)) + _s8GcU::I64));
           if (_s8GcW::I64 >= 55296) goto c8IbI; else goto c8IbJ;
       c8IbI: // global
           if (_s8GcW::I64 <= 57343) goto c8IbF; else goto c8IbG;
       c8IbF: // global
           if (%MO_S_Ge_W64(_s8Gbs::I64 - _s8GcE::I64,
                            4)) goto c8IbC; else goto c8IbD;
       c8IbC: // global
           _s8Gd8::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 2)]);
           call MO_Touch(_s8Gbo::P64);
           _s8Gde::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 3)]);
           call MO_Touch(_s8Gbo::P64);
           if (_s8GcW::I64 < 55296) goto c8Ib2; else goto c8IbA;
       c8Ib2: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I6t() args: 0, res: 0, upd: 0;
       c8IbA: // global
           if (_s8GcW::I64 > 56319) goto c8Ib8; else goto c8Ibz;
       c8Ib8: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I6P() args: 0, res: 0, upd: 0;
       c8Ibz: // global
           _s8Gdi::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Gd8::I64 << 8)) + _s8Gde::I64));
           if (_s8Gdi::I64 < 56320) goto c8Ibq; else goto c8Iby;
       c8Ibq: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7b() args: 0, res: 0, upd: 0;
       c8Iby: // global
           if (_s8Gdi::I64 > 57343) goto c8Ibw; else goto c8Ibx;
       c8Ibw: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7x() args: 0, res: 0, upd: 0;
       c8Ibx: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8GcW::I64 + -55296) << 10) + (_s8Gdi::I64 + -56320) + 65536);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 4;
           goto c8I9W;
       c8IbD: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7T() args: 0, res: 0, upd: 0;
       c8IbG: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8I9W;
       c8IbJ: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8I9W;
       c8IbP: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8B() args: 0, res: 0, upd: 0;
       c8IbS: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8X() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8I6l_info" {
     block_c8I6l_info:
         const _c8I6l;
         const 2950;
         const 30;
 },
 _c8I8f() //  []
         { []
         }
     {offset
       c8I8f: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9L; else goto c8I9K;
       c8I9L: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9K: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gck_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I8f_info" {
     block_c8I8f_info:
         const _c8I8f;
         const 352013;
         const 30;
 },
 _c8I6t() //  []
         { []
         }
     {offset
       c8I6t: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9r; else goto c8I9q;
       c8I9r: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I6t_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9q: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbG_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I6t_info" {
     block_c8I6t_info:
         const _c8I6t;
         const 352013;
         const 30;
 },
 _c8I6P() //  []
         { []
         }
     {offset
       c8I6P: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9v; else goto c8I9u;
       c8I9v: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I6P_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9u: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I6P_info" {
     block_c8I6P_info:
         const _c8I6P;
         const 352013;
         const 30;
 },
 _c8I7b() //  []
         { []
         }
     {offset
       c8I7b: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9z; else goto c8I9y;
       c8I9z: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7b_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9y: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I7b_info" {
     block_c8I7b_info:
         const _c8I7b;
         const 352013;
         const 30;
 },
 _c8I7x() //  []
         { []
         }
     {offset
       c8I7x: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9D; else goto c8I9C;
       c8I9D: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9C: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gc4_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I7x_info" {
     block_c8I7x_info:
         const _c8I7x;
         const 352013;
         const 30;
 },
 _c8I7T() //  []
         { []
         }
     {offset
       c8I7T: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9H; else goto c8I9G;
       c8I9H: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9G: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcc_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I7T_info" {
     block_c8I7T_info:
         const _c8I7T;
         const 352013;
         const 30;
 },
 _c8I8B() //  []
         { []
         }
     {offset
       c8I8B: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9P; else goto c8I9O;
       c8I9P: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9O: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcs_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I8B_info" {
     block_c8I8B_info:
         const _c8I8B;
         const 352013;
         const 30;
 },
 _c8I8X() //  []
         { []
         }
     {offset
       c8I8X: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9T; else goto c8I9S;
       c8I9T: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8X_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9S: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GcA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I8X_info" {
     block_c8I8X_info:
         const _c8I8X;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.235574118 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8IgU: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be_decode_info" {
     GHC.IO.Encoding.UTF16.utf16be_decode_info:
         const GHC.IO.Encoding.UTF16.utf16be_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.239025621 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.241459254 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { []
         }
     {offset
       c8Ih8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ih9; else goto c8Iha;
       c8Ih9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Iha: // global
           (_c8Ih5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ih5::I64 == 0) goto c8Ih7; else goto c8Ih6;
       c8Ih7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ih6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ih5::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be2_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.249070323 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8GdS_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Ihw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GdS_info" {
     sat_s8GdS_info:
         const sat_s8GdS_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt;
 },
 sat_s8GdU_entry() //  [R1]
         { []
         }
     {offset
       c8IhA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8IhE; else goto c8IhD;
       c8IhE: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8IhD: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdS_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GdU_info" {
     sat_s8GdU_info:
         const sat_s8GdU_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt;
 },
 sat_s8GdO_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8IhP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GdO_info" {
     sat_s8GdO_info:
         const sat_s8GdO_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt+8;
 },
 sat_s8GdQ_entry() //  [R1]
         { []
         }
     {offset
       c8IhT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8IhX; else goto c8IhW;
       c8IhX: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8IhW: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdO_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GdQ_info" {
     sat_s8GdQ_info:
         const sat_s8GdQ_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { []
         }
     {offset
       c8IhZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Ii3; else goto c8Ii2;
       c8Ii3: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ii2: // global
           I64[Hp - 56] = sat_s8GdU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GdQ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8GEr_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.259844221 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.262962904 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { []
         }
     {offset
       c8Iiw: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be3_info" {
     GHC.IO.Encoding.UTF16.utf16be3_info:
         const GHC.IO.Encoding.UTF16.utf16be3_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8GEr_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.266261526 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.268292964 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { []
         }
     {offset
       c8IiJ: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be1_info" {
     GHC.IO.Encoding.UTF16.utf16be1_info:
         const GHC.IO.Encoding.UTF16.utf16be1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8GEr_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.271442518 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.273945169 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.275760133 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.282012518 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { []
         }
     {offset
       c8IiV: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8Ij6: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Ij7; else goto c8Ij8;
       c8Ij7: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8Ij8: // global
           I64[Sp - 48] = block_c8IiZ_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8IkB; else goto c8Ij0;
       u8IkB: // global
           call _c8IiZ(R1) args: 0, res: 0, upd: 0;
       c8Ij0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.$wutf16_decode_info" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_info:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 7304;
         const GHC.IO.Encoding.UTF16.$wutf16_decode_slow;
 },
 _c8IiZ() //  [R1]
         { []
         }
     {offset
       c8IiZ: // global
           _s8GdY::I64 = I64[Sp + 16];
           _s8GdZ::P64 = P64[Sp + 24];
           _s8Ge0::P64 = P64[Sp + 32];
           _s8Ge1::I64 = I64[Sp + 40];
           _s8Ge2::I64 = I64[Sp + 48];
           _s8Ge3::I64 = I64[Sp + 56];
           _s8Ge4::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8Ij3; else goto c8Ij4;
       c8Ij3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Ijd; else goto c8Ijc;
       c8Ijd: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ijc: // global
           if (%MO_S_Ge_W64(_s8Ge3::I64 - _s8Ge2::I64,
                            2)) goto c8Iko; else goto c8Iks;
       c8Iko: // global
           _s8GdX::P64 = P64[Sp + 8];
           _s8Gef::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + _s8Ge2::I64]);
           call MO_Touch(_s8GdZ::P64);
           _s8Gel::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + (_s8Ge2::I64 + 1)]);
           call MO_Touch(_s8GdZ::P64);
           if (_s8Gef::I64 != 254) goto c8Ikb; else goto c8Ikm;
       c8Ikm: // global
           if (_s8Gel::I64 != 255) goto c8Ikb; else goto c8Ikl;
       c8Ikb: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8Gel::I64;
           I64[Sp] = _s8Gef::I64;
           Sp = Sp - 16;
           call _c8Ijy() args: 0, res: 0, upd: 0;
       c8Ikl: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64 + 2;
           I64[Hp - 32] = _s8Ge3::I64;
           _c8Ikk::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Ge4::P64;
           R2 = _c8Ikk::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Iks: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64;
           I64[Hp - 32] = _s8Ge3::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Ge4::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Ij4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Iky; else goto c8Ikx;
       c8Iky: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ikx: // global
           _s8GeE::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           R1 = _s8GeE::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IiZ_info" {
     block_c8IiZ_info:
         const _c8IiZ;
         const 7304;
         const 30;
 },
 _c8Ijy() //  []
         { []
         }
     {offset
       c8Ijy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IjC; else goto c8IjB;
       c8IjC: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Ijy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IjB: // global
           _s8GdX::P64 = P64[Sp + 24];
           _s8GdY::I64 = I64[Sp + 32];
           _s8GdZ::P64 = P64[Sp + 40];
           _s8Ge0::P64 = P64[Sp + 48];
           _s8Ge1::I64 = I64[Sp + 56];
           _s8Ge2::I64 = I64[Sp + 64];
           _s8Ge3::I64 = I64[Sp + 72];
           _s8Ge4::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8Ik3; else goto c8IjK;
       c8Ik3: // global
           if (I64[Sp + 8] == 254) goto c8Ik2; else goto c8IjT;
       c8Ik2: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64 + 2;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8IjT: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8IjK: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ijy_info" {
     block_c8Ijy_info:
         const _c8Ijy;
         const 29386;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.29535076 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8Ila: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ile; else goto c8Ilf;
       c8Ile: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ilf: // global
           I64[Sp - 24] = block_c8Il7_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Iln; else goto c8Il8;
       u8Iln: // global
           call _c8Il7(R1) args: 0, res: 0, upd: 0;
       c8Il8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_decode1_info" {
     GHC.IO.Encoding.UTF16.utf16_decode1_info:
         const GHC.IO.Encoding.UTF16.utf16_decode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8Il7() //  [R1]
         { []
         }
     {offset
       c8Il7: // global
           I64[Sp] = block_c8Ild_info;
           _s8GeL::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8GeL::P64;
           if (R1 & 7 != 0) goto u8Ilm; else goto c8Ilh;
       u8Ilm: // global
           call _c8Ild(R1) args: 0, res: 0, upd: 0;
       c8Ilh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Il7_info" {
     block_c8Il7_info:
         const _c8Il7;
         const 2;
         const 30;
 },
 _c8Ild() //  [R1]
         { []
         }
     {offset
       c8Ild: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ild_info" {
     block_c8Ild_info:
         const _c8Ild;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.304284628 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8IlH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_decode_info" {
     GHC.IO.Encoding.UTF16.utf16_decode_info:
         const GHC.IO.Encoding.UTF16.utf16_decode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.307502252 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.310021165 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { []
         }
     {offset
       c8IlV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8IlW; else goto c8IlX;
       c8IlW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IlX: // global
           (_c8IlS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8IlS::I64 == 0) goto c8IlU; else goto c8IlT;
       c8IlU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8IlT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8IlS::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF7_info" {
     GHC.IO.Encoding.UTF16.mkUTF7_info:
         const GHC.IO.Encoding.UTF16.mkUTF7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.319222619 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8GfD_entry() //  [R1, R2]
         { []
         }
     {offset
       c8Imo: // global
           _s8Gfl::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Gfl::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Gfl::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GfD_info" {
     sat_s8GfD_info:
         const sat_s8GfD_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8Gfz_entry() //  [R1]
         { []
         }
     {offset
       c8Imx: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gfz_info" {
     sat_s8Gfz_info:
         const sat_s8Gfz_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8Gfx_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8ImF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gfx_info" {
     sat_s8Gfx_info:
         const sat_s8Gfx_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt;
 },
 sat_s8Gfw_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8ImQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ImR; else goto c8ImS;
       c8ImR: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ImS: // global
           I64[Sp - 24] = block_c8ImN_info;
           _s8Gfl::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8Gfl::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8ImW; else goto c8ImO;
       u8ImW: // global
           call _c8ImN(R1) args: 0, res: 0, upd: 0;
       c8ImO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gfw_info" {
     sat_s8Gfw_info:
         const sat_s8Gfw_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8ImN() //  [R1]
         { []
         }
     {offset
       c8ImN: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8ImN_info" {
     block_c8ImN_info:
         const _c8ImN;
         const 2;
         const 30;
 },
 sat_s8GfF_entry() //  [R1]
         { []
         }
     {offset
       c8ImY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ImZ; else goto c8In0;
       c8ImZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8In0: // global
           I64[Sp - 16] = block_c8Ime_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8GfF_info" {
     sat_s8GfF_info:
         const sat_s8GfF_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt;
 },
 _c8Ime() //  [R1]
         { []
         }
     {offset
       c8Ime: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8In3; else goto c8In2;
       c8In3: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8In2: // global
           I64[Hp - 104] = sat_s8GfD_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfz_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gfx_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gfw_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ime_info" {
     block_c8Ime_info:
         const _c8Ime;
         const 1;
         const 4294967326;
         const S8GEr_srt;
 },
 sat_s8Gff_entry() //  [R1, R2]
         { []
         }
     {offset
       c8Inj: // global
           _s8GeX::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8GeX::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GeX::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gff_info" {
     sat_s8Gff_info:
         const sat_s8Gff_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8Gfb_entry() //  [R1]
         { []
         }
     {offset
       c8Ins: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gfb_info" {
     sat_s8Gfb_info:
         const sat_s8Gfb_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8Gf9_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8InA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gf9_info" {
     sat_s8Gf9_info:
         const sat_s8Gf9_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8GEr_srt+8;
 },
 sat_s8Gf8_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8InL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8InM; else goto c8InN;
       c8InM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8InN: // global
           I64[Sp - 24] = block_c8InI_info;
           _s8GeX::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8GeX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8InR; else goto c8InJ;
       u8InR: // global
           call _c8InI(R1) args: 0, res: 0, upd: 0;
       c8InJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gf8_info" {
     sat_s8Gf8_info:
         const sat_s8Gf8_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8InI() //  [R1]
         { []
         }
     {offset
       c8InI: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8InI_info" {
     block_c8InI_info:
         const _c8InI;
         const 2;
         const 30;
 },
 sat_s8Gfh_entry() //  [R1]
         { []
         }
     {offset
       c8InT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8InU; else goto c8InV;
       c8InU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8InV: // global
           I64[Sp - 16] = block_c8In9_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Gfh_info" {
     sat_s8Gfh_info:
         const sat_s8Gfh_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8GEr_srt+8;
 },
 _c8In9() //  [R1]
         { []
         }
     {offset
       c8In9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8InY; else goto c8InX;
       c8InY: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8InX: // global
           I64[Hp - 104] = sat_s8Gff_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfb_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gf9_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gf8_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8In9_info" {
     block_c8In9_info:
         const _c8In9;
         const 1;
         const 4294967326;
         const S8GEr_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { []
         }
     {offset
       c8Io0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Io4; else goto c8Io3;
       c8Io4: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Io3: // global
           I64[Hp - 56] = sat_s8GfF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Gfh_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16_info" {
     GHC.IO.Encoding.UTF16.mkUTF16_info:
         const GHC.IO.Encoding.UTF16.mkUTF16_entry;
         const 0;
         const 211119117434894;
         const 4294967301;
         const S8GEr_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.347454522 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { []
         }
     {offset
       c8Ipt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ipu; else goto c8Ipv;
       c8Ipu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ipv: // global
           (_c8Ipq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ipq::I64 == 0) goto c8Ips; else goto c8Ipr;
       c8Ips: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ipr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ipq::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_info" {
     GHC.IO.Encoding.UTF16.utf16_info:
         const GHC.IO.Encoding.UTF16.utf16_entry;
         const 0;
         const 4294967317;
         const S8GEr_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:49.351209325 UTC

[section ""relreadonly" . S8GEr_srt" {
     S8GEr_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.60069452 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:53.616220087 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8Iq1_entry() //  [R1]
         { []
         }
     {offset
       c8IE7: // global
           _s8Iq1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IE8; else goto c8IE9;
       c8IE9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IEb; else goto c8IEa;
       c8IEb: // global
           HpAlloc = 56;
           goto c8IE8;
       c8IE8: // global
           R1 = _s8Iq1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IEa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iq1::P64;
           _s8IpN::I64 = I64[_s8Iq1::P64 + 56];
           _s8IpX::I64 = I64[_s8Iq1::P64 + 64];
           if (_s8IpX::I64 == _s8IpN::I64) goto c8IE6; else goto c8IE5;
       c8IE6: // global
           _s8IpV::P64 = P64[_s8Iq1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IE5: // global
           _s8IpJ::P64 = P64[_s8Iq1::P64 + 16];
           _s8IpK::P64 = P64[_s8Iq1::P64 + 24];
           _s8IpI::I64 = I64[_s8Iq1::P64 + 40];
           _s8IpL::I64 = I64[_s8Iq1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8IpX::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iq1_info" {
     sat_s8Iq1_info:
         const sat_s8Iq1_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Iq9_entry() //  [R1]
         { []
         }
     {offset
       c8IEt: // global
           _s8Iq9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IEu; else goto c8IEv;
       c8IEv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IEx; else goto c8IEw;
       c8IEx: // global
           HpAlloc = 56;
           goto c8IEu;
       c8IEu: // global
           R1 = _s8Iq9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IEw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iq9::P64;
           _s8IpN::I64 = I64[_s8Iq9::P64 + 56];
           _s8Iq5::I64 = I64[_s8Iq9::P64 + 64];
           if (_s8Iq5::I64 == _s8IpN::I64) goto c8IEs; else goto c8IEr;
       c8IEs: // global
           _s8IpV::P64 = P64[_s8Iq9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IEr: // global
           _s8IpJ::P64 = P64[_s8Iq9::P64 + 16];
           _s8IpK::P64 = P64[_s8Iq9::P64 + 24];
           _s8IpI::I64 = I64[_s8Iq9::P64 + 40];
           _s8IpL::I64 = I64[_s8Iq9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iq5::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iq9_info" {
     sat_s8Iq9_info:
         const sat_s8Iq9_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Iqh_entry() //  [R1]
         { []
         }
     {offset
       c8IEP: // global
           _s8Iqh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IEQ; else goto c8IER;
       c8IER: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IET; else goto c8IES;
       c8IET: // global
           HpAlloc = 56;
           goto c8IEQ;
       c8IEQ: // global
           R1 = _s8Iqh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqh::P64;
           _s8IpN::I64 = I64[_s8Iqh::P64 + 56];
           _s8Iqd::I64 = I64[_s8Iqh::P64 + 64];
           if (_s8Iqd::I64 == _s8IpN::I64) goto c8IEO; else goto c8IEN;
       c8IEO: // global
           _s8IpV::P64 = P64[_s8Iqh::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IEN: // global
           _s8IpJ::P64 = P64[_s8Iqh::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqh::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqh::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqh::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iqd::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iqh_info" {
     sat_s8Iqh_info:
         const sat_s8Iqh_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Iqp_entry() //  [R1]
         { []
         }
     {offset
       c8IFb: // global
           _s8Iqp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFc; else goto c8IFd;
       c8IFd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFf; else goto c8IFe;
       c8IFf: // global
           HpAlloc = 56;
           goto c8IFc;
       c8IFc: // global
           R1 = _s8Iqp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqp::P64;
           _s8IpN::I64 = I64[_s8Iqp::P64 + 56];
           _s8Iql::I64 = I64[_s8Iqp::P64 + 64];
           if (_s8Iql::I64 == _s8IpN::I64) goto c8IFa; else goto c8IF9;
       c8IFa: // global
           _s8IpV::P64 = P64[_s8Iqp::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IF9: // global
           _s8IpJ::P64 = P64[_s8Iqp::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqp::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqp::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqp::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iql::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iqp_info" {
     sat_s8Iqp_info:
         const sat_s8Iqp_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Iqx_entry() //  [R1]
         { []
         }
     {offset
       c8IFx: // global
           _s8Iqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFy; else goto c8IFz;
       c8IFz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFB; else goto c8IFA;
       c8IFB: // global
           HpAlloc = 56;
           goto c8IFy;
       c8IFy: // global
           R1 = _s8Iqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqx::P64;
           _s8IpN::I64 = I64[_s8Iqx::P64 + 56];
           _s8Iqt::I64 = I64[_s8Iqx::P64 + 64];
           if (_s8Iqt::I64 == _s8IpN::I64) goto c8IFw; else goto c8IFv;
       c8IFw: // global
           _s8IpV::P64 = P64[_s8Iqx::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IFv: // global
           _s8IpJ::P64 = P64[_s8Iqx::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqx::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqx::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqx::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iqt::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iqx_info" {
     sat_s8Iqx_info:
         const sat_s8Iqx_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IqF_entry() //  [R1]
         { []
         }
     {offset
       c8IFT: // global
           _s8IqF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFU; else goto c8IFV;
       c8IFV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFX; else goto c8IFW;
       c8IFX: // global
           HpAlloc = 56;
           goto c8IFU;
       c8IFU: // global
           R1 = _s8IqF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IqF::P64;
           _s8IpN::I64 = I64[_s8IqF::P64 + 56];
           _s8IqB::I64 = I64[_s8IqF::P64 + 64];
           if (_s8IqB::I64 == _s8IpN::I64) goto c8IFS; else goto c8IFR;
       c8IFS: // global
           _s8IpV::P64 = P64[_s8IqF::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IFR: // global
           _s8IpJ::P64 = P64[_s8IqF::P64 + 16];
           _s8IpK::P64 = P64[_s8IqF::P64 + 24];
           _s8IpI::I64 = I64[_s8IqF::P64 + 40];
           _s8IpL::I64 = I64[_s8IqF::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8IqB::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IqF_info" {
     sat_s8IqF_info:
         const sat_s8IqF_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8IG0: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8IG1; else goto c8IG2;
       c8IG1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8IG2: // global
           I64[Sp - 16] = block_c8IDH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8IL8; else goto c8IDI;
       u8IL8: // global
           call _c8IDH(R1) args: 0, res: 0, upd: 0;
       c8IDI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF1_info" {
     GHC.IO.Encoding.UTF16.mkUTF1_info:
         const GHC.IO.Encoding.UTF16.mkUTF1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8IDH() //  [R1]
         { []
         }
     {offset
       c8IDH: // global
           I64[Sp - 40] = block_c8IDM_info;
           _s8IpJ::P64 = P64[R1 + 7];
           _s8IpK::P64 = P64[R1 + 15];
           _s8IpI::I64 = I64[R1 + 23];
           _s8IpL::I64 = I64[R1 + 31];
           _s8IpM::I64 = I64[R1 + 39];
           _s8IpN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8IpK::P64;
           I64[Sp - 24] = _s8IpL::I64;
           I64[Sp - 16] = _s8IpM::I64;
           I64[Sp - 8] = _s8IpN::I64;
           P64[Sp] = _s8IpJ::P64;
           I64[Sp + 8] = _s8IpI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IL1; else goto c8IDN;
       u8IL1: // global
           call _c8IDM(R1) args: 0, res: 0, upd: 0;
       c8IDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IDH_info" {
     block_c8IDH_info:
         const _c8IDH;
         const 1;
         const 30;
 },
 _c8IDM() //  [R1]
         { []
         }
     {offset
       c8IDM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IG6; else goto c8IG5;
       c8IG6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8IG5: // global
           _s8IpQ::P64 = P64[R1 + 7];
           _s8IpR::P64 = P64[R1 + 15];
           _s8IpP::I64 = I64[R1 + 23];
           _s8IpS::I64 = I64[R1 + 31];
           _s8IpT::I64 = I64[R1 + 39];
           _s8IpU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8IpJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8IpI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8IpN::I64 = I64[Sp + 32];
           _c8IDR::P64 = Hp - 47;
           _s8IqK::I64 = _s8IpU::I64;
           _s8IqJ::I64 = I64[Sp + 24];
           goto c8IGx;
       c8IGx: // global
           if (%MO_S_Lt_W64(_s8IqJ::I64,
                            _s8IpN::I64)) goto c8IHI; else goto c8IHJ;
       c8IHI: // global
           if (%MO_S_Ge_W64(_s8IpS::I64 - _s8IqK::I64,
                            2)) goto c8IHF; else goto c8IHG;
       c8IHF: // global
           _s8IqR::I64 = %MO_UU_Conv_W32_W64(I32[_s8IpI::I64 + (_s8IqJ::I64 << 2)]);
           call MO_Touch(_s8IpJ::P64);
           if (%MO_S_Ge_W64(_s8IqR::I64, 65536)) goto c8IH0; else goto c8IHD;
       c8IH0: // global
           if (%MO_S_Ge_W64(_s8IpS::I64 - _s8IqK::I64,
                            4)) goto c8IGX; else goto c8IGY;
       c8IGX: // global
           _s8IqX::I64 = _s8IqR::I64 - 65536;
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqX::I64,
                                                                            18) + 216);
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqX::I64,
                                                                                  10));
           call MO_Touch(_s8IpQ::P64);
           _s8Irc::I64 = _s8IqX::I64 & 1023;
           I8[_s8IpP::I64 + (_s8IqK::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8Irc::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8Irc::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 4;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IGY: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IDU() args: 0, res: 0, upd: 0;
       c8IHD: // global
           if (%MO_S_Gt_W64(55296, _s8IqR::I64)) goto c8IHi; else goto c8IHC;
       c8IHi: // global
           if (%MO_S_Gt_W64(56320, _s8IqR::I64)) goto c8IH8; else goto c8IHg;
       c8IH8: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHg: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 57343)) goto c8IHe; else goto c8IHf;
       c8IHe: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHf: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEg() args: 0, res: 0, upd: 0;
       c8IHC: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 56319)) goto c8IHA; else goto c8IHB;
       c8IHA: // global
           if (%MO_S_Gt_W64(56320, _s8IqR::I64)) goto c8IHq; else goto c8IHy;
       c8IHq: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHy: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 57343)) goto c8IHw; else goto c8IHx;
       c8IHw: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHx: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEC() args: 0, res: 0, upd: 0;
       c8IHB: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEY() args: 0, res: 0, upd: 0;
       c8IHG: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IFk() args: 0, res: 0, upd: 0;
       c8IHJ: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IFG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8IDM_info" {
     block_c8IDM_info:
         const _c8IDM;
         const 2950;
         const 30;
 },
 _c8IDU() //  []
         { []
         }
     {offset
       c8IDU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGa; else goto c8IG9;
       c8IGa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IDU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IG9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iq1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IDU_info" {
     block_c8IDU_info:
         const _c8IDU;
         const 352013;
         const 30;
 },
 _c8IEg() //  []
         { []
         }
     {offset
       c8IEg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGe; else goto c8IGd;
       c8IGe: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iq9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IEg_info" {
     block_c8IEg_info:
         const _c8IEg;
         const 352013;
         const 30;
 },
 _c8IEC() //  []
         { []
         }
     {offset
       c8IEC: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGi; else goto c8IGh;
       c8IGi: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGh: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqh_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IEC_info" {
     block_c8IEC_info:
         const _c8IEC;
         const 352013;
         const 30;
 },
 _c8IEY() //  []
         { []
         }
     {offset
       c8IEY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGm; else goto c8IGl;
       c8IGm: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGl: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqp_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IEY_info" {
     block_c8IEY_info:
         const _c8IEY;
         const 352013;
         const 30;
 },
 _c8IFk() //  []
         { []
         }
     {offset
       c8IFk: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGq; else goto c8IGp;
       c8IGq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IFk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqx_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IFk_info" {
     block_c8IFk_info:
         const _c8IFk;
         const 352013;
         const 30;
 },
 _c8IFG() //  []
         { []
         }
     {offset
       c8IFG: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGu; else goto c8IGt;
       c8IGu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IFG_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IqF_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IFG_info" {
     block_c8IFG_info:
         const _c8IFG;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.655643357 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8IPc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be_encode_info" {
     GHC.IO.Encoding.UTF16.utf16be_encode_info:
         const GHC.IO.Encoding.UTF16.utf16be_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.6730301 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8IsQ_entry() //  [R1]
         { []
         }
     {offset
       c8IPN: // global
           _s8IsQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IPO; else goto c8IPP;
       c8IPP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IPR; else goto c8IPQ;
       c8IPR: // global
           HpAlloc = 56;
           goto c8IPO;
       c8IPO: // global
           R1 = _s8IsQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IPQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IsQ::P64;
           _s8IsC::I64 = I64[_s8IsQ::P64 + 56];
           _s8IsM::I64 = I64[_s8IsQ::P64 + 64];
           if (_s8IsM::I64 == _s8IsC::I64) goto c8IPM; else goto c8IPL;
       c8IPM: // global
           _s8IsK::P64 = P64[_s8IsQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IPL: // global
           _s8Isy::P64 = P64[_s8IsQ::P64 + 16];
           _s8Isz::P64 = P64[_s8IsQ::P64 + 24];
           _s8Isx::I64 = I64[_s8IsQ::P64 + 40];
           _s8IsA::I64 = I64[_s8IsQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8IsM::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IsQ_info" {
     sat_s8IsQ_info:
         const sat_s8IsQ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IsY_entry() //  [R1]
         { []
         }
     {offset
       c8IQ9: // global
           _s8IsY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQa; else goto c8IQb;
       c8IQb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQd; else goto c8IQc;
       c8IQd: // global
           HpAlloc = 56;
           goto c8IQa;
       c8IQa: // global
           R1 = _s8IsY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IsY::P64;
           _s8IsC::I64 = I64[_s8IsY::P64 + 56];
           _s8IsU::I64 = I64[_s8IsY::P64 + 64];
           if (_s8IsU::I64 == _s8IsC::I64) goto c8IQ8; else goto c8IQ7;
       c8IQ8: // global
           _s8IsK::P64 = P64[_s8IsY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQ7: // global
           _s8Isy::P64 = P64[_s8IsY::P64 + 16];
           _s8Isz::P64 = P64[_s8IsY::P64 + 24];
           _s8Isx::I64 = I64[_s8IsY::P64 + 40];
           _s8IsA::I64 = I64[_s8IsY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8IsU::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IsY_info" {
     sat_s8IsY_info:
         const sat_s8IsY_entry;
         const 17179869187;
         const 15;
 },
 sat_s8It6_entry() //  [R1]
         { []
         }
     {offset
       c8IQv: // global
           _s8It6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQw; else goto c8IQx;
       c8IQx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQz; else goto c8IQy;
       c8IQz: // global
           HpAlloc = 56;
           goto c8IQw;
       c8IQw: // global
           R1 = _s8It6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8It6::P64;
           _s8IsC::I64 = I64[_s8It6::P64 + 56];
           _s8It2::I64 = I64[_s8It6::P64 + 64];
           if (_s8It2::I64 == _s8IsC::I64) goto c8IQu; else goto c8IQt;
       c8IQu: // global
           _s8IsK::P64 = P64[_s8It6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQt: // global
           _s8Isy::P64 = P64[_s8It6::P64 + 16];
           _s8Isz::P64 = P64[_s8It6::P64 + 24];
           _s8Isx::I64 = I64[_s8It6::P64 + 40];
           _s8IsA::I64 = I64[_s8It6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8It2::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8It6_info" {
     sat_s8It6_info:
         const sat_s8It6_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Ite_entry() //  [R1]
         { []
         }
     {offset
       c8IQR: // global
           _s8Ite::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQS; else goto c8IQT;
       c8IQT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQV; else goto c8IQU;
       c8IQV: // global
           HpAlloc = 56;
           goto c8IQS;
       c8IQS: // global
           R1 = _s8Ite::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ite::P64;
           _s8IsC::I64 = I64[_s8Ite::P64 + 56];
           _s8Ita::I64 = I64[_s8Ite::P64 + 64];
           if (_s8Ita::I64 == _s8IsC::I64) goto c8IQQ; else goto c8IQP;
       c8IQQ: // global
           _s8IsK::P64 = P64[_s8Ite::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQP: // global
           _s8Isy::P64 = P64[_s8Ite::P64 + 16];
           _s8Isz::P64 = P64[_s8Ite::P64 + 24];
           _s8Isx::I64 = I64[_s8Ite::P64 + 40];
           _s8IsA::I64 = I64[_s8Ite::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Ita::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Ite_info" {
     sat_s8Ite_info:
         const sat_s8Ite_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Itm_entry() //  [R1]
         { []
         }
     {offset
       c8IRd: // global
           _s8Itm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IRe; else goto c8IRf;
       c8IRf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRh; else goto c8IRg;
       c8IRh: // global
           HpAlloc = 56;
           goto c8IRe;
       c8IRe: // global
           R1 = _s8Itm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IRg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Itm::P64;
           _s8IsC::I64 = I64[_s8Itm::P64 + 56];
           _s8Iti::I64 = I64[_s8Itm::P64 + 64];
           if (_s8Iti::I64 == _s8IsC::I64) goto c8IRc; else goto c8IRb;
       c8IRc: // global
           _s8IsK::P64 = P64[_s8Itm::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IRb: // global
           _s8Isy::P64 = P64[_s8Itm::P64 + 16];
           _s8Isz::P64 = P64[_s8Itm::P64 + 24];
           _s8Isx::I64 = I64[_s8Itm::P64 + 40];
           _s8IsA::I64 = I64[_s8Itm::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Iti::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Itm_info" {
     sat_s8Itm_info:
         const sat_s8Itm_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Itu_entry() //  [R1]
         { []
         }
     {offset
       c8IRz: // global
           _s8Itu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IRA; else goto c8IRB;
       c8IRB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRD; else goto c8IRC;
       c8IRD: // global
           HpAlloc = 56;
           goto c8IRA;
       c8IRA: // global
           R1 = _s8Itu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IRC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Itu::P64;
           _s8IsC::I64 = I64[_s8Itu::P64 + 56];
           _s8Itq::I64 = I64[_s8Itu::P64 + 64];
           if (_s8Itq::I64 == _s8IsC::I64) goto c8IRy; else goto c8IRx;
       c8IRy: // global
           _s8IsK::P64 = P64[_s8Itu::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IRx: // global
           _s8Isy::P64 = P64[_s8Itu::P64 + 16];
           _s8Isz::P64 = P64[_s8Itu::P64 + 24];
           _s8Isx::I64 = I64[_s8Itu::P64 + 40];
           _s8IsA::I64 = I64[_s8Itu::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Itq::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Itu_info" {
     sat_s8Itu_info:
         const sat_s8Itu_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { []
         }
     {offset
       c8IRG: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8IRH; else goto c8IRI;
       c8IRH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8IRI: // global
           I64[Sp - 16] = block_c8IPn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8IWO; else goto c8IPo;
       u8IWO: // global
           call _c8IPn(R1) args: 0, res: 0, upd: 0;
       c8IPo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le1_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8IPn() //  [R1]
         { []
         }
     {offset
       c8IPn: // global
           I64[Sp - 40] = block_c8IPs_info;
           _s8Isy::P64 = P64[R1 + 7];
           _s8Isz::P64 = P64[R1 + 15];
           _s8Isx::I64 = I64[R1 + 23];
           _s8IsA::I64 = I64[R1 + 31];
           _s8IsB::I64 = I64[R1 + 39];
           _s8IsC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Isz::P64;
           I64[Sp - 24] = _s8IsA::I64;
           I64[Sp - 16] = _s8IsB::I64;
           I64[Sp - 8] = _s8IsC::I64;
           P64[Sp] = _s8Isy::P64;
           I64[Sp + 8] = _s8Isx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IWH; else goto c8IPt;
       u8IWH: // global
           call _c8IPs(R1) args: 0, res: 0, upd: 0;
       c8IPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IPn_info" {
     block_c8IPn_info:
         const _c8IPn;
         const 1;
         const 30;
 },
 _c8IPs() //  [R1]
         { []
         }
     {offset
       c8IPs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRM; else goto c8IRL;
       c8IRM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8IRL: // global
           _s8IsF::P64 = P64[R1 + 7];
           _s8IsG::P64 = P64[R1 + 15];
           _s8IsE::I64 = I64[R1 + 23];
           _s8IsH::I64 = I64[R1 + 31];
           _s8IsI::I64 = I64[R1 + 39];
           _s8IsJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Isy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Isx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8IsC::I64 = I64[Sp + 32];
           _c8IPx::P64 = Hp - 47;
           _s8Itz::I64 = _s8IsJ::I64;
           _s8Ity::I64 = I64[Sp + 24];
           goto c8ISd;
       c8ISd: // global
           if (%MO_S_Lt_W64(_s8Ity::I64,
                            _s8IsC::I64)) goto c8ITo; else goto c8ITp;
       c8ITo: // global
           if (%MO_S_Ge_W64(_s8IsH::I64 - _s8Itz::I64,
                            2)) goto c8ITl; else goto c8ITm;
       c8ITl: // global
           _s8ItG::I64 = %MO_UU_Conv_W32_W64(I32[_s8Isx::I64 + (_s8Ity::I64 << 2)]);
           call MO_Touch(_s8Isy::P64);
           if (%MO_S_Ge_W64(_s8ItG::I64, 65536)) goto c8ISG; else goto c8ITj;
       c8ISG: // global
           if (%MO_S_Ge_W64(_s8IsH::I64 - _s8Itz::I64,
                            4)) goto c8ISD; else goto c8ISE;
       c8ISD: // global
           _s8ItM::I64 = _s8ItG::I64 - 65536;
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItM::I64,
                                                                            10));
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItM::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8IsF::P64);
           _s8Iu1::I64 = _s8ItM::I64 & 1023;
           I8[_s8IsE::I64 + (_s8Itz::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8Iu1::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8Iu1::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 4;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISE: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IPA() args: 0, res: 0, upd: 0;
       c8ITj: // global
           if (%MO_S_Gt_W64(55296, _s8ItG::I64)) goto c8ISY; else goto c8ITi;
       c8ISY: // global
           if (%MO_S_Gt_W64(56320, _s8ItG::I64)) goto c8ISO; else goto c8ISW;
       c8ISO: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISW: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 57343)) goto c8ISU; else goto c8ISV;
       c8ISU: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISV: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IPW() args: 0, res: 0, upd: 0;
       c8ITi: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 56319)) goto c8ITg; else goto c8ITh;
       c8ITg: // global
           if (%MO_S_Gt_W64(56320, _s8ItG::I64)) goto c8IT6; else goto c8ITe;
       c8IT6: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ITe: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 57343)) goto c8ITc; else goto c8ITd;
       c8ITc: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ITd: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IQi() args: 0, res: 0, upd: 0;
       c8ITh: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IQE() args: 0, res: 0, upd: 0;
       c8ITm: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IR0() args: 0, res: 0, upd: 0;
       c8ITp: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IRm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8IPs_info" {
     block_c8IPs_info:
         const _c8IPs;
         const 2950;
         const 30;
 },
 _c8IPA() //  []
         { []
         }
     {offset
       c8IPA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRQ; else goto c8IRP;
       c8IRQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IPA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IsQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IPA_info" {
     block_c8IPA_info:
         const _c8IPA;
         const 352013;
         const 30;
 },
 _c8IPW() //  []
         { []
         }
     {offset
       c8IPW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRU; else goto c8IRT;
       c8IRU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IPW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IsY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IPW_info" {
     block_c8IPW_info:
         const _c8IPW;
         const 352013;
         const 30;
 },
 _c8IQi() //  []
         { []
         }
     {offset
       c8IQi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRY; else goto c8IRX;
       c8IRY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IQi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8It6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IQi_info" {
     block_c8IQi_info:
         const _c8IQi;
         const 352013;
         const 30;
 },
 _c8IQE() //  []
         { []
         }
     {offset
       c8IQE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IS2; else goto c8IS1;
       c8IS2: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IQE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ite_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IQE_info" {
     block_c8IQE_info:
         const _c8IQE;
         const 352013;
         const 30;
 },
 _c8IR0() //  []
         { []
         }
     {offset
       c8IR0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IS6; else goto c8IS5;
       c8IS6: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IR0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS5: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Itm_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IR0_info" {
     block_c8IR0_info:
         const _c8IR0;
         const 352013;
         const 30;
 },
 _c8IRm() //  []
         { []
         }
     {offset
       c8IRm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ISa; else goto c8IS9;
       c8ISa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IRm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Itu_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8IRm_info" {
     block_c8IRm_info:
         const _c8IRm;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.711323932 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8J0S: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le_encode_info" {
     GHC.IO.Encoding.UTF16.utf16le_encode_info:
         const GHC.IO.Encoding.UTF16.utf16le_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.714629839 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.716351116 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.718044404 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.719785515 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.721804087 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.726284331 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { []
         }
     {offset
       c8J15: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8J1g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8J1h; else goto c8J1i;
       c8J1h: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8J1i: // global
           I64[Sp - 48] = block_c8J19_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8J1Y; else goto c8J1a;
       u8J1Y: // global
           call _c8J19(R1) args: 0, res: 0, upd: 0;
       c8J1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.$wutf16_encode_info" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_info:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 14600;
         const GHC.IO.Encoding.UTF16.$wutf16_encode_slow;
 },
 _c8J19() //  [R1]
         { []
         }
     {offset
       c8J19: // global
           _s8Ivj::P64 = P64[Sp + 16];
           _s8Ivk::I64 = I64[Sp + 24];
           _s8Ivl::P64 = P64[Sp + 32];
           _s8Ivm::P64 = P64[Sp + 40];
           _s8Ivn::I64 = I64[Sp + 48];
           _s8Ivo::I64 = I64[Sp + 56];
           _s8Ivp::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8J1d; else goto c8J1e;
       c8J1d: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8J1n; else goto c8J1m;
       c8J1n: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J1m: // global
           if (%MO_S_Ge_W64(_s8Ivn::I64 - _s8Ivp::I64,
                            2)) goto c8J1N; else goto c8J1R;
       c8J1N: // global
           _s8Ivi::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8Ivi::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ivi::P64);
           I8[_s8Ivk::I64 + _s8Ivp::I64] = 254 :: W8;
           call MO_Touch(_s8Ivl::P64);
           I8[_s8Ivk::I64 + (_s8Ivp::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8Ivl::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ivl::P64;
           P64[Hp - 64] = _s8Ivm::P64;
           I64[Hp - 56] = _s8Ivk::I64;
           I64[Hp - 48] = _s8Ivn::I64;
           I64[Hp - 40] = _s8Ivo::I64;
           I64[Hp - 32] = _s8Ivp::I64 + 2;
           _c8J1L::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8J1L::P64;
           R2 = _s8Ivj::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8J1R: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ivl::P64;
           P64[Hp - 64] = _s8Ivm::P64;
           I64[Hp - 56] = _s8Ivk::I64;
           I64[Hp - 48] = _s8Ivn::I64;
           I64[Hp - 40] = _s8Ivo::I64;
           I64[Hp - 32] = _s8Ivp::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8Ivj::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8J1e: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J1X; else goto c8J1W;
       c8J1X: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J1W: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Ivl::P64;
           P64[Hp - 32] = _s8Ivm::P64;
           I64[Hp - 24] = _s8Ivk::I64;
           I64[Hp - 16] = _s8Ivn::I64;
           I64[Hp - 8] = _s8Ivo::I64;
           I64[Hp] = _s8Ivp::I64;
           R3 = Hp - 47;
           R2 = _s8Ivj::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J19_info" {
     block_c8J19_info:
         const _c8J19;
         const 14600;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.736440855 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8J2z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8J2D; else goto c8J2E;
       c8J2D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8J2E: // global
           I64[Sp - 24] = block_c8J2w_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8J2M; else goto c8J2x;
       u8J2M: // global
           call _c8J2w(R1) args: 0, res: 0, upd: 0;
       c8J2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_encode1_info" {
     GHC.IO.Encoding.UTF16.utf16_encode1_info:
         const GHC.IO.Encoding.UTF16.utf16_encode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8J2w() //  [R1]
         { []
         }
     {offset
       c8J2w: // global
           I64[Sp] = block_c8J2C_info;
           _s8IvP::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8IvP::P64;
           if (R1 & 7 != 0) goto u8J2L; else goto c8J2G;
       u8J2L: // global
           call _c8J2C(R1) args: 0, res: 0, upd: 0;
       c8J2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J2w_info" {
     block_c8J2w_info:
         const _c8J2w;
         const 2;
         const 30;
 },
 _c8J2C() //  [R1]
         { []
         }
     {offset
       c8J2C: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J2C_info" {
     block_c8J2C_info:
         const _c8J2C;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.743742143 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8J39: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_encode_info" {
     GHC.IO.Encoding.UTF16.utf16_encode_info:
         const GHC.IO.Encoding.UTF16.utf16_encode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.764121993 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8Iwk_entry() //  [R1]
         { []
         }
     {offset
       c8J3K: // global
           _s8Iwk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J3L; else goto c8J3M;
       c8J3M: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J3O; else goto c8J3N;
       c8J3O: // global
           HpAlloc = 56;
           goto c8J3L;
       c8J3L: // global
           R1 = _s8Iwk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iwk::P64;
           _s8Iw6::I64 = I64[_s8Iwk::P64 + 56];
           _s8Iwg::I64 = I64[_s8Iwk::P64 + 64];
           if (_s8Iwg::I64 == _s8Iw6::I64) goto c8J3J; else goto c8J3I;
       c8J3J: // global
           _s8Iwe::P64 = P64[_s8Iwk::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J3I: // global
           _s8Iw2::P64 = P64[_s8Iwk::P64 + 16];
           _s8Iw3::P64 = P64[_s8Iwk::P64 + 24];
           _s8Iw1::I64 = I64[_s8Iwk::P64 + 40];
           _s8Iw4::I64 = I64[_s8Iwk::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iwg::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iwk_info" {
     sat_s8Iwk_info:
         const sat_s8Iwk_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Iws_entry() //  [R1]
         { []
         }
     {offset
       c8J46: // global
           _s8Iws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J47; else goto c8J48;
       c8J48: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4a; else goto c8J49;
       c8J4a: // global
           HpAlloc = 56;
           goto c8J47;
       c8J47: // global
           R1 = _s8Iws::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J49: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iws::P64;
           _s8Iw6::I64 = I64[_s8Iws::P64 + 56];
           _s8Iwo::I64 = I64[_s8Iws::P64 + 64];
           if (_s8Iwo::I64 == _s8Iw6::I64) goto c8J45; else goto c8J44;
       c8J45: // global
           _s8Iwe::P64 = P64[_s8Iws::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J44: // global
           _s8Iw2::P64 = P64[_s8Iws::P64 + 16];
           _s8Iw3::P64 = P64[_s8Iws::P64 + 24];
           _s8Iw1::I64 = I64[_s8Iws::P64 + 40];
           _s8Iw4::I64 = I64[_s8Iws::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iwo::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Iws_info" {
     sat_s8Iws_info:
         const sat_s8Iws_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IwA_entry() //  [R1]
         { []
         }
     {offset
       c8J4s: // global
           _s8IwA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J4t; else goto c8J4u;
       c8J4u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4w; else goto c8J4v;
       c8J4w: // global
           HpAlloc = 56;
           goto c8J4t;
       c8J4t: // global
           R1 = _s8IwA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwA::P64;
           _s8Iw6::I64 = I64[_s8IwA::P64 + 56];
           _s8Iww::I64 = I64[_s8IwA::P64 + 64];
           if (_s8Iww::I64 == _s8Iw6::I64) goto c8J4r; else goto c8J4q;
       c8J4r: // global
           _s8Iwe::P64 = P64[_s8IwA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J4q: // global
           _s8Iw2::P64 = P64[_s8IwA::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwA::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwA::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iww::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IwA_info" {
     sat_s8IwA_info:
         const sat_s8IwA_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IwI_entry() //  [R1]
         { []
         }
     {offset
       c8J4O: // global
           _s8IwI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J4P; else goto c8J4Q;
       c8J4Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4S; else goto c8J4R;
       c8J4S: // global
           HpAlloc = 56;
           goto c8J4P;
       c8J4P: // global
           R1 = _s8IwI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J4R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwI::P64;
           _s8Iw6::I64 = I64[_s8IwI::P64 + 56];
           _s8IwE::I64 = I64[_s8IwI::P64 + 64];
           if (_s8IwE::I64 == _s8Iw6::I64) goto c8J4N; else goto c8J4M;
       c8J4N: // global
           _s8Iwe::P64 = P64[_s8IwI::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J4M: // global
           _s8Iw2::P64 = P64[_s8IwI::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwI::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwI::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwI::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwE::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IwI_info" {
     sat_s8IwI_info:
         const sat_s8IwI_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IwQ_entry() //  [R1]
         { []
         }
     {offset
       c8J5a: // global
           _s8IwQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5b; else goto c8J5c;
       c8J5c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5e; else goto c8J5d;
       c8J5e: // global
           HpAlloc = 56;
           goto c8J5b;
       c8J5b: // global
           R1 = _s8IwQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwQ::P64;
           _s8Iw6::I64 = I64[_s8IwQ::P64 + 56];
           _s8IwM::I64 = I64[_s8IwQ::P64 + 64];
           if (_s8IwM::I64 == _s8Iw6::I64) goto c8J59; else goto c8J58;
       c8J59: // global
           _s8Iwe::P64 = P64[_s8IwQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J58: // global
           _s8Iw2::P64 = P64[_s8IwQ::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwQ::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwQ::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwM::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IwQ_info" {
     sat_s8IwQ_info:
         const sat_s8IwQ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IwY_entry() //  [R1]
         { []
         }
     {offset
       c8J5w: // global
           _s8IwY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5x; else goto c8J5y;
       c8J5y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5A; else goto c8J5z;
       c8J5A: // global
           HpAlloc = 56;
           goto c8J5x;
       c8J5x: // global
           R1 = _s8IwY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwY::P64;
           _s8Iw6::I64 = I64[_s8IwY::P64 + 56];
           _s8IwU::I64 = I64[_s8IwY::P64 + 64];
           if (_s8IwU::I64 == _s8Iw6::I64) goto c8J5v; else goto c8J5u;
       c8J5v: // global
           _s8Iwe::P64 = P64[_s8IwY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J5u: // global
           _s8Iw2::P64 = P64[_s8IwY::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwY::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwY::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwU::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IwY_info" {
     sat_s8IwY_info:
         const sat_s8IwY_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Ix6_entry() //  [R1]
         { []
         }
     {offset
       c8J5S: // global
           _s8Ix6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5T; else goto c8J5U;
       c8J5U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5W; else goto c8J5V;
       c8J5W: // global
           HpAlloc = 56;
           goto c8J5T;
       c8J5T: // global
           R1 = _s8Ix6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ix6::P64;
           _s8Iw6::I64 = I64[_s8Ix6::P64 + 56];
           _s8Ix2::I64 = I64[_s8Ix6::P64 + 64];
           if (_s8Ix2::I64 == _s8Iw6::I64) goto c8J5R; else goto c8J5Q;
       c8J5R: // global
           _s8Iwe::P64 = P64[_s8Ix6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J5Q: // global
           _s8Iw2::P64 = P64[_s8Ix6::P64 + 16];
           _s8Iw3::P64 = P64[_s8Ix6::P64 + 24];
           _s8Iw1::I64 = I64[_s8Ix6::P64 + 40];
           _s8Iw4::I64 = I64[_s8Ix6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Ix2::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Ix6_info" {
     sat_s8Ix6_info:
         const sat_s8Ix6_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Ixe_entry() //  [R1]
         { []
         }
     {offset
       c8J6e: // global
           _s8Ixe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J6f; else goto c8J6g;
       c8J6g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J6i; else goto c8J6h;
       c8J6i: // global
           HpAlloc = 56;
           goto c8J6f;
       c8J6f: // global
           R1 = _s8Ixe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J6h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ixe::P64;
           _s8Iw6::I64 = I64[_s8Ixe::P64 + 56];
           _s8Ixa::I64 = I64[_s8Ixe::P64 + 64];
           if (_s8Ixa::I64 == _s8Iw6::I64) goto c8J6d; else goto c8J6c;
       c8J6d: // global
           _s8Iwe::P64 = P64[_s8Ixe::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J6c: // global
           _s8Iw2::P64 = P64[_s8Ixe::P64 + 16];
           _s8Iw3::P64 = P64[_s8Ixe::P64 + 24];
           _s8Iw1::I64 = I64[_s8Ixe::P64 + 40];
           _s8Iw4::I64 = I64[_s8Ixe::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Ixa::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Ixe_info" {
     sat_s8Ixe_info:
         const sat_s8Ixe_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8J6l: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8J6m; else goto c8J6n;
       c8J6m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8J6n: // global
           I64[Sp - 16] = block_c8J3k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ja7; else goto c8J3l;
       u8Ja7: // global
           call _c8J3k(R1) args: 0, res: 0, upd: 0;
       c8J3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF3_info" {
     GHC.IO.Encoding.UTF16.mkUTF3_info:
         const GHC.IO.Encoding.UTF16.mkUTF3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8J3k() //  [R1]
         { []
         }
     {offset
       c8J3k: // global
           I64[Sp - 40] = block_c8J3p_info;
           _s8Iw2::P64 = P64[R1 + 7];
           _s8Iw3::P64 = P64[R1 + 15];
           _s8Iw1::I64 = I64[R1 + 23];
           _s8Iw4::I64 = I64[R1 + 31];
           _s8Iw5::I64 = I64[R1 + 39];
           _s8Iw6::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Iw3::P64;
           I64[Sp - 24] = _s8Iw4::I64;
           I64[Sp - 16] = _s8Iw5::I64;
           I64[Sp - 8] = _s8Iw6::I64;
           P64[Sp] = _s8Iw2::P64;
           I64[Sp + 8] = _s8Iw1::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8J9Y; else goto c8J3q;
       u8J9Y: // global
           call _c8J3p(R1) args: 0, res: 0, upd: 0;
       c8J3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J3k_info" {
     block_c8J3k_info:
         const _c8J3k;
         const 1;
         const 30;
 },
 _c8J3p() //  [R1]
         { []
         }
     {offset
       c8J3p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J6r; else goto c8J6q;
       c8J6r: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J6q: // global
           _s8Iw9::P64 = P64[R1 + 7];
           _s8Iwa::P64 = P64[R1 + 15];
           _s8Iw8::I64 = I64[R1 + 23];
           _s8Iwb::I64 = I64[R1 + 31];
           _s8Iwc::I64 = I64[R1 + 39];
           _s8Iwd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Iw2::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Iw1::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Iw6::I64 = I64[Sp + 32];
           _c8J3u::P64 = Hp - 47;
           _s8Ixj::I64 = _s8Iwd::I64;
           _s8Ixi::I64 = I64[Sp + 24];
           goto c8J70;
       c8J70: // global
           if (%MO_S_Lt_W64(_s8Ixj::I64,
                            _s8Iwb::I64)) goto c8J8V; else goto c8J8W;
       c8J8V: // global
           if (%MO_S_Lt_W64(_s8Ixi::I64,
                            _s8Iw6::I64)) goto c8J8S; else goto c8J8T;
       c8J8S: // global
           if ((_s8Ixi::I64 + 1) == _s8Iw6::I64) goto c8J8Q; else goto c8J8P;
       c8J8Q: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J5j() args: 0, res: 0, upd: 0;
       c8J8P: // global
           _s8Ixs::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + _s8Ixi::I64]);
           call MO_Touch(_s8Iw2::P64);
           _s8Ixy::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 1)]);
           call MO_Touch(_s8Iw2::P64);
           _s8IxA::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Ixy::I64 << 8)) + _s8Ixs::I64));
           if (_s8IxA::I64 >= 55296) goto c8J8M; else goto c8J8N;
       c8J8M: // global
           if (_s8IxA::I64 <= 57343) goto c8J8J; else goto c8J8K;
       c8J8J: // global
           if (%MO_S_Ge_W64(_s8Iw6::I64 - _s8Ixi::I64,
                            4)) goto c8J8G; else goto c8J8H;
       c8J8G: // global
           _s8IxM::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 2)]);
           call MO_Touch(_s8Iw2::P64);
           _s8IxS::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 3)]);
           call MO_Touch(_s8Iw2::P64);
           if (_s8IxA::I64 < 55296) goto c8J86; else goto c8J8E;
       c8J86: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J3x() args: 0, res: 0, upd: 0;
       c8J8E: // global
           if (_s8IxA::I64 > 56319) goto c8J8c; else goto c8J8D;
       c8J8c: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J3T() args: 0, res: 0, upd: 0;
       c8J8D: // global
           _s8IxW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IxS::I64 << 8)) + _s8IxM::I64));
           if (_s8IxW::I64 < 56320) goto c8J8u; else goto c8J8C;
       c8J8u: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4f() args: 0, res: 0, upd: 0;
       c8J8C: // global
           if (_s8IxW::I64 > 57343) goto c8J8A; else goto c8J8B;
       c8J8A: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4B() args: 0, res: 0, upd: 0;
       c8J8B: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8IxA::I64 + -55296) << 10) + (_s8IxW::I64 + -56320) + 65536);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 4;
           goto c8J70;
       c8J8H: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4X() args: 0, res: 0, upd: 0;
       c8J8K: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IxA::I64);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 2;
           goto c8J70;
       c8J8N: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IxA::I64);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 2;
           goto c8J70;
       c8J8T: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J5F() args: 0, res: 0, upd: 0;
       c8J8W: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J61() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8J3p_info" {
     block_c8J3p_info:
         const _c8J3p;
         const 2950;
         const 30;
 },
 _c8J5j() //  []
         { []
         }
     {offset
       c8J5j: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6P; else goto c8J6O;
       c8J6P: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J5j_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6O: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J5j_info" {
     block_c8J5j_info:
         const _c8J5j;
         const 352013;
         const 30;
 },
 _c8J3x() //  []
         { []
         }
     {offset
       c8J3x: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6v; else goto c8J6u;
       c8J6v: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J3x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6u: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iwk_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J3x_info" {
     block_c8J3x_info:
         const _c8J3x;
         const 352013;
         const 30;
 },
 _c8J3T() //  []
         { []
         }
     {offset
       c8J3T: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6z; else goto c8J6y;
       c8J6z: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J3T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6y: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iws_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J3T_info" {
     block_c8J3T_info:
         const _c8J3T;
         const 352013;
         const 30;
 },
 _c8J4f() //  []
         { []
         }
     {offset
       c8J4f: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6D; else goto c8J6C;
       c8J6D: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6C: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J4f_info" {
     block_c8J4f_info:
         const _c8J4f;
         const 352013;
         const 30;
 },
 _c8J4B() //  []
         { []
         }
     {offset
       c8J4B: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6H; else goto c8J6G;
       c8J6H: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6G: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwI_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J4B_info" {
     block_c8J4B_info:
         const _c8J4B;
         const 352013;
         const 30;
 },
 _c8J4X() //  []
         { []
         }
     {offset
       c8J4X: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6L; else goto c8J6K;
       c8J6L: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4X_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6K: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J4X_info" {
     block_c8J4X_info:
         const _c8J4X;
         const 352013;
         const 30;
 },
 _c8J5F() //  []
         { []
         }
     {offset
       c8J5F: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6T; else goto c8J6S;
       c8J6T: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J5F_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6S: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ix6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J5F_info" {
     block_c8J5F_info:
         const _c8J5F;
         const 352013;
         const 30;
 },
 _c8J61() //  []
         { []
         }
     {offset
       c8J61: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6X; else goto c8J6W;
       c8J6X: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J61_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6W: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ixe_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J61_info" {
     block_c8J61_info:
         const _c8J61;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.813301447 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Jf3: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le_decode_info" {
     GHC.IO.Encoding.UTF16.utf16le_decode_info:
         const GHC.IO.Encoding.UTF16.utf16le_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.81629299 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.818618291 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { []
         }
     {offset
       c8Jfh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jfi; else goto c8Jfj;
       c8Jfi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jfj: // global
           (_c8Jfe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Jfe::I64 == 0) goto c8Jfg; else goto c8Jff;
       c8Jfg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Jff: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Jfe::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le2_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.823245454 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { []
         }
     {offset
       c8Jfw: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF2_info" {
     GHC.IO.Encoding.UTF16.mkUTF2_info:
         const GHC.IO.Encoding.UTF16.mkUTF2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.826664093 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { []
         }
     {offset
       c8JfJ: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be1_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.832248729 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8Iyz_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Jg6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Iyz_info" {
     sat_s8Iyz_info:
         const sat_s8Iyz_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt;
 },
 sat_s8IyB_entry() //  [R1]
         { []
         }
     {offset
       c8Jga: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jge; else goto c8Jgd;
       c8Jge: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jgd: // global
           _s8Iyt::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Iyz_info;
           P64[Hp - 48] = _s8Iyt::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IyB_info" {
     sat_s8IyB_info:
         const sat_s8IyB_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt;
 },
 sat_s8Iyv_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Jgp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Iyv_info" {
     sat_s8Iyv_info:
         const sat_s8Iyv_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt+8;
 },
 sat_s8Iyx_entry() //  [R1]
         { []
         }
     {offset
       c8Jgt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jgx; else goto c8Jgw;
       c8Jgx: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jgw: // global
           _s8Iyt::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Iyv_info;
           P64[Hp - 48] = _s8Iyt::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Iyx_info" {
     sat_s8Iyx_info:
         const sat_s8Iyx_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { []
         }
     {offset
       c8Jgz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JgD; else goto c8JgC;
       c8JgD: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JgC: // global
           I64[Hp - 56] = sat_s8IyB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Iyx_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16le_info" {
     GHC.IO.Encoding.UTF16.mkUTF16le_info:
         const GHC.IO.Encoding.UTF16.mkUTF16le_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8JgE_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.844175242 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Jhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jht; else goto c8Jhu;
       c8Jht: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jhu: // global
           I64[Sp - 16] = block_c8Jhm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8JhC; else goto c8Jhn;
       u8JhC: // global
           call _c8Jhm() args: 0, res: 0, upd: 0;
       c8Jhn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8G1B_info" {
     lvl_r8G1B_info:
         const lvl_r8G1B_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8JgE_srt+32;
 },
 _c8Jhm() //  []
         { []
         }
     {offset
       c8Jhm: // global
           _s8IyD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Jhs_info;
           R1 = _s8IyD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8JhB; else goto c8Jhw;
       u8JhB: // global
           call _c8Jhs() args: 0, res: 0, upd: 0;
       c8Jhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jhm_info" {
     block_c8Jhm_info:
         const _c8Jhm;
         const 1;
         const 4294967326;
         const S8JgE_srt+32;
 },
 _c8Jhs() //  []
         { []
         }
     {offset
       c8Jhs: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jhs_info" {
     block_c8Jhs_info:
         const _c8Jhs;
         const 0;
         const 4294967326;
         const S8JgE_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.850496533 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.852596744 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { []
         }
     {offset
       c8JhX: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le2_info" {
     GHC.IO.Encoding.UTF16.utf16le2_info:
         const GHC.IO.Encoding.UTF16.utf16le2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8JgE_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.856998321 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Jic: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Jig; else goto c8Jih;
       c8Jig: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jih: // global
           I64[Sp - 16] = block_c8Ji9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Jiq; else goto c8Jia;
       u8Jiq: // global
           call _c8Ji9(R1) args: 0, res: 0, upd: 0;
       c8Jia: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be2_info" {
     GHC.IO.Encoding.UTF16.utf16be2_info:
         const GHC.IO.Encoding.UTF16.utf16be2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8JgE_srt+56;
 },
 _c8Ji9() //  [R1]
         { []
         }
     {offset
       c8Ji9: // global
           I64[Sp - 16] = block_c8Jif_info;
           _s8IyZ::P64 = P64[R1 + 7];
           _s8IyY::I64 = I64[R1 + 23];
           _s8Iz2::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Iz2::I64;
           P64[Sp] = _s8IyZ::P64;
           I64[Sp + 8] = _s8IyY::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Jip; else goto c8Jij;
       u8Jip: // global
           call _c8Jif() args: 0, res: 0, upd: 0;
       c8Jij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ji9_info" {
     block_c8Ji9_info:
         const _c8Ji9;
         const 1;
         const 4294967326;
         const S8JgE_srt+56;
 },
 _c8Jif() //  []
         { []
         }
     {offset
       c8Jif: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jif_info" {
     block_c8Jif_info:
         const _c8Jif;
         const 323;
         const 4294967326;
         const S8JgE_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.863967259 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.866087871 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { []
         }
     {offset
       c8JiL: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16le1_info" {
     GHC.IO.Encoding.UTF16.utf16le1_info:
         const GHC.IO.Encoding.UTF16.utf16le1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8JgE_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.869330165 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.88808511 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8IzD_entry() //  [R1]
         { []
         }
     {offset
       c8Jjo: // global
           _s8IzD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jjp; else goto c8Jjq;
       c8Jjq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jjs; else goto c8Jjr;
       c8Jjs: // global
           HpAlloc = 56;
           goto c8Jjp;
       c8Jjp: // global
           R1 = _s8IzD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jjr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzD::P64;
           _s8Izp::I64 = I64[_s8IzD::P64 + 56];
           _s8Izz::I64 = I64[_s8IzD::P64 + 64];
           if (_s8Izz::I64 == _s8Izp::I64) goto c8Jjn; else goto c8Jjm;
       c8Jjn: // global
           _s8Izx::P64 = P64[_s8IzD::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jjm: // global
           _s8Izl::P64 = P64[_s8IzD::P64 + 16];
           _s8Izm::P64 = P64[_s8IzD::P64 + 24];
           _s8Izk::I64 = I64[_s8IzD::P64 + 40];
           _s8Izn::I64 = I64[_s8IzD::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8Izz::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IzD_info" {
     sat_s8IzD_info:
         const sat_s8IzD_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IzL_entry() //  [R1]
         { []
         }
     {offset
       c8JjK: // global
           _s8IzL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JjL; else goto c8JjM;
       c8JjM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JjO; else goto c8JjN;
       c8JjO: // global
           HpAlloc = 56;
           goto c8JjL;
       c8JjL: // global
           R1 = _s8IzL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JjN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzL::P64;
           _s8Izp::I64 = I64[_s8IzL::P64 + 56];
           _s8IzH::I64 = I64[_s8IzL::P64 + 64];
           if (_s8IzH::I64 == _s8Izp::I64) goto c8JjJ; else goto c8JjI;
       c8JjJ: // global
           _s8Izx::P64 = P64[_s8IzL::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JjI: // global
           _s8Izl::P64 = P64[_s8IzL::P64 + 16];
           _s8Izm::P64 = P64[_s8IzL::P64 + 24];
           _s8Izk::I64 = I64[_s8IzL::P64 + 40];
           _s8Izn::I64 = I64[_s8IzL::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzH::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IzL_info" {
     sat_s8IzL_info:
         const sat_s8IzL_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IzT_entry() //  [R1]
         { []
         }
     {offset
       c8Jk6: // global
           _s8IzT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jk7; else goto c8Jk8;
       c8Jk8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jka; else goto c8Jk9;
       c8Jka: // global
           HpAlloc = 56;
           goto c8Jk7;
       c8Jk7: // global
           R1 = _s8IzT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jk9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzT::P64;
           _s8Izp::I64 = I64[_s8IzT::P64 + 56];
           _s8IzP::I64 = I64[_s8IzT::P64 + 64];
           if (_s8IzP::I64 == _s8Izp::I64) goto c8Jk5; else goto c8Jk4;
       c8Jk5: // global
           _s8Izx::P64 = P64[_s8IzT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jk4: // global
           _s8Izl::P64 = P64[_s8IzT::P64 + 16];
           _s8Izm::P64 = P64[_s8IzT::P64 + 24];
           _s8Izk::I64 = I64[_s8IzT::P64 + 40];
           _s8Izn::I64 = I64[_s8IzT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzP::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IzT_info" {
     sat_s8IzT_info:
         const sat_s8IzT_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IA1_entry() //  [R1]
         { []
         }
     {offset
       c8Jks: // global
           _s8IA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jkt; else goto c8Jku;
       c8Jku: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jkw; else goto c8Jkv;
       c8Jkw: // global
           HpAlloc = 56;
           goto c8Jkt;
       c8Jkt: // global
           R1 = _s8IA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jkv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IA1::P64;
           _s8Izp::I64 = I64[_s8IA1::P64 + 56];
           _s8IzX::I64 = I64[_s8IA1::P64 + 64];
           if (_s8IzX::I64 == _s8Izp::I64) goto c8Jkr; else goto c8Jkq;
       c8Jkr: // global
           _s8Izx::P64 = P64[_s8IA1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jkq: // global
           _s8Izl::P64 = P64[_s8IA1::P64 + 16];
           _s8Izm::P64 = P64[_s8IA1::P64 + 24];
           _s8Izk::I64 = I64[_s8IA1::P64 + 40];
           _s8Izn::I64 = I64[_s8IA1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzX::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IA1_info" {
     sat_s8IA1_info:
         const sat_s8IA1_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IA9_entry() //  [R1]
         { []
         }
     {offset
       c8JkO: // global
           _s8IA9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JkP; else goto c8JkQ;
       c8JkQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JkS; else goto c8JkR;
       c8JkS: // global
           HpAlloc = 56;
           goto c8JkP;
       c8JkP: // global
           R1 = _s8IA9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IA9::P64;
           _s8Izp::I64 = I64[_s8IA9::P64 + 56];
           _s8IA5::I64 = I64[_s8IA9::P64 + 64];
           if (_s8IA5::I64 == _s8Izp::I64) goto c8JkN; else goto c8JkM;
       c8JkN: // global
           _s8Izx::P64 = P64[_s8IA9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JkM: // global
           _s8Izl::P64 = P64[_s8IA9::P64 + 16];
           _s8Izm::P64 = P64[_s8IA9::P64 + 24];
           _s8Izk::I64 = I64[_s8IA9::P64 + 40];
           _s8Izn::I64 = I64[_s8IA9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IA5::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IA9_info" {
     sat_s8IA9_info:
         const sat_s8IA9_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IAh_entry() //  [R1]
         { []
         }
     {offset
       c8Jla: // global
           _s8IAh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jlb; else goto c8Jlc;
       c8Jlc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jle; else goto c8Jld;
       c8Jle: // global
           HpAlloc = 56;
           goto c8Jlb;
       c8Jlb: // global
           R1 = _s8IAh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jld: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAh::P64;
           _s8Izp::I64 = I64[_s8IAh::P64 + 56];
           _s8IAd::I64 = I64[_s8IAh::P64 + 64];
           if (_s8IAd::I64 == _s8Izp::I64) goto c8Jl9; else goto c8Jl8;
       c8Jl9: // global
           _s8Izx::P64 = P64[_s8IAh::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jl8: // global
           _s8Izl::P64 = P64[_s8IAh::P64 + 16];
           _s8Izm::P64 = P64[_s8IAh::P64 + 24];
           _s8Izk::I64 = I64[_s8IAh::P64 + 40];
           _s8Izn::I64 = I64[_s8IAh::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAd::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IAh_info" {
     sat_s8IAh_info:
         const sat_s8IAh_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IAp_entry() //  [R1]
         { []
         }
     {offset
       c8Jlw: // global
           _s8IAp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jlx; else goto c8Jly;
       c8Jly: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JlA; else goto c8Jlz;
       c8JlA: // global
           HpAlloc = 56;
           goto c8Jlx;
       c8Jlx: // global
           R1 = _s8IAp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jlz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAp::P64;
           _s8Izp::I64 = I64[_s8IAp::P64 + 56];
           _s8IAl::I64 = I64[_s8IAp::P64 + 64];
           if (_s8IAl::I64 == _s8Izp::I64) goto c8Jlv; else goto c8Jlu;
       c8Jlv: // global
           _s8Izx::P64 = P64[_s8IAp::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jlu: // global
           _s8Izl::P64 = P64[_s8IAp::P64 + 16];
           _s8Izm::P64 = P64[_s8IAp::P64 + 24];
           _s8Izk::I64 = I64[_s8IAp::P64 + 40];
           _s8Izn::I64 = I64[_s8IAp::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAl::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IAp_info" {
     sat_s8IAp_info:
         const sat_s8IAp_entry;
         const 17179869187;
         const 15;
 },
 sat_s8IAx_entry() //  [R1]
         { []
         }
     {offset
       c8JlS: // global
           _s8IAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JlT; else goto c8JlU;
       c8JlU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JlW; else goto c8JlV;
       c8JlW: // global
           HpAlloc = 56;
           goto c8JlT;
       c8JlT: // global
           R1 = _s8IAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAx::P64;
           _s8Izp::I64 = I64[_s8IAx::P64 + 56];
           _s8IAt::I64 = I64[_s8IAx::P64 + 64];
           if (_s8IAt::I64 == _s8Izp::I64) goto c8JlR; else goto c8JlQ;
       c8JlR: // global
           _s8Izx::P64 = P64[_s8IAx::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JlQ: // global
           _s8Izl::P64 = P64[_s8IAx::P64 + 16];
           _s8Izm::P64 = P64[_s8IAx::P64 + 24];
           _s8Izk::I64 = I64[_s8IAx::P64 + 40];
           _s8Izn::I64 = I64[_s8IAx::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAt::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8IAx_info" {
     sat_s8IAx_info:
         const sat_s8IAx_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8JlZ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Jm0; else goto c8Jm1;
       c8Jm0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jm1: // global
           I64[Sp - 16] = block_c8JiY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8JpL; else goto c8JiZ;
       u8JpL: // global
           call _c8JiY(R1) args: 0, res: 0, upd: 0;
       c8JiZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF5_info" {
     GHC.IO.Encoding.UTF16.mkUTF5_info:
         const GHC.IO.Encoding.UTF16.mkUTF5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8JiY() //  [R1]
         { []
         }
     {offset
       c8JiY: // global
           I64[Sp - 40] = block_c8Jj3_info;
           _s8Izl::P64 = P64[R1 + 7];
           _s8Izm::P64 = P64[R1 + 15];
           _s8Izk::I64 = I64[R1 + 23];
           _s8Izn::I64 = I64[R1 + 31];
           _s8Izo::I64 = I64[R1 + 39];
           _s8Izp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Izm::P64;
           I64[Sp - 24] = _s8Izn::I64;
           I64[Sp - 16] = _s8Izo::I64;
           I64[Sp - 8] = _s8Izp::I64;
           P64[Sp] = _s8Izl::P64;
           I64[Sp + 8] = _s8Izk::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8JpC; else goto c8Jj4;
       u8JpC: // global
           call _c8Jj3(R1) args: 0, res: 0, upd: 0;
       c8Jj4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JiY_info" {
     block_c8JiY_info:
         const _c8JiY;
         const 1;
         const 30;
 },
 _c8Jj3() //  [R1]
         { []
         }
     {offset
       c8Jj3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jm5; else goto c8Jm4;
       c8Jm5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Jm4: // global
           _s8Izs::P64 = P64[R1 + 7];
           _s8Izt::P64 = P64[R1 + 15];
           _s8Izr::I64 = I64[R1 + 23];
           _s8Izu::I64 = I64[R1 + 31];
           _s8Izv::I64 = I64[R1 + 39];
           _s8Izw::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Izl::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Izk::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Izp::I64 = I64[Sp + 32];
           _c8Jj8::P64 = Hp - 47;
           _s8IAC::I64 = _s8Izw::I64;
           _s8IAB::I64 = I64[Sp + 24];
           goto c8JmE;
       c8JmE: // global
           if (%MO_S_Lt_W64(_s8IAC::I64,
                            _s8Izu::I64)) goto c8Joz; else goto c8JoA;
       c8Joz: // global
           if (%MO_S_Lt_W64(_s8IAB::I64,
                            _s8Izp::I64)) goto c8Jow; else goto c8Jox;
       c8Jow: // global
           if ((_s8IAB::I64 + 1) == _s8Izp::I64) goto c8Jou; else goto c8Jot;
       c8Jou: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JkX() args: 0, res: 0, upd: 0;
       c8Jot: // global
           _s8IAL::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + _s8IAB::I64]);
           call MO_Touch(_s8Izl::P64);
           _s8IAR::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 1)]);
           call MO_Touch(_s8Izl::P64);
           _s8IAT::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IAL::I64 << 8)) + _s8IAR::I64));
           if (_s8IAT::I64 >= 55296) goto c8Joq; else goto c8Jor;
       c8Joq: // global
           if (_s8IAT::I64 <= 57343) goto c8Jon; else goto c8Joo;
       c8Jon: // global
           if (%MO_S_Ge_W64(_s8Izp::I64 - _s8IAB::I64,
                            4)) goto c8Jok; else goto c8Jol;
       c8Jok: // global
           _s8IB5::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 2)]);
           call MO_Touch(_s8Izl::P64);
           _s8IBb::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 3)]);
           call MO_Touch(_s8Izl::P64);
           if (_s8IAT::I64 < 55296) goto c8JnK; else goto c8Joi;
       c8JnK: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jjb() args: 0, res: 0, upd: 0;
       c8Joi: // global
           if (_s8IAT::I64 > 56319) goto c8JnQ; else goto c8Joh;
       c8JnQ: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jjx() args: 0, res: 0, upd: 0;
       c8Joh: // global
           _s8IBf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IB5::I64 << 8)) + _s8IBb::I64));
           if (_s8IBf::I64 < 56320) goto c8Jo8; else goto c8Jog;
       c8Jo8: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JjT() args: 0, res: 0, upd: 0;
       c8Jog: // global
           if (_s8IBf::I64 > 57343) goto c8Joe; else goto c8Jof;
       c8Joe: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jkf() args: 0, res: 0, upd: 0;
       c8Jof: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8IAT::I64 + -55296) << 10) + (_s8IBf::I64 + -56320) + 65536);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 4;
           goto c8JmE;
       c8Jol: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JkB() args: 0, res: 0, upd: 0;
       c8Joo: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IAT::I64);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 2;
           goto c8JmE;
       c8Jor: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IAT::I64);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 2;
           goto c8JmE;
       c8Jox: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jlj() args: 0, res: 0, upd: 0;
       c8JoA: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JlF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Jj3_info" {
     block_c8Jj3_info:
         const _c8Jj3;
         const 2950;
         const 30;
 },
 _c8JkX() //  []
         { []
         }
     {offset
       c8JkX: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmt; else goto c8Jms;
       c8Jmt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JkX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jms: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAh_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JkX_info" {
     block_c8JkX_info:
         const _c8JkX;
         const 352013;
         const 30;
 },
 _c8Jjb() //  []
         { []
         }
     {offset
       c8Jjb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jm9; else goto c8Jm8;
       c8Jm9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jjb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jm8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzD_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jjb_info" {
     block_c8Jjb_info:
         const _c8Jjb;
         const 352013;
         const 30;
 },
 _c8Jjx() //  []
         { []
         }
     {offset
       c8Jjx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmd; else goto c8Jmc;
       c8Jmd: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jjx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzL_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jjx_info" {
     block_c8Jjx_info:
         const _c8Jjx;
         const 352013;
         const 30;
 },
 _c8JjT() //  []
         { []
         }
     {offset
       c8JjT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmh; else goto c8Jmg;
       c8Jmh: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JjT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JjT_info" {
     block_c8JjT_info:
         const _c8JjT;
         const 352013;
         const 30;
 },
 _c8Jkf() //  []
         { []
         }
     {offset
       c8Jkf: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jml; else goto c8Jmk;
       c8Jml: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jkf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IA1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jkf_info" {
     block_c8Jkf_info:
         const _c8Jkf;
         const 352013;
         const 30;
 },
 _c8JkB() //  []
         { []
         }
     {offset
       c8JkB: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmp; else goto c8Jmo;
       c8Jmp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JkB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IA9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JkB_info" {
     block_c8JkB_info:
         const _c8JkB;
         const 352013;
         const 30;
 },
 _c8Jlj() //  []
         { []
         }
     {offset
       c8Jlj: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmx; else goto c8Jmw;
       c8Jmx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jlj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAp_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jlj_info" {
     block_c8Jlj_info:
         const _c8Jlj;
         const 352013;
         const 30;
 },
 _c8JlF() //  []
         { []
         }
     {offset
       c8JlF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8JmB; else goto c8JmA;
       c8JmB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JlF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8JmA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAx_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JlF_info" {
     block_c8JlF_info:
         const _c8JlF;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.935213613 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8JuH: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be_decode_info" {
     GHC.IO.Encoding.UTF16.utf16be_decode_info:
         const GHC.IO.Encoding.UTF16.utf16be_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.938565405 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.940764163 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { []
         }
     {offset
       c8JuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JuW; else goto c8JuX;
       c8JuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JuX: // global
           (_c8JuS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JuS::I64 == 0) goto c8JuU; else goto c8JuT;
       c8JuU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JuT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JuS::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be2_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.946434353 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8IBP_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Jvk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IBP_info" {
     sat_s8IBP_info:
         const sat_s8IBP_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt;
 },
 sat_s8IBR_entry() //  [R1]
         { []
         }
     {offset
       c8Jvo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jvs; else goto c8Jvr;
       c8Jvs: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jvr: // global
           _s8IBJ::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8IBP_info;
           P64[Hp - 48] = _s8IBJ::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IBR_info" {
     sat_s8IBR_info:
         const sat_s8IBR_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt;
 },
 sat_s8IBL_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8JvD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IBL_info" {
     sat_s8IBL_info:
         const sat_s8IBL_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt+8;
 },
 sat_s8IBN_entry() //  [R1]
         { []
         }
     {offset
       c8JvH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JvL; else goto c8JvK;
       c8JvL: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JvK: // global
           _s8IBJ::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8IBL_info;
           P64[Hp - 48] = _s8IBJ::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IBN_info" {
     sat_s8IBN_info:
         const sat_s8IBN_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { []
         }
     {offset
       c8JvN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JvR; else goto c8JvQ;
       c8JvR: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JvQ: // global
           I64[Hp - 56] = sat_s8IBR_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8IBN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16be_info" {
     GHC.IO.Encoding.UTF16.mkUTF16be_info:
         const GHC.IO.Encoding.UTF16.mkUTF16be_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8JgE_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.956631281 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.958748998 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { []
         }
     {offset
       c8JwA: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be3_info" {
     GHC.IO.Encoding.UTF16.utf16be3_info:
         const GHC.IO.Encoding.UTF16.utf16be3_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8JgE_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.961860991 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.963831355 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { []
         }
     {offset
       c8JwN: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16be1_info" {
     GHC.IO.Encoding.UTF16.utf16be1_info:
         const GHC.IO.Encoding.UTF16.utf16be1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8JgE_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.967508239 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.969320652 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.970999107 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.976884836 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { []
         }
     {offset
       c8JwZ: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c8Jxa: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Jxb; else goto c8Jxc;
       c8Jxb: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8Jxc: // global
           I64[Sp - 48] = block_c8Jx3_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8JyF; else goto c8Jx4;
       u8JyF: // global
           call _c8Jx3(R1) args: 0, res: 0, upd: 0;
       c8Jx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.$wutf16_decode_info" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_info:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 7304;
         const GHC.IO.Encoding.UTF16.$wutf16_decode_slow;
 },
 _c8Jx3() //  [R1]
         { []
         }
     {offset
       c8Jx3: // global
           _s8IBV::I64 = I64[Sp + 16];
           _s8IBW::P64 = P64[Sp + 24];
           _s8IBX::P64 = P64[Sp + 32];
           _s8IBY::I64 = I64[Sp + 40];
           _s8IBZ::I64 = I64[Sp + 48];
           _s8IC0::I64 = I64[Sp + 56];
           _s8IC1::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8Jx7; else goto c8Jx8;
       c8Jx7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Jxh; else goto c8Jxg;
       c8Jxh: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Jxg: // global
           if (%MO_S_Ge_W64(_s8IC0::I64 - _s8IBZ::I64,
                            2)) goto c8Jys; else goto c8Jyw;
       c8Jys: // global
           _s8IBU::P64 = P64[Sp + 8];
           _s8ICc::I64 = %MO_UU_Conv_W8_W64(I8[_s8IBV::I64 + _s8IBZ::I64]);
           call MO_Touch(_s8IBW::P64);
           _s8ICi::I64 = %MO_UU_Conv_W8_W64(I8[_s8IBV::I64 + (_s8IBZ::I64 + 1)]);
           call MO_Touch(_s8IBW::P64);
           if (_s8ICc::I64 != 254) goto c8Jyf; else goto c8Jyq;
       c8Jyq: // global
           if (_s8ICi::I64 != 255) goto c8Jyf; else goto c8Jyp;
       c8Jyf: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8ICi::I64;
           I64[Sp] = _s8ICc::I64;
           Sp = Sp - 16;
           call _c8JxC() args: 0, res: 0, upd: 0;
       c8Jyp: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8IBW::P64;
           P64[Hp - 64] = _s8IBX::P64;
           I64[Hp - 56] = _s8IBV::I64;
           I64[Hp - 48] = _s8IBY::I64;
           I64[Hp - 40] = _s8IBZ::I64 + 2;
           I64[Hp - 32] = _s8IC0::I64;
           _c8Jyo::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8IC1::P64;
           R2 = _c8Jyo::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Jyw: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8IBW::P64;
           P64[Hp - 64] = _s8IBX::P64;
           I64[Hp - 56] = _s8IBV::I64;
           I64[Hp - 48] = _s8IBY::I64;
           I64[Hp - 40] = _s8IBZ::I64;
           I64[Hp - 32] = _s8IC0::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8IC1::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Jx8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JyC; else goto c8JyB;
       c8JyC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JyB: // global
           _s8ICB::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           R1 = _s8ICB::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jx3_info" {
     block_c8Jx3_info:
         const _c8Jx3;
         const 7304;
         const 30;
 },
 _c8JxC() //  []
         { []
         }
     {offset
       c8JxC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JxG; else goto c8JxF;
       c8JxG: // global
           HpAlloc = 56;
           I64[Sp] = block_c8JxC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8JxF: // global
           _s8IBU::P64 = P64[Sp + 24];
           _s8IBV::I64 = I64[Sp + 32];
           _s8IBW::P64 = P64[Sp + 40];
           _s8IBX::P64 = P64[Sp + 48];
           _s8IBY::I64 = I64[Sp + 56];
           _s8IBZ::I64 = I64[Sp + 64];
           _s8IC0::I64 = I64[Sp + 72];
           _s8IC1::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8Jy7; else goto c8JxO;
       c8Jy7: // global
           if (I64[Sp + 8] == 254) goto c8Jy6; else goto c8JxX;
       c8Jy6: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64 + 2;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8JxX: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8JxO: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JxC_info" {
     block_c8JxC_info:
         const _c8JxC;
         const 29386;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.990295088 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8Jzt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Jzx; else goto c8Jzy;
       c8Jzx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jzy: // global
           I64[Sp - 24] = block_c8Jzq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JzG; else goto c8Jzr;
       u8JzG: // global
           call _c8Jzq(R1) args: 0, res: 0, upd: 0;
       c8Jzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_decode1_info" {
     GHC.IO.Encoding.UTF16.utf16_decode1_info:
         const GHC.IO.Encoding.UTF16.utf16_decode1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _c8Jzq() //  [R1]
         { []
         }
     {offset
       c8Jzq: // global
           I64[Sp] = block_c8Jzw_info;
           _s8ICI::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ICI::P64;
           if (R1 & 7 != 0) goto u8JzF; else goto c8JzA;
       u8JzF: // global
           call _c8Jzw(R1) args: 0, res: 0, upd: 0;
       c8JzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jzq_info" {
     block_c8Jzq_info:
         const _c8Jzq;
         const 2;
         const 30;
 },
 _c8Jzw() //  [R1]
         { []
         }
     {offset
       c8Jzw: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jzw_info" {
     block_c8Jzw_info:
         const _c8Jzw;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.996920702 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8JA2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_decode_info" {
     GHC.IO.Encoding.UTF16.utf16_decode_info:
         const GHC.IO.Encoding.UTF16.utf16_decode_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:53.999827613 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.002093465 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { []
         }
     {offset
       c8JAg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JAh; else goto c8JAi;
       c8JAh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JAi: // global
           (_c8JAd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JAd::I64 == 0) goto c8JAf; else goto c8JAe;
       c8JAf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JAe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JAd::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF7_info" {
     GHC.IO.Encoding.UTF16.mkUTF7_info:
         const GHC.IO.Encoding.UTF16.mkUTF7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.010934962 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8IDA_entry() //  [R1, R2]
         { []
         }
     {offset
       c8JAK: // global
           _s8IDi::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8IDi::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IDi::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDA_info" {
     sat_s8IDA_info:
         const sat_s8IDA_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8IDw_entry() //  [R1]
         { []
         }
     {offset
       c8JAT: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDw_info" {
     sat_s8IDw_info:
         const sat_s8IDw_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8IDu_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8JB1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDu_info" {
     sat_s8IDu_info:
         const sat_s8IDu_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt;
 },
 sat_s8IDt_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8JBc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8JBd; else goto c8JBe;
       c8JBd: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8JBe: // global
           I64[Sp - 24] = block_c8JB9_info;
           _s8IDi::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8IDi::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JBi; else goto c8JBa;
       u8JBi: // global
           call _c8JB9(R1) args: 0, res: 0, upd: 0;
       c8JBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDt_info" {
     sat_s8IDt_info:
         const sat_s8IDt_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8JB9() //  [R1]
         { []
         }
     {offset
       c8JB9: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JB9_info" {
     block_c8JB9_info:
         const _c8JB9;
         const 2;
         const 30;
 },
 sat_s8IDC_entry() //  [R1]
         { []
         }
     {offset
       c8JBk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JBl; else goto c8JBm;
       c8JBl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JBm: // global
           I64[Sp - 16] = block_c8JAA_info;
           _s8ICQ::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8ICQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDC_info" {
     sat_s8IDC_info:
         const sat_s8IDC_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt;
 },
 _c8JAA() //  [R1]
         { []
         }
     {offset
       c8JAA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8JBp; else goto c8JBo;
       c8JBp: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JBo: // global
           I64[Hp - 104] = sat_s8IDA_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8IDw_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8IDu_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8IDt_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JAA_info" {
     block_c8JAA_info:
         const _c8JAA;
         const 1;
         const 4294967326;
         const S8JgE_srt;
 },
 sat_s8IDc_entry() //  [R1, R2]
         { []
         }
     {offset
       c8JBF: // global
           _s8ICU::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8ICU::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8ICU::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDc_info" {
     sat_s8IDc_info:
         const sat_s8IDc_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s8ID8_entry() //  [R1]
         { []
         }
     {offset
       c8JBO: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ID8_info" {
     sat_s8ID8_info:
         const sat_s8ID8_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s8ID6_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8JBW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ID6_info" {
     sat_s8ID6_info:
         const sat_s8ID6_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8JgE_srt+8;
 },
 sat_s8ID5_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8JC7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8JC8; else goto c8JC9;
       c8JC8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8JC9: // global
           I64[Sp - 24] = block_c8JC4_info;
           _s8ICU::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8ICU::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JCd; else goto c8JC5;
       u8JCd: // global
           call _c8JC4(R1) args: 0, res: 0, upd: 0;
       c8JC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ID5_info" {
     sat_s8ID5_info:
         const sat_s8ID5_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _c8JC4() //  [R1]
         { []
         }
     {offset
       c8JC4: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JC4_info" {
     block_c8JC4_info:
         const _c8JC4;
         const 2;
         const 30;
 },
 sat_s8IDe_entry() //  [R1]
         { []
         }
     {offset
       c8JCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JCg; else goto c8JCh;
       c8JCg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JCh: // global
           I64[Sp - 16] = block_c8JBv_info;
           _s8ICQ::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8ICQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8IDe_info" {
     sat_s8IDe_info:
         const sat_s8IDe_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8JgE_srt+8;
 },
 _c8JBv() //  [R1]
         { []
         }
     {offset
       c8JBv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8JCk; else goto c8JCj;
       c8JCk: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JCj: // global
           I64[Hp - 104] = sat_s8IDc_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8ID8_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8ID6_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8ID5_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JBv_info" {
     block_c8JBv_info:
         const _c8JBv;
         const 1;
         const 4294967326;
         const S8JgE_srt+8;
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { []
         }
     {offset
       c8JCm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JCq; else goto c8JCp;
       c8JCq: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JCp: // global
           I64[Hp - 56] = sat_s8IDC_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8IDe_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.mkUTF16_info" {
     GHC.IO.Encoding.UTF16.mkUTF16_info:
         const GHC.IO.Encoding.UTF16.mkUTF16_entry;
         const 0;
         const 211119117434894;
         const 4294967301;
         const S8JgE_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.037533089 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { []
         }
     {offset
       c8JEd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JEe; else goto c8JEf;
       c8JEe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JEf: // global
           (_c8JEa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JEa::I64 == 0) goto c8JEc; else goto c8JEb;
       c8JEc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JEb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JEa::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.UTF16.utf16_info" {
     GHC.IO.Encoding.UTF16.utf16_info:
         const GHC.IO.Encoding.UTF16.utf16_entry;
         const 0;
         const 4294967317;
         const S8JgE_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.041077571 UTC

[section ""relreadonly" . S8JgE_srt" {
     S8JgE_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]

