
==================== Raw Cmm ====================
2018-03-16 16:03:35.099416653 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:35.100487536 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.103212065 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { []
         }
     {offset
       c8seZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sf0; else goto c8sf1;
       c8sf0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sf1: // global
           (_c8seW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8seW::I64 == 0) goto c8seY; else goto c8seX;
       c8seY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8seX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8seW::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.106886941 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.109125837 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { []
         }
     {offset
       c8sfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfh; else goto c8sfi;
       c8sfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfi: // global
           (_c8sfd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfd::I64 == 0) goto c8sff; else goto c8sfe;
       c8sff: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfd::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.112684636 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.115388811 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { []
         }
     {offset
       c8sfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfy; else goto c8sfz;
       c8sfy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfz: // global
           (_c8sfu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfu::I64 == 0) goto c8sfw; else goto c8sfv;
       c8sfw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfu::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.118939669 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.122113626 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { []
         }
     {offset
       c8sfO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfP; else goto c8sfQ;
       c8sfP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfQ: // global
           (_c8sfL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfL::I64 == 0) goto c8sfN; else goto c8sfM;
       c8sfN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfL::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.127262437 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c8sgb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sgc; else goto c8sgd;
       c8sgc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sgd: // global
           I64[Sp - 16] = block_c8sg2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8sgs; else goto c8sg3;
       u8sgs: // global
           call _c8sg2(R1) args: 0, res: 0, upd: 0;
       c8sg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$w$cshowsPrec_info" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_info:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_entry;
         const 0;
         const 133143986190;
         const 8589934607;
         const S8rYU_srt;
 },
 _c8sg2() //  [R1]
         { []
         }
     {offset
       c8sg2: // global
           _s8rVM::P64 = P64[Sp + 8];
           _c8sga::P64 = R1 & 7;
           if (_c8sga::P64 < 3) goto u8sgq; else goto u8sgr;
       u8sgq: // global
           if (_c8sga::P64 < 2) goto c8sg6; else goto c8sg7;
       c8sg6: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8sg7: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8sgr: // global
           if (_c8sga::P64 < 4) goto c8sg8; else goto c8sg9;
       c8sg8: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8sg9: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sg2_info" {
     block_c8sg2_info:
         const _c8sg2;
         const 1;
         const 64424509470;
         const S8rYU_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.133313965 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { []
         }
     {offset
       c8sgH: // global
           _s8rVP::P64 = R3;
           R3 = R4;
           R2 = _s8rVP::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry;
         const 0;
         const 4294967310;
         const 12884901911;
         const S8rYU_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.137469256 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c8sh1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sh2; else goto c8sh3;
       c8sh2: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sh3: // global
           I64[Sp - 8] = block_c8sgS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8shi; else goto c8sgT;
       u8shi: // global
           call _c8sgS(R1) args: 0, res: 0, upd: 0;
       c8sgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry;
         const 0;
         const 133143986190;
         const 4294967301;
         const S8rYU_srt+8;
 },
 _c8sgS() //  [R1]
         { []
         }
     {offset
       c8sgS: // global
           _c8sh0::P64 = R1 & 7;
           if (_c8sh0::P64 < 3) goto u8shg; else goto u8shh;
       u8shg: // global
           if (_c8sh0::P64 < 2) goto c8sgW; else goto c8sgX;
       c8sgW: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sgX: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8shh: // global
           if (_c8sh0::P64 < 4) goto c8sgY; else goto c8sgZ;
       c8sgY: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sgZ: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sgS_info" {
     block_c8sgS_info:
         const _c8sgS;
         const 0;
         const 64424509470;
         const S8rYU_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.143034715 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { []
         }
     {offset
       c8shB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S8rYU_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.14628706 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.148047232 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.15024793 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { []
         }
     {offset
       c8shQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8shR; else goto c8shS;
       c8shR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8shS: // global
           (_c8shN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8shN::I64 == 0) goto c8shP; else goto c8shO;
       c8shP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8shO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8shN::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.154302162 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.157167278 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { []
         }
     {offset
       c8si7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8si8; else goto c8si9;
       c8si8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8si9: // global
           (_c8si4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8si4::I64 == 0) goto c8si6; else goto c8si5;
       c8si6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8si5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8si4::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.160867207 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.163075664 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { []
         }
     {offset
       c8sio: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sip; else goto c8siq;
       c8sip: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8siq: // global
           (_c8sil::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sil::I64 == 0) goto c8sin; else goto c8sim;
       c8sin: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sim: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sil::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.16793399 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { []
         }
     {offset
       c8siL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8siM; else goto c8siN;
       c8siM: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8siN: // global
           I64[Sp - 8] = block_c8siC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sj2; else goto c8siD;
       u8sj2: // global
           call _c8siC(R1) args: 0, res: 0, upd: 0;
       c8siD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8rYU_srt+48;
 },
 _c8siC() //  [R1]
         { []
         }
     {offset
       c8siC: // global
           _c8siK::P64 = R1 & 7;
           if (_c8siK::P64 < 3) goto u8sj0; else goto u8sj1;
       u8sj0: // global
           if (_c8siK::P64 < 2) goto c8siG; else goto c8siH;
       c8siG: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8siH: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8sj1: // global
           if (_c8siK::P64 < 4) goto c8siI; else goto c8siJ;
       c8siI: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8siJ: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8siC_info" {
     block_c8siC_info:
         const _c8siC;
         const 0;
         const 30064771102;
         const S8rYU_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.17318792 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.175386209 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { []
         }
     {offset
       c8sjo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjp; else goto c8sjq;
       c8sjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjq: // global
           (_c8sjl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjl::I64 == 0) goto c8sjn; else goto c8sjm;
       c8sjn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjl::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode6_info" {
     GHC.IO.Encoding.Failure.recoverDecode6_info:
         const GHC.IO.Encoding.Failure.recoverDecode6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.179365613 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.181579263 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { []
         }
     {offset
       c8sjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjG; else goto c8sjH;
       c8sjG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjH: // global
           (_c8sjC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjC::I64 == 0) goto c8sjE; else goto c8sjD;
       c8sjE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjC::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode4_info" {
     GHC.IO.Encoding.Failure.recoverDecode4_info:
         const GHC.IO.Encoding.Failure.recoverDecode4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.185214726 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.187605285 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { []
         }
     {offset
       c8sjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjX; else goto c8sjY;
       c8sjX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjY: // global
           (_c8sjT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjT::I64 == 0) goto c8sjV; else goto c8sjU;
       c8sjV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjT::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode2_info" {
     GHC.IO.Encoding.Failure.recoverDecode2_info:
         const GHC.IO.Encoding.Failure.recoverDecode2_entry;
         const 0;
         const 12884901909;
         const S8rYU_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.192104457 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.194366985 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { []
         }
     {offset
       c8skd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ske; else goto c8skf;
       c8ske: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skf: // global
           (_c8ska::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ska::I64 == 0) goto c8skc; else goto c8skb;
       c8skc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8skb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ska::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode6_info" {
     GHC.IO.Encoding.Failure.recoverEncode6_info:
         const GHC.IO.Encoding.Failure.recoverEncode6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.197935247 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.20012951 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { []
         }
     {offset
       c8sku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8skv; else goto c8skw;
       c8skv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skw: // global
           (_c8skr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8skr::I64 == 0) goto c8skt; else goto c8sks;
       c8skt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sks: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8skr::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode4_info" {
     GHC.IO.Encoding.Failure.recoverEncode4_info:
         const GHC.IO.Encoding.Failure.recoverEncode4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.204190317 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.20657459 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { []
         }
     {offset
       c8skL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8skM; else goto c8skN;
       c8skM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skN: // global
           (_c8skI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8skI::I64 == 0) goto c8skK; else goto c8skJ;
       c8skK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8skJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8skI::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode2_info" {
     GHC.IO.Encoding.Failure.recoverEncode2_info:
         const GHC.IO.Encoding.Failure.recoverEncode2_entry;
         const 0;
         const 21474836501;
         const S8rYU_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.21011549 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.211836466 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.214047926 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.215771973 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.217595136 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.219287333 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.222059047 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.223886006 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.225731441 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.227448739 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.229226654 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.231339319 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.233528757 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.235439676 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.23767373 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.239462671 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.241187437 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.243012582 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.244852527 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.246590328 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.248904894 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.255590285 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sln: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8slr; else goto c8sls;
       c8slr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sls: // global
           I64[Sp - 24] = block_c8slk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8snm; else goto c8sll;
       u8snm: // global
           call _c8slk(R1) args: 0, res: 0, upd: 0;
       c8sll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode1_info" {
     GHC.IO.Encoding.Failure.recoverDecode1_info:
         const GHC.IO.Encoding.Failure.recoverDecode1_entry;
         const 0;
         const 30064771086;
         const 17179869207;
         const S8rYU_srt+104;
 },
 _c8slk() //  [R1]
         { []
         }
     {offset
       c8slk: // global
           I64[Sp - 40] = block_c8slq_info;
           _s8rW3::P64 = P64[R1 + 7];
           _s8rW4::P64 = P64[R1 + 15];
           _s8rW2::I64 = I64[R1 + 23];
           _s8rW5::I64 = I64[R1 + 31];
           _s8rW6::I64 = I64[R1 + 39];
           _s8rW7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8rW4::P64;
           I64[Sp - 24] = _s8rW5::I64;
           I64[Sp - 16] = _s8rW6::I64;
           I64[Sp - 8] = _s8rW7::I64;
           P64[Sp] = _s8rW3::P64;
           I64[Sp + 16] = _s8rW2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8snl; else goto c8slu;
       u8snl: // global
           call _c8slq(R1) args: 0, res: 0, upd: 0;
       c8slu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8slk_info" {
     block_c8slk_info:
         const _c8slk;
         const 2;
         const 21474836510;
         const S8rYU_srt+104;
 },
 _c8slq() //  [R1]
         { []
         }
     {offset
       c8slq: // global
           I64[Sp - 48] = block_c8sly_info;
           _s8rW8::P64 = R1;
           _s8rWa::P64 = P64[R1 + 7];
           _s8rWb::P64 = P64[R1 + 15];
           _s8rW9::I64 = I64[R1 + 23];
           _s8rWc::I64 = I64[R1 + 31];
           _s8rWd::I64 = I64[R1 + 39];
           _s8rWe::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8rWa::P64;
           P64[Sp - 32] = _s8rWb::P64;
           I64[Sp - 24] = _s8rWc::I64;
           I64[Sp - 16] = _s8rWd::I64;
           I64[Sp - 8] = _s8rWe::I64;
           I64[Sp] = _s8rW9::I64;
           P64[Sp + 48] = _s8rW8::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8snn; else goto c8slA;
       u8snn: // global
           call _c8sly(R1) args: 0, res: 0, upd: 0;
       c8slA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8slq_info" {
     block_c8slq_info:
         const _c8slq;
         const 4999;
         const 21474836510;
         const S8rYU_srt+104;
 },
 _c8sly() //  [R1]
         { []
         }
     {offset
       c8sly: // global
           _s8rW2::I64 = I64[Sp + 104];
           _s8rW3::P64 = P64[Sp + 88];
           _s8rW4::P64 = P64[Sp + 56];
           _s8rW5::I64 = I64[Sp + 64];
           _s8rW6::I64 = I64[Sp + 72];
           _s8rW7::I64 = I64[Sp + 80];
           _c8sni::P64 = R1 & 7;
           if (_c8sni::P64 < 3) goto u8snj; else goto u8snk;
       u8snj: // global
           if (_c8sni::P64 < 2) goto c8slG; else goto c8slO;
       c8slG: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8slO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8slR; else goto c8slQ;
       c8slR: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8slQ: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8snk: // global
           _s8rW9::I64 = I64[Sp + 48];
           _s8rWa::P64 = P64[Sp + 8];
           _s8rWb::P64 = P64[Sp + 16];
           _s8rWc::I64 = I64[Sp + 24];
           _s8rWd::I64 = I64[Sp + 32];
           _s8rWe::I64 = I64[Sp + 40];
           if (_c8sni::P64 < 4) goto c8sm4; else goto c8sm8;
       c8sm4: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8smd; else goto c8sm6;
       c8sm6: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sm8: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8smd; else goto c8smc;
       c8smd: // global
           HpAlloc = 136;
           R1 = _s8rWf::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8smc: // global
           _s8rWt::I64 = %MO_UU_Conv_W8_W64(I8[_s8rW2::I64 + _s8rW6::I64]);
           call MO_Touch(_s8rW3::P64);
           if (_s8rWt::I64 >= 128) goto c8smP; else goto c8snh;
       c8smP: // global
           _s8rWw::I64 = _s8rWt::I64 + 56320;
           if (_s8rWw::I64 > 1114111) goto c8smx; else goto c8smN;
       c8smx: // global
           Hp = Hp - 136;
           R2 = _s8rWw::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8smN: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWw::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8snh: // global
           if (_s8rWt::I64 > 1114111) goto c8sn0; else goto c8sng;
       c8sn0: // global
           Hp = Hp - 136;
           R2 = _s8rWt::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sng: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWt::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sly_info" {
     block_c8sly_info:
         const _c8sly;
         const 323341;
         const 21474836510;
         const S8rYU_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.268417609 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8so3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode_info" {
     GHC.IO.Encoding.Failure.recoverDecode_info:
         const GHC.IO.Encoding.Failure.recoverDecode_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S8rYU_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.275868422 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8soh: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8sol; else goto c8som;
       c8sol: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8som: // global
           I64[Sp - 24] = block_c8soe_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8spQ; else goto c8sof;
       u8spQ: // global
           call _c8soe(R1) args: 0, res: 0, upd: 0;
       c8sof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode1_info" {
     GHC.IO.Encoding.Failure.recoverEncode1_info:
         const GHC.IO.Encoding.Failure.recoverEncode1_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const S8rYU_srt+128;
 },
 _c8soe() //  [R1]
         { []
         }
     {offset
       c8soe: // global
           I64[Sp - 48] = block_c8sok_info;
           _s8rWZ::P64 = R1;
           _s8rX1::P64 = P64[R1 + 7];
           _s8rX2::P64 = P64[R1 + 15];
           _s8rX0::I64 = I64[R1 + 23];
           _s8rX3::I64 = I64[R1 + 31];
           _s8rX4::I64 = I64[R1 + 39];
           _s8rX5::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8rX1::P64;
           P64[Sp - 32] = _s8rX2::P64;
           I64[Sp - 24] = _s8rX3::I64;
           I64[Sp - 16] = _s8rX4::I64;
           I64[Sp - 8] = _s8rX5::I64;
           I64[Sp] = _s8rX0::I64;
           P64[Sp + 16] = _s8rWZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8spP; else goto c8soo;
       u8spP: // global
           call _c8sok(R1) args: 0, res: 0, upd: 0;
       c8soo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8soe_info" {
     block_c8soe_info:
         const _c8soe;
         const 2;
         const 4294967326;
         const S8rYU_srt+136;
 },
 _c8sok() //  [R1]
         { []
         }
     {offset
       c8sok: // global
           _s8rWV::P64 = P64[Sp + 56];
           _s8rX8::P64 = P64[R1 + 7];
           _s8rX9::P64 = P64[R1 + 15];
           _s8rX7::I64 = I64[R1 + 23];
           _s8rXa::I64 = I64[R1 + 31];
           _s8rXb::I64 = I64[R1 + 39];
           _s8rXc::I64 = I64[R1 + 47];
           _s8rXf::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8sot_info;
           _s8rX6::P64 = R1;
           R1 = _s8rWV::P64;
           P64[Sp - 48] = _s8rX8::P64;
           P64[Sp - 40] = _s8rX9::P64;
           I64[Sp - 32] = _s8rXa::I64;
           I64[Sp - 24] = _s8rXb::I64;
           I64[Sp - 16] = _s8rXc::I64;
           I64[Sp - 8] = _s8rXf::I64;
           I64[Sp] = _s8rX7::I64;
           P64[Sp + 56] = _s8rX6::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8spR; else goto c8sov;
       u8spR: // global
           call _c8sot(R1) args: 0, res: 0, upd: 0;
       c8sov: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sok_info" {
     block_c8sok_info:
         const _c8sok;
         const 3848;
         const 4294967326;
         const S8rYU_srt+136;
 },
 _c8sot() //  [R1]
         { []
         }
     {offset
       c8sot: // global
           _s8rX0::I64 = I64[Sp + 104];
           _s8rX1::P64 = P64[Sp + 64];
           _s8rX2::P64 = P64[Sp + 72];
           _s8rX3::I64 = I64[Sp + 80];
           _s8rX4::I64 = I64[Sp + 88];
           _s8rX5::I64 = I64[Sp + 96];
           _s8rX6::P64 = P64[Sp + 112];
           _c8spM::P64 = R1 & 7;
           if (_c8spM::P64 < 3) goto u8spN; else goto u8spO;
       u8spN: // global
           if (_c8spM::P64 < 2) goto c8soB; else goto c8soJ;
       c8soB: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8soJ: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8soS; else goto c8soL;
       c8soL: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8spO: // global
           _s8rXf::I64 = I64[Sp + 48];
           if (_c8spM::P64 < 4) goto c8soN; else goto c8sp6;
       c8soN: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8soS; else goto c8soR;
       c8soS: // global
           HpAlloc = 80;
           R1 = _s8rXh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8soR: // global
           if (_s8rXf::I64 == 63) goto c8sp5; else goto c8soY;
       c8sp5: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8soY: // global
           _s8rWZ::P64 = P64[Sp + 120];
           I32[_s8rX0::I64 + (_s8rX4::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8rX1::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8rWZ::P64;
           P64[Hp - 56] = _s8rX6::P64;
           _c8soW::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8soW::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sp6: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8spb; else goto c8spa;
       c8spb: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8spa: // global
           if (%MO_S_Gt_W64(56448, _s8rXf::I64)) goto c8spo; else goto c8spL;
       c8spL: // global
           if (%MO_S_Ge_W64(_s8rXf::I64, 56576)) goto c8spo; else goto c8spK;
       c8spo: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8spK: // global
           _s8rX7::I64 = I64[Sp + 56];
           _s8rX8::P64 = P64[Sp + 8];
           _s8rX9::P64 = P64[Sp + 16];
           _s8rXa::I64 = I64[Sp + 24];
           _s8rXb::I64 = I64[Sp + 32];
           _s8rXc::I64 = I64[Sp + 40];
           I8[_s8rX7::I64 + _s8rXc::I64] = %MO_UU_Conv_W64_W8(_s8rXf::I64);
           call MO_Touch(_s8rX8::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rX8::P64;
           P64[Hp - 112] = _s8rX9::P64;
           I64[Hp - 104] = _s8rX7::I64;
           I64[Hp - 96] = _s8rXa::I64;
           I64[Hp - 88] = _s8rXb::I64;
           I64[Hp - 80] = _s8rXc::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sot_info" {
     block_c8sot_info:
         const _c8sot;
         const 499471;
         const 4294967326;
         const S8rYU_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.288589197 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sqt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode_info" {
     GHC.IO.Encoding.Failure.recoverEncode_info:
         const GHC.IO.Encoding.Failure.recoverEncode_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S8rYU_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.293007866 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { []
         }
     {offset
       c8sqH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sqI; else goto c8sqJ;
       c8sqI: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sqJ: // global
           I64[Sp - 8] = block_c8sqE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8srj; else goto c8sqF;
       u8srj: // global
           call _c8sqE(R1) args: 0, res: 0, upd: 0;
       c8sqF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.isSurrogate_info" {
     GHC.IO.Encoding.Failure.isSurrogate_info:
         const GHC.IO.Encoding.Failure.isSurrogate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c8sqE() //  [R1]
         { []
         }
     {offset
       c8sqE: // global
           _s8rXI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8rXI::I64)) goto c8sqZ; else goto c8src;
       c8sqZ: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sr7; else goto c8sqX;
       c8sqX: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8src: // global
           if (%MO_S_Gt_W64(_s8rXI::I64, 56319)) goto c8sra; else goto c8srb;
       c8sra: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sr7; else goto c8sr8;
       c8sr7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sr8: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8srb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sqE_info" {
     block_c8sqE_info:
         const _c8sqE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.299284179 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.301114125 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.302787855 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.30443952 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.306205857 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.308221353 UTC

[section ""cstring" . i8seL_str" {
     i8seL_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8srG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry;
         const 4294967296;
         const 3;
         const i8seL_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.311553796 UTC

[section ""cstring" . i8seN_str" {
     i8seN_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8srM: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry;
         const 4294967296;
         const 4294967299;
         const i8seN_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.314824661 UTC

[section ""cstring" . i8seP_str" {
     i8seP_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8srS: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry;
         const 4294967296;
         const 8589934595;
         const i8seP_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.31808647 UTC

[section ""cstring" . i8seR_str" {
     i8seR_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8srY: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.RoundtripFailure_con_info" {
     GHC.IO.Encoding.Failure.RoundtripFailure_con_info:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_entry;
         const 4294967296;
         const 12884901891;
         const i8seR_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.321735303 UTC

[section ""relreadonly" . S8rYU_srt" {
     S8rYU_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.743672784 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:35.74472289 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.747214318 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { []
         }
     {offset
       c8sug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suh; else goto c8sui;
       c8suh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sui: // global
           (_c8sud::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sud::I64 == 0) goto c8suf; else goto c8sue;
       c8suf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sue: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sud::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.751061129 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.753382395 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { []
         }
     {offset
       c8suy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suz; else goto c8suA;
       c8suz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8suA: // global
           (_c8suv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8suv::I64 == 0) goto c8sux; else goto c8suw;
       c8sux: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8suw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8suv::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.75694562 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.759241842 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { []
         }
     {offset
       c8suQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suR; else goto c8suS;
       c8suR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8suS: // global
           (_c8suN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8suN::I64 == 0) goto c8suP; else goto c8suO;
       c8suP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8suO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8suN::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.76294677 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.765231622 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { []
         }
     {offset
       c8sv8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sv9; else goto c8sva;
       c8sv9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sva: // global
           (_c8sv5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sv5::I64 == 0) goto c8sv7; else goto c8sv6;
       c8sv7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sv6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sv5::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.771388531 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c8svw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8svx; else goto c8svy;
       c8svx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8svy: // global
           I64[Sp - 16] = block_c8svn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8svN; else goto c8svo;
       u8svN: // global
           call _c8svn(R1) args: 0, res: 0, upd: 0;
       c8svo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$w$cshowsPrec_info" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_info:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_entry;
         const 0;
         const 133143986190;
         const 8589934607;
         const S8svO_srt;
 },
 _c8svn() //  [R1]
         { []
         }
     {offset
       c8svn: // global
           _s8ss6::P64 = P64[Sp + 8];
           _c8svv::P64 = R1 & 7;
           if (_c8svv::P64 < 3) goto u8svL; else goto u8svM;
       u8svL: // global
           if (_c8svv::P64 < 2) goto c8svr; else goto c8svs;
       c8svr: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8svs: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8svM: // global
           if (_c8svv::P64 < 4) goto c8svt; else goto c8svu;
       c8svt: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8svu: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8svn_info" {
     block_c8svn_info:
         const _c8svn;
         const 1;
         const 64424509470;
         const S8svO_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.777017708 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { []
         }
     {offset
       c8sw4: // global
           _s8ss9::P64 = R3;
           R3 = R4;
           R2 = _s8ss9::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry;
         const 0;
         const 4294967310;
         const 12884901911;
         const S8svO_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.782020856 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c8swo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8swp; else goto c8swq;
       c8swp: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8swq: // global
           I64[Sp - 8] = block_c8swf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8swF; else goto c8swg;
       u8swF: // global
           call _c8swf(R1) args: 0, res: 0, upd: 0;
       c8swg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry;
         const 0;
         const 133143986190;
         const 4294967301;
         const S8svO_srt+8;
 },
 _c8swf() //  [R1]
         { []
         }
     {offset
       c8swf: // global
           _c8swn::P64 = R1 & 7;
           if (_c8swn::P64 < 3) goto u8swD; else goto u8swE;
       u8swD: // global
           if (_c8swn::P64 < 2) goto c8swj; else goto c8swk;
       c8swj: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8swk: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8swE: // global
           if (_c8swn::P64 < 4) goto c8swl; else goto c8swm;
       c8swl: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8swm: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8swf_info" {
     block_c8swf_info:
         const _c8swf;
         const 0;
         const 64424509470;
         const S8svO_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.78769883 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { []
         }
     {offset
       c8swZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S8svO_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.791164107 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.792961154 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.795299228 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { []
         }
     {offset
       c8sxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxf; else goto c8sxg;
       c8sxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxg: // global
           (_c8sxb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxb::I64 == 0) goto c8sxd; else goto c8sxc;
       c8sxd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxb::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.799014943 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.801635516 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { []
         }
     {offset
       c8sxw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxx; else goto c8sxy;
       c8sxx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxy: // global
           (_c8sxt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxt::I64 == 0) goto c8sxv; else goto c8sxu;
       c8sxv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxt::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.805811785 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.807941855 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { []
         }
     {offset
       c8sxO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxP; else goto c8sxQ;
       c8sxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxQ: // global
           (_c8sxL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxL::I64 == 0) goto c8sxN; else goto c8sxM;
       c8sxN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxL::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.812717435 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { []
         }
     {offset
       c8syc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8syd; else goto c8sye;
       c8syd: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sye: // global
           I64[Sp - 8] = block_c8sy3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8syt; else goto c8sy4;
       u8syt: // global
           call _c8sy3(R1) args: 0, res: 0, upd: 0;
       c8sy4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_info" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_info:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8svO_srt+48;
 },
 _c8sy3() //  [R1]
         { []
         }
     {offset
       c8sy3: // global
           _c8syb::P64 = R1 & 7;
           if (_c8syb::P64 < 3) goto u8syr; else goto u8sys;
       u8syr: // global
           if (_c8syb::P64 < 2) goto c8sy7; else goto c8sy8;
       c8sy7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sy8: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8sys: // global
           if (_c8syb::P64 < 4) goto c8sy9; else goto c8sya;
       c8sy9: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sya: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sy3_info" {
     block_c8sy3_info:
         const _c8sy3;
         const 0;
         const 30064771102;
         const S8svO_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.818452826 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.82072525 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { []
         }
     {offset
       c8syR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8syS; else goto c8syT;
       c8syS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8syT: // global
           (_c8syO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8syO::I64 == 0) goto c8syQ; else goto c8syP;
       c8syQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8syP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8syO::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode6_info" {
     GHC.IO.Encoding.Failure.recoverDecode6_info:
         const GHC.IO.Encoding.Failure.recoverDecode6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.824357554 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.826925673 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { []
         }
     {offset
       c8sz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sza; else goto c8szb;
       c8sza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szb: // global
           (_c8sz6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sz6::I64 == 0) goto c8sz8; else goto c8sz7;
       c8sz8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sz7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sz6::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode4_info" {
     GHC.IO.Encoding.Failure.recoverDecode4_info:
         const GHC.IO.Encoding.Failure.recoverDecode4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.830579462 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.832857951 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { []
         }
     {offset
       c8szr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8szs; else goto c8szt;
       c8szs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szt: // global
           (_c8szo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szo::I64 == 0) goto c8szq; else goto c8szp;
       c8szq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szo::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode2_info" {
     GHC.IO.Encoding.Failure.recoverDecode2_info:
         const GHC.IO.Encoding.Failure.recoverDecode2_entry;
         const 0;
         const 12884901909;
         const S8svO_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.836359133 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.839750157 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { []
         }
     {offset
       c8szJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8szK; else goto c8szL;
       c8szK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szL: // global
           (_c8szG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szG::I64 == 0) goto c8szI; else goto c8szH;
       c8szI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szG::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode6_info" {
     GHC.IO.Encoding.Failure.recoverEncode6_info:
         const GHC.IO.Encoding.Failure.recoverEncode6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.843638075 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.846203161 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { []
         }
     {offset
       c8sA1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sA2; else goto c8sA3;
       c8sA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sA3: // global
           (_c8szY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szY::I64 == 0) goto c8sA0; else goto c8szZ;
       c8sA0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szY::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode4_info" {
     GHC.IO.Encoding.Failure.recoverEncode4_info:
         const GHC.IO.Encoding.Failure.recoverEncode4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.850111346 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.852604829 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { []
         }
     {offset
       c8sAj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sAk; else goto c8sAl;
       c8sAk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sAl: // global
           (_c8sAg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sAg::I64 == 0) goto c8sAi; else goto c8sAh;
       c8sAi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sAh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sAg::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode2_info" {
     GHC.IO.Encoding.Failure.recoverEncode2_info:
         const GHC.IO.Encoding.Failure.recoverEncode2_entry;
         const 0;
         const 21474836501;
         const S8svO_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.856781896 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.858493255 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.860152783 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.861944623 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.863656074 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.868194628 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.87041485 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.872474808 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.875244454 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.877160288 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.879744559 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.882048062 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.884029859 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.88610904 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.888176344 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.890651275 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.892393326 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.894564553 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.896795068 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.898846799 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.900875145 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.90825715 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sAW: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8sB0; else goto c8sB1;
       c8sB0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sB1: // global
           I64[Sp - 24] = block_c8sAT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sCV; else goto c8sAU;
       u8sCV: // global
           call _c8sAT(R1) args: 0, res: 0, upd: 0;
       c8sAU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode1_info" {
     GHC.IO.Encoding.Failure.recoverDecode1_info:
         const GHC.IO.Encoding.Failure.recoverDecode1_entry;
         const 0;
         const 30064771086;
         const 17179869207;
         const S8svO_srt+104;
 },
 _c8sAT() //  [R1]
         { []
         }
     {offset
       c8sAT: // global
           I64[Sp - 40] = block_c8sAZ_info;
           _s8ssn::P64 = P64[R1 + 7];
           _s8sso::P64 = P64[R1 + 15];
           _s8ssm::I64 = I64[R1 + 23];
           _s8ssp::I64 = I64[R1 + 31];
           _s8ssq::I64 = I64[R1 + 39];
           _s8ssr::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8sso::P64;
           I64[Sp - 24] = _s8ssp::I64;
           I64[Sp - 16] = _s8ssq::I64;
           I64[Sp - 8] = _s8ssr::I64;
           P64[Sp] = _s8ssn::P64;
           I64[Sp + 16] = _s8ssm::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8sCU; else goto c8sB3;
       u8sCU: // global
           call _c8sAZ(R1) args: 0, res: 0, upd: 0;
       c8sB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sAT_info" {
     block_c8sAT_info:
         const _c8sAT;
         const 2;
         const 21474836510;
         const S8svO_srt+104;
 },
 _c8sAZ() //  [R1]
         { []
         }
     {offset
       c8sAZ: // global
           I64[Sp - 48] = block_c8sB7_info;
           _s8sss::P64 = R1;
           _s8ssu::P64 = P64[R1 + 7];
           _s8ssv::P64 = P64[R1 + 15];
           _s8sst::I64 = I64[R1 + 23];
           _s8ssw::I64 = I64[R1 + 31];
           _s8ssx::I64 = I64[R1 + 39];
           _s8ssy::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8ssu::P64;
           P64[Sp - 32] = _s8ssv::P64;
           I64[Sp - 24] = _s8ssw::I64;
           I64[Sp - 16] = _s8ssx::I64;
           I64[Sp - 8] = _s8ssy::I64;
           I64[Sp] = _s8sst::I64;
           P64[Sp + 48] = _s8sss::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sCW; else goto c8sB9;
       u8sCW: // global
           call _c8sB7(R1) args: 0, res: 0, upd: 0;
       c8sB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sAZ_info" {
     block_c8sAZ_info:
         const _c8sAZ;
         const 4999;
         const 21474836510;
         const S8svO_srt+104;
 },
 _c8sB7() //  [R1]
         { []
         }
     {offset
       c8sB7: // global
           _s8ssm::I64 = I64[Sp + 104];
           _s8ssn::P64 = P64[Sp + 88];
           _s8sso::P64 = P64[Sp + 56];
           _s8ssp::I64 = I64[Sp + 64];
           _s8ssq::I64 = I64[Sp + 72];
           _s8ssr::I64 = I64[Sp + 80];
           _c8sCR::P64 = R1 & 7;
           if (_c8sCR::P64 < 3) goto u8sCS; else goto u8sCT;
       u8sCS: // global
           if (_c8sCR::P64 < 2) goto c8sBf; else goto c8sBn;
       c8sBf: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sBn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8sBq; else goto c8sBp;
       c8sBq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sBp: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sCT: // global
           _s8sst::I64 = I64[Sp + 48];
           _s8ssu::P64 = P64[Sp + 8];
           _s8ssv::P64 = P64[Sp + 16];
           _s8ssw::I64 = I64[Sp + 24];
           _s8ssx::I64 = I64[Sp + 32];
           _s8ssy::I64 = I64[Sp + 40];
           if (_c8sCR::P64 < 4) goto c8sBD; else goto c8sBH;
       c8sBD: // global
           Hp = Hp + 136;
           _s8ssz::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sBM; else goto c8sBF;
       c8sBF: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sBH: // global
           Hp = Hp + 136;
           _s8ssz::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sBM; else goto c8sBL;
       c8sBM: // global
           HpAlloc = 136;
           R1 = _s8ssz::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sBL: // global
           _s8ssN::I64 = %MO_UU_Conv_W8_W64(I8[_s8ssm::I64 + _s8ssq::I64]);
           call MO_Touch(_s8ssn::P64);
           if (_s8ssN::I64 >= 128) goto c8sCo; else goto c8sCQ;
       c8sCo: // global
           _s8ssQ::I64 = _s8ssN::I64 + 56320;
           if (_s8ssQ::I64 > 1114111) goto c8sC6; else goto c8sCm;
       c8sC6: // global
           Hp = Hp - 136;
           R2 = _s8ssQ::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sCm: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8ssQ::I64);
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sCQ: // global
           if (_s8ssN::I64 > 1114111) goto c8sCz; else goto c8sCP;
       c8sCz: // global
           Hp = Hp - 136;
           R2 = _s8ssN::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sCP: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8ssN::I64);
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sB7_info" {
     block_c8sB7_info:
         const _c8sB7;
         const 323341;
         const 21474836510;
         const S8svO_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.923455907 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sDQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverDecode_info" {
     GHC.IO.Encoding.Failure.recoverDecode_info:
         const GHC.IO.Encoding.Failure.recoverDecode_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S8svO_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.93112932 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sE4: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8sE8; else goto c8sE9;
       c8sE8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sE9: // global
           I64[Sp - 24] = block_c8sE1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sFD; else goto c8sE2;
       u8sFD: // global
           call _c8sE1(R1) args: 0, res: 0, upd: 0;
       c8sE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode1_info" {
     GHC.IO.Encoding.Failure.recoverEncode1_info:
         const GHC.IO.Encoding.Failure.recoverEncode1_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const S8svO_srt+128;
 },
 _c8sE1() //  [R1]
         { []
         }
     {offset
       c8sE1: // global
           I64[Sp - 48] = block_c8sE7_info;
           _s8stj::P64 = R1;
           _s8stl::P64 = P64[R1 + 7];
           _s8stm::P64 = P64[R1 + 15];
           _s8stk::I64 = I64[R1 + 23];
           _s8stn::I64 = I64[R1 + 31];
           _s8sto::I64 = I64[R1 + 39];
           _s8stp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8stl::P64;
           P64[Sp - 32] = _s8stm::P64;
           I64[Sp - 24] = _s8stn::I64;
           I64[Sp - 16] = _s8sto::I64;
           I64[Sp - 8] = _s8stp::I64;
           I64[Sp] = _s8stk::I64;
           P64[Sp + 16] = _s8stj::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sFC; else goto c8sEb;
       u8sFC: // global
           call _c8sE7(R1) args: 0, res: 0, upd: 0;
       c8sEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sE1_info" {
     block_c8sE1_info:
         const _c8sE1;
         const 2;
         const 4294967326;
         const S8svO_srt+136;
 },
 _c8sE7() //  [R1]
         { []
         }
     {offset
       c8sE7: // global
           _s8stf::P64 = P64[Sp + 56];
           _s8sts::P64 = P64[R1 + 7];
           _s8stt::P64 = P64[R1 + 15];
           _s8str::I64 = I64[R1 + 23];
           _s8stu::I64 = I64[R1 + 31];
           _s8stv::I64 = I64[R1 + 39];
           _s8stw::I64 = I64[R1 + 47];
           _s8stz::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8sEg_info;
           _s8stq::P64 = R1;
           R1 = _s8stf::P64;
           P64[Sp - 48] = _s8sts::P64;
           P64[Sp - 40] = _s8stt::P64;
           I64[Sp - 32] = _s8stu::I64;
           I64[Sp - 24] = _s8stv::I64;
           I64[Sp - 16] = _s8stw::I64;
           I64[Sp - 8] = _s8stz::I64;
           I64[Sp] = _s8str::I64;
           P64[Sp + 56] = _s8stq::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8sFE; else goto c8sEi;
       u8sFE: // global
           call _c8sEg(R1) args: 0, res: 0, upd: 0;
       c8sEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sE7_info" {
     block_c8sE7_info:
         const _c8sE7;
         const 3848;
         const 4294967326;
         const S8svO_srt+136;
 },
 _c8sEg() //  [R1]
         { []
         }
     {offset
       c8sEg: // global
           _s8stk::I64 = I64[Sp + 104];
           _s8stl::P64 = P64[Sp + 64];
           _s8stm::P64 = P64[Sp + 72];
           _s8stn::I64 = I64[Sp + 80];
           _s8sto::I64 = I64[Sp + 88];
           _s8stp::I64 = I64[Sp + 96];
           _s8stq::P64 = P64[Sp + 112];
           _c8sFz::P64 = R1 & 7;
           if (_c8sFz::P64 < 3) goto u8sFA; else goto u8sFB;
       u8sFA: // global
           if (_c8sFz::P64 < 2) goto c8sEo; else goto c8sEw;
       c8sEo: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sEw: // global
           Hp = Hp + 80;
           _s8stB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sEF; else goto c8sEy;
       c8sEy: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8stq::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sFB: // global
           _s8stz::I64 = I64[Sp + 48];
           if (_c8sFz::P64 < 4) goto c8sEA; else goto c8sET;
       c8sEA: // global
           Hp = Hp + 80;
           _s8stB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sEF; else goto c8sEE;
       c8sEF: // global
           HpAlloc = 80;
           R1 = _s8stB::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sEE: // global
           if (_s8stz::I64 == 63) goto c8sES; else goto c8sEL;
       c8sES: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8stq::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sEL: // global
           _s8stj::P64 = P64[Sp + 120];
           I32[_s8stk::I64 + (_s8sto::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8stl::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8stj::P64;
           P64[Hp - 56] = _s8stq::P64;
           _c8sEJ::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8sEJ::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sET: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8sEY; else goto c8sEX;
       c8sEY: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sEX: // global
           if (%MO_S_Gt_W64(56448, _s8stz::I64)) goto c8sFb; else goto c8sFy;
       c8sFy: // global
           if (%MO_S_Ge_W64(_s8stz::I64, 56576)) goto c8sFb; else goto c8sFx;
       c8sFb: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sFx: // global
           _s8str::I64 = I64[Sp + 56];
           _s8sts::P64 = P64[Sp + 8];
           _s8stt::P64 = P64[Sp + 16];
           _s8stu::I64 = I64[Sp + 24];
           _s8stv::I64 = I64[Sp + 32];
           _s8stw::I64 = I64[Sp + 40];
           I8[_s8str::I64 + _s8stw::I64] = %MO_UU_Conv_W64_W8(_s8stz::I64);
           call MO_Touch(_s8sts::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8sts::P64;
           P64[Hp - 112] = _s8stt::P64;
           I64[Hp - 104] = _s8str::I64;
           I64[Hp - 96] = _s8stu::I64;
           I64[Hp - 88] = _s8stv::I64;
           I64[Hp - 80] = _s8stw::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sEg_info" {
     block_c8sEg_info:
         const _c8sEg;
         const 499471;
         const 4294967326;
         const S8svO_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.943617239 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sGr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.recoverEncode_info" {
     GHC.IO.Encoding.Failure.recoverEncode_info:
         const GHC.IO.Encoding.Failure.recoverEncode_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S8svO_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.948238011 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { []
         }
     {offset
       c8sGF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sGG; else goto c8sGH;
       c8sGG: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sGH: // global
           I64[Sp - 8] = block_c8sGC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sHh; else goto c8sGD;
       u8sHh: // global
           call _c8sGC(R1) args: 0, res: 0, upd: 0;
       c8sGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.isSurrogate_info" {
     GHC.IO.Encoding.Failure.isSurrogate_info:
         const GHC.IO.Encoding.Failure.isSurrogate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c8sGC() //  [R1]
         { []
         }
     {offset
       c8sGC: // global
           _s8su2::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8su2::I64)) goto c8sGX; else goto c8sHa;
       c8sGX: // global
           if (%MO_S_Gt_W64(56320, _s8su2::I64)) goto c8sH5; else goto c8sGV;
       c8sGV: // global
           R1 = I64[(%MO_S_Le_W64(_s8su2::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sHa: // global
           if (%MO_S_Gt_W64(_s8su2::I64, 56319)) goto c8sH8; else goto c8sH9;
       c8sH8: // global
           if (%MO_S_Gt_W64(56320, _s8su2::I64)) goto c8sH5; else goto c8sH6;
       c8sH5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sH6: // global
           R1 = I64[(%MO_S_Le_W64(_s8su2::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sH9: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sGC_info" {
     block_c8sGC_info:
         const _c8sGC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.955005999 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.957089914 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.959685672 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.961413121 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.963128324 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.965192187 UTC

[section ""cstring" . i8sHK_str" {
     i8sHK_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8sHJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry;
         const 4294967296;
         const 3;
         const i8sHK_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.968914932 UTC

[section ""cstring" . i8sHR_str" {
     i8sHR_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8sHQ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry;
         const 4294967296;
         const 4294967299;
         const i8sHR_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.972250038 UTC

[section ""cstring" . i8sHY_str" {
     i8sHY_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8sHX: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry;
         const 4294967296;
         const 8589934595;
         const i8sHY_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.975591487 UTC

[section ""cstring" . i8sI5_str" {
     i8sI5_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 },
 GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { []
         }
     {offset
       c8sI4: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Failure.RoundtripFailure_con_info" {
     GHC.IO.Encoding.Failure.RoundtripFailure_con_info:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_entry;
         const 4294967296;
         const 12884901891;
         const i8sI5_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:35.97923601 UTC

[section ""relreadonly" . S8svO_srt" {
     S8svO_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]

