
==================== Raw Cmm ====================
2018-03-16 16:05:00.093559867 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:00.094637171 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.096337587 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.098032518 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.099681403 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.101365819 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.103060364 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.10540354 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { []
         }
     {offset
       c9VCI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VCJ; else goto c9VCK;
       c9VCJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VCK: // global
           (_c9VCF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VCF::I64 == 0) goto c9VCH; else goto c9VCG;
       c9VCH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VCG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VCF::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_r9V6z_info" {
     lvl1_r9V6z_info:
         const lvl1_r9V6z_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.109305968 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { []
         }
     {offset
       c9VCY: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding16_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const S9Vc5_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.11275968 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { []
         }
     {offset
       c9VD9: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding15_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.117220039 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { []
         }
     {offset
       c9VDl: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding14_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.120220623 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.122428171 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { []
         }
     {offset
       c9VDA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VDB; else goto c9VDC;
       c9VDB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VDC: // global
           (_c9VDx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VDx::I64 == 0) goto c9VDz; else goto c9VDy;
       c9VDz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VDy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VDx::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding12_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.133204009 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9V7x_entry() //  [R1]
         { []
         }
     {offset
       c9VEF: // global
           (_s9V7q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7q::I64) == (-1) :: W32) goto c9VEE; else goto c9VED;
       c9VEE: // global
           (_s9V7v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7v::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9VED: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s9V7x_info" {
     sat_s9V7x_info:
         const sat_s9V7x_entry;
         const 4294967296;
         const 4294967306;
         const 4294967299;
         const S9Vc5_srt+16;
 },
 sat_s9V7l_entry() //  [R1]
         { []
         }
     {offset
       c9VEY: // global
           _s9V7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VEZ; else goto c9VF0;
       c9VF0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VF2; else goto c9VF1;
       c9VF2: // global
           HpAlloc = 16;
           goto c9VEZ;
       c9VEZ: // global
           R1 = _s9V7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VF1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V7l::P64;
           _s9V6L::P64 = P64[_s9V7l::P64 + 16];
           _s9V7h::I64 = I64[_s9V7l::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9V7h::I64;
           R2 = Hp - 7;
           R1 = _s9V6L::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9V7l_info" {
     sat_s9V7l_info:
         const sat_s9V7l_entry;
         const 4294967297;
         const 19;
 },
 sat_s9V7S_entry() //  [R1]
         { []
         }
     {offset
       c9VFg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VFh; else goto c9VFi;
       c9VFh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9VFi: // global
           I64[Sp - 8] = block_c9VFd_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VFE; else goto c9VFe;
       u9VFE: // global
           call _c9VFd(R1) args: 0, res: 0, upd: 0;
       c9VFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s9V7S_info" {
     sat_s9V7S_info:
         const sat_s9V7S_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S9Vc5_srt+16;
 },
 _c9VFd() //  [R1]
         { []
         }
     {offset
       c9VFd: // global
           (_s9V7L::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9V7L::I64) == (-1) :: W32) goto c9VFz; else goto c9VFt;
       c9VFz: // global
           (_s9V7Q::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9V7Q::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9VFt: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VFd_info" {
     block_c9VFd_info:
         const _c9VFd;
         const 0;
         const 4294967326;
         const S9Vc5_srt+16;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       c9VFF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9VFG; else goto c9VFH;
       c9VFG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VFH: // global
           I64[Sp - 40] = block_c9VDO_info;
           _s9V6J::P64 = R3;
           R3 = 0;
           _s9V6I::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9V6I::P64;
           P64[Sp - 24] = _s9V6J::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding11_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_entry;
         const 0;
         const 64424509454;
         const 21474836504;
         const S9Vc5_srt+16;
 },
 _c9VDO() //  [R1]
         { []
         }
     {offset
       c9VDO: // global
           I64[Sp] = block_c9VDV_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VDO_info" {
     block_c9VDO_info:
         const _c9VDO;
         const 4;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VDV() //  [R1]
         { []
         }
     {offset
       c9VDV: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9VGp() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9VDV_info" {
     block_c9VDV_info:
         const _c9VDV;
         const 4;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VGp() //  []
         { []
         }
     {offset
       c9VGp: // global
           _s9V88::P64 = P64[Sp];
           I64[Sp] = block_c9VGs_info;
           R1 = _s9V88::P64;
           if (R1 & 7 != 0) goto u9VHe; else goto c9VGu;
       u9VHe: // global
           call _c9VGs(R1) args: 0, res: 0, upd: 0;
       c9VGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VGs() //  [R1]
         { []
         }
     {offset
       c9VGs: // global
           if (R1 & 7 == 1) goto c9VGA; else goto c9VGF;
       c9VGA: // global
           _s9V6J::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9VE5_info;
           R3 = 0;
           R2 = _s9V6J::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9VGF: // global
           I64[Sp - 8] = block_c9VGD_info;
           _s9V8d::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V8d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VHf; else goto c9VGG;
       u9VHf: // global
           call _c9VGD(R1) args: 0, res: 0, upd: 0;
       c9VGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VGs_info" {
     block_c9VGs_info:
         const _c9VGs;
         const 198;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VE5() //  [R1]
         { []
         }
     {offset
       c9VE5: // global
           I64[Sp] = block_c9VEc_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VE5_info" {
     block_c9VE5_info:
         const _c9VE5;
         const 69;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VEc() //  [R1]
         { []
         }
     {offset
       c9VEc: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9VG1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9VEc_info" {
     block_c9VEc_info:
         const _c9VEc;
         const 69;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VG1() //  []
         { []
         }
     {offset
       c9VG1: // global
           _s9V7V::P64 = P64[Sp];
           I64[Sp] = block_c9VG4_info;
           R1 = _s9V7V::P64;
           if (R1 & 7 != 0) goto u9VHa; else goto c9VG6;
       u9VHa: // global
           call _c9VG4(R1) args: 0, res: 0, upd: 0;
       c9VG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VG4() //  [R1]
         { []
         }
     {offset
       c9VG4: // global
           if (R1 & 7 == 1) goto c9VGc; else goto c9VGh;
       c9VGc: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9VEk() args: 0, res: 0, upd: 0;
       c9VGh: // global
           I64[Sp - 8] = block_c9VGf_info;
           _s9V80::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9V80::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VHb; else goto c9VGi;
       u9VHb: // global
           call _c9VGf(R1) args: 0, res: 0, upd: 0;
       c9VGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VG4_info" {
     block_c9VG4_info:
         const _c9VG4;
         const 455;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VEk() //  []
         { []
         }
     {offset
       c9VEk: // global
           Hp = Hp + 96;
           _s9V7a::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9VFP; else goto c9VFO;
       c9VFP: // global
           HpAlloc = 96;
           I64[Sp] = block_c9VEj_info;
           R1 = _s9V7a::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9VFO: // global
           _s9V6K::P64 = P64[Sp + 40];
           _s9V6L::P64 = P64[Sp + 48];
           _s9V6U::P64 = P64[Sp + 24];
           _s9V6V::I64 = I64[Sp + 16];
           _s9V77::P64 = P64[Sp + 32];
           _s9V78::I64 = I64[Sp + 8];
           I8[_s9V78::I64 + _s9V7a::I64] = 0 :: W8;
           (_s9V7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9V78::I64, _s9V6V::I64);
           if (_s9V7g::I64 == (-1)) goto c9VFV; else goto c9VFS;
       c9VFV: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9VF4_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VFS: // global
           call MO_Touch(_s9V77::P64);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7x_info;
           I64[Hp - 80] = _s9V7g::I64;
           I64[Hp - 72] = sat_s9V7l_info;
           P64[Hp - 56] = _s9V6L::P64;
           I64[Hp - 48] = _s9V7g::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9VEj() //  [R1]
         { []
         }
     {offset
       c9VEj: // global
           I64[Sp] = R1;
           call _c9VEk() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9VEj_info" {
     block_c9VEj_info:
         const _c9VEj;
         const 198;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VF4() //  [R1]
         { []
         }
     {offset
       c9VF4: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9VFY; else goto c9VFX;
       c9VFY: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VFX: // global
           _s9V6K::P64 = P64[Sp + 24];
           _s9V6L::P64 = P64[Sp + 32];
           _s9V6U::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9V6U::P64);
           I64[Hp - 88] = sat_s9V7S_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9V6L::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9V6K::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VF4_info" {
     block_c9VF4_info:
         const _c9VF4;
         const 4;
         const 4294967326;
         const S9Vc5_srt+16;
 },
 _c9VGf() //  [R1]
         { []
         }
     {offset
       c9VGf: // global
           _s9V7W::I64 = I64[Sp + 16];
           _s9V80::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V7W::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V80::P64;
           I64[Sp + 16] = _s9V7W::I64 + 1;
           Sp = Sp + 8;
           call _c9VG1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9VGf_info" {
     block_c9VGf_info:
         const _c9VGf;
         const 904;
         const 47244640286;
         const S9Vc5_srt+16;
 },
 _c9VGD() //  [R1]
         { []
         }
     {offset
       c9VGD: // global
           _s9V89::I64 = I64[Sp + 16];
           _s9V8d::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9V89::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9V8d::P64;
           I64[Sp + 16] = _s9V89::I64 + 1;
           Sp = Sp + 8;
           call _c9VGp() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9VGD_info" {
     block_c9VGD_info:
         const _c9VGD;
         const 391;
         const 47244640286;
         const S9Vc5_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.164529821 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { []
         }
     {offset
       c9VIM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VIN; else goto c9VIO;
       c9VIN: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9VIO: // global
           I64[Sp - 8] = block_c9VIJ_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_r9V6A_info" {
     lvl2_r9V6A_info:
         const lvl2_r9V6A_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _c9VIJ() //  []
         { []
         }
     {offset
       c9VIJ: // global
           (_s9V8p::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9V8p::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VIJ_info" {
     block_c9VIJ_info:
         const _c9VIJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.170003817 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { []
         }
     {offset
       c9VJ6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VJ7; else goto c9VJ8;
       c9VJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJ8: // global
           (_c9VJ1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJ1::I64 == 0) goto c9VJ3; else goto c9VJ2;
       c9VJ3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJ2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJ1::I64;
           I64[Sp - 24] = block_c9VJ4_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.localeEncodingName_info" {
     GHC.IO.Encoding.Iconv.localeEncodingName_info:
         const GHC.IO.Encoding.Iconv.localeEncodingName_entry;
         const 0;
         const 21;
 },
 _c9VJ4() //  [R1]
         { []
         }
     {offset
       c9VJ4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VJ4_info" {
     block_c9VJ4_info:
         const _c9VJ4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.174846053 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.176522908 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.178762796 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { []
         }
     {offset
       c9VJu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VJv; else goto c9VJw;
       c9VJv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJw: // global
           (_c9VJr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJr::I64 == 0) goto c9VJt; else goto c9VJs;
       c9VJt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJr::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.haskellChar_info" {
     GHC.IO.Encoding.Iconv.haskellChar_info:
         const GHC.IO.Encoding.Iconv.haskellChar_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.182770693 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.184931507 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.186567606 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.18870137 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { []
         }
     {offset
       c9VJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VJO; else goto c9VJP;
       c9VJO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VJP: // global
           (_c9VJK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9VJK::I64 == 0) goto c9VJM; else goto c9VJL;
       c9VJM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9VJL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9VJK::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding7_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.20807384 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9V9L_entry() //  [R1]
         { []
         }
     {offset
       c9VLv: // global
           _s9V9L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VLw; else goto c9VLx;
       c9VLx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VLz; else goto c9VLy;
       c9VLz: // global
           HpAlloc = 16;
           goto c9VLw;
       c9VLw: // global
           R1 = _s9V9L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VLy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9L::P64;
           _s9V97::I64 = I64[_s9V9L::P64 + 16];
           _s9V9K::I64 = I64[_s9V9L::P64 + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VLt; else goto c9VLu;
       c9VLt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9V9K::I64, _s9V97::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLu: // global
           if (%MO_S_Ge_W64(_s9V9K::I64, 0)) goto c9VLP; else goto c9VLQ;
       c9VLP: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLQ: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . new_outleft'_s9V9L_info" {
     new_outleft'_s9V9L_info:
         const new_outleft'_s9V9L_entry;
         const 8589934592;
         const 20;
 },
 new_input_s9V9R_entry() //  [R1]
         { []
         }
     {offset
       c9VLZ: // global
           _s9V9R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VM0; else goto c9VM1;
       c9VM1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VM3; else goto c9VM2;
       c9VM3: // global
           HpAlloc = 56;
           goto c9VM0;
       c9VM0: // global
           R1 = _s9V9R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VM2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9V9R::P64;
           _s9V8B::P64 = P64[_s9V9R::P64 + 16];
           _s9V8C::P64 = P64[_s9V9R::P64 + 24];
           _s9V8A::I64 = I64[_s9V9R::P64 + 32];
           _s9V8D::I64 = I64[_s9V9R::P64 + 40];
           _s9V9S::I64 = I64[_s9V9R::P64 + 64];
           if (_s9V9S::I64 != 0) goto c9VLX; else goto c9VLY;
       c9VLX: // global
           _s9V8F::I64 = I64[_s9V9R::P64 + 48];
           _s9V8U::I64 = I64[_s9V9R::P64 + 56];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VMj; else goto c9VMA;
       c9VMj: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 - %MO_S_Shr_W64(_s9V9S::I64,
                                                     _s9V8U::I64);
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VMA: // global
           if (%MO_S_Ge_W64(_s9V9S::I64, 0)) goto c9VMt; else goto c9VMz;
       c9VMt: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VMz: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = _s9V8F::I64 + 1;
           I64[Hp] = _s9V8F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VLY: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9V8B::P64;
           P64[Hp - 32] = _s9V8C::P64;
           I64[Hp - 24] = _s9V8A::I64;
           I64[Hp - 16] = _s9V8D::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . new_input_s9V9R_info" {
     new_input_s9V9R_info:
         const new_input_s9V9R_entry;
         const 21474836482;
         const 15;
 },
 sat_s9Vaa_entry() //  [R1]
         { []
         }
     {offset
       c9VMS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VMZ; else goto c9VN0;
       c9VMZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VMP_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VN4; else goto c9VMQ;
       u9VN4: // global
           call _c9VMP(R1) args: 0, res: 0, upd: 0;
       c9VMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9Vaa_info" {
     sat_s9Vaa_info:
         const sat_s9Vaa_entry;
         const 12884901891;
         const 15;
 },
 _c9VMP() //  [R1]
         { []
         }
     {offset
       c9VMP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VN3; else goto c9VN2;
       c9VN3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VN2: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Va9::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Va9::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VMP_info" {
     block_c9VMP_info:
         const _c9VMP;
         const 1605;
         const 30;
 },
 sat_s9Vaz_entry() //  [R1]
         { []
         }
     {offset
       c9VNo: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VNv; else goto c9VNw;
       c9VNv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VNw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VNl_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VNA; else goto c9VNm;
       u9VNA: // global
           call _c9VNl(R1) args: 0, res: 0, upd: 0;
       c9VNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9Vaz_info" {
     sat_s9Vaz_info:
         const sat_s9Vaz_entry;
         const 12884901891;
         const 15;
 },
 _c9VNl() //  [R1]
         { []
         }
     {offset
       c9VNl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VNz; else goto c9VNy;
       c9VNz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VNy: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9Vay::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9Vay::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VNl_info" {
     block_c9VNl_info:
         const _c9VNl;
         const 1605;
         const 30;
 },
 sat_s9VaK_entry() //  [R1]
         { []
         }
     {offset
       c9VNP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VNW; else goto c9VNX;
       c9VNW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VNX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VNM_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VO1; else goto c9VNN;
       u9VO1: // global
           call _c9VNM(R1) args: 0, res: 0, upd: 0;
       c9VNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VaK_info" {
     sat_s9VaK_info:
         const sat_s9VaK_entry;
         const 12884901891;
         const 15;
 },
 _c9VNM() //  [R1]
         { []
         }
     {offset
       c9VNM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VO0; else goto c9VNZ;
       c9VO0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VNZ: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaJ::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VNM_info" {
     block_c9VNM_info:
         const _c9VNM;
         const 1605;
         const 30;
 },
 sat_s9VaZ_entry() //  [R1]
         { []
         }
     {offset
       c9VOg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9VOn; else goto c9VOo;
       c9VOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9VOd_info;
           _s9V8I::P64 = P64[R1 + 16];
           _s9V8J::P64 = P64[R1 + 24];
           _s9V8H::I64 = I64[R1 + 40];
           _s9V8K::I64 = I64[R1 + 48];
           _s9V8L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9V8H::I64;
           P64[Sp - 48] = _s9V8I::P64;
           P64[Sp - 40] = _s9V8J::P64;
           I64[Sp - 32] = _s9V8K::I64;
           I64[Sp - 24] = _s9V8L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9VOs; else goto c9VOe;
       u9VOs: // global
           call _c9VOd(R1) args: 0, res: 0, upd: 0;
       c9VOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VaZ_info" {
     sat_s9VaZ_info:
         const sat_s9VaZ_entry;
         const 12884901891;
         const 15;
 },
 _c9VOd() //  [R1]
         { []
         }
     {offset
       c9VOd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9VOr; else goto c9VOq;
       c9VOr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VOq: // global
           _s9V8K::I64 = I64[Sp + 32];
           _s9VaY::I64 = _s9V8K::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9V8K::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VaY::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VOd_info" {
     block_c9VOd_info:
         const _c9VOd;
         const 1605;
         const 30;
 },
 sat_s9VaV_entry() //  [R1]
         { []
         }
     {offset
       c9VOA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VOB; else goto c9VOC;
       c9VOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VOC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VOx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9VOK; else goto c9VOy;
       u9VOK: // global
           call _c9VOx(R1) args: 0, res: 0, upd: 0;
       c9VOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VaV_info" {
     sat_s9VaV_info:
         const sat_s9VaV_entry;
         const 1;
         const 16;
 },
 _c9VOx() //  [R1]
         { []
         }
     {offset
       c9VOx: // global
           if (I64[R1 + 7] == 0) goto c9VOJ; else goto c9VOI;
       c9VOJ: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VOI: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VOx_info" {
     block_c9VOx_info:
         const _c9VOx;
         const 0;
         const 30;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c9VOL: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9VOM; else goto c9VON;
       c9VOM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VON: // global
           I64[Sp - 40] = block_c9VK1_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VQ3; else goto c9VK2;
       u9VQ3: // global
           call _c9VK1(R1) args: 0, res: 0, upd: 0;
       c9VK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding6_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_entry;
         const 0;
         const 107374182414;
         const 25769803801;
         const S9Vc5_srt+24;
 },
 _c9VK1() //  [R1]
         { []
         }
     {offset
       c9VK1: // global
           I64[Sp - 40] = block_c9VK6_info;
           _s9V8B::P64 = P64[R1 + 7];
           _s9V8C::P64 = P64[R1 + 15];
           _s9V8A::I64 = I64[R1 + 23];
           _s9V8D::I64 = I64[R1 + 31];
           _s9V8E::I64 = I64[R1 + 39];
           _s9V8F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9V8C::P64;
           I64[Sp - 24] = _s9V8D::I64;
           I64[Sp - 16] = _s9V8E::I64;
           I64[Sp - 8] = _s9V8F::I64;
           P64[Sp] = _s9V8B::P64;
           I64[Sp + 24] = _s9V8A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9VPZ; else goto c9VK7;
       u9VPZ: // global
           call _c9VK6(R1) args: 0, res: 0, upd: 0;
       c9VK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VK1_info" {
     block_c9VK1_info:
         const _c9VK1;
         const 4;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VK6() //  [R1]
         { []
         }
     {offset
       c9VK6: // global
           I64[Sp - 48] = block_c9VKb_info;
           R2 = 8;
           _s9V8I::P64 = P64[R1 + 7];
           _s9V8J::P64 = P64[R1 + 15];
           _s9V8H::I64 = I64[R1 + 23];
           _s9V8K::I64 = I64[R1 + 31];
           _s9V8L::I64 = I64[R1 + 39];
           _s9V8M::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9V8I::P64;
           P64[Sp - 32] = _s9V8J::P64;
           I64[Sp - 24] = _s9V8K::I64;
           I64[Sp - 16] = _s9V8L::I64;
           I64[Sp - 8] = _s9V8M::I64;
           I64[Sp] = _s9V8H::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VK6_info" {
     block_c9VK6_info:
         const _c9VK6;
         const 9097;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKb() //  [R1]
         { []
         }
     {offset
       c9VKb: // global
           I64[Sp] = block_c9VKd_info;
           _s9V8S::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9V8S::P64;
           if (R1 & 7 != 0) goto u9VQ0; else goto c9VKe;
       u9VQ0: // global
           call _c9VKd(R1) args: 0, res: 0, upd: 0;
       c9VKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKb_info" {
     block_c9VKb_info:
         const _c9VKb;
         const 585487;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKd() //  [R1]
         { []
         }
     {offset
       c9VKd: // global
           _s9V8A::I64 = I64[Sp + 112];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V8U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VPA; else goto c9VPB;
       c9VPA: // global
           _s9V8W::I64 = I64[Sp + 72] << _s9V8U::I64;
           goto s9V8V;
       c9VPB: // global
           _s9V8W::I64 = 0;
           goto s9V8V;
       s9V8V: // global
           _s9V8X::I64 = _s9V8S::P64 + 16;
           I64[_s9V8X::I64] = _s9V8A::I64 + _s9V8W::I64;
           I64[Sp - 16] = block_c9VKt_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V8X::I64;
           I64[Sp] = _s9V8U::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKd_info" {
     block_c9VKd_info:
         const _c9VKd;
         const 585487;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKt() //  [R1]
         { []
         }
     {offset
       c9VKt: // global
           I64[Sp] = block_c9VKv_info;
           _s9V95::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9V95::P64;
           if (R1 & 7 != 0) goto u9VQ1; else goto c9VKw;
       u9VQ1: // global
           call _c9VKv(R1) args: 0, res: 0, upd: 0;
       c9VKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKt_info" {
     block_c9VKt_info:
         const _c9VKt;
         const 2342097;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKv() //  [R1]
         { []
         }
     {offset
       c9VKv: // global
           _s9V8H::I64 = I64[Sp + 64];
           _s9V95::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VPv; else goto c9VPw;
       c9VPv: // global
           _s9V99::I64 = I64[Sp + 56] << _s9V97::I64;
           goto s9V98;
       c9VPw: // global
           _s9V99::I64 = 0;
           goto s9V98;
       s9V98: // global
           _s9V9a::I64 = _s9V95::P64 + 16;
           I64[_s9V9a::I64] = _s9V8H::I64 + _s9V99::I64;
           I64[Sp - 16] = block_c9VKL_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9V9a::I64;
           I64[Sp] = _s9V97::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKv_info" {
     block_c9VKv_info:
         const _c9VKv;
         const 2342097;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKL() //  [R1]
         { []
         }
     {offset
       c9VKL: // global
           _s9V8U::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9V8U::I64, 64)) goto c9VPq; else goto c9VPr;
       c9VPq: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9V8U::I64;
           goto s9V9j;
       c9VPr: // global
           _s9V9i::P64 = R1;
           _s9V9k::I64 = 0;
           goto s9V9j;
       s9V9j: // global
           _s9V9l::I64 = _s9V9i::P64 + 16;
           I64[_s9V9l::I64] = _s9V9k::I64;
           I64[Sp - 8] = block_c9VKY_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9V9l::I64;
           P64[Sp + 104] = _s9V9i::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKL_info" {
     block_c9VKL_info:
         const _c9VKL;
         const 9368531;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VKY() //  [R1]
         { []
         }
     {offset
       c9VKY: // global
           _s9V8t::P64 = P64[Sp + 136];
           _s9V97::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9V97::I64, 64)) goto c9VPl; else goto c9VPm;
       c9VPl: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9V97::I64;
           goto s9V9u;
       c9VPm: // global
           _s9V9t::P64 = R1;
           _s9V9v::I64 = 0;
           goto s9V9u;
       s9V9u: // global
           _s9V9w::I64 = _s9V9t::P64 + 16;
           I64[_s9V9w::I64] = _s9V9v::I64;
           I64[Sp] = block_c9VLb_info;
           R1 = _s9V8t::P64;
           I64[Sp + 80] = _s9V9w::I64;
           P64[Sp + 136] = _s9V9t::P64;
           if (R1 & 7 != 0) goto u9VQ2; else goto c9VLc;
       u9VQ2: // global
           call _c9VLb(R1) args: 0, res: 0, upd: 0;
       c9VLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VKY_info" {
     block_c9VKY_info:
         const _c9VKY;
         const 18212820;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VLb() //  [R1]
         { []
         }
     {offset
       c9VLb: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9VP2; else goto c9VP1;
       c9VP2: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VP1: // global
           _s9V8A::I64 = I64[Sp + 152];
           _s9V8B::P64 = P64[Sp + 128];
           _s9V8C::P64 = P64[Sp + 96];
           _s9V8D::I64 = I64[Sp + 104];
           _s9V8F::I64 = I64[Sp + 120];
           _s9V8H::I64 = I64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 48];
           _s9V8J::P64 = P64[Sp + 56];
           _s9V8K::I64 = I64[Sp + 64];
           _s9V8L::I64 = I64[Sp + 72];
           _s9V8S::P64 = P64[Sp + 144];
           _s9V8U::I64 = I64[Sp + 40];
           _s9V95::P64 = P64[Sp + 160];
           _s9V97::I64 = I64[Sp + 24];
           _s9V9i::P64 = P64[Sp + 112];
           _s9V9l::I64 = I64[Sp + 8];
           _s9V9t::P64 = P64[Sp + 136];
           _s9V9w::I64 = I64[Sp + 80];
           (_s9V9E::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9V9l::I64, I64[Sp + 16], _s9V9w::I64);
           _s9V9H::I64 = I64[_s9V9l::I64];
           _s9V9K::I64 = I64[_s9V9w::I64];
           I64[Hp - 216] = new_outleft'_s9V9L_info;
           I64[Hp - 200] = _s9V97::I64;
           I64[Hp - 192] = _s9V9K::I64;
           I64[Hp - 184] = new_input_s9V9R_info;
           P64[Hp - 168] = _s9V8B::P64;
           P64[Hp - 160] = _s9V8C::P64;
           I64[Hp - 152] = _s9V8A::I64;
           I64[Hp - 144] = _s9V8D::I64;
           I64[Hp - 136] = _s9V8F::I64;
           I64[Hp - 128] = _s9V8U::I64;
           I64[Hp - 120] = _s9V9H::I64;
           _c9VLm::P64 = Hp - 216;
           _c9VLR::P64 = Hp - 184;
           if (_s9V9E::I64 == 18446744073709551615) goto c9VPh; else goto c9VP5;
       c9VPh: // global
           (_s9Vaf::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9Vag::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9Vaf::I64));
           if (%MO_S_Lt_W64(_s9Vag::I64, 23)) goto u9VPW; else goto u9VPY;
       u9VPW: // global
           if (%MO_S_Lt_W64(_s9Vag::I64, 22)) goto u9VPX; else goto c9VPe;
       u9VPX: // global
           if (_s9Vag::I64 != 7) goto c9VP8; else goto c9VPc;
       c9VPc: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaz_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VPb::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VPb::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VPe: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaK_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VPd::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VPd::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9VPY: // global
           if (_s9Vag::I64 != 84) goto c9VP8; else goto c9VPg;
       c9VP8: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9VP6_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9VPg: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9VaZ_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = sat_s9VaV_info;
           P64[Hp - 32] = _c9VLm::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9VLR::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VP5: // global
           call MO_Touch(_s9V9t::P64);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           I64[Hp - 112] = sat_s9Vaa_info;
           P64[Hp - 96] = _s9V8I::P64;
           P64[Hp - 88] = _s9V8J::P64;
           P64[Hp - 80] = _c9VLm::P64;
           I64[Hp - 72] = _s9V8H::I64;
           I64[Hp - 64] = _s9V8K::I64;
           I64[Hp - 56] = _s9V8L::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9VLR::P64;
           P64[Hp - 24] = Hp - 112;
           _c9VP3::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9VP3::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VLb_info" {
     block_c9VLb_info:
         const _c9VLb;
         const 18212820;
         const 73014444062;
         const S9Vc5_srt+24;
 },
 _c9VP6() //  [R1]
         { []
         }
     {offset
       c9VP6: // global
           _s9V8B::P64 = P64[Sp + 88];
           _s9V8I::P64 = P64[Sp + 8];
           _s9V8S::P64 = P64[Sp + 104];
           _s9V95::P64 = P64[Sp + 120];
           _s9V9i::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9V9i::P64);
           call MO_Touch(_s9V95::P64);
           call MO_Touch(_s9V8S::P64);
           call MO_Touch(_s9V8I::P64);
           call MO_Touch(_s9V8B::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VP6_info" {
     block_c9VP6_info:
         const _c9VP6;
         const 573327;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.25763301 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c9VSD: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding10_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S9Vc5_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.261157789 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c9VSO: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding4_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S9Vc5_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.265223398 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { []
         }
     {offset
       c9VT2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VT3; else goto c9VT4;
       c9VT3: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9VT4: // global
           I64[Sp - 8] = block_c9VSZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VTc; else goto c9VT0;
       u9VTc: // global
           call _c9VSZ(R1) args: 0, res: 0, upd: 0;
       c9VT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding18_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c9VSZ() //  [R1]
         { []
         }
     {offset
       c9VSZ: // global
           if (I64[R1 + 7] == 47) goto c9VTb; else goto c9VTa;
       c9VTb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9VTa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VSZ_info" {
     block_c9VSZ_info:
         const _c9VSZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.270352238 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.276516638 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9Vbq_entry() //  [R1]
         { []
         }
     {offset
       c9VTA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9VTB; else goto c9VTC;
       c9VTB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VTC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9VTx_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_s9Vbq_info" {
     ds_s9Vbq_info:
         const ds_s9Vbq_entry;
         const 1;
         const 16;
 },
 _c9VTx() //  [R1, R2]
         { []
         }
     {offset
       c9VTx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VTF; else goto c9VTE;
       c9VTF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9VTE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VTx_info" {
     block_c9VTx_info:
         const _c9VTx;
         const 0;
         const 30;
 },
 enc_s9Vby_entry() //  [R1]
         { []
         }
     {offset
       c9VTM: // global
           _s9Vby::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VTN; else goto c9VTO;
       c9VTO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9VTQ; else goto c9VTP;
       c9VTQ: // global
           HpAlloc = 24;
           goto c9VTN;
       c9VTN: // global
           R1 = _s9Vby::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VTP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9Vby::P64;
           _s9Vbq::P64 = P64[_s9Vby::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9Vbq::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . enc_s9Vby_info" {
     enc_s9Vby_info:
         const enc_s9Vby_entry;
         const 1;
         const 4294967312;
         const S9Vc5_srt+64;
 },
 enc1_s9VbD_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c9VTW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc1_s9VbD_info" {
     enc1_s9VbD_info:
         const enc1_s9VbD_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S9Vc5_srt+72;
 },
 enc2_s9VbE_entry() //  [R1]
         { []
         }
     {offset
       c9VU4: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc2_s9VbE_info" {
     enc2_s9VbE_info:
         const enc2_s9VbE_entry;
         const 3;
         const 279172874248;
         const 4294967299;
         const S9Vc5_srt+32;
 },
 enc3_s9VbF_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c9VUc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc3_s9VbF_info" {
     enc3_s9VbF_info:
         const enc3_s9VbF_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S9Vc5_srt+88;
 },
 enc4_s9VbG_entry() //  [R1]
         { []
         }
     {offset
       c9VUk: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc4_s9VbG_info" {
     enc4_s9VbG_info:
         const enc4_s9VbG_entry;
         const 2;
         const 1172526071819;
         const 4294967299;
         const S9Vc5_srt+32;
 },
 sat_s9VbM_entry() //  [R1]
         { []
         }
     {offset
       c9VUB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9VUC; else goto c9VUD;
       c9VUC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VUD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9VUu_info;
           _s9VbH::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9VbH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9VUN; else goto c9VUv;
       u9VUN: // global
           call _c9VUu(R1) args: 0, res: 0, upd: 0;
       c9VUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VbM_info" {
     sat_s9VbM_info:
         const sat_s9VbM_entry;
         const 2;
         const 18;
 },
 _c9VUu() //  [R1]
         { []
         }
     {offset
       c9VUu: // global
           if (R1 & 7 == 1) goto c9VUy; else goto c9VUz;
       c9VUy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9VUz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9VUM; else goto c9VUL;
       c9VUM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9VUL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9VUu_info" {
     block_c9VUu_info:
         const _c9VUu;
         const 1;
         const 30;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { []
         }
     {offset
       c9VUO: // global
           _s9Vbo::P64 = R3;
           _s9Vbn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9VUP; else goto c9VUQ;
       c9VUQ: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9VUS; else goto c9VUR;
       c9VUS: // global
           HpAlloc = 192;
           goto c9VUP;
       c9VUP: // global
           R3 = _s9Vbo::P64;
           R2 = _s9Vbn::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VUR: // global
           I64[Hp - 184] = ds_s9Vbq_info;
           P64[Hp - 168] = _s9Vbo::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9VTt::P64 = Hp - 184;
           P64[Hp - 144] = _c9VTt::P64;
           I64[Hp - 136] = enc_s9Vby_info;
           P64[Hp - 120] = _c9VTt::P64;
           I64[Hp - 112] = enc1_s9VbD_info;
           P64[Hp - 104] = _s9Vbn::P64;
           I64[Hp - 96] = enc2_s9VbE_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9VbF_info;
           P64[Hp - 56] = _s9Vbn::P64;
           I64[Hp - 48] = enc4_s9VbG_info;
           P64[Hp - 40] = _s9Vbo::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9Vbo::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9VUo_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9VUn::P64 = Hp - 23;
           R2 = _c9VUn::P64;
           P64[Sp - 8] = _c9VUn::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding2_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_entry;
         const 0;
         const 8731668512782;
         const 12884901903;
         const S9Vc5_srt+32;
 },
 _c9VUo() //  [R1]
         { []
         }
     {offset
       c9VUo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9VUV; else goto c9VUU;
       c9VUV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9VUU: // global
           I64[Hp - 24] = sat_s9VbM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9VUo_info" {
     block_c9VUo_info:
         const _c9VUo;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.298476704 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { []
         }
     {offset
       c9VVR: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.mkIconvEncoding_info" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_info:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const S9Vc5_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.30178797 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { []
         }
     {offset
       c9VW2: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding1_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const S9Vc5_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.305130763 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { []
         }
     {offset
       c9VWd: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const S9Vc5_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:00.308288641 UTC

[section ""relreadonly" . S9Vc5_srt" {
     S9Vc5_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.598956686 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:01.600050266 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule4_bytes" {
     GHC.IO.Encoding.Iconv.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.60176856 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule3_closure" {
     GHC.IO.Encoding.Iconv.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.603417748 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.$trModule2_bytes" {
     GHC.IO.Encoding.Iconv.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,73,99,111,110,118]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.6051576 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule1_closure" {
     GHC.IO.Encoding.Iconv.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Iconv.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.606895268 UTC

[section ""data" . GHC.IO.Encoding.Iconv.$trModule_closure" {
     GHC.IO.Encoding.Iconv.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Iconv.$trModule3_closure+1;
         const GHC.IO.Encoding.Iconv.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.608667729 UTC

[section ""cstring" . lvl_r9V6y_bytes" {
     lvl_r9V6y_bytes:
         I8[] [73,99,111,110,118,46,99,108,111,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.611157769 UTC

[section ""data" . lvl1_r9V6z_closure" {
     lvl1_r9V6z_closure:
         const lvl1_r9V6z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r9V6z_entry() //  [R1]
         { []
         }
     {offset
       c9W1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W1J; else goto c9W1K;
       c9W1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W1K: // global
           (_c9W1F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W1F::I64 == 0) goto c9W1H; else goto c9W1G;
       c9W1H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W1G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W1F::I64;
           R2 = lvl_r9V6y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_r9V6z_info" {
     lvl1_r9V6z_info:
         const lvl1_r9V6z_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.615259558 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding16_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding16_entry() //  [R2]
         { []
         }
     {offset
       c9W1Z: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_r9V6z_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding16_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding16_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding16_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const S9W22_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.618829851 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding15_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding15_entry() //  []
         { []
         }
     {offset
       c9W2b: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding15_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding15_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding15_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.62236367 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding14_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding14_entry() //  []
         { []
         }
     {offset
       c9W2o: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding14_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding14_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding14_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.627111955 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding13_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding13_bytes:
         I8[] [109,107,84,101,120,116,69,110,99,111,100,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.629355214 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding12_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding12_entry() //  [R1]
         { []
         }
     {offset
       c9W2E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W2F; else goto c9W2G;
       c9W2F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W2G: // global
           (_c9W2B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W2B::I64 == 0) goto c9W2D; else goto c9W2C;
       c9W2D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W2C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W2B::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding12_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding12_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding12_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.640325777 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding11_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_info;
         const 0;
 },
 sat_s9VXg_entry() //  [R1]
         { []
         }
     {offset
       c9W3K: // global
           (_s9VX9::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9VX9::I64) == (-1) :: W32) goto c9W3J; else goto c9W3I;
       c9W3J: // global
           (_s9VXe::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9VXe::I64;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9W3I: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s9VXg_info" {
     sat_s9VXg_info:
         const sat_s9VXg_entry;
         const 4294967296;
         const 4294967306;
         const 4294967299;
         const S9W22_srt+16;
 },
 sat_s9VX4_entry() //  [R1]
         { []
         }
     {offset
       c9W43: // global
           _s9VX4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9W44; else goto c9W45;
       c9W45: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9W47; else goto c9W46;
       c9W47: // global
           HpAlloc = 16;
           goto c9W44;
       c9W44: // global
           R1 = _s9VX4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W46: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VX4::P64;
           _s9VWu::P64 = P64[_s9VX4::P64 + 16];
           _s9VX0::I64 = I64[_s9VX4::P64 + 24];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9VX0::I64;
           R2 = Hp - 7;
           R1 = _s9VWu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VX4_info" {
     sat_s9VX4_info:
         const sat_s9VX4_entry;
         const 4294967297;
         const 19;
 },
 sat_s9VXB_entry() //  [R1]
         { []
         }
     {offset
       c9W4l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9W4m; else goto c9W4n;
       c9W4m: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9W4n: // global
           I64[Sp - 8] = block_c9W4i_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W4J; else goto c9W4j;
       u9W4J: // global
           call _c9W4i(R1) args: 0, res: 0, upd: 0;
       c9W4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s9VXB_info" {
     sat_s9VXB_info:
         const sat_s9VXB_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S9W22_srt+16;
 },
 _c9W4i() //  [R1]
         { []
         }
     {offset
       c9W4i: // global
           (_s9VXu::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] hs_iconv_close(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_s9VXu::I64) == (-1) :: W32) goto c9W4E; else goto c9W4y;
       c9W4E: // global
           (_s9VXz::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _s9VXz::I64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Iconv.iconvEncoding16_entry(R2) args: 8, res: 0, upd: 8;
       c9W4y: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W4i_info" {
     block_c9W4i_info:
         const _c9W4i;
         const 0;
         const 4294967326;
         const S9W22_srt+16;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding11_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       c9W4K: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9W4L; else goto c9W4M;
       c9W4L: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9W4M: // global
           I64[Sp - 40] = block_c9W2T_info;
           _s9VWs::P64 = R3;
           R3 = 0;
           _s9VWr::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s9VWr::P64;
           P64[Sp - 24] = _s9VWs::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding11_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding11_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding11_entry;
         const 0;
         const 64424509454;
         const 21474836504;
         const S9W22_srt+16;
 },
 _c9W2T() //  [R1]
         { []
         }
     {offset
       c9W2T: // global
           I64[Sp] = block_c9W30_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W2T_info" {
     block_c9W2T_info:
         const _c9W2T;
         const 4;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W30() //  [R1]
         { []
         }
     {offset
       c9W30: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c9W5u() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9W30_info" {
     block_c9W30_info:
         const _c9W30;
         const 4;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W5u() //  []
         { []
         }
     {offset
       c9W5u: // global
           _s9VXR::P64 = P64[Sp];
           I64[Sp] = block_c9W5x_info;
           R1 = _s9VXR::P64;
           if (R1 & 7 != 0) goto u9W6j; else goto c9W5z;
       u9W6j: // global
           call _c9W5x(R1) args: 0, res: 0, upd: 0;
       c9W5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W5x() //  [R1]
         { []
         }
     {offset
       c9W5x: // global
           if (R1 & 7 == 1) goto c9W5F; else goto c9W5K;
       c9W5F: // global
           _s9VWs::P64 = P64[Sp + 32];
           I8[I64[Sp + 16] + I64[Sp + 8]] = 0 :: W8;
           I64[Sp + 8] = block_c9W3a_info;
           R3 = 0;
           R2 = _s9VWs::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
       c9W5K: // global
           I64[Sp - 8] = block_c9W5I_info;
           _s9VXW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9VXW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W6k; else goto c9W5L;
       u9W6k: // global
           call _c9W5I(R1) args: 0, res: 0, upd: 0;
       c9W5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W5x_info" {
     block_c9W5x_info:
         const _c9W5x;
         const 198;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W3a() //  [R1]
         { []
         }
     {offset
       c9W3a: // global
           I64[Sp] = block_c9W3h_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W3a_info" {
     block_c9W3a_info:
         const _c9W3a;
         const 69;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W3h() //  [R1]
         { []
         }
     {offset
       c9W3h: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c9W56() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9W3h_info" {
     block_c9W3h_info:
         const _c9W3h;
         const 69;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W56() //  []
         { []
         }
     {offset
       c9W56: // global
           _s9VXE::P64 = P64[Sp];
           I64[Sp] = block_c9W59_info;
           R1 = _s9VXE::P64;
           if (R1 & 7 != 0) goto u9W6f; else goto c9W5b;
       u9W6f: // global
           call _c9W59(R1) args: 0, res: 0, upd: 0;
       c9W5b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9W59() //  [R1]
         { []
         }
     {offset
       c9W59: // global
           if (R1 & 7 == 1) goto c9W5h; else goto c9W5m;
       c9W5h: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c9W3p() args: 0, res: 0, upd: 0;
       c9W5m: // global
           I64[Sp - 8] = block_c9W5k_info;
           _s9VXJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s9VXJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9W6g; else goto c9W5n;
       u9W6g: // global
           call _c9W5k(R1) args: 0, res: 0, upd: 0;
       c9W5n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W59_info" {
     block_c9W59_info:
         const _c9W59;
         const 455;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W3p() //  []
         { []
         }
     {offset
       c9W3p: // global
           Hp = Hp + 96;
           _s9VWT::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c9W4U; else goto c9W4T;
       c9W4U: // global
           HpAlloc = 96;
           I64[Sp] = block_c9W3o_info;
           R1 = _s9VWT::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9W4T: // global
           _s9VWt::P64 = P64[Sp + 40];
           _s9VWu::P64 = P64[Sp + 48];
           _s9VWD::P64 = P64[Sp + 24];
           _s9VWE::I64 = I64[Sp + 16];
           _s9VWQ::P64 = P64[Sp + 32];
           _s9VWR::I64 = I64[Sp + 8];
           I8[_s9VWR::I64 + _s9VWT::I64] = 0 :: W8;
           (_s9VWZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [‘signed’] hs_iconv_open(_s9VWR::I64, _s9VWE::I64);
           if (_s9VWZ::I64 == (-1)) goto c9W50; else goto c9W4X;
       c9W50: // global
           Hp = Hp - 96;
           I64[Sp + 16] = block_c9W49_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9W4X: // global
           call MO_Touch(_s9VWQ::P64);
           call MO_Touch(_s9VWD::P64);
           I64[Hp - 88] = sat_s9VXg_info;
           I64[Hp - 80] = _s9VWZ::I64;
           I64[Hp - 72] = sat_s9VX4_info;
           P64[Hp - 56] = _s9VWu::P64;
           I64[Hp - 48] = _s9VWZ::I64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9VWt::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9W3o() //  [R1]
         { []
         }
     {offset
       c9W3o: // global
           I64[Sp] = R1;
           call _c9W3p() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9W3o_info" {
     block_c9W3o_info:
         const _c9W3o;
         const 198;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W49() //  [R1]
         { []
         }
     {offset
       c9W49: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9W53; else goto c9W52;
       c9W53: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9W52: // global
           _s9VWt::P64 = P64[Sp + 24];
           _s9VWu::P64 = P64[Sp + 32];
           _s9VWD::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_s9VWD::P64);
           I64[Hp - 88] = sat_s9VXB_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = _s9VWu::P64;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s9VWt::P64;
           P64[Hp - 16] = Hp - 87;
           P64[Hp - 8] = GHC.IO.Encoding.Iconv.iconvEncoding15_closure+1;
           P64[Hp] = GHC.IO.Encoding.Iconv.iconvEncoding14_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W49_info" {
     block_c9W49_info:
         const _c9W49;
         const 4;
         const 4294967326;
         const S9W22_srt+16;
 },
 _c9W5k() //  [R1]
         { []
         }
     {offset
       c9W5k: // global
           _s9VXF::I64 = I64[Sp + 16];
           _s9VXJ::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9VXF::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9VXJ::P64;
           I64[Sp + 16] = _s9VXF::I64 + 1;
           Sp = Sp + 8;
           call _c9W56() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9W5k_info" {
     block_c9W5k_info:
         const _c9W5k;
         const 904;
         const 47244640286;
         const S9W22_srt+16;
 },
 _c9W5I() //  [R1]
         { []
         }
     {offset
       c9W5I: // global
           _s9VXS::I64 = I64[Sp + 16];
           _s9VXW::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s9VXS::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s9VXW::P64;
           I64[Sp + 16] = _s9VXS::I64 + 1;
           Sp = Sp + 8;
           call _c9W5u() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c9W5I_info" {
     block_c9W5I_info:
         const _c9W5I;
         const 391;
         const 47244640286;
         const S9W22_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.671672439 UTC

[section ""data" . lvl2_r9V6A_closure" {
     lvl2_r9V6A_closure:
         const lvl2_r9V6A_info;
 },
 lvl2_r9V6A_entry() //  []
         { []
         }
     {offset
       c9W8g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9W8h; else goto c9W8i;
       c9W8h: // global
           R1 = lvl2_r9V6A_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9W8i: // global
           I64[Sp - 8] = block_c9W8d_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_r9V6A_info" {
     lvl2_r9V6A_info:
         const lvl2_r9V6A_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _c9W8d() //  []
         { []
         }
     {offset
       c9W8d: // global
           (_s9VY8::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] localeEncoding();
           R2 = _s9VY8::I64;
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W8d_info" {
     block_c9W8d_info:
         const _c9W8d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.676951494 UTC

[section ""data" . GHC.IO.Encoding.Iconv.localeEncodingName_closure" {
     GHC.IO.Encoding.Iconv.localeEncodingName_closure:
         const GHC.IO.Encoding.Iconv.localeEncodingName_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.localeEncodingName_entry() //  [R1]
         { []
         }
     {offset
       c9W8B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9W8C; else goto c9W8D;
       c9W8C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W8D: // global
           (_c9W8w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W8w::I64 == 0) goto c9W8y; else goto c9W8x;
       c9W8y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W8x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W8w::I64;
           I64[Sp - 24] = block_c9W8z_info;
           Sp = Sp - 24;
           call lvl2_r9V6A_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.localeEncodingName_info" {
     GHC.IO.Encoding.Iconv.localeEncodingName_info:
         const GHC.IO.Encoding.Iconv.localeEncodingName_entry;
         const 0;
         const 21;
 },
 _c9W8z() //  [R1]
         { []
         }
     {offset
       c9W8z: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9W8z_info" {
     block_c9W8z_info:
         const _c9W8z;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.682066493 UTC

[section ""data" . GHC.IO.Encoding.Iconv.char_shift_closure" {
     GHC.IO.Encoding.Iconv.char_shift_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.68379294 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding17_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding17_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.686066616 UTC

[section ""data" . GHC.IO.Encoding.Iconv.haskellChar_closure" {
     GHC.IO.Encoding.Iconv.haskellChar_closure:
         const GHC.IO.Encoding.Iconv.haskellChar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.haskellChar_entry() //  [R1]
         { []
         }
     {offset
       c9W91: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W92; else goto c9W93;
       c9W92: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W93: // global
           (_c9W8Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W8Y::I64 == 0) goto c9W90; else goto c9W8Z;
       c9W90: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W8Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W8Y::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.haskellChar_info" {
     GHC.IO.Encoding.Iconv.haskellChar_info:
         const GHC.IO.Encoding.Iconv.haskellChar_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.690328223 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding5_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.69199331 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding9_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding9_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.693696755 UTC

[section ""cstring" . GHC.IO.Encoding.Iconv.iconvEncoding8_bytes" {
     GHC.IO.Encoding.Iconv.iconvEncoding8_bytes:
         I8[] [105,99,111,110,118,82,101,99,111,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.695960042 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding7_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding7_entry() //  [R1]
         { []
         }
     {offset
       c9W9l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W9m; else goto c9W9n;
       c9W9m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W9n: // global
           (_c9W9i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9W9i::I64 == 0) goto c9W9k; else goto c9W9j;
       c9W9k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9W9j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9W9i::I64;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding7_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding7_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding7_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.714775354 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding6_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_info;
         const 0;
 },
 new_outleft'_s9VZu_entry() //  [R1]
         { []
         }
     {offset
       c9Wb4: // global
           _s9VZu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wb5; else goto c9Wb6;
       c9Wb6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Wb8; else goto c9Wb7;
       c9Wb8: // global
           HpAlloc = 16;
           goto c9Wb5;
       c9Wb5: // global
           R1 = _s9VZu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wb7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VZu::P64;
           _s9VYQ::I64 = I64[_s9VZu::P64 + 16];
           _s9VZt::I64 = I64[_s9VZu::P64 + 24];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9Wb2; else goto c9Wb3;
       c9Wb2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s9VZt::I64, _s9VYQ::I64);
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wb3: // global
           if (%MO_S_Ge_W64(_s9VZt::I64, 0)) goto c9Wbo; else goto c9Wbp;
       c9Wbo: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wbp: // global
           Hp = Hp - 16;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding9_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . new_outleft'_s9VZu_info" {
     new_outleft'_s9VZu_info:
         const new_outleft'_s9VZu_entry;
         const 8589934592;
         const 20;
 },
 new_input_s9VZA_entry() //  [R1]
         { []
         }
     {offset
       c9Wby: // global
           _s9VZA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wbz; else goto c9WbA;
       c9WbA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9WbC; else goto c9WbB;
       c9WbC: // global
           HpAlloc = 56;
           goto c9Wbz;
       c9Wbz: // global
           R1 = _s9VZA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WbB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9VZA::P64;
           _s9VYk::P64 = P64[_s9VZA::P64 + 16];
           _s9VYl::P64 = P64[_s9VZA::P64 + 24];
           _s9VYj::I64 = I64[_s9VZA::P64 + 32];
           _s9VYm::I64 = I64[_s9VZA::P64 + 40];
           _s9VZB::I64 = I64[_s9VZA::P64 + 64];
           if (_s9VZB::I64 != 0) goto c9Wbw; else goto c9Wbx;
       c9Wbw: // global
           _s9VYo::I64 = I64[_s9VZA::P64 + 48];
           _s9VYD::I64 = I64[_s9VZA::P64 + 56];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9WbS; else goto c9Wc9;
       c9WbS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64 - %MO_S_Shr_W64(_s9VZB::I64,
                                                     _s9VYD::I64);
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wc9: // global
           if (%MO_S_Ge_W64(_s9VZB::I64, 0)) goto c9Wc2; else goto c9Wc8;
       c9Wc2: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64;
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wc8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = _s9VYo::I64 + 1;
           I64[Hp] = _s9VYo::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Wbx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s9VYk::P64;
           P64[Hp - 32] = _s9VYl::P64;
           I64[Hp - 24] = _s9VYj::I64;
           I64[Hp - 16] = _s9VYm::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . new_input_s9VZA_info" {
     new_input_s9VZA_info:
         const new_input_s9VZA_entry;
         const 21474836482;
         const 15;
 },
 sat_s9VZT_entry() //  [R1]
         { []
         }
     {offset
       c9Wcr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wcy; else goto c9Wcz;
       c9Wcy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wcz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Wco_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9WcD; else goto c9Wcp;
       u9WcD: // global
           call _c9Wco(R1) args: 0, res: 0, upd: 0;
       c9Wcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9VZT_info" {
     sat_s9VZT_info:
         const sat_s9VZT_entry;
         const 12884901891;
         const 15;
 },
 _c9Wco() //  [R1]
         { []
         }
     {offset
       c9Wco: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9WcC; else goto c9WcB;
       c9WcC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9WcB: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9VZS::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9VZS::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9Wco_info" {
     block_c9Wco_info:
         const _c9Wco;
         const 1605;
         const 30;
 },
 sat_s9W0i_entry() //  [R1]
         { []
         }
     {offset
       c9WcX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wd4; else goto c9Wd5;
       c9Wd4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wd5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9WcU_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9Wd9; else goto c9WcV;
       u9Wd9: // global
           call _c9WcU(R1) args: 0, res: 0, upd: 0;
       c9WcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9W0i_info" {
     sat_s9W0i_info:
         const sat_s9W0i_entry;
         const 12884901891;
         const 15;
 },
 _c9WcU() //  [R1]
         { []
         }
     {offset
       c9WcU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Wd8; else goto c9Wd7;
       c9Wd8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wd7: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0h::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0h::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9WcU_info" {
     block_c9WcU_info:
         const _c9WcU;
         const 1605;
         const 30;
 },
 sat_s9W0t_entry() //  [R1]
         { []
         }
     {offset
       c9Wdo: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Wdv; else goto c9Wdw;
       c9Wdv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wdw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9Wdl_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9WdA; else goto c9Wdm;
       u9WdA: // global
           call _c9Wdl(R1) args: 0, res: 0, upd: 0;
       c9Wdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9W0t_info" {
     sat_s9W0t_info:
         const sat_s9W0t_entry;
         const 12884901891;
         const 15;
 },
 _c9Wdl() //  [R1]
         { []
         }
     {offset
       c9Wdl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Wdz; else goto c9Wdy;
       c9Wdz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wdy: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0s::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0s::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9Wdl_info" {
     block_c9Wdl_info:
         const _c9Wdl;
         const 1605;
         const 30;
 },
 sat_s9W0I_entry() //  [R1]
         { []
         }
     {offset
       c9WdP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9WdW; else goto c9WdX;
       c9WdW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WdX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c9WdM_info;
           _s9VYr::P64 = P64[R1 + 16];
           _s9VYs::P64 = P64[R1 + 24];
           _s9VYq::I64 = I64[R1 + 40];
           _s9VYt::I64 = I64[R1 + 48];
           _s9VYu::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _s9VYq::I64;
           P64[Sp - 48] = _s9VYr::P64;
           P64[Sp - 40] = _s9VYs::P64;
           I64[Sp - 32] = _s9VYt::I64;
           I64[Sp - 24] = _s9VYu::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto u9We1; else goto c9WdN;
       u9We1: // global
           call _c9WdM(R1) args: 0, res: 0, upd: 0;
       c9WdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9W0I_info" {
     sat_s9W0I_info:
         const sat_s9W0I_entry;
         const 12884901891;
         const 15;
 },
 _c9WdM() //  [R1]
         { []
         }
     {offset
       c9WdM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9We0; else goto c9WdZ;
       c9We0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9WdZ: // global
           _s9VYt::I64 = I64[Sp + 32];
           _s9W0H::I64 = _s9VYt::I64 - I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s9VYt::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s9W0H::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9WdM_info" {
     block_c9WdM_info:
         const _c9WdM;
         const 1605;
         const 30;
 },
 sat_s9W0E_entry() //  [R1]
         { []
         }
     {offset
       c9We9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Wea; else goto c9Web;
       c9Wea: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Web: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9We6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Wej; else goto c9We7;
       u9Wej: // global
           call _c9We6(R1) args: 0, res: 0, upd: 0;
       c9We7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9W0E_info" {
     sat_s9W0E_info:
         const sat_s9W0E_entry;
         const 1;
         const 16;
 },
 _c9We6() //  [R1]
         { []
         }
     {offset
       c9We6: // global
           if (I64[R1 + 7] == 0) goto c9Wei; else goto c9Weh;
       c9Wei: // global
           R1 = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Weh: // global
           R1 = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9We6_info" {
     block_c9We6_info:
         const _c9We6;
         const 0;
         const 30;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding6_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       c9Wek: // global
           if ((Sp + -168) < SpLim) (likely: False) goto c9Wel; else goto c9Wem;
       c9Wel: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wem: // global
           I64[Sp - 40] = block_c9W9A_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9WfC; else goto c9W9B;
       u9WfC: // global
           call _c9W9A(R1) args: 0, res: 0, upd: 0;
       c9W9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding6_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding6_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding6_entry;
         const 0;
         const 107374182414;
         const 25769803801;
         const S9W22_srt+24;
 },
 _c9W9A() //  [R1]
         { []
         }
     {offset
       c9W9A: // global
           I64[Sp - 40] = block_c9W9F_info;
           _s9VYk::P64 = P64[R1 + 7];
           _s9VYl::P64 = P64[R1 + 15];
           _s9VYj::I64 = I64[R1 + 23];
           _s9VYm::I64 = I64[R1 + 31];
           _s9VYn::I64 = I64[R1 + 39];
           _s9VYo::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           P64[Sp - 32] = _s9VYl::P64;
           I64[Sp - 24] = _s9VYm::I64;
           I64[Sp - 16] = _s9VYn::I64;
           I64[Sp - 8] = _s9VYo::I64;
           P64[Sp] = _s9VYk::P64;
           I64[Sp + 24] = _s9VYj::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9Wfy; else goto c9W9G;
       u9Wfy: // global
           call _c9W9F(R1) args: 0, res: 0, upd: 0;
       c9W9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W9A_info" {
     block_c9W9A_info:
         const _c9W9A;
         const 4;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9W9F() //  [R1]
         { []
         }
     {offset
       c9W9F: // global
           I64[Sp - 48] = block_c9W9K_info;
           R2 = 8;
           _s9VYr::P64 = P64[R1 + 7];
           _s9VYs::P64 = P64[R1 + 15];
           _s9VYq::I64 = I64[R1 + 23];
           _s9VYt::I64 = I64[R1 + 31];
           _s9VYu::I64 = I64[R1 + 39];
           _s9VYv::I64 = I64[R1 + 47];
           R1 = 8;
           P64[Sp - 40] = _s9VYr::P64;
           P64[Sp - 32] = _s9VYs::P64;
           I64[Sp - 24] = _s9VYt::I64;
           I64[Sp - 16] = _s9VYu::I64;
           I64[Sp - 8] = _s9VYv::I64;
           I64[Sp] = _s9VYq::I64;
           Sp = Sp - 48;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W9F_info" {
     block_c9W9F_info:
         const _c9W9F;
         const 9097;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9W9K() //  [R1]
         { []
         }
     {offset
       c9W9K: // global
           I64[Sp] = block_c9W9M_info;
           _s9VYB::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 104] = _s9VYB::P64;
           if (R1 & 7 != 0) goto u9Wfz; else goto c9W9N;
       u9Wfz: // global
           call _c9W9M(R1) args: 0, res: 0, upd: 0;
       c9W9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W9K_info" {
     block_c9W9K_info:
         const _c9W9K;
         const 585487;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9W9M() //  [R1]
         { []
         }
     {offset
       c9W9M: // global
           _s9VYj::I64 = I64[Sp + 112];
           _s9VYB::P64 = P64[Sp + 104];
           _s9VYD::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9Wf9; else goto c9Wfa;
       c9Wf9: // global
           _s9VYF::I64 = I64[Sp + 72] << _s9VYD::I64;
           goto s9VYE;
       c9Wfa: // global
           _s9VYF::I64 = 0;
           goto s9VYE;
       s9VYE: // global
           _s9VYG::I64 = _s9VYB::P64 + 16;
           I64[_s9VYG::I64] = _s9VYj::I64 + _s9VYF::I64;
           I64[Sp - 16] = block_c9Wa2_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9VYG::I64;
           I64[Sp] = _s9VYD::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9W9M_info" {
     block_c9W9M_info:
         const _c9W9M;
         const 585487;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9Wa2() //  [R1]
         { []
         }
     {offset
       c9Wa2: // global
           I64[Sp] = block_c9Wa4_info;
           _s9VYO::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp + 136] = _s9VYO::P64;
           if (R1 & 7 != 0) goto u9WfA; else goto c9Wa5;
       u9WfA: // global
           call _c9Wa4(R1) args: 0, res: 0, upd: 0;
       c9Wa5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9Wa2_info" {
     block_c9Wa2_info:
         const _c9Wa2;
         const 2342097;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9Wa4() //  [R1]
         { []
         }
     {offset
       c9Wa4: // global
           _s9VYq::I64 = I64[Sp + 64];
           _s9VYO::P64 = P64[Sp + 136];
           _s9VYQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9Wf4; else goto c9Wf5;
       c9Wf4: // global
           _s9VYS::I64 = I64[Sp + 56] << _s9VYQ::I64;
           goto s9VYR;
       c9Wf5: // global
           _s9VYS::I64 = 0;
           goto s9VYR;
       s9VYR: // global
           _s9VYT::I64 = _s9VYO::P64 + 16;
           I64[_s9VYT::I64] = _s9VYq::I64 + _s9VYS::I64;
           I64[Sp - 16] = block_c9Wak_info;
           R2 = 8;
           R1 = 8;
           I64[Sp - 8] = _s9VYT::I64;
           I64[Sp] = _s9VYQ::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9Wa4_info" {
     block_c9Wa4_info:
         const _c9Wa4;
         const 2342097;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9Wak() //  [R1]
         { []
         }
     {offset
       c9Wak: // global
           _s9VYD::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_s9VYD::I64, 64)) goto c9WeZ; else goto c9Wf0;
       c9WeZ: // global
           _s9VZ1::P64 = R1;
           _s9VZ3::I64 = I64[Sp + 112] - I64[Sp + 104] << _s9VYD::I64;
           goto s9VZ2;
       c9Wf0: // global
           _s9VZ1::P64 = R1;
           _s9VZ3::I64 = 0;
           goto s9VZ2;
       s9VZ2: // global
           _s9VZ4::I64 = _s9VZ1::P64 + 16;
           I64[_s9VZ4::I64] = _s9VZ3::I64;
           I64[Sp - 8] = block_c9Wax_info;
           R2 = 8;
           R1 = 8;
           I64[Sp] = _s9VZ4::I64;
           P64[Sp + 104] = _s9VZ1::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9Wak_info" {
     block_c9Wak_info:
         const _c9Wak;
         const 9368531;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9Wax() //  [R1]
         { []
         }
     {offset
       c9Wax: // global
           _s9VYc::P64 = P64[Sp + 136];
           _s9VYQ::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_s9VYQ::I64, 64)) goto c9WeU; else goto c9WeV;
       c9WeU: // global
           _s9VZc::P64 = R1;
           _s9VZe::I64 = I64[Sp + 64] - I64[Sp + 80] << _s9VYQ::I64;
           goto s9VZd;
       c9WeV: // global
           _s9VZc::P64 = R1;
           _s9VZe::I64 = 0;
           goto s9VZd;
       s9VZd: // global
           _s9VZf::I64 = _s9VZc::P64 + 16;
           I64[_s9VZf::I64] = _s9VZe::I64;
           I64[Sp] = block_c9WaK_info;
           R1 = _s9VYc::P64;
           I64[Sp + 80] = _s9VZf::I64;
           P64[Sp + 136] = _s9VZc::P64;
           if (R1 & 7 != 0) goto u9WfB; else goto c9WaL;
       u9WfB: // global
           call _c9WaK(R1) args: 0, res: 0, upd: 0;
       c9WaL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c9Wax_info" {
     block_c9Wax_info:
         const _c9Wax;
         const 18212820;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9WaK() //  [R1]
         { []
         }
     {offset
       c9WaK: // global
           Hp = Hp + 224;
           if (Hp > HpLim) (likely: False) goto c9WeB; else goto c9WeA;
       c9WeB: // global
           HpAlloc = 224;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9WeA: // global
           _s9VYj::I64 = I64[Sp + 152];
           _s9VYk::P64 = P64[Sp + 128];
           _s9VYl::P64 = P64[Sp + 96];
           _s9VYm::I64 = I64[Sp + 104];
           _s9VYo::I64 = I64[Sp + 120];
           _s9VYq::I64 = I64[Sp + 88];
           _s9VYr::P64 = P64[Sp + 48];
           _s9VYs::P64 = P64[Sp + 56];
           _s9VYt::I64 = I64[Sp + 64];
           _s9VYu::I64 = I64[Sp + 72];
           _s9VYB::P64 = P64[Sp + 144];
           _s9VYD::I64 = I64[Sp + 40];
           _s9VYO::P64 = P64[Sp + 160];
           _s9VYQ::I64 = I64[Sp + 24];
           _s9VZ1::P64 = P64[Sp + 112];
           _s9VZ4::I64 = I64[Sp + 8];
           _s9VZc::P64 = P64[Sp + 136];
           _s9VZf::I64 = I64[Sp + 80];
           (_s9VZn::I64) = call "ccall" arg hints:  [‘signed’, PtrHint,
                                                     PtrHint, PtrHint,
                                                     PtrHint]  result hints:  [] hs_iconv(I64[R1 + 7], I64[Sp + 32], _s9VZ4::I64, I64[Sp + 16], _s9VZf::I64);
           _s9VZq::I64 = I64[_s9VZ4::I64];
           _s9VZt::I64 = I64[_s9VZf::I64];
           I64[Hp - 216] = new_outleft'_s9VZu_info;
           I64[Hp - 200] = _s9VYQ::I64;
           I64[Hp - 192] = _s9VZt::I64;
           I64[Hp - 184] = new_input_s9VZA_info;
           P64[Hp - 168] = _s9VYk::P64;
           P64[Hp - 160] = _s9VYl::P64;
           I64[Hp - 152] = _s9VYj::I64;
           I64[Hp - 144] = _s9VYm::I64;
           I64[Hp - 136] = _s9VYo::I64;
           I64[Hp - 128] = _s9VYD::I64;
           I64[Hp - 120] = _s9VZq::I64;
           _c9WaV::P64 = Hp - 216;
           _c9Wbq::P64 = Hp - 184;
           if (_s9VZn::I64 == 18446744073709551615) goto c9WeQ; else goto c9WeE;
       c9WeQ: // global
           (_s9VZY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _s9VZZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9VZY::I64));
           if (%MO_S_Lt_W64(_s9VZZ::I64, 23)) goto u9Wfv; else goto u9Wfx;
       u9Wfv: // global
           if (%MO_S_Lt_W64(_s9VZZ::I64, 22)) goto u9Wfw; else goto c9WeN;
       u9Wfw: // global
           if (_s9VZZ::I64 != 7) goto c9WeH; else goto c9WeL;
       c9WeL: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0i_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeK::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeK::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WeN: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0t_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeM::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeM::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9Wfx: // global
           if (_s9VZZ::I64 != 84) goto c9WeH; else goto c9WeP;
       c9WeH: // global
           Hp = Hp - 120;
           I64[Sp + 40] = block_c9WeF_info;
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       c9WeP: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9W0I_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = sat_s9W0E_info;
           P64[Hp - 32] = _c9WaV::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _c9Wbq::P64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WeE: // global
           call MO_Touch(_s9VZc::P64);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           I64[Hp - 112] = sat_s9VZT_info;
           P64[Hp - 96] = _s9VYr::P64;
           P64[Hp - 88] = _s9VYs::P64;
           P64[Hp - 80] = _c9WaV::P64;
           I64[Hp - 72] = _s9VYq::I64;
           I64[Hp - 64] = _s9VYt::I64;
           I64[Hp - 56] = _s9VYu::I64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 32] = _c9Wbq::P64;
           P64[Hp - 24] = Hp - 112;
           _c9WeC::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _c9WeC::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9WaK_info" {
     block_c9WaK_info:
         const _c9WaK;
         const 18212820;
         const 73014444062;
         const S9W22_srt+24;
 },
 _c9WeF() //  [R1]
         { []
         }
     {offset
       c9WeF: // global
           _s9VYk::P64 = P64[Sp + 88];
           _s9VYr::P64 = P64[Sp + 8];
           _s9VYB::P64 = P64[Sp + 104];
           _s9VYO::P64 = P64[Sp + 120];
           _s9VZ1::P64 = P64[Sp + 72];
           call MO_Touch(P64[Sp + 96]);
           call MO_Touch(_s9VZ1::P64);
           call MO_Touch(_s9VYO::P64);
           call MO_Touch(_s9VYB::P64);
           call MO_Touch(_s9VYr::P64);
           call MO_Touch(_s9VYk::P64);
           R1 = R1;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9WeF_info" {
     block_c9WeF_info:
         const _c9WeF;
         const 573327;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.764436264 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding10_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding10_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c9Wj0: // global
           R6 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding10_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding10_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding10_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S9W22_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.767894021 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding4_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c9Wjb: // global
           R6 = GHC.IO.Encoding.Iconv.iconvEncoding5_closure+1;
           R5 = R4;
           R4 = GHC.IO.Encoding.Iconv.char_shift_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding6_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding4_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding4_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding4_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const S9W22_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.772118961 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding18_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_info;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding18_entry() //  [R2]
         { []
         }
     {offset
       c9Wjp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Wjq; else goto c9Wjr;
       c9Wjq: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Wjr: // global
           I64[Sp - 8] = block_c9Wjm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Wjz; else goto c9Wjn;
       u9Wjz: // global
           call _c9Wjm(R1) args: 0, res: 0, upd: 0;
       c9Wjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding18_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding18_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding18_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c9Wjm() //  [R1]
         { []
         }
     {offset
       c9Wjm: // global
           if (I64[R1 + 7] == 47) goto c9Wjy; else goto c9Wjx;
       c9Wjy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Wjx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9Wjm_info" {
     block_c9Wjm_info:
         const _c9Wjm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.777035235 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding3_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding3_closure:
         const GHC.Types.C#_con_info;
         const 97;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.783531579 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding2_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_info;
         const 0;
 },
 ds_s9W19_entry() //  [R1]
         { []
         }
     {offset
       c9Wk0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Wk1; else goto c9Wk2;
       c9Wk1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wk2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9WjX_info;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Encoding.Iconv.iconvEncoding18_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_s9W19_info" {
     ds_s9W19_info:
         const ds_s9W19_entry;
         const 1;
         const 16;
 },
 _c9WjX() //  [R1, R2]
         { []
         }
     {offset
       c9WjX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Wk5; else goto c9Wk4;
       c9Wk5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9Wk4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9WjX_info" {
     block_c9WjX_info:
         const _c9WjX;
         const 0;
         const 30;
 },
 enc_s9W1h_entry() //  [R1]
         { []
         }
     {offset
       c9Wkc: // global
           _s9W1h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wkd; else goto c9Wke;
       c9Wke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Wkg; else goto c9Wkf;
       c9Wkg: // global
           HpAlloc = 24;
           goto c9Wkd;
       c9Wkd: // global
           R1 = _s9W1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wkf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9W1h::P64;
           _s9W19::P64 = P64[_s9W1h::P64 + 16];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = _s9W19::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . enc_s9W1h_info" {
     enc_s9W1h_info:
         const enc_s9W1h_entry;
         const 1;
         const 4294967312;
         const S9W22_srt+64;
 },
 enc1_s9W1m_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c9Wkm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc1_s9W1m_info" {
     enc1_s9W1m_info:
         const enc1_s9W1m_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S9W22_srt+72;
 },
 enc2_s9W1n_entry() //  [R1]
         { []
         }
     {offset
       c9Wku: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding10_closure+4;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc2_s9W1n_info" {
     enc2_s9W1n_info:
         const enc2_s9W1n_entry;
         const 3;
         const 279172874248;
         const 4294967299;
         const S9W22_srt+32;
 },
 enc3_s9W1o_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c9WkC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc3_s9W1o_info" {
     enc3_s9W1o_info:
         const enc3_s9W1o_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S9W22_srt+88;
 },
 enc4_s9W1p_entry() //  [R1]
         { []
         }
     {offset
       c9WkK: // global
           R5 = GHC.IO.Encoding.Iconv.iconvEncoding4_closure+4;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Encoding.Iconv.haskellChar_closure;
           call GHC.IO.Encoding.Iconv.iconvEncoding11_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . enc4_s9W1p_info" {
     enc4_s9W1p_info:
         const enc4_s9W1p_entry;
         const 2;
         const 1172526071819;
         const 4294967299;
         const S9W22_srt+32;
 },
 sat_s9W1v_entry() //  [R1]
         { []
         }
     {offset
       c9Wl1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Wl2; else goto c9Wl3;
       c9Wl2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wl3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9WkU_info;
           _s9W1q::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s9W1q::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9Wld; else goto c9WkV;
       u9Wld: // global
           call _c9WkU(R1) args: 0, res: 0, upd: 0;
       c9WkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s9W1v_info" {
     sat_s9W1v_info:
         const sat_s9W1v_entry;
         const 2;
         const 18;
 },
 _c9WkU() //  [R1]
         { []
         }
     {offset
       c9WkU: // global
           if (R1 & 7 == 1) goto c9WkY; else goto c9WkZ;
       c9WkY: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9WkZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Wlc; else goto c9Wlb;
       c9Wlc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9Wlb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c9WkU_info" {
     block_c9WkU_info:
         const _c9WkU;
         const 1;
         const 30;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding2_entry() //  [R2, R3]
         { []
         }
     {offset
       c9Wle: // global
           _s9W17::P64 = R3;
           _s9W16::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wlf; else goto c9Wlg;
       c9Wlg: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c9Wli; else goto c9Wlh;
       c9Wli: // global
           HpAlloc = 192;
           goto c9Wlf;
       c9Wlf: // global
           R3 = _s9W17::P64;
           R2 = _s9W16::P64;
           R1 = GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wlh: // global
           I64[Hp - 184] = ds_s9W19_info;
           P64[Hp - 168] = _s9W17::P64;
           I64[Hp - 160] = stg_sel_0_upd_info;
           _c9WjT::P64 = Hp - 184;
           P64[Hp - 144] = _c9WjT::P64;
           I64[Hp - 136] = enc_s9W1h_info;
           P64[Hp - 120] = _c9WjT::P64;
           I64[Hp - 112] = enc1_s9W1m_info;
           P64[Hp - 104] = _s9W16::P64;
           I64[Hp - 96] = enc2_s9W1n_info;
           P64[Hp - 88] = Hp - 160;
           P64[Hp - 80] = Hp - 136;
           P64[Hp - 72] = Hp - 109;
           I64[Hp - 64] = enc3_s9W1o_info;
           P64[Hp - 56] = _s9W16::P64;
           I64[Hp - 48] = enc4_s9W1p_info;
           P64[Hp - 40] = _s9W17::P64;
           P64[Hp - 32] = Hp - 61;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = _s9W17::P64;
           P64[Hp - 8] = Hp - 95;
           P64[Hp] = Hp - 47;
           I64[Sp - 16] = block_c9WkO_info;
           R3 = GHC.IO.Encoding.Iconv.iconvEncoding3_closure+1;
           _c9WkN::P64 = Hp - 23;
           R2 = _c9WkN::P64;
           P64[Sp - 8] = _c9WkN::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding2_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding2_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding2_entry;
         const 0;
         const 8731668512782;
         const 12884901903;
         const S9W22_srt+32;
 },
 _c9WkO() //  [R1]
         { []
         }
     {offset
       c9WkO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9Wll; else goto c9Wlk;
       c9Wll: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Wlk: // global
           I64[Hp - 24] = sat_s9W1v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c9WkO_info" {
     block_c9WkO_info:
         const _c9WkO;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.804709919 UTC

[section ""data" . GHC.IO.Encoding.Iconv.mkIconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.mkIconvEncoding_entry() //  [R2, R3]
         { []
         }
     {offset
       c9WmA: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.mkIconvEncoding_info" {
     GHC.IO.Encoding.Iconv.mkIconvEncoding_info:
         const GHC.IO.Encoding.Iconv.mkIconvEncoding_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const S9W22_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.808255745 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding1_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding1_entry() //  [R2]
         { []
         }
     {offset
       c9WmL: // global
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           call GHC.IO.Encoding.Iconv.iconvEncoding2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding1_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding1_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding1_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const S9W22_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.811566588 UTC

[section ""data" . GHC.IO.Encoding.Iconv.iconvEncoding_closure" {
     GHC.IO.Encoding.Iconv.iconvEncoding_closure:
         const GHC.IO.Encoding.Iconv.iconvEncoding_info;
         const 0;
 },
 GHC.IO.Encoding.Iconv.iconvEncoding_entry() //  [R2]
         { []
         }
     {offset
       c9WmX: // global
           R2 = R2;
           call GHC.IO.Encoding.Iconv.iconvEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Iconv.iconvEncoding_info" {
     GHC.IO.Encoding.Iconv.iconvEncoding_info:
         const GHC.IO.Encoding.Iconv.iconvEncoding_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const S9W22_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:01.814697753 UTC

[section ""relreadonly" . S9W22_srt" {
     S9W22_srt:
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_r9V6z_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding16_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding11_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding12_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding6_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding7_closure;
         const GHC.IO.Encoding.Iconv.haskellChar_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding10_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding4_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding2_closure;
         const GHC.IO.Encoding.Iconv.iconvEncoding1_closure;
 }]

