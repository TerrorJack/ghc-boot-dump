
==================== Output Cmm ====================
2018-03-16 16:03:34.964240001 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:34.964847784 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.965769744 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { info_tbl: [(c8rXV,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rXV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rXW; else goto c8rXX;
       c8rXW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rXX: // global
           (_c8rXS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rXS::I64 == 0) goto c8rXU; else goto c8rXT;
       c8rXU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rXT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rXS::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.966721443 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.967446995 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { info_tbl: [(c8rY4,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rY4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rY5; else goto c8rY6;
       c8rY5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rY6: // global
           (_c8rY1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rY1::I64 == 0) goto c8rY3; else goto c8rY2;
       c8rY3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rY2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rY1::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.968374151 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.969108895 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { info_tbl: [(c8rYd,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rYd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rYe; else goto c8rYf;
       c8rYe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rYf: // global
           (_c8rYa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rYa::I64 == 0) goto c8rYc; else goto c8rYb;
       c8rYc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rYb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rYa::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.970072115 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.970788579 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { info_tbl: [(c8rYm,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rYn; else goto c8rYo;
       c8rYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rYo: // global
           (_c8rYj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rYj::I64 == 0) goto c8rYl; else goto c8rYk;
       c8rYl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rYk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rYj::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.972085415 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8rYC,
                       label: GHC.IO.Encoding.Failure.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rYD; else goto c8rYE;
       c8rYD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8rYE: // global
           I64[Sp - 16] = block_c8rYt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8rYT; else goto c8rYu;
       u8rYT: // global
           call _c8rYt(R1) args: 0, res: 0, upd: 0;
       c8rYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8rYt() //  [R1]
         { info_tbl: [(c8rYt,
                       label: block_c8rYt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rYt: // global
           _s8rVM::P64 = P64[Sp + 8];
           _c8rYB::P64 = R1 & 7;
           if (_c8rYB::P64 < 3) goto u8rYR; else goto u8rYS;
       u8rYR: // global
           if (_c8rYB::P64 < 2) goto c8rYx; else goto c8rYy;
       c8rYx: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8rYy: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8rYS: // global
           if (_c8rYB::P64 < 4) goto c8rYz; else goto c8rYA;
       c8rYz: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8rYA: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.973521733 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { info_tbl: [(c8rYZ,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rYZ: // global
           _s8rVP::P64 = R3;
           R3 = R4;
           R2 = _s8rVP::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.974579341 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8rZf,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rZf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8rZg; else goto c8rZh;
       c8rZg: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8rZh: // global
           I64[Sp - 8] = block_c8rZ6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8rZw; else goto c8rZ7;
       u8rZw: // global
           call _c8rZ6(R1) args: 0, res: 0, upd: 0;
       c8rZ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8rZ6() //  [R1]
         { info_tbl: [(c8rZ6,
                       label: block_c8rZ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rZ6: // global
           _c8rZe::P64 = R1 & 7;
           if (_c8rZe::P64 < 3) goto u8rZu; else goto u8rZv;
       u8rZu: // global
           if (_c8rZe::P64 < 2) goto c8rZa; else goto c8rZb;
       c8rZa: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8rZb: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8rZv: // global
           if (_c8rZe::P64 < 4) goto c8rZc; else goto c8rZd;
       c8rZc: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8rZd: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.975930005 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8rZB,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rZB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.976637545 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.977267673 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.978021808 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { info_tbl: [(c8rZK,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rZK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rZL; else goto c8rZM;
       c8rZL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rZM: // global
           (_c8rZH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rZH::I64 == 0) goto c8rZJ; else goto c8rZI;
       c8rZJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rZI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rZH::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.97888468 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.979589174 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { info_tbl: [(c8rZT,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rZT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rZU; else goto c8rZV;
       c8rZU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8rZV: // global
           (_c8rZQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rZQ::I64 == 0) goto c8rZS; else goto c8rZR;
       c8rZS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8rZR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rZQ::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.980436153 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.981184039 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { info_tbl: [(c8s02,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s02: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s03; else goto c8s04;
       c8s03: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s04: // global
           (_c8rZZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8rZZ::I64 == 0) goto c8s01; else goto c8s00;
       c8s01: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s00: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8rZZ::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.982603429 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { info_tbl: [(c8s0i,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s0i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8s0j; else goto c8s0k;
       c8s0j: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8s0k: // global
           I64[Sp - 8] = block_c8s09_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8s0z; else goto c8s0a;
       u8s0z: // global
           call _c8s09(R1) args: 0, res: 0, upd: 0;
       c8s0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s09() //  [R1]
         { info_tbl: [(c8s09,
                       label: block_c8s09_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s09: // global
           _c8s0h::P64 = R1 & 7;
           if (_c8s0h::P64 < 3) goto u8s0x; else goto u8s0y;
       u8s0x: // global
           if (_c8s0h::P64 < 2) goto c8s0d; else goto c8s0e;
       c8s0d: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s0e: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8s0y: // global
           if (_c8s0h::P64 < 4) goto c8s0f; else goto c8s0g;
       c8s0f: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8s0g: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.983799433 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.98453994 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { info_tbl: [(c8s0G,
                       label: GHC.IO.Encoding.Failure.recoverDecode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s0G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s0H; else goto c8s0I;
       c8s0H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s0I: // global
           (_c8s0D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s0D::I64 == 0) goto c8s0F; else goto c8s0E;
       c8s0F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s0E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s0D::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.985436392 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.986148088 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { info_tbl: [(c8s0P,
                       label: GHC.IO.Encoding.Failure.recoverDecode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s0P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s0Q; else goto c8s0R;
       c8s0Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s0R: // global
           (_c8s0M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s0M::I64 == 0) goto c8s0O; else goto c8s0N;
       c8s0O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s0N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s0M::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.986996595 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.987785249 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { info_tbl: [(c8s0Y,
                       label: GHC.IO.Encoding.Failure.recoverDecode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s0Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s0Z; else goto c8s10;
       c8s0Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s10: // global
           (_c8s0V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s0V::I64 == 0) goto c8s0X; else goto c8s0W;
       c8s0X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s0W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s0V::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.988677089 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.989412824 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { info_tbl: [(c8s17,
                       label: GHC.IO.Encoding.Failure.recoverEncode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s17: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s18; else goto c8s19;
       c8s18: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s19: // global
           (_c8s14::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s14::I64 == 0) goto c8s16; else goto c8s15;
       c8s16: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s15: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s14::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.990269311 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.99101353 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { info_tbl: [(c8s1g,
                       label: GHC.IO.Encoding.Failure.recoverEncode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s1h; else goto c8s1i;
       c8s1h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s1i: // global
           (_c8s1d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s1d::I64 == 0) goto c8s1f; else goto c8s1e;
       c8s1f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s1e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s1d::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.991922091 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.992698711 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { info_tbl: [(c8s1p,
                       label: GHC.IO.Encoding.Failure.recoverEncode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s1q; else goto c8s1r;
       c8s1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s1r: // global
           (_c8s1m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s1m::I64 == 0) goto c8s1o; else goto c8s1n;
       c8s1o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s1n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s1m::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.993975549 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.994513665 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.995050777 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.995634493 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.996240532 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.997063079 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.997871319 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.999967752 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.000531465 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.001124577 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.001697393 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.002276655 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.002844976 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.003346552 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.003886688 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.004405228 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.004920473 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.005501664 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.006031617 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.006586551 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.007159075 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.009827626 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8s1z,
                       label: GHC.IO.Encoding.Failure.recoverDecode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1z: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8s1D; else goto c8s1E;
       c8s1D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8s1E: // global
           I64[Sp - 24] = block_c8s1w_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8s3y; else goto c8s1x;
       u8s3y: // global
           call _c8s1w(R1) args: 0, res: 0, upd: 0;
       c8s1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s1w() //  [R1]
         { info_tbl: [(c8s1w,
                       label: block_c8s1w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1w: // global
           I64[Sp - 40] = block_c8s1C_info;
           _s8rW3::P64 = P64[R1 + 7];
           _s8rW4::P64 = P64[R1 + 15];
           _s8rW2::I64 = I64[R1 + 23];
           _s8rW5::I64 = I64[R1 + 31];
           _s8rW6::I64 = I64[R1 + 39];
           _s8rW7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8rW4::P64;
           I64[Sp - 24] = _s8rW5::I64;
           I64[Sp - 16] = _s8rW6::I64;
           I64[Sp - 8] = _s8rW7::I64;
           P64[Sp] = _s8rW3::P64;
           I64[Sp + 16] = _s8rW2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8s3x; else goto c8s1G;
       u8s3x: // global
           call _c8s1C(R1) args: 0, res: 0, upd: 0;
       c8s1G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s1C() //  [R1]
         { info_tbl: [(c8s1C,
                       label: block_c8s1C_info
                       rep:StackRep [False, True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1C: // global
           I64[Sp - 48] = block_c8s1K_info;
           _s8rW8::P64 = R1;
           _s8rWa::P64 = P64[R1 + 7];
           _s8rWb::P64 = P64[R1 + 15];
           _s8rW9::I64 = I64[R1 + 23];
           _s8rWc::I64 = I64[R1 + 31];
           _s8rWd::I64 = I64[R1 + 39];
           _s8rWe::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8rWa::P64;
           P64[Sp - 32] = _s8rWb::P64;
           I64[Sp - 24] = _s8rWc::I64;
           I64[Sp - 16] = _s8rWd::I64;
           I64[Sp - 8] = _s8rWe::I64;
           I64[Sp] = _s8rW9::I64;
           P64[Sp + 48] = _s8rW8::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8s3z; else goto c8s1M;
       u8s3z: // global
           call _c8s1K(R1) args: 0, res: 0, upd: 0;
       c8s1M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s1K() //  [R1]
         { info_tbl: [(c8s1K,
                       label: block_c8s1K_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s1K: // global
           _s8rW2::I64 = I64[Sp + 104];
           _s8rW3::P64 = P64[Sp + 88];
           _s8rW4::P64 = P64[Sp + 56];
           _s8rW5::I64 = I64[Sp + 64];
           _s8rW6::I64 = I64[Sp + 72];
           _s8rW7::I64 = I64[Sp + 80];
           _c8s3u::P64 = R1 & 7;
           if (_c8s3u::P64 < 3) goto u8s3v; else goto u8s3w;
       u8s3v: // global
           if (_c8s3u::P64 < 2) goto c8s1S; else goto c8s20;
       c8s1S: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8s20: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8s23; else goto c8s22;
       c8s23: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8s22: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8s3w: // global
           _s8rW9::I64 = I64[Sp + 48];
           _s8rWa::P64 = P64[Sp + 8];
           _s8rWb::P64 = P64[Sp + 16];
           _s8rWc::I64 = I64[Sp + 24];
           _s8rWd::I64 = I64[Sp + 32];
           _s8rWe::I64 = I64[Sp + 40];
           if (_c8s3u::P64 < 4) goto c8s2g; else goto c8s2k;
       c8s2g: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8s2p; else goto c8s2i;
       c8s2i: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s2k: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8s2p; else goto c8s2o;
       c8s2p: // global
           HpAlloc = 136;
           R1 = _s8rWf::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8s2o: // global
           _s8rWt::I64 = %MO_UU_Conv_W8_W64(I8[_s8rW2::I64 + _s8rW6::I64]);
           call MO_Touch(_s8rW3::P64);
           if (_s8rWt::I64 >= 128) goto c8s31; else goto c8s3t;
       c8s31: // global
           _s8rWw::I64 = _s8rWt::I64 + 56320;
           if (_s8rWw::I64 > 1114111) goto c8s2J; else goto c8s2Z;
       c8s2J: // global
           Hp = Hp - 136;
           R2 = _s8rWw::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8s2Z: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWw::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s3t: // global
           if (_s8rWt::I64 > 1114111) goto c8s3c; else goto c8s3s;
       c8s3c: // global
           Hp = Hp - 136;
           R2 = _s8rWt::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8s3s: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWt::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.013375691 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8s3E,
                       label: GHC.IO.Encoding.Failure.recoverDecode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s3E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.015614369 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8s3O,
                       label: GHC.IO.Encoding.Failure.recoverEncode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s3O: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8s3S; else goto c8s3T;
       c8s3S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8s3T: // global
           I64[Sp - 24] = block_c8s3L_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8s5n; else goto c8s3M;
       u8s5n: // global
           call _c8s3L(R1) args: 0, res: 0, upd: 0;
       c8s3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s3L() //  [R1]
         { info_tbl: [(c8s3L,
                       label: block_c8s3L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s3L: // global
           I64[Sp - 48] = block_c8s3R_info;
           _s8rWZ::P64 = R1;
           _s8rX1::P64 = P64[R1 + 7];
           _s8rX2::P64 = P64[R1 + 15];
           _s8rX0::I64 = I64[R1 + 23];
           _s8rX3::I64 = I64[R1 + 31];
           _s8rX4::I64 = I64[R1 + 39];
           _s8rX5::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8rX1::P64;
           P64[Sp - 32] = _s8rX2::P64;
           I64[Sp - 24] = _s8rX3::I64;
           I64[Sp - 16] = _s8rX4::I64;
           I64[Sp - 8] = _s8rX5::I64;
           I64[Sp] = _s8rX0::I64;
           P64[Sp + 16] = _s8rWZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8s5m; else goto c8s3V;
       u8s5m: // global
           call _c8s3R(R1) args: 0, res: 0, upd: 0;
       c8s3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s3R() //  [R1]
         { info_tbl: [(c8s3R,
                       label: block_c8s3R_info
                       rep:StackRep [False, False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s3R: // global
           _s8rWV::P64 = P64[Sp + 56];
           _s8rX8::P64 = P64[R1 + 7];
           _s8rX9::P64 = P64[R1 + 15];
           _s8rX7::I64 = I64[R1 + 23];
           _s8rXa::I64 = I64[R1 + 31];
           _s8rXb::I64 = I64[R1 + 39];
           _s8rXc::I64 = I64[R1 + 47];
           _s8rXf::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8s40_info;
           _s8rX6::P64 = R1;
           R1 = _s8rWV::P64;
           P64[Sp - 48] = _s8rX8::P64;
           P64[Sp - 40] = _s8rX9::P64;
           I64[Sp - 32] = _s8rXa::I64;
           I64[Sp - 24] = _s8rXb::I64;
           I64[Sp - 16] = _s8rXc::I64;
           I64[Sp - 8] = _s8rXf::I64;
           I64[Sp] = _s8rX7::I64;
           P64[Sp + 56] = _s8rX6::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8s5o; else goto c8s42;
       u8s5o: // global
           call _c8s40(R1) args: 0, res: 0, upd: 0;
       c8s42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s40() //  [R1]
         { info_tbl: [(c8s40,
                       label: block_c8s40_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s40: // global
           _s8rX0::I64 = I64[Sp + 104];
           _s8rX1::P64 = P64[Sp + 64];
           _s8rX2::P64 = P64[Sp + 72];
           _s8rX3::I64 = I64[Sp + 80];
           _s8rX4::I64 = I64[Sp + 88];
           _s8rX5::I64 = I64[Sp + 96];
           _s8rX6::P64 = P64[Sp + 112];
           _c8s5j::P64 = R1 & 7;
           if (_c8s5j::P64 < 3) goto u8s5k; else goto u8s5l;
       u8s5k: // global
           if (_c8s5j::P64 < 2) goto c8s48; else goto c8s4g;
       c8s48: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8s4g: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8s4p; else goto c8s4i;
       c8s4i: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8s5l: // global
           _s8rXf::I64 = I64[Sp + 48];
           if (_c8s5j::P64 < 4) goto c8s4k; else goto c8s4D;
       c8s4k: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8s4p; else goto c8s4o;
       c8s4p: // global
           HpAlloc = 80;
           R1 = _s8rXh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8s4o: // global
           if (_s8rXf::I64 == 63) goto c8s4C; else goto c8s4v;
       c8s4C: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s4v: // global
           _s8rWZ::P64 = P64[Sp + 120];
           I32[_s8rX0::I64 + (_s8rX4::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8rX1::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8rWZ::P64;
           P64[Hp - 56] = _s8rX6::P64;
           _c8s4t::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8s4t::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s4D: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8s4I; else goto c8s4H;
       c8s4I: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8s4H: // global
           if (%MO_S_Gt_W64(56448, _s8rXf::I64)) goto c8s4V; else goto c8s5i;
       c8s5i: // global
           if (%MO_S_Ge_W64(_s8rXf::I64, 56576)) goto c8s4V; else goto c8s5h;
       c8s4V: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8s5h: // global
           _s8rX7::I64 = I64[Sp + 56];
           _s8rX8::P64 = P64[Sp + 8];
           _s8rX9::P64 = P64[Sp + 16];
           _s8rXa::I64 = I64[Sp + 24];
           _s8rXb::I64 = I64[Sp + 32];
           _s8rXc::I64 = I64[Sp + 40];
           I8[_s8rX7::I64 + _s8rXc::I64] = %MO_UU_Conv_W64_W8(_s8rXf::I64);
           call MO_Touch(_s8rX8::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rX8::P64;
           P64[Hp - 112] = _s8rX9::P64;
           I64[Hp - 104] = _s8rX7::I64;
           I64[Hp - 96] = _s8rXa::I64;
           I64[Hp - 88] = _s8rXb::I64;
           I64[Hp - 80] = _s8rXc::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.018920286 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8s5t,
                       label: GHC.IO.Encoding.Failure.recoverEncode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s5t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.02014434 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { info_tbl: [(c8s5D,
                       label: GHC.IO.Encoding.Failure.isSurrogate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s5D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8s5E; else goto c8s5F;
       c8s5E: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8s5F: // global
           I64[Sp - 8] = block_c8s5A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8s6f; else goto c8s5B;
       u8s6f: // global
           call _c8s5A(R1) args: 0, res: 0, upd: 0;
       c8s5B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s5A() //  [R1]
         { info_tbl: [(c8s5A,
                       label: block_c8s5A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s5A: // global
           _s8rXI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8rXI::I64)) goto c8s5V; else goto c8s68;
       c8s5V: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8s63; else goto c8s5T;
       c8s5T: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s68: // global
           if (%MO_S_Gt_W64(_s8rXI::I64, 56319)) goto c8s66; else goto c8s67;
       c8s66: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8s63; else goto c8s64;
       c8s63: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s64: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s67: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.02201166 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.022552302 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.023084143 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.023637762 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.024162282 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.024786915 UTC

[GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8s6g,
                       label: GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6g: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.025569634 UTC

[GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8s6h,
                       label: GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6h: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.026260338 UTC

[GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8s6i,
                       label: GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6i: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.026976061 UTC

[GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { info_tbl: [(c8s6j,
                       label: GHC.IO.Encoding.Failure.RoundtripFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6j: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.027652013 UTC

[section ""relreadonly" . S8rYU_srt" {
     S8rYU_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.028295326 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:35.028811237 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.029632691 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { info_tbl: [(c8s6q,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s6r; else goto c8s6s;
       c8s6r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s6s: // global
           (_c8s6n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s6n::I64 == 0) goto c8s6p; else goto c8s6o;
       c8s6p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s6o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s6n::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.030568072 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.031259726 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { info_tbl: [(c8s6z,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s6A; else goto c8s6B;
       c8s6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s6B: // global
           (_c8s6w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s6w::I64 == 0) goto c8s6y; else goto c8s6x;
       c8s6y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s6x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s6w::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.032102977 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.032835233 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { info_tbl: [(c8s6I,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s6J; else goto c8s6K;
       c8s6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s6K: // global
           (_c8s6F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s6F::I64 == 0) goto c8s6H; else goto c8s6G;
       c8s6H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s6G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s6F::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.033876566 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.034612056 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { info_tbl: [(c8s6R,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s6S; else goto c8s6T;
       c8s6S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s6T: // global
           (_c8s6O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s6O::I64 == 0) goto c8s6Q; else goto c8s6P;
       c8s6Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s6P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s6O::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.035895612 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8s77,
                       label: GHC.IO.Encoding.Failure.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s78; else goto c8s79;
       c8s78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8s79: // global
           I64[Sp - 16] = block_c8s6Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8s7o; else goto c8s6Z;
       u8s7o: // global
           call _c8s6Y(R1) args: 0, res: 0, upd: 0;
       c8s6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s6Y() //  [R1]
         { info_tbl: [(c8s6Y,
                       label: block_c8s6Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s6Y: // global
           _s8rVM::P64 = P64[Sp + 8];
           _c8s76::P64 = R1 & 7;
           if (_c8s76::P64 < 3) goto u8s7m; else goto u8s7n;
       u8s7m: // global
           if (_c8s76::P64 < 2) goto c8s72; else goto c8s73;
       c8s72: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8s73: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8s7n: // global
           if (_c8s76::P64 < 4) goto c8s74; else goto c8s75;
       c8s74: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8s75: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.037328943 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { info_tbl: [(c8s7t,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s7t: // global
           _s8rVP::P64 = R3;
           R3 = R4;
           R2 = _s8rVP::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.038440618 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8s7J,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s7J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8s7K; else goto c8s7L;
       c8s7K: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8s7L: // global
           I64[Sp - 8] = block_c8s7A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8s80; else goto c8s7B;
       u8s80: // global
           call _c8s7A(R1) args: 0, res: 0, upd: 0;
       c8s7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s7A() //  [R1]
         { info_tbl: [(c8s7A,
                       label: block_c8s7A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s7A: // global
           _c8s7I::P64 = R1 & 7;
           if (_c8s7I::P64 < 3) goto u8s7Y; else goto u8s7Z;
       u8s7Y: // global
           if (_c8s7I::P64 < 2) goto c8s7E; else goto c8s7F;
       c8s7E: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8s7F: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8s7Z: // global
           if (_c8s7I::P64 < 4) goto c8s7G; else goto c8s7H;
       c8s7G: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8s7H: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.039758338 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8s85,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s85: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.041862814 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.042473509 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.043225495 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { info_tbl: [(c8s8e,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s8f; else goto c8s8g;
       c8s8f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s8g: // global
           (_c8s8b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s8b::I64 == 0) goto c8s8d; else goto c8s8c;
       c8s8d: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s8c: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s8b::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.044186234 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.044904776 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { info_tbl: [(c8s8n,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s8o; else goto c8s8p;
       c8s8o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s8p: // global
           (_c8s8k::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s8k::I64 == 0) goto c8s8m; else goto c8s8l;
       c8s8m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s8l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s8k::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.046227883 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.046984069 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { info_tbl: [(c8s8w,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s8x; else goto c8s8y;
       c8s8x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s8y: // global
           (_c8s8t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s8t::I64 == 0) goto c8s8v; else goto c8s8u;
       c8s8v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s8u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s8t::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.048202445 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { info_tbl: [(c8s8M,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8s8N; else goto c8s8O;
       c8s8N: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8s8O: // global
           I64[Sp - 8] = block_c8s8D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8s93; else goto c8s8E;
       u8s93: // global
           call _c8s8D(R1) args: 0, res: 0, upd: 0;
       c8s8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s8D() //  [R1]
         { info_tbl: [(c8s8D,
                       label: block_c8s8D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8D: // global
           _c8s8L::P64 = R1 & 7;
           if (_c8s8L::P64 < 3) goto u8s91; else goto u8s92;
       u8s91: // global
           if (_c8s8L::P64 < 2) goto c8s8H; else goto c8s8I;
       c8s8H: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8s8I: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8s92: // global
           if (_c8s8L::P64 < 4) goto c8s8J; else goto c8s8K;
       c8s8J: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8s8K: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.049435402 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.050133427 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { info_tbl: [(c8s9a,
                       label: GHC.IO.Encoding.Failure.recoverDecode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9b; else goto c8s9c;
       c8s9b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9c: // global
           (_c8s97::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s97::I64 == 0) goto c8s99; else goto c8s98;
       c8s99: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s98: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s97::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.051021723 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.051760624 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { info_tbl: [(c8s9j,
                       label: GHC.IO.Encoding.Failure.recoverDecode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9k; else goto c8s9l;
       c8s9k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9l: // global
           (_c8s9g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s9g::I64 == 0) goto c8s9i; else goto c8s9h;
       c8s9i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s9h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s9g::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.052679457 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.053472865 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { info_tbl: [(c8s9s,
                       label: GHC.IO.Encoding.Failure.recoverDecode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9t; else goto c8s9u;
       c8s9t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9u: // global
           (_c8s9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s9p::I64 == 0) goto c8s9r; else goto c8s9q;
       c8s9r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s9q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s9p::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.054405277 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.055143692 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { info_tbl: [(c8s9B,
                       label: GHC.IO.Encoding.Failure.recoverEncode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9C; else goto c8s9D;
       c8s9C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9D: // global
           (_c8s9y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s9y::I64 == 0) goto c8s9A; else goto c8s9z;
       c8s9A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s9z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s9y::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.056002965 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.056722219 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { info_tbl: [(c8s9K,
                       label: GHC.IO.Encoding.Failure.recoverEncode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9L; else goto c8s9M;
       c8s9L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9M: // global
           (_c8s9H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s9H::I64 == 0) goto c8s9J; else goto c8s9I;
       c8s9J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s9I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s9H::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.057645154 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.0584152 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { info_tbl: [(c8s9T,
                       label: GHC.IO.Encoding.Failure.recoverEncode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8s9U; else goto c8s9V;
       c8s9U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8s9V: // global
           (_c8s9Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8s9Q::I64 == 0) goto c8s9S; else goto c8s9R;
       c8s9S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8s9R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8s9Q::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.059284917 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.059895821 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.060452044 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.061018729 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.061925871 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.062503363 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.063011032 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.06357619 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.064183323 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.064801485 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.065392437 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.06601034 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.066587675 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.0671467 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.067707049 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.068354335 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.069092056 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.070571782 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.071407268 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.072158073 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.072927352 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.075985048 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sa3,
                       label: GHC.IO.Encoding.Failure.recoverDecode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sa3: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8sa7; else goto c8sa8;
       c8sa7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sa8: // global
           I64[Sp - 24] = block_c8sa0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sc2; else goto c8sa1;
       u8sc2: // global
           call _c8sa0(R1) args: 0, res: 0, upd: 0;
       c8sa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sa0() //  [R1]
         { info_tbl: [(c8sa0,
                       label: block_c8sa0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sa0: // global
           I64[Sp - 40] = block_c8sa6_info;
           _s8rW3::P64 = P64[R1 + 7];
           _s8rW4::P64 = P64[R1 + 15];
           _s8rW2::I64 = I64[R1 + 23];
           _s8rW5::I64 = I64[R1 + 31];
           _s8rW6::I64 = I64[R1 + 39];
           _s8rW7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8rW4::P64;
           I64[Sp - 24] = _s8rW5::I64;
           I64[Sp - 16] = _s8rW6::I64;
           I64[Sp - 8] = _s8rW7::I64;
           P64[Sp] = _s8rW3::P64;
           I64[Sp + 16] = _s8rW2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8sc1; else goto c8saa;
       u8sc1: // global
           call _c8sa6(R1) args: 0, res: 0, upd: 0;
       c8saa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sa6() //  [R1]
         { info_tbl: [(c8sa6,
                       label: block_c8sa6_info
                       rep:StackRep [False, True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sa6: // global
           I64[Sp - 48] = block_c8sae_info;
           _s8rW8::P64 = R1;
           _s8rWa::P64 = P64[R1 + 7];
           _s8rWb::P64 = P64[R1 + 15];
           _s8rW9::I64 = I64[R1 + 23];
           _s8rWc::I64 = I64[R1 + 31];
           _s8rWd::I64 = I64[R1 + 39];
           _s8rWe::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8rWa::P64;
           P64[Sp - 32] = _s8rWb::P64;
           I64[Sp - 24] = _s8rWc::I64;
           I64[Sp - 16] = _s8rWd::I64;
           I64[Sp - 8] = _s8rWe::I64;
           I64[Sp] = _s8rW9::I64;
           P64[Sp + 48] = _s8rW8::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sc3; else goto c8sag;
       u8sc3: // global
           call _c8sae(R1) args: 0, res: 0, upd: 0;
       c8sag: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sae() //  [R1]
         { info_tbl: [(c8sae,
                       label: block_c8sae_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sae: // global
           _s8rW2::I64 = I64[Sp + 104];
           _s8rW3::P64 = P64[Sp + 88];
           _s8rW4::P64 = P64[Sp + 56];
           _s8rW5::I64 = I64[Sp + 64];
           _s8rW6::I64 = I64[Sp + 72];
           _s8rW7::I64 = I64[Sp + 80];
           _c8sbY::P64 = R1 & 7;
           if (_c8sbY::P64 < 3) goto u8sbZ; else goto u8sc0;
       u8sbZ: // global
           if (_c8sbY::P64 < 2) goto c8sam; else goto c8sau;
       c8sam: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sau: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8sax; else goto c8saw;
       c8sax: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8saw: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sc0: // global
           _s8rW9::I64 = I64[Sp + 48];
           _s8rWa::P64 = P64[Sp + 8];
           _s8rWb::P64 = P64[Sp + 16];
           _s8rWc::I64 = I64[Sp + 24];
           _s8rWd::I64 = I64[Sp + 32];
           _s8rWe::I64 = I64[Sp + 40];
           if (_c8sbY::P64 < 4) goto c8saK; else goto c8saO;
       c8saK: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8saT; else goto c8saM;
       c8saM: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8saO: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8saT; else goto c8saS;
       c8saT: // global
           HpAlloc = 136;
           R1 = _s8rWf::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8saS: // global
           _s8rWt::I64 = %MO_UU_Conv_W8_W64(I8[_s8rW2::I64 + _s8rW6::I64]);
           call MO_Touch(_s8rW3::P64);
           if (_s8rWt::I64 >= 128) goto c8sbv; else goto c8sbX;
       c8sbv: // global
           _s8rWw::I64 = _s8rWt::I64 + 56320;
           if (_s8rWw::I64 > 1114111) goto c8sbd; else goto c8sbt;
       c8sbd: // global
           Hp = Hp - 136;
           R2 = _s8rWw::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sbt: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWw::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sbX: // global
           if (_s8rWt::I64 > 1114111) goto c8sbG; else goto c8sbW;
       c8sbG: // global
           Hp = Hp - 136;
           R2 = _s8rWt::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sbW: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWt::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.080912124 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sc8,
                       label: GHC.IO.Encoding.Failure.recoverDecode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sc8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.085467118 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sci,
                       label: GHC.IO.Encoding.Failure.recoverEncode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sci: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8scm; else goto c8scn;
       c8scm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8scn: // global
           I64[Sp - 24] = block_c8scf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sdR; else goto c8scg;
       u8sdR: // global
           call _c8scf(R1) args: 0, res: 0, upd: 0;
       c8scg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8scf() //  [R1]
         { info_tbl: [(c8scf,
                       label: block_c8scf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8scf: // global
           I64[Sp - 48] = block_c8scl_info;
           _s8rWZ::P64 = R1;
           _s8rX1::P64 = P64[R1 + 7];
           _s8rX2::P64 = P64[R1 + 15];
           _s8rX0::I64 = I64[R1 + 23];
           _s8rX3::I64 = I64[R1 + 31];
           _s8rX4::I64 = I64[R1 + 39];
           _s8rX5::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8rX1::P64;
           P64[Sp - 32] = _s8rX2::P64;
           I64[Sp - 24] = _s8rX3::I64;
           I64[Sp - 16] = _s8rX4::I64;
           I64[Sp - 8] = _s8rX5::I64;
           I64[Sp] = _s8rX0::I64;
           P64[Sp + 16] = _s8rWZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sdQ; else goto c8scp;
       u8sdQ: // global
           call _c8scl(R1) args: 0, res: 0, upd: 0;
       c8scp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8scl() //  [R1]
         { info_tbl: [(c8scl,
                       label: block_c8scl_info
                       rep:StackRep [False, False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8scl: // global
           _s8rWV::P64 = P64[Sp + 56];
           _s8rX8::P64 = P64[R1 + 7];
           _s8rX9::P64 = P64[R1 + 15];
           _s8rX7::I64 = I64[R1 + 23];
           _s8rXa::I64 = I64[R1 + 31];
           _s8rXb::I64 = I64[R1 + 39];
           _s8rXc::I64 = I64[R1 + 47];
           _s8rXf::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8scu_info;
           _s8rX6::P64 = R1;
           R1 = _s8rWV::P64;
           P64[Sp - 48] = _s8rX8::P64;
           P64[Sp - 40] = _s8rX9::P64;
           I64[Sp - 32] = _s8rXa::I64;
           I64[Sp - 24] = _s8rXb::I64;
           I64[Sp - 16] = _s8rXc::I64;
           I64[Sp - 8] = _s8rXf::I64;
           I64[Sp] = _s8rX7::I64;
           P64[Sp + 56] = _s8rX6::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8sdS; else goto c8scw;
       u8sdS: // global
           call _c8scu(R1) args: 0, res: 0, upd: 0;
       c8scw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8scu() //  [R1]
         { info_tbl: [(c8scu,
                       label: block_c8scu_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8scu: // global
           _s8rX0::I64 = I64[Sp + 104];
           _s8rX1::P64 = P64[Sp + 64];
           _s8rX2::P64 = P64[Sp + 72];
           _s8rX3::I64 = I64[Sp + 80];
           _s8rX4::I64 = I64[Sp + 88];
           _s8rX5::I64 = I64[Sp + 96];
           _s8rX6::P64 = P64[Sp + 112];
           _c8sdN::P64 = R1 & 7;
           if (_c8sdN::P64 < 3) goto u8sdO; else goto u8sdP;
       u8sdO: // global
           if (_c8sdN::P64 < 2) goto c8scC; else goto c8scK;
       c8scC: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8scK: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8scT; else goto c8scM;
       c8scM: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sdP: // global
           _s8rXf::I64 = I64[Sp + 48];
           if (_c8sdN::P64 < 4) goto c8scO; else goto c8sd7;
       c8scO: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8scT; else goto c8scS;
       c8scT: // global
           HpAlloc = 80;
           R1 = _s8rXh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8scS: // global
           if (_s8rXf::I64 == 63) goto c8sd6; else goto c8scZ;
       c8sd6: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8scZ: // global
           _s8rWZ::P64 = P64[Sp + 120];
           I32[_s8rX0::I64 + (_s8rX4::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8rX1::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8rWZ::P64;
           P64[Hp - 56] = _s8rX6::P64;
           _c8scX::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8scX::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sd7: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8sdc; else goto c8sdb;
       c8sdc: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sdb: // global
           if (%MO_S_Gt_W64(56448, _s8rXf::I64)) goto c8sdp; else goto c8sdM;
       c8sdM: // global
           if (%MO_S_Ge_W64(_s8rXf::I64, 56576)) goto c8sdp; else goto c8sdL;
       c8sdp: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sdL: // global
           _s8rX7::I64 = I64[Sp + 56];
           _s8rX8::P64 = P64[Sp + 8];
           _s8rX9::P64 = P64[Sp + 16];
           _s8rXa::I64 = I64[Sp + 24];
           _s8rXb::I64 = I64[Sp + 32];
           _s8rXc::I64 = I64[Sp + 40];
           I8[_s8rX7::I64 + _s8rXc::I64] = %MO_UU_Conv_W64_W8(_s8rXf::I64);
           call MO_Touch(_s8rX8::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rX8::P64;
           P64[Hp - 112] = _s8rX9::P64;
           I64[Hp - 104] = _s8rX7::I64;
           I64[Hp - 96] = _s8rXa::I64;
           I64[Hp - 88] = _s8rXb::I64;
           I64[Hp - 80] = _s8rXc::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.089696584 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sdX,
                       label: GHC.IO.Encoding.Failure.recoverEncode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sdX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.090899303 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { info_tbl: [(c8se7,
                       label: GHC.IO.Encoding.Failure.isSurrogate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8se7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8se8; else goto c8se9;
       c8se8: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8se9: // global
           I64[Sp - 8] = block_c8se4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8seJ; else goto c8se5;
       u8seJ: // global
           call _c8se4(R1) args: 0, res: 0, upd: 0;
       c8se5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8se4() //  [R1]
         { info_tbl: [(c8se4,
                       label: block_c8se4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8se4: // global
           _s8rXI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8rXI::I64)) goto c8sep; else goto c8seC;
       c8sep: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sex; else goto c8sen;
       c8sen: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8seC: // global
           if (%MO_S_Gt_W64(_s8rXI::I64, 56319)) goto c8seA; else goto c8seB;
       c8seA: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sex; else goto c8sey;
       c8sex: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sey: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8seB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.092172995 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.09271327 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.093228071 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.093826476 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.09440021 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.09504103 UTC

[GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8seK,
                       label: GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8seK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.095756055 UTC

[GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8seM,
                       label: GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8seM: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.096496814 UTC

[GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8seO,
                       label: GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8seO: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.097214001 UTC

[GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { info_tbl: [(c8seQ,
                       label: GHC.IO.Encoding.Failure.RoundtripFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8seQ: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.097905736 UTC

[section ""relreadonly" . S8rYU_srt" {
     S8rYU_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.098816806 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:35.099963574 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.102253538 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { info_tbl: [(c8seZ,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8seZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sf0; else goto c8sf1;
       c8sf0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sf1: // global
           (_c8seW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8seW::I64 == 0) goto c8seY; else goto c8seX;
       c8seY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8seX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8seW::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.106342845 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.108211634 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { info_tbl: [(c8sfg,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfh; else goto c8sfi;
       c8sfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfi: // global
           (_c8sfd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfd::I64 == 0) goto c8sff; else goto c8sfe;
       c8sff: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfd::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.112117036 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.11450239 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { info_tbl: [(c8sfx,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfy; else goto c8sfz;
       c8sfy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfz: // global
           (_c8sfu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfu::I64 == 0) goto c8sfw; else goto c8sfv;
       c8sfw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfu::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.118405525 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.121257448 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { info_tbl: [(c8sfO,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sfO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sfP; else goto c8sfQ;
       c8sfP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sfQ: // global
           (_c8sfL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sfL::I64 == 0) goto c8sfN; else goto c8sfM;
       c8sfN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sfM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sfL::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.126018205 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8sgb,
                       label: GHC.IO.Encoding.Failure.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sgb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sgc; else goto c8sgd;
       c8sgc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sgd: // global
           I64[Sp - 16] = block_c8sg2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8sgs; else goto c8sg3;
       u8sgs: // global
           call _c8sg2(R1) args: 0, res: 0, upd: 0;
       c8sg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sg2() //  [R1]
         { info_tbl: [(c8sg2,
                       label: block_c8sg2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sg2: // global
           _s8rVM::P64 = P64[Sp + 8];
           _c8sga::P64 = R1 & 7;
           if (_c8sga::P64 < 3) goto u8sgq; else goto u8sgr;
       u8sgq: // global
           if (_c8sga::P64 < 2) goto c8sg6; else goto c8sg7;
       c8sg6: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8sg7: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8sgr: // global
           if (_c8sga::P64 < 4) goto c8sg8; else goto c8sg9;
       c8sg8: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8sg9: // global
           R3 = _s8rVM::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.132460555 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { info_tbl: [(c8sgH,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sgH: // global
           _s8rVP::P64 = R3;
           R3 = R4;
           R2 = _s8rVP::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.136221267 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8sh1,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sh1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sh2; else goto c8sh3;
       c8sh2: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sh3: // global
           I64[Sp - 8] = block_c8sgS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8shi; else goto c8sgT;
       u8shi: // global
           call _c8sgS(R1) args: 0, res: 0, upd: 0;
       c8sgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sgS() //  [R1]
         { info_tbl: [(c8sgS,
                       label: block_c8sgS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sgS: // global
           _c8sh0::P64 = R1 & 7;
           if (_c8sh0::P64 < 3) goto u8shg; else goto u8shh;
       u8shg: // global
           if (_c8sh0::P64 < 2) goto c8sgW; else goto c8sgX;
       c8sgW: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sgX: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8shh: // global
           if (_c8sh0::P64 < 4) goto c8sgY; else goto c8sgZ;
       c8sgY: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sgZ: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.142296968 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8shB,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8shB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.14568854 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.147505468 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.149362075 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { info_tbl: [(c8shQ,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8shQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8shR; else goto c8shS;
       c8shR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8shS: // global
           (_c8shN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8shN::I64 == 0) goto c8shP; else goto c8shO;
       c8shP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8shO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8shN::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.153735417 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.156259983 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { info_tbl: [(c8si7,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8si7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8si8; else goto c8si9;
       c8si8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8si9: // global
           (_c8si4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8si4::I64 == 0) goto c8si6; else goto c8si5;
       c8si6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8si5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8si4::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.160273031 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.162204521 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { info_tbl: [(c8sio,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sio: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sip; else goto c8siq;
       c8sip: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8siq: // global
           (_c8sil::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sil::I64 == 0) goto c8sin; else goto c8sim;
       c8sin: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sim: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sil::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.16679946 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { info_tbl: [(c8siL,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8siL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8siM; else goto c8siN;
       c8siM: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8siN: // global
           I64[Sp - 8] = block_c8siC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sj2; else goto c8siD;
       u8sj2: // global
           call _c8siC(R1) args: 0, res: 0, upd: 0;
       c8siD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8siC() //  [R1]
         { info_tbl: [(c8siC,
                       label: block_c8siC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8siC: // global
           _c8siK::P64 = R1 & 7;
           if (_c8siK::P64 < 3) goto u8sj0; else goto u8sj1;
       u8sj0: // global
           if (_c8siK::P64 < 2) goto c8siG; else goto c8siH;
       c8siG: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8siH: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8sj1: // global
           if (_c8siK::P64 < 4) goto c8siI; else goto c8siJ;
       c8siI: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8siJ: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.172620692 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.174476037 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { info_tbl: [(c8sjo,
                       label: GHC.IO.Encoding.Failure.recoverDecode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sjo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjp; else goto c8sjq;
       c8sjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjq: // global
           (_c8sjl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjl::I64 == 0) goto c8sjn; else goto c8sjm;
       c8sjn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjl::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.178792553 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.180710862 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { info_tbl: [(c8sjF,
                       label: GHC.IO.Encoding.Failure.recoverDecode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjG; else goto c8sjH;
       c8sjG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjH: // global
           (_c8sjC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjC::I64 == 0) goto c8sjE; else goto c8sjD;
       c8sjE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjC::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.184583132 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.186676242 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { info_tbl: [(c8sjW,
                       label: GHC.IO.Encoding.Failure.recoverDecode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sjX; else goto c8sjY;
       c8sjX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sjY: // global
           (_c8sjT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sjT::I64 == 0) goto c8sjV; else goto c8sjU;
       c8sjV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sjU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sjT::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.191519287 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.19348178 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { info_tbl: [(c8skd,
                       label: GHC.IO.Encoding.Failure.recoverEncode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8skd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ske; else goto c8skf;
       c8ske: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skf: // global
           (_c8ska::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ska::I64 == 0) goto c8skc; else goto c8skb;
       c8skc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8skb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ska::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.197353487 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.199238415 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { info_tbl: [(c8sku,
                       label: GHC.IO.Encoding.Failure.recoverEncode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8skv; else goto c8skw;
       c8skv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skw: // global
           (_c8skr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8skr::I64 == 0) goto c8skt; else goto c8sks;
       c8skt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sks: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8skr::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.203553547 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.205655279 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { info_tbl: [(c8skL,
                       label: GHC.IO.Encoding.Failure.recoverEncode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8skL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8skM; else goto c8skN;
       c8skM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8skN: // global
           (_c8skI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8skI::I64 == 0) goto c8skK; else goto c8skJ;
       c8skK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8skJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8skI::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.209581149 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.21128736 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.2130389 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.215199411 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.216981399 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.218746372 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.221004298 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.223290974 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.225102511 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.226875312 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.228619557 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.230740212 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.232920932 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.234820406 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.236637809 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.238901377 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.240613106 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.24240877 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.244273716 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.246027881 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.248330625 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.252206972 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sln,
                       label: GHC.IO.Encoding.Failure.recoverDecode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sln: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8slr; else goto c8sls;
       c8slr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sls: // global
           I64[Sp - 24] = block_c8slk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8snm; else goto c8sll;
       u8snm: // global
           call _c8slk(R1) args: 0, res: 0, upd: 0;
       c8sll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8slk() //  [R1]
         { info_tbl: [(c8slk,
                       label: block_c8slk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8slk: // global
           I64[Sp - 40] = block_c8slq_info;
           _s8rW3::P64 = P64[R1 + 7];
           _s8rW4::P64 = P64[R1 + 15];
           _s8rW2::I64 = I64[R1 + 23];
           _s8rW5::I64 = I64[R1 + 31];
           _s8rW6::I64 = I64[R1 + 39];
           _s8rW7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8rW4::P64;
           I64[Sp - 24] = _s8rW5::I64;
           I64[Sp - 16] = _s8rW6::I64;
           I64[Sp - 8] = _s8rW7::I64;
           P64[Sp] = _s8rW3::P64;
           I64[Sp + 16] = _s8rW2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8snl; else goto c8slu;
       u8snl: // global
           call _c8slq(R1) args: 0, res: 0, upd: 0;
       c8slu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8slq() //  [R1]
         { info_tbl: [(c8slq,
                       label: block_c8slq_info
                       rep:StackRep [False, True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8slq: // global
           I64[Sp - 48] = block_c8sly_info;
           _s8rW8::P64 = R1;
           _s8rWa::P64 = P64[R1 + 7];
           _s8rWb::P64 = P64[R1 + 15];
           _s8rW9::I64 = I64[R1 + 23];
           _s8rWc::I64 = I64[R1 + 31];
           _s8rWd::I64 = I64[R1 + 39];
           _s8rWe::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8rWa::P64;
           P64[Sp - 32] = _s8rWb::P64;
           I64[Sp - 24] = _s8rWc::I64;
           I64[Sp - 16] = _s8rWd::I64;
           I64[Sp - 8] = _s8rWe::I64;
           I64[Sp] = _s8rW9::I64;
           P64[Sp + 48] = _s8rW8::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8snn; else goto c8slA;
       u8snn: // global
           call _c8sly(R1) args: 0, res: 0, upd: 0;
       c8slA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sly() //  [R1]
         { info_tbl: [(c8sly,
                       label: block_c8sly_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sly: // global
           _s8rW2::I64 = I64[Sp + 104];
           _s8rW3::P64 = P64[Sp + 88];
           _s8rW4::P64 = P64[Sp + 56];
           _s8rW5::I64 = I64[Sp + 64];
           _s8rW6::I64 = I64[Sp + 72];
           _s8rW7::I64 = I64[Sp + 80];
           _c8sni::P64 = R1 & 7;
           if (_c8sni::P64 < 3) goto u8snj; else goto u8snk;
       u8snj: // global
           if (_c8sni::P64 < 2) goto c8slG; else goto c8slO;
       c8slG: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8slO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8slR; else goto c8slQ;
       c8slR: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8slQ: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8snk: // global
           _s8rW9::I64 = I64[Sp + 48];
           _s8rWa::P64 = P64[Sp + 8];
           _s8rWb::P64 = P64[Sp + 16];
           _s8rWc::I64 = I64[Sp + 24];
           _s8rWd::I64 = I64[Sp + 32];
           _s8rWe::I64 = I64[Sp + 40];
           if (_c8sni::P64 < 4) goto c8sm4; else goto c8sm8;
       c8sm4: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8smd; else goto c8sm6;
       c8sm6: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sm8: // global
           Hp = Hp + 136;
           _s8rWf::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8smd; else goto c8smc;
       c8smd: // global
           HpAlloc = 136;
           R1 = _s8rWf::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8smc: // global
           _s8rWt::I64 = %MO_UU_Conv_W8_W64(I8[_s8rW2::I64 + _s8rW6::I64]);
           call MO_Touch(_s8rW3::P64);
           if (_s8rWt::I64 >= 128) goto c8smP; else goto c8snh;
       c8smP: // global
           _s8rWw::I64 = _s8rWt::I64 + 56320;
           if (_s8rWw::I64 > 1114111) goto c8smx; else goto c8smN;
       c8smx: // global
           Hp = Hp - 136;
           R2 = _s8rWw::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8smN: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWw::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8snh: // global
           if (_s8rWt::I64 > 1114111) goto c8sn0; else goto c8sng;
       c8sn0: // global
           Hp = Hp - 136;
           R2 = _s8rWt::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sng: // global
           I32[_s8rW9::I64 + (_s8rWe::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8rWt::I64);
           call MO_Touch(_s8rWa::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rWa::P64;
           P64[Hp - 112] = _s8rWb::P64;
           I64[Hp - 104] = _s8rW9::I64;
           I64[Hp - 96] = _s8rWc::I64;
           I64[Hp - 88] = _s8rWd::I64;
           I64[Hp - 80] = _s8rWe::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rW3::P64;
           P64[Hp - 56] = _s8rW4::P64;
           I64[Hp - 48] = _s8rW2::I64;
           I64[Hp - 40] = _s8rW5::I64;
           I64[Hp - 32] = _s8rW6::I64 + 1;
           I64[Hp - 24] = _s8rW7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.267575041 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8so3,
                       label: GHC.IO.Encoding.Failure.recoverDecode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8so3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.272587004 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8soh,
                       label: GHC.IO.Encoding.Failure.recoverEncode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8soh: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8sol; else goto c8som;
       c8sol: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8som: // global
           I64[Sp - 24] = block_c8soe_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8spQ; else goto c8sof;
       u8spQ: // global
           call _c8soe(R1) args: 0, res: 0, upd: 0;
       c8sof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8soe() //  [R1]
         { info_tbl: [(c8soe,
                       label: block_c8soe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8soe: // global
           I64[Sp - 48] = block_c8sok_info;
           _s8rWZ::P64 = R1;
           _s8rX1::P64 = P64[R1 + 7];
           _s8rX2::P64 = P64[R1 + 15];
           _s8rX0::I64 = I64[R1 + 23];
           _s8rX3::I64 = I64[R1 + 31];
           _s8rX4::I64 = I64[R1 + 39];
           _s8rX5::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8rX1::P64;
           P64[Sp - 32] = _s8rX2::P64;
           I64[Sp - 24] = _s8rX3::I64;
           I64[Sp - 16] = _s8rX4::I64;
           I64[Sp - 8] = _s8rX5::I64;
           I64[Sp] = _s8rX0::I64;
           P64[Sp + 16] = _s8rWZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8spP; else goto c8soo;
       u8spP: // global
           call _c8sok(R1) args: 0, res: 0, upd: 0;
       c8soo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sok() //  [R1]
         { info_tbl: [(c8sok,
                       label: block_c8sok_info
                       rep:StackRep [False, False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sok: // global
           _s8rWV::P64 = P64[Sp + 56];
           _s8rX8::P64 = P64[R1 + 7];
           _s8rX9::P64 = P64[R1 + 15];
           _s8rX7::I64 = I64[R1 + 23];
           _s8rXa::I64 = I64[R1 + 31];
           _s8rXb::I64 = I64[R1 + 39];
           _s8rXc::I64 = I64[R1 + 47];
           _s8rXf::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8sot_info;
           _s8rX6::P64 = R1;
           R1 = _s8rWV::P64;
           P64[Sp - 48] = _s8rX8::P64;
           P64[Sp - 40] = _s8rX9::P64;
           I64[Sp - 32] = _s8rXa::I64;
           I64[Sp - 24] = _s8rXb::I64;
           I64[Sp - 16] = _s8rXc::I64;
           I64[Sp - 8] = _s8rXf::I64;
           I64[Sp] = _s8rX7::I64;
           P64[Sp + 56] = _s8rX6::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8spR; else goto c8sov;
       u8spR: // global
           call _c8sot(R1) args: 0, res: 0, upd: 0;
       c8sov: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sot() //  [R1]
         { info_tbl: [(c8sot,
                       label: block_c8sot_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sot: // global
           _s8rX0::I64 = I64[Sp + 104];
           _s8rX1::P64 = P64[Sp + 64];
           _s8rX2::P64 = P64[Sp + 72];
           _s8rX3::I64 = I64[Sp + 80];
           _s8rX4::I64 = I64[Sp + 88];
           _s8rX5::I64 = I64[Sp + 96];
           _s8rX6::P64 = P64[Sp + 112];
           _c8spM::P64 = R1 & 7;
           if (_c8spM::P64 < 3) goto u8spN; else goto u8spO;
       u8spN: // global
           if (_c8spM::P64 < 2) goto c8soB; else goto c8soJ;
       c8soB: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8soJ: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8soS; else goto c8soL;
       c8soL: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8spO: // global
           _s8rXf::I64 = I64[Sp + 48];
           if (_c8spM::P64 < 4) goto c8soN; else goto c8sp6;
       c8soN: // global
           Hp = Hp + 80;
           _s8rXh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8soS; else goto c8soR;
       c8soS: // global
           HpAlloc = 80;
           R1 = _s8rXh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8soR: // global
           if (_s8rXf::I64 == 63) goto c8sp5; else goto c8soY;
       c8sp5: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8rX6::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8soY: // global
           _s8rWZ::P64 = P64[Sp + 120];
           I32[_s8rX0::I64 + (_s8rX4::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8rX1::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8rWZ::P64;
           P64[Hp - 56] = _s8rX6::P64;
           _c8soW::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8soW::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sp6: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8spb; else goto c8spa;
       c8spb: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8spa: // global
           if (%MO_S_Gt_W64(56448, _s8rXf::I64)) goto c8spo; else goto c8spL;
       c8spL: // global
           if (%MO_S_Ge_W64(_s8rXf::I64, 56576)) goto c8spo; else goto c8spK;
       c8spo: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8spK: // global
           _s8rX7::I64 = I64[Sp + 56];
           _s8rX8::P64 = P64[Sp + 8];
           _s8rX9::P64 = P64[Sp + 16];
           _s8rXa::I64 = I64[Sp + 24];
           _s8rXb::I64 = I64[Sp + 32];
           _s8rXc::I64 = I64[Sp + 40];
           I8[_s8rX7::I64 + _s8rXc::I64] = %MO_UU_Conv_W64_W8(_s8rXf::I64);
           call MO_Touch(_s8rX8::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8rX8::P64;
           P64[Hp - 112] = _s8rX9::P64;
           I64[Hp - 104] = _s8rX7::I64;
           I64[Hp - 96] = _s8rXa::I64;
           I64[Hp - 88] = _s8rXb::I64;
           I64[Hp - 80] = _s8rXc::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8rX1::P64;
           P64[Hp - 56] = _s8rX2::P64;
           I64[Hp - 48] = _s8rX0::I64;
           I64[Hp - 40] = _s8rX3::I64;
           I64[Hp - 32] = _s8rX4::I64 + 1;
           I64[Hp - 24] = _s8rX5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.287793415 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sqt,
                       label: GHC.IO.Encoding.Failure.recoverEncode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sqt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.291677198 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { info_tbl: [(c8sqH,
                       label: GHC.IO.Encoding.Failure.isSurrogate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sqH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sqI; else goto c8sqJ;
       c8sqI: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sqJ: // global
           I64[Sp - 8] = block_c8sqE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8srj; else goto c8sqF;
       u8srj: // global
           call _c8sqE(R1) args: 0, res: 0, upd: 0;
       c8sqF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sqE() //  [R1]
         { info_tbl: [(c8sqE,
                       label: block_c8sqE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sqE: // global
           _s8rXI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8rXI::I64)) goto c8sqZ; else goto c8src;
       c8sqZ: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sr7; else goto c8sqX;
       c8sqX: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8src: // global
           if (%MO_S_Gt_W64(_s8rXI::I64, 56319)) goto c8sra; else goto c8srb;
       c8sra: // global
           if (%MO_S_Gt_W64(56320, _s8rXI::I64)) goto c8sr7; else goto c8sr8;
       c8sr7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sr8: // global
           R1 = I64[(%MO_S_Le_W64(_s8rXI::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8srb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.298677579 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.300501517 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.302254046 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.303920909 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.305642944 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.307518452 UTC

[GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8srG,
                       label: GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8srG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.31084958 UTC

[GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8srM,
                       label: GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8srM: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.314104753 UTC

[GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8srS,
                       label: GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8srS: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.31738903 UTC

[GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { info_tbl: [(c8srY,
                       label: GHC.IO.Encoding.Failure.RoundtripFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8srY: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.320569016 UTC

[section ""relreadonly" . S8rYU_srt" {
     S8rYU_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.743134097 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:35.744162055 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes:
         I8[] [69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.746262309 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_entry() //  [R1]
         { info_tbl: [(c8sug,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suh; else goto c8sui;
       c8suh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sui: // global
           (_c8sud::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sud::I64 == 0) goto c8suf; else goto c8sue;
       c8suf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sue: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sud::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.750470298 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes:
         I8[] [73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.752445336 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_entry() //  [R1]
         { info_tbl: [(c8suy,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8suy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suz; else goto c8suA;
       c8suz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8suA: // global
           (_c8suv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8suv::I64 == 0) goto c8sux; else goto c8suw;
       c8sux: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8suw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8suv::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.756363433 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes:
         I8[] [84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.758319568 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_entry() //  [R1]
         { info_tbl: [(c8suQ,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8suQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8suR; else goto c8suS;
       c8suR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8suS: // global
           (_c8suN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8suN::I64 == 0) goto c8suP; else goto c8suO;
       c8suP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8suO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8suN::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.762356982 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes:
         I8[] [82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.76430803 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_entry() //  [R1]
         { info_tbl: [(c8sv8,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sv8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sv9; else goto c8sva;
       c8sv9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sva: // global
           (_c8sv5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sv5::I64 == 0) goto c8sv7; else goto c8sv6;
       c8sv7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sv6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sv5::I64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.768933861 UTC

[section ""data" . GHC.IO.Encoding.Failure.$w$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$w$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8svw,
                       label: GHC.IO.Encoding.Failure.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8svw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8svx; else goto c8svy;
       c8svx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8svy: // global
           I64[Sp - 16] = block_c8svn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8svN; else goto c8svo;
       u8svN: // global
           call _c8svn(R1) args: 0, res: 0, upd: 0;
       c8svo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8svn() //  [R1]
         { info_tbl: [(c8svn,
                       label: block_c8svn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8svn: // global
           _s8ss6::P64 = P64[Sp + 8];
           _c8svv::P64 = R1 & 7;
           if (_c8svv::P64 < 3) goto u8svL; else goto u8svM;
       u8svL: // global
           if (_c8svv::P64 < 2) goto c8svr; else goto c8svs;
       c8svr: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8svs: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8svM: // global
           if (_c8svv::P64 < 4) goto c8svt; else goto c8svu;
       c8svt: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8svu: // global
           R3 = _s8ss6::P64;
           R2 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.776244977 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_entry() //  [R3,
                                                                          R4]
         { info_tbl: [(c8sw4,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sw4: // global
           _s8ss9::P64 = R3;
           R3 = R4;
           R2 = _s8ss9::P64;
           call GHC.IO.Encoding.Failure.$w$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.780802446 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8swo,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8swo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8swp; else goto c8swq;
       c8swp: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8swq: // global
           I64[Sp - 8] = block_c8swf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8swF; else goto c8swg;
       u8swF: // global
           call _c8swf(R1) args: 0, res: 0, upd: 0;
       c8swg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8swf() //  [R1]
         { info_tbl: [(c8swf,
                       label: block_c8swf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8swf: // global
           _c8swn::P64 = R1 & 7;
           if (_c8swn::P64 < 3) goto u8swD; else goto u8swE;
       u8swD: // global
           if (_c8swn::P64 < 2) goto c8swj; else goto c8swk;
       c8swj: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8swk: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8swE: // global
           if (_c8swn::P64 < 4) goto c8swl; else goto c8swm;
       c8swl: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8swm: // global
           R1 = GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.786960963 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure:
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8swZ,
                       label: GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8swZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.Failure.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.790603659 UTC

[section ""data" . GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$fShowCodingFailureMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowsPrec_closure+3;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure+1;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.792389917 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes:
         I8[] [47,47,73,71,78,79,82,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.794387767 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix5_entry() //  [R1]
         { info_tbl: [(c8sxe,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxf; else goto c8sxg;
       c8sxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxg: // global
           (_c8sxb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxb::I64 == 0) goto c8sxd; else goto c8sxc;
       c8sxd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxb::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.798428569 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes:
         I8[] [47,47,84,82,65,78,83,76,73,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.800326862 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix3_entry() //  [R1]
         { info_tbl: [(c8sxw,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sxw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxx; else goto c8sxy;
       c8sxx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxy: // global
           (_c8sxt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxt::I64 == 0) goto c8sxv; else goto c8sxu;
       c8sxv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxt::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.805186867 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes:
         I8[] [47,47,82,79,85,78,68,84,82,73,80]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.80710532 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix1_entry() //  [R1]
         { info_tbl: [(c8sxO,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sxO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sxP; else goto c8sxQ;
       c8sxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sxQ: // global
           (_c8sxL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sxL::I64 == 0) goto c8sxN; else goto c8sxM;
       c8sxN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sxM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sxL::I64;
           R2 = GHC.IO.Encoding.Failure.codingFailureModeSuffix2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.811426975 UTC

[section ""data" . GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure" {
     GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure:
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.codingFailureModeSuffix_entry() //  [R2]
         { info_tbl: [(c8syc,
                       label: GHC.IO.Encoding.Failure.codingFailureModeSuffix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8syc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8syd; else goto c8sye;
       c8syd: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sye: // global
           I64[Sp - 8] = block_c8sy3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8syt; else goto c8sy4;
       u8syt: // global
           call _c8sy3(R1) args: 0, res: 0, upd: 0;
       c8sy4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sy3() //  [R1]
         { info_tbl: [(c8sy3,
                       label: block_c8sy3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sy3: // global
           _c8syb::P64 = R1 & 7;
           if (_c8syb::P64 < 3) goto u8syr; else goto u8sys;
       u8syr: // global
           if (_c8syb::P64 < 2) goto c8sy7; else goto c8sy8;
       c8sy7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sy8: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8sys: // global
           if (_c8syb::P64 < 4) goto c8sy9; else goto c8sya;
       c8sy9: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8sya: // global
           R1 = GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.81791271 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode7_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode7_bytes:
         I8[] [114,101,99,111,118,101,114,68,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.819817121 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode6_closure" {
     GHC.IO.Encoding.Failure.recoverDecode6_closure:
         const GHC.IO.Encoding.Failure.recoverDecode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode6_entry() //  [R1]
         { info_tbl: [(c8syR,
                       label: GHC.IO.Encoding.Failure.recoverDecode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8syR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8syS; else goto c8syT;
       c8syS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8syT: // global
           (_c8syO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8syO::I64 == 0) goto c8syQ; else goto c8syP;
       c8syQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8syP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8syO::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.823781304 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverDecode5_bytes" {
     GHC.IO.Encoding.Failure.recoverDecode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,98,121,116,101,32,115,101,113,117,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.826035633 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode4_closure" {
     GHC.IO.Encoding.Failure.recoverDecode4_closure:
         const GHC.IO.Encoding.Failure.recoverDecode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode4_entry() //  [R1]
         { info_tbl: [(c8sz9,
                       label: GHC.IO.Encoding.Failure.recoverDecode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sza; else goto c8szb;
       c8sza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szb: // global
           (_c8sz6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sz6::I64 == 0) goto c8sz8; else goto c8sz7;
       c8sz8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sz7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sz6::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.829969788 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode3_closure" {
     GHC.IO.Encoding.Failure.recoverDecode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverDecode6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.831955599 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode2_closure" {
     GHC.IO.Encoding.Failure.recoverDecode2_closure:
         const GHC.IO.Encoding.Failure.recoverDecode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode2_entry() //  [R1]
         { info_tbl: [(c8szr,
                       label: GHC.IO.Encoding.Failure.recoverDecode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8szr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8szs; else goto c8szt;
       c8szs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szt: // global
           (_c8szo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szo::I64 == 0) goto c8szq; else goto c8szp;
       c8szq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szo::I64;
           R2 = GHC.IO.Encoding.Failure.recoverDecode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.83582724 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode7_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode7_bytes:
         I8[] [114,101,99,111,118,101,114,69,110,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.838083093 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode6_closure" {
     GHC.IO.Encoding.Failure.recoverEncode6_closure:
         const GHC.IO.Encoding.Failure.recoverEncode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode6_entry() //  [R1]
         { info_tbl: [(c8szJ,
                       label: GHC.IO.Encoding.Failure.recoverEncode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8szJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8szK; else goto c8szL;
       c8szK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8szL: // global
           (_c8szG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szG::I64 == 0) goto c8szI; else goto c8szH;
       c8szI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szG::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.843073537 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.recoverEncode5_bytes" {
     GHC.IO.Encoding.Failure.recoverEncode5_bytes:
         I8[] [105,110,118,97,108,105,100,32,99,104,97,114,97,99,116,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.845117543 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode4_closure" {
     GHC.IO.Encoding.Failure.recoverEncode4_closure:
         const GHC.IO.Encoding.Failure.recoverEncode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode4_entry() //  [R1]
         { info_tbl: [(c8sA1,
                       label: GHC.IO.Encoding.Failure.recoverEncode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sA1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sA2; else goto c8sA3;
       c8sA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sA3: // global
           (_c8szY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8szY::I64 == 0) goto c8sA0; else goto c8szZ;
       c8sA0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8szZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8szY::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.849474455 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode3_closure" {
     GHC.IO.Encoding.Failure.recoverEncode3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Encoding.Failure.recoverEncode6_closure;
         const GHC.IO.Encoding.Failure.recoverEncode4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.851685544 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode2_closure" {
     GHC.IO.Encoding.Failure.recoverEncode2_closure:
         const GHC.IO.Encoding.Failure.recoverEncode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode2_entry() //  [R1]
         { info_tbl: [(c8sAj,
                       label: GHC.IO.Encoding.Failure.recoverEncode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sAj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8sAk; else goto c8sAl;
       c8sAk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8sAl: // global
           (_c8sAg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8sAg::I64 == 0) goto c8sAi; else goto c8sAh;
       c8sAi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8sAh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8sAg::I64;
           R2 = GHC.IO.Encoding.Failure.recoverEncode3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.85623946 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule4_bytes" {
     GHC.IO.Encoding.Failure.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.857959947 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule3_closure" {
     GHC.IO.Encoding.Failure.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.859643775 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$trModule2_bytes" {
     GHC.IO.Encoding.Failure.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.861316039 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule1_closure" {
     GHC.IO.Encoding.Failure.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.863064714 UTC

[section ""data" . GHC.IO.Encoding.Failure.$trModule_closure" {
     GHC.IO.Encoding.Failure.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Failure.$trModule3_closure+1;
         const GHC.IO.Encoding.Failure.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.864847406 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes:
         I8[] [67,111,100,105,110,103,70,97,105,108,117,114,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.869824072 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.871748763 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure" {
     GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14925461047987757098;
         const 8591318658186141108;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.874649586 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Failure.$tcCodingFailureMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.876518799 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes:
         I8[] [39,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.879057047 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.881101349 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure2_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12360460340946478580;
         const 790065067637529655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.883402878 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes:
         I8[] [39,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.88551753 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.887574395 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'IgnoreCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 1247277247292781024;
         const 4030462313976053703;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.890002957 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes:
         I8[] [39,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.891841672 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.893910484 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'TransliterateCodingFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 2231629224643919862;
         const 7270908418490455598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.896009774 UTC

[section ""cstring" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes:
         I8[] [39,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.898124481 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.900187943 UTC

[section ""data" . GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.$tc'RoundtripFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Encoding.Failure.$trModule_closure+1;
         const GHC.IO.Encoding.Failure.$tc'RoundtripFailure1_closure+1;
         const GHC.IO.Encoding.Failure.$tc'ErrorOnCodingFailure1_closure+1;
         const 12324562344665179767;
         const 401887646038237864;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.904038048 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode1_closure" {
     GHC.IO.Encoding.Failure.recoverDecode1_closure:
         const GHC.IO.Encoding.Failure.recoverDecode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sAW,
                       label: GHC.IO.Encoding.Failure.recoverDecode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sAW: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8sB0; else goto c8sB1;
       c8sB0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverDecode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sB1: // global
           I64[Sp - 24] = block_c8sAT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sCV; else goto c8sAU;
       u8sCV: // global
           call _c8sAT(R1) args: 0, res: 0, upd: 0;
       c8sAU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sAT() //  [R1]
         { info_tbl: [(c8sAT,
                       label: block_c8sAT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sAT: // global
           I64[Sp - 40] = block_c8sAZ_info;
           _s8ssn::P64 = P64[R1 + 7];
           _s8sso::P64 = P64[R1 + 15];
           _s8ssm::I64 = I64[R1 + 23];
           _s8ssp::I64 = I64[R1 + 31];
           _s8ssq::I64 = I64[R1 + 39];
           _s8ssr::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _s8sso::P64;
           I64[Sp - 24] = _s8ssp::I64;
           I64[Sp - 16] = _s8ssq::I64;
           I64[Sp - 8] = _s8ssr::I64;
           P64[Sp] = _s8ssn::P64;
           I64[Sp + 16] = _s8ssm::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8sCU; else goto c8sB3;
       u8sCU: // global
           call _c8sAZ(R1) args: 0, res: 0, upd: 0;
       c8sB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sAZ() //  [R1]
         { info_tbl: [(c8sAZ,
                       label: block_c8sAZ_info
                       rep:StackRep [False, True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sAZ: // global
           I64[Sp - 48] = block_c8sB7_info;
           _s8sss::P64 = R1;
           _s8ssu::P64 = P64[R1 + 7];
           _s8ssv::P64 = P64[R1 + 15];
           _s8sst::I64 = I64[R1 + 23];
           _s8ssw::I64 = I64[R1 + 31];
           _s8ssx::I64 = I64[R1 + 39];
           _s8ssy::I64 = I64[R1 + 47];
           R1 = P64[Sp + 48];
           P64[Sp - 40] = _s8ssu::P64;
           P64[Sp - 32] = _s8ssv::P64;
           I64[Sp - 24] = _s8ssw::I64;
           I64[Sp - 16] = _s8ssx::I64;
           I64[Sp - 8] = _s8ssy::I64;
           I64[Sp] = _s8sst::I64;
           P64[Sp + 48] = _s8sss::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sCW; else goto c8sB9;
       u8sCW: // global
           call _c8sB7(R1) args: 0, res: 0, upd: 0;
       c8sB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sB7() //  [R1]
         { info_tbl: [(c8sB7,
                       label: block_c8sB7_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sB7: // global
           _s8ssm::I64 = I64[Sp + 104];
           _s8ssn::P64 = P64[Sp + 88];
           _s8sso::P64 = P64[Sp + 56];
           _s8ssp::I64 = I64[Sp + 64];
           _s8ssq::I64 = I64[Sp + 72];
           _s8ssr::I64 = I64[Sp + 80];
           _c8sCR::P64 = R1 & 7;
           if (_c8sCR::P64 < 3) goto u8sCS; else goto u8sCT;
       u8sCS: // global
           if (_c8sCR::P64 < 2) goto c8sBf; else goto c8sBn;
       c8sBf: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 112;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sBn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8sBq; else goto c8sBp;
       c8sBq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sBp: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sCT: // global
           _s8sst::I64 = I64[Sp + 48];
           _s8ssu::P64 = P64[Sp + 8];
           _s8ssv::P64 = P64[Sp + 16];
           _s8ssw::I64 = I64[Sp + 24];
           _s8ssx::I64 = I64[Sp + 32];
           _s8ssy::I64 = I64[Sp + 40];
           if (_c8sCR::P64 < 4) goto c8sBD; else goto c8sBH;
       c8sBD: // global
           Hp = Hp + 136;
           _s8ssz::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sBM; else goto c8sBF;
       c8sBF: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = 65533 :: W32;
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sBH: // global
           Hp = Hp + 136;
           _s8ssz::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sBM; else goto c8sBL;
       c8sBM: // global
           HpAlloc = 136;
           R1 = _s8ssz::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sBL: // global
           _s8ssN::I64 = %MO_UU_Conv_W8_W64(I8[_s8ssm::I64 + _s8ssq::I64]);
           call MO_Touch(_s8ssn::P64);
           if (_s8ssN::I64 >= 128) goto c8sCo; else goto c8sCQ;
       c8sCo: // global
           _s8ssQ::I64 = _s8ssN::I64 + 56320;
           if (_s8ssQ::I64 > 1114111) goto c8sC6; else goto c8sCm;
       c8sC6: // global
           Hp = Hp - 136;
           R2 = _s8ssQ::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sCm: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8ssQ::I64);
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sCQ: // global
           if (_s8ssN::I64 > 1114111) goto c8sCz; else goto c8sCP;
       c8sCz: // global
           Hp = Hp - 136;
           R2 = _s8ssN::I64;
           Sp = Sp + 112;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8sCP: // global
           I32[_s8sst::I64 + (_s8ssy::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8ssN::I64);
           call MO_Touch(_s8ssu::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8ssu::P64;
           P64[Hp - 112] = _s8ssv::P64;
           I64[Hp - 104] = _s8sst::I64;
           I64[Hp - 96] = _s8ssw::I64;
           I64[Hp - 88] = _s8ssx::I64;
           I64[Hp - 80] = _s8ssy::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8ssn::P64;
           P64[Hp - 56] = _s8sso::P64;
           I64[Hp - 48] = _s8ssm::I64;
           I64[Hp - 40] = _s8ssp::I64;
           I64[Hp - 32] = _s8ssq::I64 + 1;
           I64[Hp - 24] = _s8ssr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.922630367 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverDecode_closure" {
     GHC.IO.Encoding.Failure.recoverDecode_closure:
         const GHC.IO.Encoding.Failure.recoverDecode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverDecode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sDQ,
                       label: GHC.IO.Encoding.Failure.recoverDecode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sDQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.927697477 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode1_closure" {
     GHC.IO.Encoding.Failure.recoverEncode1_closure:
         const GHC.IO.Encoding.Failure.recoverEncode1_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sE4,
                       label: GHC.IO.Encoding.Failure.recoverEncode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sE4: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8sE8; else goto c8sE9;
       c8sE8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.recoverEncode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8sE9: // global
           I64[Sp - 24] = block_c8sE1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8sFD; else goto c8sE2;
       u8sFD: // global
           call _c8sE1(R1) args: 0, res: 0, upd: 0;
       c8sE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sE1() //  [R1]
         { info_tbl: [(c8sE1,
                       label: block_c8sE1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sE1: // global
           I64[Sp - 48] = block_c8sE7_info;
           _s8stj::P64 = R1;
           _s8stl::P64 = P64[R1 + 7];
           _s8stm::P64 = P64[R1 + 15];
           _s8stk::I64 = I64[R1 + 23];
           _s8stn::I64 = I64[R1 + 31];
           _s8sto::I64 = I64[R1 + 39];
           _s8stp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           P64[Sp - 40] = _s8stl::P64;
           P64[Sp - 32] = _s8stm::P64;
           I64[Sp - 24] = _s8stn::I64;
           I64[Sp - 16] = _s8sto::I64;
           I64[Sp - 8] = _s8stp::I64;
           I64[Sp] = _s8stk::I64;
           P64[Sp + 16] = _s8stj::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8sFC; else goto c8sEb;
       u8sFC: // global
           call _c8sE7(R1) args: 0, res: 0, upd: 0;
       c8sEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sE7() //  [R1]
         { info_tbl: [(c8sE7,
                       label: block_c8sE7_info
                       rep:StackRep [False, False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sE7: // global
           _s8stf::P64 = P64[Sp + 56];
           _s8sts::P64 = P64[R1 + 7];
           _s8stt::P64 = P64[R1 + 15];
           _s8str::I64 = I64[R1 + 23];
           _s8stu::I64 = I64[R1 + 31];
           _s8stv::I64 = I64[R1 + 39];
           _s8stw::I64 = I64[R1 + 47];
           _s8stz::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 48] + (I64[Sp + 32] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp - 56] = block_c8sEg_info;
           _s8stq::P64 = R1;
           R1 = _s8stf::P64;
           P64[Sp - 48] = _s8sts::P64;
           P64[Sp - 40] = _s8stt::P64;
           I64[Sp - 32] = _s8stu::I64;
           I64[Sp - 24] = _s8stv::I64;
           I64[Sp - 16] = _s8stw::I64;
           I64[Sp - 8] = _s8stz::I64;
           I64[Sp] = _s8str::I64;
           P64[Sp + 56] = _s8stq::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u8sFE; else goto c8sEi;
       u8sFE: // global
           call _c8sEg(R1) args: 0, res: 0, upd: 0;
       c8sEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sEg() //  [R1]
         { info_tbl: [(c8sEg,
                       label: block_c8sEg_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sEg: // global
           _s8stk::I64 = I64[Sp + 104];
           _s8stl::P64 = P64[Sp + 64];
           _s8stm::P64 = P64[Sp + 72];
           _s8stn::I64 = I64[Sp + 80];
           _s8sto::I64 = I64[Sp + 88];
           _s8stp::I64 = I64[Sp + 96];
           _s8stq::P64 = P64[Sp + 112];
           _c8sFz::P64 = R1 & 7;
           if (_c8sFz::P64 < 3) goto u8sFA; else goto u8sFB;
       u8sFA: // global
           if (_c8sFz::P64 < 2) goto c8sEo; else goto c8sEw;
       c8sEo: // global
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sEw: // global
           Hp = Hp + 80;
           _s8stB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sEF; else goto c8sEy;
       c8sEy: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8stq::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8sFB: // global
           _s8stz::I64 = I64[Sp + 48];
           if (_c8sFz::P64 < 4) goto c8sEA; else goto c8sET;
       c8sEA: // global
           Hp = Hp + 80;
           _s8stB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8sEF; else goto c8sEE;
       c8sEF: // global
           HpAlloc = 80;
           R1 = _s8stB::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sEE: // global
           if (_s8stz::I64 == 63) goto c8sES; else goto c8sEL;
       c8sES: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = _s8stq::P64;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sEL: // global
           _s8stj::P64 = P64[Sp + 120];
           I32[_s8stk::I64 + (_s8sto::I64 << 2)] = 63 :: W32;
           call MO_Touch(_s8stl::P64);
           I64[Hp - 72] = (,)_con_info;
           P64[Hp - 64] = _s8stj::P64;
           P64[Hp - 56] = _s8stq::P64;
           _c8sEJ::P64 = Hp - 71;
           Hp = Hp - 56;
           R1 = _c8sEJ::P64;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sET: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8sEY; else goto c8sEX;
       c8sEY: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8sEX: // global
           if (%MO_S_Gt_W64(56448, _s8stz::I64)) goto c8sFb; else goto c8sFy;
       c8sFy: // global
           if (%MO_S_Ge_W64(_s8stz::I64, 56576)) goto c8sFb; else goto c8sFx;
       c8sFb: // global
           Hp = Hp - 136;
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 128;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8sFx: // global
           _s8str::I64 = I64[Sp + 56];
           _s8sts::P64 = P64[Sp + 8];
           _s8stt::P64 = P64[Sp + 16];
           _s8stu::I64 = I64[Sp + 24];
           _s8stv::I64 = I64[Sp + 32];
           _s8stw::I64 = I64[Sp + 40];
           I8[_s8str::I64 + _s8stw::I64] = %MO_UU_Conv_W64_W8(_s8stz::I64);
           call MO_Touch(_s8sts::P64);
           I64[Hp - 128] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 120] = _s8sts::P64;
           P64[Hp - 112] = _s8stt::P64;
           I64[Hp - 104] = _s8str::I64;
           I64[Hp - 96] = _s8stu::I64;
           I64[Hp - 88] = _s8stv::I64;
           I64[Hp - 80] = _s8stw::I64 + 1;
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _s8stl::P64;
           P64[Hp - 56] = _s8stm::P64;
           I64[Hp - 48] = _s8stk::I64;
           I64[Hp - 40] = _s8stn::I64;
           I64[Hp - 32] = _s8sto::I64 + 1;
           I64[Hp - 24] = _s8stp::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 127;
           R1 = Hp - 15;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.942788606 UTC

[section ""data" . GHC.IO.Encoding.Failure.recoverEncode_closure" {
     GHC.IO.Encoding.Failure.recoverEncode_closure:
         const GHC.IO.Encoding.Failure.recoverEncode_info;
         const 0;
 },
 GHC.IO.Encoding.Failure.recoverEncode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sGr,
                       label: GHC.IO.Encoding.Failure.recoverEncode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sGr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.946873518 UTC

[section ""data" . GHC.IO.Encoding.Failure.isSurrogate_closure" {
     GHC.IO.Encoding.Failure.isSurrogate_closure:
         const GHC.IO.Encoding.Failure.isSurrogate_info;
 },
 GHC.IO.Encoding.Failure.isSurrogate_entry() //  [R2]
         { info_tbl: [(c8sGF,
                       label: GHC.IO.Encoding.Failure.isSurrogate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sGF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sGG; else goto c8sGH;
       c8sGG: // global
           R2 = R2;
           R1 = GHC.IO.Encoding.Failure.isSurrogate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sGH: // global
           I64[Sp - 8] = block_c8sGC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sHh; else goto c8sGD;
       u8sHh: // global
           call _c8sGC(R1) args: 0, res: 0, upd: 0;
       c8sGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sGC() //  [R1]
         { info_tbl: [(c8sGC,
                       label: block_c8sGC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sGC: // global
           _s8su2::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(55296, _s8su2::I64)) goto c8sGX; else goto c8sHa;
       c8sGX: // global
           if (%MO_S_Gt_W64(56320, _s8su2::I64)) goto c8sH5; else goto c8sGV;
       c8sGV: // global
           R1 = I64[(%MO_S_Le_W64(_s8su2::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sHa: // global
           if (%MO_S_Gt_W64(_s8su2::I64, 56319)) goto c8sH8; else goto c8sH9;
       c8sH8: // global
           if (%MO_S_Gt_W64(56320, _s8su2::I64)) goto c8sH5; else goto c8sH6;
       c8sH5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sH6: // global
           R1 = I64[(%MO_S_Le_W64(_s8su2::I64,
                                  57343) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8sH9: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.954261974 UTC

[section ""data" . GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure" {
     GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.956437846 UTC

[section ""data" . GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure" {
     GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure:
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.959100158 UTC

[section ""data" . GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure" {
     GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure:
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.960794832 UTC

[section ""data" . GHC.IO.Encoding.Failure.RoundtripFailure_closure" {
     GHC.IO.Encoding.Failure.RoundtripFailure_closure:
         const GHC.IO.Encoding.Failure.RoundtripFailure_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.962543004 UTC

[section ""relreadonly" . GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl" {
     GHC.IO.Encoding.Failure.CodingFailureMode_closure_tbl:
         const GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
         const GHC.IO.Encoding.Failure.IgnoreCodingFailure_closure+2;
         const GHC.IO.Encoding.Failure.TransliterateCodingFailure_closure+3;
         const GHC.IO.Encoding.Failure.RoundtripFailure_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.964465136 UTC

[GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8sHJ,
                       label: GHC.IO.Encoding.Failure.ErrorOnCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,69,114,114,111,114,79,110,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sHJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.968251485 UTC

[GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8sHQ,
                       label: GHC.IO.Encoding.Failure.IgnoreCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,73,103,110,111,114,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sHQ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.971551067 UTC

[GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_entry() //  [R1]
         { info_tbl: [(c8sHX,
                       label: GHC.IO.Encoding.Failure.TransliterateCodingFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,84,114,97,110,115,108,105,116,101,114,97,116,101,67,111,100,105,110,103,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sHX: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.974901773 UTC

[GHC.IO.Encoding.Failure.RoundtripFailure_con_entry() //  [R1]
         { info_tbl: [(c8sI4,
                       label: GHC.IO.Encoding.Failure.RoundtripFailure_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,70,97,105,108,117,114,101,46,82,111,117,110,100,116,114,105,112,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sI4: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:35.978593744 UTC

[section ""relreadonly" . S8svO_srt" {
     S8svO_srt:
         const GHC.IO.Encoding.Failure.$w$cshowsPrec_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode1_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode3_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode5_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode7_closure;
         const GHC.IO.Encoding.Failure.$fShowCodingFailureMode_$cshow_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix1_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix3_closure;
         const GHC.IO.Encoding.Failure.codingFailureModeSuffix5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Encoding.Failure.recoverDecode3_closure;
         const GHC.IO.Encoding.Failure.recoverEncode3_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
 }]

