
==================== Output Cmm ====================
2018-03-16 16:03:24.667293411 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:24.667917906 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,77,86,97,114,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.668860731 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_entry() //  [R1]
         { info_tbl: [(c8jhR,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jhR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jhS; else goto c8jhT;
       c8jhS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jhT: // global
           (_c8jhO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jhO::I64 == 0) goto c8jhQ; else goto c8jhP;
       c8jhQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jhP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jhO::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.670135855 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(c8ji1,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ji1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ji2; else goto c8ji3;
       c8ji2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ji3: // global
           I64[Sp - 16] = block_c8jhY_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ji7; else goto c8jhZ;
       u8ji7: // global
           call _c8jhY() args: 0, res: 0, upd: 0;
       c8jhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jhY() //  []
         { info_tbl: [(c8jhY,
                       label: block_c8jhY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jhY: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.671427136 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_entry() //  [R2]
         { info_tbl: [(c8jig,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jig: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jih; else goto c8jii;
       c8jih: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jii: // global
           I64[Sp - 8] = block_c8jid_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jim; else goto c8jie;
       u8jim: // global
           call _c8jid() args: 0, res: 0, upd: 0;
       c8jie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jid() //  []
         { info_tbl: [(c8jid,
                       label: block_c8jid_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jid: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.672644409 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8jiu,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jiv; else goto c8jiw;
       c8jiv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jiw: // global
           I64[Sp - 16] = block_c8jir_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jiA; else goto c8jis;
       u8jiA: // global
           call _c8jir() args: 0, res: 0, upd: 0;
       c8jis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jir() //  []
         { info_tbl: [(c8jir,
                       label: block_c8jir_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jir: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.673882796 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(c8jiF,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jiF: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.674687056 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.675297589 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,83,84,77,32,116,114,97,110,115,97,99,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.676055169 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_entry() //  [R1]
         { info_tbl: [(c8jiO,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jiP; else goto c8jiQ;
       c8jiP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jiQ: // global
           (_c8jiL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jiL::I64 == 0) goto c8jiN; else goto c8jiM;
       c8jiN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jiM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jiL::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.677198893 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_entry() //  [R2,
                                                                          R3, R4]
         { info_tbl: [(c8jiY,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jiY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jiZ; else goto c8jj0;
       c8jiZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jj0: // global
           I64[Sp - 16] = block_c8jiV_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jj4; else goto c8jiW;
       u8jj4: // global
           call _c8jiV() args: 0, res: 0, upd: 0;
       c8jiW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jiV() //  []
         { info_tbl: [(c8jiV,
                       label: block_c8jiV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jiV: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.678493316 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_entry() //  [R2]
         { info_tbl: [(c8jjc,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jjd; else goto c8jje;
       c8jjd: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jje: // global
           I64[Sp - 8] = block_c8jj9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jji; else goto c8jja;
       u8jji: // global
           call _c8jj9() args: 0, res: 0, upd: 0;
       c8jja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jj9() //  []
         { info_tbl: [(c8jj9,
                       label: block_c8jj9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jj9: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.679669456 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8jjq,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jjr; else goto c8jjs;
       c8jjr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jjs: // global
           I64[Sp - 16] = block_c8jjn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jjw; else goto c8jjo;
       u8jjw: // global
           call _c8jjn() args: 0, res: 0, upd: 0;
       c8jjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jjn() //  []
         { info_tbl: [(c8jjn,
                       label: block_c8jjn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjn: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.680861214 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8jjB,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.681669766 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.682292225 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock2_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock2_bytes:
         I8[] [60,60,100,101,97,100,108,111,99,107,62,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.683011829 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock1_closure" {
     GHC.IO.Exception.$fExceptionDeadlock1_closure:
         const GHC.IO.Exception.$fExceptionDeadlock1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock1_entry() //  [R1]
         { info_tbl: [(c8jjK,
                       label: GHC.IO.Exception.$fExceptionDeadlock1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jjL; else goto c8jjM;
       c8jjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jjM: // global
           (_c8jjH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jjH::I64 == 0) goto c8jjJ; else goto c8jjI;
       c8jjJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jjI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jjH::I64;
           R2 = GHC.IO.Exception.$fExceptionDeadlock2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.684218896 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8jjU,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jjV; else goto c8jjW;
       c8jjV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jjW: // global
           I64[Sp - 16] = block_c8jjR_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jk0; else goto c8jjS;
       u8jk0: // global
           call _c8jjR() args: 0, res: 0, upd: 0;
       c8jjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jjR() //  []
         { info_tbl: [(c8jjR,
                       label: block_c8jjR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jjR: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.685506819 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cshow_entry() //  [R2]
         { info_tbl: [(c8jk8,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jk8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jk9; else goto c8jka;
       c8jk9: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jka: // global
           I64[Sp - 8] = block_c8jk5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jke; else goto c8jk6;
       u8jke: // global
           call _c8jk5() args: 0, res: 0, upd: 0;
       c8jk6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jk5() //  []
         { info_tbl: [(c8jk5,
                       label: block_c8jk5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jk5: // global
           R1 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.686701432 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock1_closure" {
     GHC.IO.Exception.$fShowDeadlock1_closure:
         const GHC.IO.Exception.$fShowDeadlock1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock1_entry() //  [R2, R3]
         { info_tbl: [(c8jkm,
                       label: GHC.IO.Exception.$fShowDeadlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jkn; else goto c8jko;
       c8jkn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jko: // global
           I64[Sp - 16] = block_c8jkj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jks; else goto c8jkk;
       u8jks: // global
           call _c8jkj() args: 0, res: 0, upd: 0;
       c8jkk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jkj() //  []
         { info_tbl: [(c8jkj,
                       label: block_c8jkj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkj: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.687890422 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowList_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowList_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8jkx,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkx: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowDeadlock1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.688630804 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_closure" {
     GHC.IO.Exception.$fShowDeadlock_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.689292269 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes:
         I8[] [97,108,108,111,99,97,116,105,111,110,32,108,105,109,105,116,32,101,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.690099057 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_entry() //  [R1]
         { info_tbl: [(c8jkG,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jkH; else goto c8jkI;
       c8jkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jkI: // global
           (_c8jkD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jkD::I64 == 0) goto c8jkF; else goto c8jkE;
       c8jkF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jkE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jkD::I64;
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.691216905 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_entry() //  [R2,
                                                                         R3, R4]
         { info_tbl: [(c8jkQ,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jkR; else goto c8jkS;
       c8jkR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jkS: // global
           I64[Sp - 16] = block_c8jkN_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jkW; else goto c8jkO;
       u8jkW: // global
           call _c8jkN() args: 0, res: 0, upd: 0;
       c8jkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jkN() //  []
         { info_tbl: [(c8jkN,
                       label: block_c8jkN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jkN: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.692434476 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_entry() //  [R2]
         { info_tbl: [(c8jl4,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jl4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jl5; else goto c8jl6;
       c8jl5: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jl6: // global
           I64[Sp - 8] = block_c8jl1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jla; else goto c8jl2;
       u8jla: // global
           call _c8jl1() args: 0, res: 0, upd: 0;
       c8jl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jl1() //  []
         { info_tbl: [(c8jl1,
                       label: block_c8jl1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jl1: // global
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.6936997 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8jli,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jli: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jlj; else goto c8jlk;
       c8jlj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jlk: // global
           I64[Sp - 16] = block_c8jlf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jlo; else goto c8jlg;
       u8jlo: // global
           call _c8jlf() args: 0, res: 0, upd: 0;
       c8jlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jlf() //  []
         { info_tbl: [(c8jlf,
                       label: block_c8jlf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlf: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.69485055 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c8jlt,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlt: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.695605425 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.69615723 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed1_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed1_bytes:
         I8[] [99,111,109,112,97,99,116,105,111,110,32,102,97,105,108,101,100,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.697024784 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec2_closure" {
     GHC.IO.Exception.$w$cshowsPrec2_closure:
         const GHC.IO.Exception.$w$cshowsPrec2_info;
 },
 sat_s8j4q_entry() //  [R1]
         { info_tbl: [(c8jlE,
                       label: sat_s8j4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jlF; else goto c8jlG;
       c8jlF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jlG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec2_entry() //  [R2]
         { info_tbl: [(c8jlH,
                       label: GHC.IO.Exception.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jlL; else goto c8jlK;
       c8jlL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jlK: // global
           I64[Hp - 16] = sat_s8j4q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.698274364 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(c8jlQ,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlQ: // global
           R2 = R3;
           call GHC.IO.Exception.$w$cshowsPrec2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.699072682 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_entry() //  [R2]
         { info_tbl: [(c8jlX,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jlX: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.699914408 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(c8jm4,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jm4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec2_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.700633616 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure+2;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.701424266 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_entry() //  [R3,
                                                                 R4]
         { info_tbl: [(c8jmb,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmb: // global
           _s8j4x::P64 = R3;
           R3 = R4;
           R2 = _s8j4x::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.702318865 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed1_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed1_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed1_info;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed1_entry() //  [R2]
         { info_tbl: [(c8jmi,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.703211851 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8jmp,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmp: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.++_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.704027123 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.704995987 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8jmz,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jmD; else goto c8jmE;
       c8jmD: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jmE: // global
           I64[Sp - 8] = block_c8jmw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jmK; else goto c8jmx;
       u8jmK: // global
           call _c8jmw(R1) args: 0, res: 0, upd: 0;
       c8jmx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jmw() //  [R1]
         { info_tbl: [(c8jmw,
                       label: block_c8jmw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmw: // global
           I64[Sp - 8] = block_c8jmC_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jmC() //  [R1]
         { info_tbl: [(c8jmC,
                       label: block_c8jmC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmC: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.706501007 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_entry() //  [R2,
                                                                    R3, R4]
         { info_tbl: [(c8jmS,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jn0; else goto c8jn1;
       c8jn0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jn1: // global
           I64[Sp - 16] = block_c8jmP_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jn8; else goto c8jmQ;
       u8jn8: // global
           call _c8jmP(R1) args: 0, res: 0, upd: 0;
       c8jmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jmP() //  [R1]
         { info_tbl: [(c8jmP,
                       label: block_c8jmP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmP: // global
           I64[Sp - 8] = block_c8jmV_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jmV() //  [R1]
         { info_tbl: [(c8jmV,
                       label: block_c8jmV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmV: // global
           _s8j4L::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jmZ_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4L::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8jmZ() //  [R1]
         { info_tbl: [(c8jmZ,
                       label: block_c8jmZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jmZ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.708201818 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException1_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException1_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException1_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException1_entry() //  [R2, R3]
         { info_tbl: [(c8jng,
                       label: GHC.IO.Exception.$fShowSomeAsyncException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jng: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jno; else goto c8jnp;
       c8jno: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jnp: // global
           I64[Sp - 16] = block_c8jnd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jnw; else goto c8jne;
       u8jnw: // global
           call _c8jnd(R1) args: 0, res: 0, upd: 0;
       c8jne: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jnd() //  [R1]
         { info_tbl: [(c8jnd,
                       label: block_c8jnd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnd: // global
           I64[Sp - 8] = block_c8jnj_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jnj() //  [R1]
         { info_tbl: [(c8jnj,
                       label: block_c8jnj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnj: // global
           _s8j4S::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jnn_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4S::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8jnn() //  [R1]
         { info_tbl: [(c8jnn,
                       label: block_c8jnn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnn: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.711788062 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c8jnB,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowSomeAsyncException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.712629888 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.713171777 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException8_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException8_bytes:
         I8[] [115,116,97,99,107,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.714013491 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException7_closure" {
     GHC.IO.Exception.$fExceptionAsyncException7_closure:
         const GHC.IO.Exception.$fExceptionAsyncException7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException7_entry() //  [R1]
         { info_tbl: [(c8jnK,
                       label: GHC.IO.Exception.$fExceptionAsyncException7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jnL; else goto c8jnM;
       c8jnL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jnM: // global
           (_c8jnH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jnH::I64 == 0) goto c8jnJ; else goto c8jnI;
       c8jnJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jnI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jnH::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.714928971 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException6_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException6_bytes:
         I8[] [104,101,97,112,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.715639407 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException5_closure" {
     GHC.IO.Exception.$fExceptionAsyncException5_closure:
         const GHC.IO.Exception.$fExceptionAsyncException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException5_entry() //  [R1]
         { info_tbl: [(c8jnT,
                       label: GHC.IO.Exception.$fExceptionAsyncException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jnT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jnU; else goto c8jnV;
       c8jnU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jnV: // global
           (_c8jnQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jnQ::I64 == 0) goto c8jnS; else goto c8jnR;
       c8jnS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jnR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jnQ::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.716511371 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException4_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException4_bytes:
         I8[] [116,104,114,101,97,100,32,107,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.717231498 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException3_closure" {
     GHC.IO.Exception.$fExceptionAsyncException3_closure:
         const GHC.IO.Exception.$fExceptionAsyncException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException3_entry() //  [R1]
         { info_tbl: [(c8jo2,
                       label: GHC.IO.Exception.$fExceptionAsyncException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jo2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jo3; else goto c8jo4;
       c8jo3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jo4: // global
           (_c8jnZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jnZ::I64 == 0) goto c8jo1; else goto c8jo0;
       c8jo1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jo0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jnZ::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.718144835 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException2_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException2_bytes:
         I8[] [117,115,101,114,32,105,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.718857255 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException1_closure" {
     GHC.IO.Exception.$fExceptionAsyncException1_closure:
         const GHC.IO.Exception.$fExceptionAsyncException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException1_entry() //  [R1]
         { info_tbl: [(c8job,
                       label: GHC.IO.Exception.$fExceptionAsyncException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8job: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8joc; else goto c8jod;
       c8joc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jod: // global
           (_c8jo8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jo8::I64 == 0) goto c8joa; else goto c8jo9;
       c8joa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jo9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jo8::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.720145101 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec1_closure" {
     GHC.IO.Exception.$w$cshowsPrec1_closure:
         const GHC.IO.Exception.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(c8jor,
                       label: GHC.IO.Exception.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jor: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jos; else goto c8jot;
       c8jos: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jot: // global
           I64[Sp - 16] = block_c8joi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8joI; else goto c8joj;
       u8joI: // global
           call _c8joi(R1) args: 0, res: 0, upd: 0;
       c8joj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8joi() //  [R1]
         { info_tbl: [(c8joi,
                       label: block_c8joi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8joi: // global
           _s8j4Y::P64 = P64[Sp + 8];
           _c8joq::P64 = R1 & 7;
           if (_c8joq::P64 < 3) goto u8joG; else goto u8joH;
       u8joG: // global
           if (_c8joq::P64 < 2) goto c8jom; else goto c8jon;
       c8jom: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jon: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8joH: // global
           if (_c8joq::P64 < 4) goto c8joo; else goto c8jop;
       c8joo: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jop: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.721600719 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_entry() //  [R3,
                                                                R4]
         { info_tbl: [(c8joN,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8joN: // global
           _s8j51::P64 = R3;
           R3 = R4;
           R2 = _s8j51::P64;
           call GHC.IO.Exception.$w$cshowsPrec1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.722602874 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8jp3,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jp3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jp4; else goto c8jp5;
       c8jp4: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jp5: // global
           I64[Sp - 8] = block_c8joU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jpk; else goto c8joV;
       u8jpk: // global
           call _c8joU(R1) args: 0, res: 0, upd: 0;
       c8joV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8joU() //  [R1]
         { info_tbl: [(c8joU,
                       label: block_c8joU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8joU: // global
           _c8jp2::P64 = R1 & 7;
           if (_c8jp2::P64 < 3) goto u8jpi; else goto u8jpj;
       u8jpi: // global
           if (_c8jp2::P64 < 2) goto c8joY; else goto c8joZ;
       c8joY: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8joZ: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8jpj: // global
           if (_c8jp2::P64 < 4) goto c8jp0; else goto c8jp1;
       c8jp0: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jp1: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.723915457 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8jpp,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jpp: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.724690722 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_closure" {
     GHC.IO.Exception.$fShowAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.725640046 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException4_bytes" {
     GHC.IO.Exception.$fExceptionArrayException4_bytes:
         I8[] [97,114,114,97,121,32,105,110,100,101,120,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.726176048 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException3_bytes" {
     GHC.IO.Exception.$fExceptionArrayException3_bytes:
         I8[] [58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.726700936 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException2_bytes" {
     GHC.IO.Exception.$fExceptionArrayException2_bytes:
         I8[] [117,110,100,101,102,105,110,101,100,32,97,114,114,97,121,32,101,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.728642938 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec_closure" {
     GHC.IO.Exception.$w$cshowsPrec_closure:
         const GHC.IO.Exception.$w$cshowsPrec_info;
 },
 sat_s8j5e_entry() //  [R1]
         { info_tbl: [(c8jpP,
                       label: sat_s8j5e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jpP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jpQ; else goto c8jpR;
       c8jpQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jpR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5f_entry() //  [R1]
         { info_tbl: [(c8jpW,
                       label: sat_s8j5f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jpW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jpX; else goto c8jpY;
       c8jpX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jpY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8jpF_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jq4; else goto c8jpG;
       u8jq4: // global
           call _c8jpF(R1) args: 0, res: 0, upd: 0;
       c8jpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jpF() //  [R1]
         { info_tbl: [(c8jpF,
                       label: block_c8jpF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jpF: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jpT; else goto c8jpU;
       c8jpT: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8jpU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8jq3; else goto c8jq2;
       c8jq3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jq2: // global
           I64[Hp - 24] = sat_s8j5e_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5k_entry() //  [R1]
         { info_tbl: [(c8jql,
                       label: sat_s8j5k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jql: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jqm; else goto c8jqn;
       c8jqm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jqn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5l_entry() //  [R1]
         { info_tbl: [(c8jqs,
                       label: sat_s8j5l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jqs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jqt; else goto c8jqu;
       c8jqt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jqu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8jqb_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jqA; else goto c8jqc;
       u8jqA: // global
           call _c8jqb(R1) args: 0, res: 0, upd: 0;
       c8jqc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jqb() //  [R1]
         { info_tbl: [(c8jqb,
                       label: block_c8jqb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jqb: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jqp; else goto c8jqq;
       c8jqp: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8jqq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8jqz; else goto c8jqy;
       c8jqz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jqy: // global
           I64[Hp - 24] = sat_s8j5k_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8jqF,
                       label: GHC.IO.Exception.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jqF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jqG; else goto c8jqH;
       c8jqG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jqH: // global
           I64[Sp - 16] = block_c8jpw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jqO; else goto c8jpx;
       u8jqO: // global
           call _c8jpw(R1) args: 0, res: 0, upd: 0;
       c8jpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jpw() //  [R1]
         { info_tbl: [(c8jpw,
                       label: block_c8jpw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jpw: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jqC; else goto c8jqD;
       c8jqC: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8jqN; else goto c8jqJ;
       c8jqJ: // global
           _s8j5a::P64 = P64[_s8j59::P64 + 7];
           I64[Hp - 24] = sat_s8j5f_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5a::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8jqD: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8jqN; else goto c8jqM;
       c8jqN: // global
           HpAlloc = 32;
           R1 = _s8j59::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jqM: // global
           _s8j5g::P64 = P64[_s8j59::P64 + 6];
           I64[Hp - 24] = sat_s8j5l_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5g::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException2_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.731841827 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_entry() //  [R3,
                                                                     R4]
         { info_tbl: [(c8jqT,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jqT: // global
           _s8j5n::P64 = R3;
           R3 = R4;
           R2 = _s8j5n::P64;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.732592312 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException1_closure" {
     GHC.IO.Exception.$fExceptionArrayException1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.73329861 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshow_entry() //  [R2]
         { info_tbl: [(c8jr0,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jr0: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.734127753 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_$cshowList_closure" {
     GHC.IO.Exception.$fShowArrayException_$cshowList_closure:
         const GHC.IO.Exception.$fShowArrayException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowArrayException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8jr7,
                       label: GHC.IO.Exception.$fShowArrayException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jr7: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.734864275 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_closure" {
     GHC.IO.Exception.$fShowArrayException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowArrayException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.73542826 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException2_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException2_bytes:
         I8[] [99,121,99,108,105,99,32,101,118,97,108,117,97,116,105,111,110,32,105,110,32,102,105,120,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.736185267 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException1_closure" {
     GHC.IO.Exception.$fExceptionFixIOException1_closure:
         const GHC.IO.Exception.$fExceptionFixIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException1_entry() //  [R1]
         { info_tbl: [(c8jrg,
                       label: GHC.IO.Exception.$fExceptionFixIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jrh; else goto c8jri;
       c8jrh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jri: // global
           (_c8jrd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jrd::I64 == 0) goto c8jrf; else goto c8jre;
       c8jrf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jre: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jrd::I64;
           R2 = GHC.IO.Exception.$fExceptionFixIOException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.737738958 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8jrq,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jrr; else goto c8jrs;
       c8jrr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jrs: // global
           I64[Sp - 16] = block_c8jrn_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jrw; else goto c8jro;
       u8jrw: // global
           call _c8jrn() args: 0, res: 0, upd: 0;
       c8jro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jrn() //  []
         { info_tbl: [(c8jrn,
                       label: block_c8jrn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrn: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.738989899 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8jrE,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jrF; else goto c8jrG;
       c8jrF: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jrG: // global
           I64[Sp - 8] = block_c8jrB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jrK; else goto c8jrC;
       u8jrK: // global
           call _c8jrB() args: 0, res: 0, upd: 0;
       c8jrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jrB() //  []
         { info_tbl: [(c8jrB,
                       label: block_c8jrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrB: // global
           R1 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.740141928 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException1_closure" {
     GHC.IO.Exception.$fShowFixIOException1_closure:
         const GHC.IO.Exception.$fShowFixIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8jrS,
                       label: GHC.IO.Exception.$fShowFixIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jrT; else goto c8jrU;
       c8jrT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jrU: // global
           I64[Sp - 16] = block_c8jrP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jrY; else goto c8jrQ;
       u8jrY: // global
           call _c8jrP() args: 0, res: 0, upd: 0;
       c8jrQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jrP() //  []
         { info_tbl: [(c8jrP,
                       label: block_c8jrP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jrP: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.74128786 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8js3,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8js3: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowFixIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.742028486 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_closure" {
     GHC.IO.Exception.$fShowFixIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.742977958 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c==_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c==_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c==_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8jse,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jse: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jsk; else goto c8jsl;
       c8jsk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jsl: // global
           I64[Sp - 16] = block_c8jsa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jsF; else goto c8jsb;
       u8jsF: // global
           call _c8jsa(R1) args: 0, res: 0, upd: 0;
       c8jsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jsa() //  [R1]
         { info_tbl: [(c8jsa,
                       label: block_c8jsa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jsa: // global
           _s8j5G::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8jsj_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5G::I64;
           if (R1 & 7 != 0) goto u8jsE; else goto c8jsq;
       u8jsE: // global
           call _c8jsj(R1) args: 0, res: 0, upd: 0;
       c8jsq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jsj() //  [R1]
         { info_tbl: [(c8jsj,
                       label: block_c8jsj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jsj: // global
           R1 = I64[((%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.744635752 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c/=_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c/=_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8jsO,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jsO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jsU; else goto c8jsV;
       c8jsU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jsV: // global
           I64[Sp - 16] = block_c8jsK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jtj; else goto c8jsL;
       u8jtj: // global
           call _c8jsK(R1) args: 0, res: 0, upd: 0;
       c8jsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jsK() //  [R1]
         { info_tbl: [(c8jsK,
                       label: block_c8jsK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jsK: // global
           _s8j5N::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8jsT_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5N::I64;
           if (R1 & 7 != 0) goto u8jti; else goto c8jt0;
       u8jti: // global
           call _c8jsT(R1) args: 0, res: 0, upd: 0;
       c8jt0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jsT() //  [R1]
         { info_tbl: [(c8jsT,
                       label: block_c8jsT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jsT: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) goto c8jtf; else goto c8jte;
       c8jtf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jte: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.745961824 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_closure" {
     GHC.IO.Exception.$fEqIOErrorType_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOErrorType_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.746492417 UTC

[section ""cstring" . lvl_r8j2D_bytes" {
     lvl_r8j2D_bytes:
         I8[] [97,108,114,101,97,100,121,32,101,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.747260278 UTC

[section ""data" . lvl1_r8j2E_closure" {
     lvl1_r8j2E_closure:
         const lvl1_r8j2E_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8j2E_entry() //  [R1]
         { info_tbl: [(c8jtq,
                       label: lvl1_r8j2E_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jtq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jtr; else goto c8jts;
       c8jtr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jts: // global
           (_c8jtn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jtn::I64 == 0) goto c8jtp; else goto c8jto;
       c8jtp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jto: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jtn::I64;
           R2 = lvl_r8j2D_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.748136294 UTC

[section ""cstring" . lvl2_r8j2F_bytes" {
     lvl2_r8j2F_bytes:
         I8[] [100,111,101,115,32,110,111,116,32,101,120,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.748861359 UTC

[section ""data" . lvl3_r8j2G_closure" {
     lvl3_r8j2G_closure:
         const lvl3_r8j2G_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8j2G_entry() //  [R1]
         { info_tbl: [(c8jtz,
                       label: lvl3_r8j2G_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jtz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jtA; else goto c8jtB;
       c8jtA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jtB: // global
           (_c8jtw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jtw::I64 == 0) goto c8jty; else goto c8jtx;
       c8jty: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jtx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jtw::I64;
           R2 = lvl2_r8j2F_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.750028695 UTC

[section ""cstring" . lvl4_r8j2H_bytes" {
     lvl4_r8j2H_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,98,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.750701565 UTC

[section ""data" . lvl5_r8j2I_closure" {
     lvl5_r8j2I_closure:
         const lvl5_r8j2I_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8j2I_entry() //  [R1]
         { info_tbl: [(c8jtI,
                       label: lvl5_r8j2I_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jtI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jtJ; else goto c8jtK;
       c8jtJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jtK: // global
           (_c8jtF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jtF::I64 == 0) goto c8jtH; else goto c8jtG;
       c8jtH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jtG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jtF::I64;
           R2 = lvl4_r8j2H_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.751566759 UTC

[section ""cstring" . lvl6_r8j2J_bytes" {
     lvl6_r8j2J_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,101,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.752319616 UTC

[section ""data" . lvl7_r8j2K_closure" {
     lvl7_r8j2K_closure:
         const lvl7_r8j2K_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r8j2K_entry() //  [R1]
         { info_tbl: [(c8jtR,
                       label: lvl7_r8j2K_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jtR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jtS; else goto c8jtT;
       c8jtS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jtT: // global
           (_c8jtO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jtO::I64 == 0) goto c8jtQ; else goto c8jtP;
       c8jtQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jtP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jtO::I64;
           R2 = lvl6_r8j2J_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.75316262 UTC

[section ""cstring" . lvl8_r8j2L_bytes" {
     lvl8_r8j2L_bytes:
         I8[] [101,110,100,32,111,102,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.755170336 UTC

[section ""data" . lvl9_r8j2M_closure" {
     lvl9_r8j2M_closure:
         const lvl9_r8j2M_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r8j2M_entry() //  [R1]
         { info_tbl: [(c8ju0,
                       label: lvl9_r8j2M_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ju0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ju1; else goto c8ju2;
       c8ju1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ju2: // global
           (_c8jtX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jtX::I64 == 0) goto c8jtZ; else goto c8jtY;
       c8jtZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jtY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jtX::I64;
           R2 = lvl8_r8j2L_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.756078821 UTC

[section ""cstring" . lvl10_r8j2N_bytes" {
     lvl10_r8j2N_bytes:
         I8[] [105,108,108,101,103,97,108,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.756810209 UTC

[section ""data" . lvl11_r8j2O_closure" {
     lvl11_r8j2O_closure:
         const lvl11_r8j2O_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8j2O_entry() //  [R1]
         { info_tbl: [(c8ju9,
                       label: lvl11_r8j2O_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ju9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jua; else goto c8jub;
       c8jua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jub: // global
           (_c8ju6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ju6::I64 == 0) goto c8ju8; else goto c8ju7;
       c8ju8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ju7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ju6::I64;
           R2 = lvl10_r8j2N_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.757771326 UTC

[section ""cstring" . lvl12_r8j2P_bytes" {
     lvl12_r8j2P_bytes:
         I8[] [112,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.758508868 UTC

[section ""data" . lvl13_r8j2Q_closure" {
     lvl13_r8j2Q_closure:
         const lvl13_r8j2Q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r8j2Q_entry() //  [R1]
         { info_tbl: [(c8jui,
                       label: lvl13_r8j2Q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8juj; else goto c8juk;
       c8juj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8juk: // global
           (_c8juf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8juf::I64 == 0) goto c8juh; else goto c8jug;
       c8juh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jug: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8juf::I64;
           R2 = lvl12_r8j2P_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.759353183 UTC

[section ""cstring" . lvl14_r8j2R_bytes" {
     lvl14_r8j2R_bytes:
         I8[] [117,115,101,114,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.760086298 UTC

[section ""data" . lvl15_r8j2S_closure" {
     lvl15_r8j2S_closure:
         const lvl15_r8j2S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_r8j2S_entry() //  [R1]
         { info_tbl: [(c8jur,
                       label: lvl15_r8j2S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jus; else goto c8jut;
       c8jus: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jut: // global
           (_c8juo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8juo::I64 == 0) goto c8juq; else goto c8jup;
       c8juq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jup: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8juo::I64;
           R2 = lvl14_r8j2R_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.760962257 UTC

[section ""cstring" . lvl16_r8j2T_bytes" {
     lvl16_r8j2T_bytes:
         I8[] [117,110,115,97,116,105,115,102,105,101,100,32,99,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.761996451 UTC

[section ""data" . lvl17_r8j2U_closure" {
     lvl17_r8j2U_closure:
         const lvl17_r8j2U_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_r8j2U_entry() //  [R1]
         { info_tbl: [(c8juA,
                       label: lvl17_r8j2U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8juA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8juB; else goto c8juC;
       c8juB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8juC: // global
           (_c8jux::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jux::I64 == 0) goto c8juz; else goto c8juy;
       c8juz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8juy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jux::I64;
           R2 = lvl16_r8j2T_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.762853285 UTC

[section ""cstring" . lvl18_r8j2V_bytes" {
     lvl18_r8j2V_bytes:
         I8[] [115,121,115,116,101,109,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.76359207 UTC

[section ""data" . lvl19_r8j2W_closure" {
     lvl19_r8j2W_closure:
         const lvl19_r8j2W_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r8j2W_entry() //  [R1]
         { info_tbl: [(c8juJ,
                       label: lvl19_r8j2W_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8juJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8juK; else goto c8juL;
       c8juK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8juL: // global
           (_c8juG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8juG::I64 == 0) goto c8juI; else goto c8juH;
       c8juI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8juH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8juG::I64;
           R2 = lvl18_r8j2V_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.764462359 UTC

[section ""cstring" . lvl20_r8j2X_bytes" {
     lvl20_r8j2X_bytes:
         I8[] [112,114,111,116,111,99,111,108,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.765200085 UTC

[section ""data" . lvl21_r8j2Y_closure" {
     lvl21_r8j2Y_closure:
         const lvl21_r8j2Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_r8j2Y_entry() //  [R1]
         { info_tbl: [(c8juS,
                       label: lvl21_r8j2Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8juS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8juT; else goto c8juU;
       c8juT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8juU: // global
           (_c8juP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8juP::I64 == 0) goto c8juR; else goto c8juQ;
       c8juR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8juQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8juP::I64;
           R2 = lvl20_r8j2X_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.766070144 UTC

[section ""cstring" . lvl22_r8j2Z_bytes" {
     lvl22_r8j2Z_bytes:
         I8[] [102,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.7667947 UTC

[section ""data" . lvl23_r8j30_closure" {
     lvl23_r8j30_closure:
         const lvl23_r8j30_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_r8j30_entry() //  [R1]
         { info_tbl: [(c8jv1,
                       label: lvl23_r8j30_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jv1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jv2; else goto c8jv3;
       c8jv2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jv3: // global
           (_c8juY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8juY::I64 == 0) goto c8jv0; else goto c8juZ;
       c8jv0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8juZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8juY::I64;
           R2 = lvl22_r8j2Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.767641003 UTC

[section ""cstring" . lvl24_r8j31_bytes" {
     lvl24_r8j31_bytes:
         I8[] [105,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.768362161 UTC

[section ""data" . lvl25_r8j32_closure" {
     lvl25_r8j32_closure:
         const lvl25_r8j32_info;
         const 0;
         const 0;
         const 0;
 },
 lvl25_r8j32_entry() //  [R1]
         { info_tbl: [(c8jva,
                       label: lvl25_r8j32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jva: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvb; else goto c8jvc;
       c8jvb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvc: // global
           (_c8jv7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jv7::I64 == 0) goto c8jv9; else goto c8jv8;
       c8jv9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jv8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jv7::I64;
           R2 = lvl24_r8j31_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.769278887 UTC

[section ""cstring" . lvl26_r8j33_bytes" {
     lvl26_r8j33_bytes:
         I8[] [105,110,97,112,112,114,111,112,114,105,97,116,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.770001069 UTC

[section ""data" . lvl27_r8j34_closure" {
     lvl27_r8j34_closure:
         const lvl27_r8j34_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_r8j34_entry() //  [R1]
         { info_tbl: [(c8jvj,
                       label: lvl27_r8j34_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jvj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvk; else goto c8jvl;
       c8jvk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvl: // global
           (_c8jvg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvg::I64 == 0) goto c8jvi; else goto c8jvh;
       c8jvi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jvh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvg::I64;
           R2 = lvl26_r8j33_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.770879281 UTC

[section ""cstring" . lvl28_r8j35_bytes" {
     lvl28_r8j35_bytes:
         I8[] [104,97,114,100,119,97,114,101,32,102,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.77162345 UTC

[section ""data" . lvl29_r8j36_closure" {
     lvl29_r8j36_closure:
         const lvl29_r8j36_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_r8j36_entry() //  [R1]
         { info_tbl: [(c8jvs,
                       label: lvl29_r8j36_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jvs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvt; else goto c8jvu;
       c8jvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvu: // global
           (_c8jvp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvp::I64 == 0) goto c8jvr; else goto c8jvq;
       c8jvr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jvq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvp::I64;
           R2 = lvl28_r8j35_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.772514116 UTC

[section ""cstring" . lvl30_r8j37_bytes" {
     lvl30_r8j37_bytes:
         I8[] [117,110,115,117,112,112,111,114,116,101,100,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.773575391 UTC

[section ""data" . lvl31_r8j38_closure" {
     lvl31_r8j38_closure:
         const lvl31_r8j38_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_r8j38_entry() //  [R1]
         { info_tbl: [(c8jvB,
                       label: lvl31_r8j38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jvB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvC; else goto c8jvD;
       c8jvC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvD: // global
           (_c8jvy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvy::I64 == 0) goto c8jvA; else goto c8jvz;
       c8jvA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jvz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvy::I64;
           R2 = lvl30_r8j37_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.774459175 UTC

[section ""cstring" . lvl32_r8j39_bytes" {
     lvl32_r8j39_bytes:
         I8[] [116,105,109,101,111,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.775166271 UTC

[section ""data" . lvl33_r8j3a_closure" {
     lvl33_r8j3a_closure:
         const lvl33_r8j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_r8j3a_entry() //  [R1]
         { info_tbl: [(c8jvK,
                       label: lvl33_r8j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jvK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvL; else goto c8jvM;
       c8jvL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvM: // global
           (_c8jvH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvH::I64 == 0) goto c8jvJ; else goto c8jvI;
       c8jvJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jvI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvH::I64;
           R2 = lvl32_r8j39_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.776054564 UTC

[section ""cstring" . lvl34_r8j3b_bytes" {
     lvl34_r8j3b_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,118,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.776749272 UTC

[section ""data" . lvl35_r8j3c_closure" {
     lvl35_r8j3c_closure:
         const lvl35_r8j3c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_r8j3c_entry() //  [R1]
         { info_tbl: [(c8jvT,
                       label: lvl35_r8j3c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jvT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jvU; else goto c8jvV;
       c8jvU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jvV: // global
           (_c8jvQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvQ::I64 == 0) goto c8jvS; else goto c8jvR;
       c8jvS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jvR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvQ::I64;
           R2 = lvl34_r8j3b_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.777636667 UTC

[section ""cstring" . lvl36_r8j3d_bytes" {
     lvl36_r8j3d_bytes:
         I8[] [105,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.778330104 UTC

[section ""data" . lvl37_r8j3e_closure" {
     lvl37_r8j3e_closure:
         const lvl37_r8j3e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_r8j3e_entry() //  [R1]
         { info_tbl: [(c8jw2,
                       label: lvl37_r8j3e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jw2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jw3; else goto c8jw4;
       c8jw3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jw4: // global
           (_c8jvZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jvZ::I64 == 0) goto c8jw1; else goto c8jw0;
       c8jw1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jw0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jvZ::I64;
           R2 = lvl36_r8j3d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.779885337 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec4_closure" {
     GHC.IO.Exception.$w$cshowsPrec4_closure:
         const GHC.IO.Exception.$w$cshowsPrec4_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec4_entry() //  [R2, R3]
         { info_tbl: [(c8jwx,
                       label: GHC.IO.Exception.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jwy; else goto c8jwz;
       c8jwy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jwz: // global
           I64[Sp - 16] = block_c8jw9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jxv; else goto c8jwa;
       u8jxv: // global
           call _c8jw9(R1) args: 0, res: 0, upd: 0;
       c8jwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jw9() //  [R1]
         { info_tbl: [(c8jw9,
                       label: block_c8jw9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jw9: // global
           _s8j5S::P64 = P64[Sp + 8];
           switch [0 .. 18] (%MO_UU_Conv_W32_W64(I32[I64[R1 - 1] + 20])) {
               case 0 : goto c8jwd;
               case 1 : goto c8jwe;
               case 2 : goto c8jwf;
               case 3 : goto c8jwg;
               case 4 : goto c8jwh;
               case 5 : goto c8jwi;
               case 6 : goto c8jwj;
               case 7 : goto c8jwk;
               case 8 : goto c8jwl;
               case 9 : goto c8jwm;
               case 10 : goto c8jwn;
               case 11 : goto c8jwo;
               case 12 : goto c8jwp;
               case 13 : goto c8jwq;
               case 14 : goto c8jwr;
               case 15 : goto c8jws;
               case 16 : goto c8jwt;
               case 17 : goto c8jwu;
               case 18 : goto c8jwv;
           }
       c8jwv: // global
           R3 = _s8j5S::P64;
           R2 = lvl37_r8j3e_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwu: // global
           R3 = _s8j5S::P64;
           R2 = lvl35_r8j3c_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwt: // global
           R3 = _s8j5S::P64;
           R2 = lvl33_r8j3a_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jws: // global
           R3 = _s8j5S::P64;
           R2 = lvl31_r8j38_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwr: // global
           R3 = _s8j5S::P64;
           R2 = lvl29_r8j36_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwq: // global
           R3 = _s8j5S::P64;
           R2 = lvl27_r8j34_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwp: // global
           R3 = _s8j5S::P64;
           R2 = lvl25_r8j32_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwo: // global
           R3 = _s8j5S::P64;
           R2 = lvl23_r8j30_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwn: // global
           R3 = _s8j5S::P64;
           R2 = lvl21_r8j2Y_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwm: // global
           R3 = _s8j5S::P64;
           R2 = lvl19_r8j2W_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwl: // global
           R3 = _s8j5S::P64;
           R2 = lvl17_r8j2U_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwk: // global
           R3 = _s8j5S::P64;
           R2 = lvl15_r8j2S_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwj: // global
           R3 = _s8j5S::P64;
           R2 = lvl13_r8j2Q_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwi: // global
           R3 = _s8j5S::P64;
           R2 = lvl11_r8j2O_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwh: // global
           R3 = _s8j5S::P64;
           R2 = lvl9_r8j2M_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwg: // global
           R3 = _s8j5S::P64;
           R2 = lvl7_r8j2K_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwf: // global
           R3 = _s8j5S::P64;
           R2 = lvl5_r8j2I_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwe: // global
           R3 = _s8j5S::P64;
           R2 = lvl3_r8j2G_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jwd: // global
           R3 = _s8j5S::P64;
           R2 = lvl1_r8j2E_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.782166853 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c8jxA,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jxA: // global
           _s8j5V::P64 = R3;
           R3 = R4;
           R2 = _s8j5V::P64;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.783036692 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshow_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshow_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshow_entry() //  [R2]
         { info_tbl: [(c8jxH,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jxH: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.783907621 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8jxO,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jxO: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.784643498 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_closure" {
     GHC.IO.Exception.$fShowIOErrorType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.788174675 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c==_closure" {
     GHC.IO.Exception.$fEqIOException_$c==_closure:
         const GHC.IO.Exception.$fEqIOException_$c==_info;
 },
 GHC.IO.Exception.$fEqIOException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8jxY,
                       label: GHC.IO.Exception.$fEqIOException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jxY: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c8jyf; else goto c8jyg;
       c8jyf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jyg: // global
           I64[Sp - 16] = block_c8jxV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jCS; else goto c8jxW;
       u8jCS: // global
           call _c8jxV(R1) args: 0, res: 0, upd: 0;
       c8jxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jxV() //  [R1]
         { info_tbl: [(c8jxV,
                       label: block_c8jxV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jxV: // global
           I64[Sp - 40] = block_c8jy1_info;
           _s8j63::P64 = P64[R1 + 7];
           _s8j64::P64 = P64[R1 + 15];
           _s8j65::P64 = P64[R1 + 23];
           _s8j66::P64 = P64[R1 + 31];
           _s8j67::P64 = P64[R1 + 39];
           _s8j68::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8j65::P64;
           P64[Sp - 24] = _s8j66::P64;
           P64[Sp - 16] = _s8j67::P64;
           P64[Sp - 8] = _s8j68::P64;
           P64[Sp] = _s8j64::P64;
           P64[Sp + 8] = _s8j63::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8jCR; else goto c8jy2;
       u8jCR: // global
           call _c8jy1(R1) args: 0, res: 0, upd: 0;
       c8jy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jy1() //  [R1]
         { info_tbl: [(c8jy1,
                       label: block_c8jy1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jy1: // global
           I64[Sp - 40] = block_c8jy6_info;
           _s8j6a::P64 = P64[R1 + 7];
           _s8j6c::P64 = P64[R1 + 23];
           _s8j6d::P64 = P64[R1 + 31];
           _s8j6e::P64 = P64[R1 + 39];
           _s8j6f::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _s8j6c::P64;
           P64[Sp - 24] = _s8j6d::P64;
           P64[Sp - 16] = _s8j6e::P64;
           P64[Sp - 8] = _s8j6f::P64;
           P64[Sp] = _s8j6a::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8jCT; else goto c8jy7;
       u8jCT: // global
           call _c8jy6(R1) args: 0, res: 0, upd: 0;
       c8jy7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jy6() //  [R1]
         { info_tbl: [(c8jy6,
                       label: block_c8jy6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jy6: // global
           _s8j6h::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8jye_info;
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _s8j6h::I64;
           if (R1 & 7 != 0) goto u8jCU; else goto c8jyn;
       u8jCU: // global
           call _c8jye(R1) args: 0, res: 0, upd: 0;
       c8jyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jye() //  [R1]
         { info_tbl: [(c8jye,
                       label: block_c8jye_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jye: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 80]) goto c8jyF; else goto u8jCy;
       c8jyF: // global
           I64[Sp] = block_c8jyE_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8jCy: // global
           Sp = Sp + 96;
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _c8jyE() //  [R1]
         { info_tbl: [(c8jyE,
                       label: block_c8jyE_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jyE: // global
           if (R1 & 7 == 1) goto u8jCz; else goto c8jAE;
       u8jCz: // global
           Sp = Sp + 96;
           call _c8jC7() args: 0, res: 0, upd: 0;
       c8jAE: // global
           I64[Sp] = block_c8jyQ_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto u8jCW; else goto c8jAF;
       u8jCW: // global
           call _c8jyQ(R1) args: 0, res: 0, upd: 0;
       c8jAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jyQ() //  [R1]
         { info_tbl: [(c8jyQ,
                       label: block_c8jyQ_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jyQ: // global
           _s8j6a::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8jAM; else goto c8jB2;
       c8jAM: // global
           I64[Sp] = block_c8jAJ_info;
           R1 = _s8j6a::P64;
           if (R1 & 7 != 0) goto u8jCY; else goto c8jAN;
       u8jCY: // global
           call _c8jAJ(R1) args: 0, res: 0, upd: 0;
       c8jAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jB2: // global
           I64[Sp] = block_c8jB0_info;
           _s8j6J::P64 = P64[R1 + 6];
           R1 = _s8j6a::P64;
           P64[Sp + 88] = _s8j6J::P64;
           if (R1 & 7 != 0) goto u8jCZ; else goto c8jB3;
       u8jCZ: // global
           call _c8jB0(R1) args: 0, res: 0, upd: 0;
       c8jB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jAJ() //  [R1]
         { info_tbl: [(c8jAJ,
                       label: block_c8jAJ_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jAJ: // global
           if (R1 & 7 == 1) goto u8jCH; else goto u8jCI;
       u8jCH: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8jCI: // global
           Sp = Sp + 96;
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _c8jB0() //  [R1]
         { info_tbl: [(c8jB0,
                       label: block_c8jB0_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jB0: // global
           if (R1 & 7 == 1) goto u8jCA; else goto c8jBe;
       u8jCA: // global
           Sp = Sp + 96;
           call _c8jC7() args: 0, res: 0, upd: 0;
       c8jBe: // global
           I64[Sp] = block_c8jBc_info;
           _s8j6L::P64 = P64[R1 + 6];
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _s8j6L::P64;
           if (R1 & 7 != 0) goto u8jDh; else goto c8jBf;
       u8jDh: // global
           call _c8jBc(R1) args: 0, res: 0, upd: 0;
       c8jBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jBc() //  [R1]
         { info_tbl: [(c8jBc,
                       label: block_c8jBc_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jBc: // global
           _s8j6L::P64 = P64[Sp + 88];
           if (R1 & 7 == 1) goto c8jBm; else goto c8jBR;
       c8jBm: // global
           I64[Sp] = block_c8jBj_info;
           _s8j6O::P64 = P64[R1 + 15];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6O::P64;
           if (R1 & 7 != 0) goto u8jDj; else goto c8jBn;
       u8jDj: // global
           call _c8jBj(R1) args: 0, res: 0, upd: 0;
       c8jBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jBR: // global
           I64[Sp] = block_c8jBP_info;
           _s8j6X::P64 = P64[R1 + 14];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6X::P64;
           if (R1 & 7 != 0) goto u8jDk; else goto c8jBS;
       u8jDk: // global
           call _c8jBP(R1) args: 0, res: 0, upd: 0;
       c8jBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jBj() //  [R1]
         { info_tbl: [(c8jBj,
                       label: block_c8jBj_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jBj: // global
           if (R1 & 7 == 1) goto c8jBI; else goto u8jCE;
       c8jBI: // global
           if (P64[Sp + 88] == P64[R1 + 15]) goto u8jCF; else goto u8jCG;
       u8jCF: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8jCG: // global
           Sp = Sp + 96;
           goto u8jDn;
       u8jCE: // global
           Sp = Sp + 96;
           goto u8jDn;
       u8jDn: // global
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _c8jBP() //  [R1]
         { info_tbl: [(c8jBP,
                       label: block_c8jBP_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jBP: // global
           if (R1 & 7 == 1) goto u8jCB; else goto c8jCh;
       u8jCB: // global
           Sp = Sp + 96;
           goto u8jDq;
       c8jCh: // global
           if (P64[Sp + 88] == P64[R1 + 14]) goto u8jCC; else goto u8jCD;
       u8jCC: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8jCD: // global
           Sp = Sp + 96;
           goto u8jDq;
       u8jDq: // global
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6m: // global
           I64[Sp + 8] = block_c8jyV_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jyV() //  [R1]
         { info_tbl: [(c8jyV,
                       label: block_c8jyV_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jyV: // global
           if (R1 & 7 == 1) goto u8jCJ; else goto c8jzN;
       u8jCJ: // global
           Sp = Sp + 80;
           call _c8jC7() args: 0, res: 0, upd: 0;
       c8jzN: // global
           I64[Sp] = block_c8jz7_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto u8jD0; else goto c8jzO;
       u8jD0: // global
           call _c8jz7(R1) args: 0, res: 0, upd: 0;
       c8jzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jz7() //  [R1]
         { info_tbl: [(c8jz7,
                       label: block_c8jz7_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jz7: // global
           _s8j6e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jzV; else goto c8jAb;
       c8jzV: // global
           I64[Sp + 8] = block_c8jzS_info;
           R1 = _s8j6e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jD2; else goto c8jzW;
       u8jD2: // global
           call _c8jzS(R1) args: 0, res: 0, upd: 0;
       c8jzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jAb: // global
           I64[Sp + 8] = block_c8jA9_info;
           _s8j6y::P64 = P64[R1 + 6];
           R1 = _s8j6e::P64;
           P64[Sp + 72] = _s8j6y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jD3; else goto c8jAc;
       u8jD3: // global
           call _c8jA9(R1) args: 0, res: 0, upd: 0;
       c8jAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jzS() //  [R1]
         { info_tbl: [(c8jzS,
                       label: block_c8jzS_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jzS: // global
           if (R1 & 7 == 1) goto u8jCN; else goto u8jCO;
       u8jCN: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8jCO: // global
           Sp = Sp + 72;
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _c8jA9() //  [R1]
         { info_tbl: [(c8jA9,
                       label: block_c8jA9_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jA9: // global
           if (R1 & 7 == 1) goto u8jCK; else goto c8jAs;
       u8jCK: // global
           Sp = Sp + 72;
           call _c8jC7() args: 0, res: 0, upd: 0;
       c8jAs: // global
           I64[Sp] = block_c8jAl_info;
           _s8j6A::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8j6A::P64;
           if (R1 & 7 != 0) goto u8jDa; else goto c8jAm;
       u8jDa: // global
           call _c8jAl(R1) args: 0, res: 0, upd: 0;
       c8jAm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jAl() //  [R1]
         { info_tbl: [(c8jAl,
                       label: block_c8jAl_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jAl: // global
           I64[Sp] = block_c8jAq_info;
           _s8j6C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 64];
           I64[Sp + 64] = _s8j6C::I64;
           if (R1 & 7 != 0) goto u8jDc; else goto c8jAu;
       u8jDc: // global
           call _c8jAq(R1) args: 0, res: 0, upd: 0;
       c8jAu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jAq() //  [R1]
         { info_tbl: [(c8jAq,
                       label: block_c8jAq_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jAq: // global
           if (I64[Sp + 64] == I64[R1 + 7]) goto u8jCL; else goto u8jCM;
       u8jCL: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8jCM: // global
           Sp = Sp + 72;
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6o: // global
           I64[Sp - 8] = block_c8jzc_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jDr; else goto c8jze;
       u8jDr: // global
           call _c8jzc(R1) args: 0, res: 0, upd: 0;
       c8jze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jzc() //  [R1]
         { info_tbl: [(c8jzc,
                       label: block_c8jzc_info
                       rep:StackRep [False, True, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jzc: // global
           _s8j6f::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jzl; else goto c8jzB;
       c8jzl: // global
           I64[Sp + 64] = block_c8jzi_info;
           R1 = _s8j6f::P64;
           Sp = Sp + 64;
           if (R1 & 7 != 0) goto u8jD4; else goto c8jzm;
       u8jD4: // global
           call _c8jzi(R1) args: 0, res: 0, upd: 0;
       c8jzm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jzB: // global
           I64[Sp + 56] = block_c8jzz_info;
           _s8j6s::P64 = P64[R1 + 6];
           R1 = _s8j6f::P64;
           P64[Sp + 64] = _s8j6s::P64;
           Sp = Sp + 56;
           if (R1 & 7 != 0) goto u8jD5; else goto c8jzC;
       u8jD5: // global
           call _c8jzz(R1) args: 0, res: 0, upd: 0;
       c8jzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jzi() //  [R1]
         { info_tbl: [(c8jzi,
                       label: block_c8jzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jzi: // global
           if (R1 & 7 == 1) goto c8jzs; else goto u8jCQ;
       c8jzs: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8jCQ: // global
           Sp = Sp + 8;
           call _c8jC7() args: 0, res: 0, upd: 0;
     }
 },
 _c8jzz() //  [R1]
         { info_tbl: [(c8jzz,
                       label: block_c8jzz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jzz: // global
           if (R1 & 7 == 1) goto u8jCP; else goto c8jzM;
       u8jCP: // global
           Sp = Sp + 16;
           call _c8jC7() args: 0, res: 0, upd: 0;
       c8jzM: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8jC7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jC7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.795312633 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c/=_closure" {
     GHC.IO.Exception.$fEqIOException_$c/=_closure:
         const GHC.IO.Exception.$fEqIOException_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8jDC,
                       label: GHC.IO.Exception.$fEqIOException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jDC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jDD; else goto c8jDE;
       c8jDD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jDE: // global
           I64[Sp - 8] = block_c8jDw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Exception.$fEqIOException_$c==_entry(R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jDw() //  [R1]
         { info_tbl: [(c8jDw,
                       label: block_c8jDw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jDw: // global
           if (R1 & 7 == 1) goto c8jDz; else goto c8jDA;
       c8jDz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jDA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.796403076 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_closure" {
     GHC.IO.Exception.$fEqIOException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOException_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.79719835 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException1_closure" {
     GHC.IO.Exception.$fExceptionIOException1_closure:
         const GHC.IO.Exception.$fExceptionIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException1_entry() //  [R1]
         { info_tbl: [(c8jDR,
                       label: GHC.IO.Exception.$fExceptionIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jDR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jDS; else goto c8jDT;
       c8jDS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jDT: // global
           (_c8jDO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jDO::I64 == 0) goto c8jDQ; else goto c8jDP;
       c8jDQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jDP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jDO::I64;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.798121872 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException3_bytes" {
     GHC.IO.Exception.$fExceptionIOException3_bytes:
         I8[] [32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.798654955 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException2_bytes" {
     GHC.IO.Exception.$fExceptionIOException2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.802473167 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec3_closure" {
     GHC.IO.Exception.$w$cshowsPrec3_closure:
         const GHC.IO.Exception.$w$cshowsPrec3_info;
         const 0;
 },
 sat_s8j7k_entry() //  [R1]
         { info_tbl: [(c8jEo,
                       label: sat_s8j7k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEo: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7l_entry() //  [R1]
         { info_tbl: [(c8jEr,
                       label: sat_s8j7l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEr: // global
           _s8j7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jEs; else goto c8jEt;
       c8jEt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jEv; else goto c8jEu;
       c8jEv: // global
           HpAlloc = 24;
           goto c8jEs;
       c8jEs: // global
           R1 = _s8j7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jEu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7l::P64;
           _s8j7e::P64 = P64[_s8j7l::P64 + 16];
           _s8j7h::P64 = P64[_s8j7l::P64 + 24];
           I64[Hp - 16] = sat_s8j7k_info;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 16;
           R2 = _s8j7h::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7m_entry() //  [R1]
         { info_tbl: [(c8jEA,
                       label: sat_s8j7m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jEB; else goto c8jEC;
       c8jEB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jEC: // global
           I64[Sp - 16] = block_c8jEa_info;
           _s8j7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s8j7e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jEI; else goto c8jEb;
       u8jEI: // global
           call _c8jEa(R1) args: 0, res: 0, upd: 0;
       c8jEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jEa() //  [R1]
         { info_tbl: [(c8jEa,
                       label: block_c8jEa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEa: // global
           _s8j7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jEx; else goto c8jEy;
       c8jEx: // global
           R1 = _s8j7e::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jEy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8jEH; else goto c8jEG;
       c8jEH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jEG: // global
           I64[Hp - 24] = sat_s8j7l_info;
           P64[Hp - 8] = _s8j7e::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionIOException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8j7g_entry() //  [R1]
         { info_tbl: [(c8jEJ,
                       label: karg_s8j7g_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEJ: // global
           _s8j7g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jEK; else goto c8jEL;
       c8jEL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8jEN; else goto c8jEM;
       c8jEN: // global
           HpAlloc = 32;
           goto c8jEK;
       c8jEK: // global
           R1 = _s8j7g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jEM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7g::P64;
           _s8j7a::P64 = P64[_s8j7g::P64 + 16];
           _s8j7c::P64 = P64[_s8j7g::P64 + 24];
           _s8j7e::P64 = P64[_s8j7g::P64 + 32];
           I64[Hp - 24] = sat_s8j7m_info;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 24;
           R2 = _s8j7a::P64;
           Sp = Sp - 16;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7q_entry() //  [R1]
         { info_tbl: [(c8jEY,
                       label: sat_s8j7q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEY: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_s8j7f_entry() //  [R1]
         { info_tbl: [(c8jF5,
                       label: eta_s8j7f_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jF5: // global
           _s8j7f::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8jF6; else goto c8jF7;
       c8jF7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8jF9; else goto c8jF8;
       c8jF9: // global
           HpAlloc = 40;
           goto c8jF6;
       c8jF6: // global
           R1 = _s8j7f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jF8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7f::P64;
           _s8j7a::P64 = P64[_s8j7f::P64 + 16];
           _s8j7b::P64 = P64[_s8j7f::P64 + 24];
           _s8j7c::P64 = P64[_s8j7f::P64 + 32];
           _s8j7e::P64 = P64[_s8j7f::P64 + 40];
           I64[Hp - 32] = karg_s8j7g_info;
           P64[Hp - 16] = _s8j7a::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           I64[Sp - 32] = block_c8jEO_info;
           R1 = _s8j7b::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jFf; else goto c8jEP;
       u8jFf: // global
           call _c8jEO(R1) args: 0, res: 0, upd: 0;
       c8jEP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jEO() //  [R1]
         { info_tbl: [(c8jEO,
                       label: block_c8jEO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jEO: // global
           _c8jE2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jF2; else goto c8jF3;
       c8jF2: // global
           R1 = _c8jE2::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8jF3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jFe; else goto c8jFd;
       c8jFe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jFd: // global
           I64[Hp - 16] = sat_s8j7q_info;
           P64[Hp] = _c8jE2::P64;
           R3 = Hp - 16;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7x_entry() //  [R1]
         { info_tbl: [(c8jFI,
                       label: sat_s8j7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jFJ; else goto c8jFK;
       c8jFJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jFK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7y_entry() //  [R1]
         { info_tbl: [(c8jFL,
                       label: sat_s8j7y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jFP; else goto c8jFO;
       c8jFP: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jFO: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7x_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7z_entry() //  [R1]
         { info_tbl: [(c8jFQ,
                       label: sat_s8j7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFQ: // global
           _s8j7z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jFR; else goto c8jFS;
       c8jFS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jFU; else goto c8jFT;
       c8jFU: // global
           HpAlloc = 24;
           goto c8jFR;
       c8jFR: // global
           R1 = _s8j7z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jFT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7z::P64;
           _s8j7f::P64 = P64[_s8j7z::P64 + 16];
           _s8j7v::P64 = P64[_s8j7z::P64 + 24];
           I64[Hp - 16] = sat_s8j7y_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7v::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7D_entry() //  [R1]
         { info_tbl: [(c8jG9,
                       label: sat_s8j7D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jGa; else goto c8jGb;
       c8jGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jGb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7E_entry() //  [R1]
         { info_tbl: [(c8jGc,
                       label: sat_s8j7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jGc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jGg; else goto c8jGf;
       c8jGg: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jGf: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7D_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7F_entry() //  [R1]
         { info_tbl: [(c8jGh,
                       label: sat_s8j7F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jGh: // global
           _s8j7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jGi; else goto c8jGj;
       c8jGj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jGl; else goto c8jGk;
       c8jGl: // global
           HpAlloc = 24;
           goto c8jGi;
       c8jGi: // global
           R1 = _s8j7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jGk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7F::P64;
           _s8j7f::P64 = P64[_s8j7F::P64 + 16];
           _s8j7A::P64 = P64[_s8j7F::P64 + 24];
           I64[Hp - 16] = sat_s8j7E_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7A::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7H_entry() //  [R1]
         { info_tbl: [(c8jGs,
                       label: sat_s8j7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jGs: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8jGz,
                       label: GHC.IO.Exception.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jGz: // global
           _s8j7d::P64 = R6;
           _s8j7c::P64 = R5;
           _s8j7b::P64 = R4;
           _s8j7a::P64 = R3;
           _s8j79::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jGA; else goto c8jGB;
       c8jGB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8jGD; else goto c8jGC;
       c8jGD: // global
           HpAlloc = 48;
           goto c8jGA;
       c8jGA: // global
           R6 = _s8j7d::P64;
           R5 = _s8j7c::P64;
           R4 = _s8j7b::P64;
           R3 = _s8j7a::P64;
           R2 = _s8j79::P64;
           R1 = GHC.IO.Exception.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8jGC: // global
           I64[Hp - 40] = eta_s8j7f_info;
           P64[Hp - 24] = _s8j7a::P64;
           P64[Hp - 16] = _s8j7b::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_c8jFg_info;
           R1 = _s8j7d::P64;
           P64[Sp - 8] = _s8j79::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jH1; else goto c8jFh;
       u8jH1: // global
           call _c8jFg(R1) args: 0, res: 0, upd: 0;
       c8jFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jFg() //  [R1]
         { info_tbl: [(c8jFg,
                       label: block_c8jFg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFg: // global
           if (R1 & 7 == 1) goto c8jGw; else goto c8jGx;
       c8jGw: // global
           _s8j79::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jFl_info;
           R1 = _s8j79::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jGZ; else goto c8jFm;
       u8jGZ: // global
           call _c8jFl(R1) args: 0, res: 0, upd: 0;
       c8jFm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jGx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jGW; else goto c8jGV;
       c8jGW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jGV: // global
           _s8j7G::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j7H_info;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = _s8j7G::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8jFl() //  [R1]
         { info_tbl: [(c8jFl,
                       label: block_c8jFl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFl: // global
           if (R1 & 7 == 1) goto c8jGI; else goto c8jGK;
       c8jGI: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jGK: // global
           I64[Sp] = block_c8jFr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u8jH0; else goto c8jFs;
       u8jH0: // global
           call _c8jFr(R1) args: 0, res: 0, upd: 0;
       c8jFs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jFr() //  [R1]
         { info_tbl: [(c8jFr,
                       label: block_c8jFr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jFr: // global
           _c8jDY::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jGM; else goto c8jGQ;
       c8jGM: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8jGT; else goto c8jGO;
       c8jGO: // global
           _s8j7v::P64 = P64[_s8j7u::P64 + 7];
           I64[Hp - 24] = sat_s8j7z_info;
           P64[Hp - 8] = _c8jDY::P64;
           P64[Hp] = _s8j7v::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8jGQ: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8jGT; else goto c8jGS;
       c8jGT: // global
           HpAlloc = 32;
           R1 = _s8j7u::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jGS: // global
           _s8j7A::P64 = P64[_s8j7u::P64 + 6];
           I64[Hp - 24] = sat_s8j7F_info;
           P64[Hp - 8] = _c8jDY::P64;
           P64[Hp] = _s8j7A::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.809497742 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_entry() //  [R2,
                                                                  R3, R4]
         { info_tbl: [(c8jH9,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jH9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jHa; else goto c8jHb;
       c8jHa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jHb: // global
           I64[Sp - 16] = block_c8jH6_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jHf; else goto c8jH7;
       u8jHf: // global
           call _c8jH6(R1) args: 0, res: 0, upd: 0;
       c8jH7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jH6() //  [R1]
         { info_tbl: [(c8jH6,
                       label: block_c8jH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jH6: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.811057906 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8jHn,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jHo; else goto c8jHp;
       c8jHo: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jHp: // global
           I64[Sp - 8] = block_c8jHk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jHt; else goto c8jHl;
       u8jHt: // global
           call _c8jHk(R1) args: 0, res: 0, upd: 0;
       c8jHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jHk() //  [R1]
         { info_tbl: [(c8jHk,
                       label: block_c8jHk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHk: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = GHC.Types.[]_closure+1;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.814293176 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException1_closure" {
     GHC.IO.Exception.$fShowIOException1_closure:
         const GHC.IO.Exception.$fShowIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8jHB,
                       label: GHC.IO.Exception.$fShowIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jHC; else goto c8jHD;
       c8jHC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jHD: // global
           I64[Sp - 16] = block_c8jHy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jHH; else goto c8jHz;
       u8jHH: // global
           call _c8jHy(R1) args: 0, res: 0, upd: 0;
       c8jHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jHy() //  [R1]
         { info_tbl: [(c8jHy,
                       label: block_c8jHy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHy: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.815495495 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8jHM,
                       label: GHC.IO.Exception.$fShowIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHM: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.816228796 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_closure" {
     GHC.IO.Exception.$fShowIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.817193392 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_$cto_closure" {
     GHC.IO.Exception.$fGenericExitCode_$cto_closure:
         const GHC.IO.Exception.$fGenericExitCode_$cto_info;
 },
 GHC.IO.Exception.$fGenericExitCode_$cto_entry() //  [R2]
         { info_tbl: [(c8jHZ,
                       label: GHC.IO.Exception.$fGenericExitCode_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jI0; else goto c8jI1;
       c8jI0: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jI1: // global
           I64[Sp - 8] = block_c8jHT_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jHT() //  [R1]
         { info_tbl: [(c8jHT,
                       label: block_c8jHT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jHT: // global
           if (R1 & 7 == 1) goto c8jHW; else goto c8jHX;
       c8jHW: // global
           I64[Sp] = block_c8jI4_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8jIh; else goto c8jI6;
       u8jIh: // global
           call _c8jI4() args: 0, res: 0, upd: 0;
       c8jI6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jHX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jIg; else goto c8jIf;
       c8jIg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jIf: // global
           _s8j8f::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = _s8j8f::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jI4() //  []
         { info_tbl: [(c8jI4,
                       label: block_c8jI4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jI4: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.818482214 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode2_closure" {
     GHC.IO.Exception.$fGenericExitCode2_closure:
         const GHC.Generics.L1_con_info;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.819363144 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode1_closure" {
     GHC.IO.Exception.$fGenericExitCode1_closure:
         const GHC.IO.Exception.$fGenericExitCode1_info;
 },
 GHC.IO.Exception.$fGenericExitCode1_entry() //  [R2]
         { info_tbl: [(c8jIt,
                       label: GHC.IO.Exception.$fGenericExitCode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jIt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jIu; else goto c8jIv;
       c8jIu: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jIv: // global
           I64[Sp - 8] = block_c8jIm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jIF; else goto c8jIn;
       u8jIF: // global
           call _c8jIm(R1) args: 0, res: 0, upd: 0;
       c8jIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jIm() //  [R1]
         { info_tbl: [(c8jIm,
                       label: block_c8jIm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jIm: // global
           if (R1 & 7 == 1) goto c8jIq; else goto c8jIr;
       c8jIq: // global
           R1 = GHC.IO.Exception.$fGenericExitCode2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jIr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jIE; else goto c8jID;
       c8jIE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jID: // global
           _s8j8i::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _s8j8i::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.820479626 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_closure" {
     GHC.IO.Exception.$fGenericExitCode_closure:
         const GHC.Generics.C:Generic_con_info;
         const GHC.IO.Exception.$fGenericExitCode1_closure+1;
         const GHC.IO.Exception.$fGenericExitCode_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.82105064 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode3_bytes" {
     GHC.IO.Exception.$fExceptionExitCode3_bytes:
         I8[] [69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.821793657 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode2_closure" {
     GHC.IO.Exception.$fExceptionExitCode2_closure:
         const GHC.IO.Exception.$fExceptionExitCode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode2_entry() //  [R1]
         { info_tbl: [(c8jIM,
                       label: GHC.IO.Exception.$fExceptionExitCode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jIM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jIN; else goto c8jIO;
       c8jIN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jIO: // global
           (_c8jIJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jIJ::I64 == 0) goto c8jIL; else goto c8jIK;
       c8jIL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jIK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jIJ::I64;
           R2 = GHC.IO.Exception.$fExceptionExitCode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.822733774 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode1_bytes" {
     GHC.IO.Exception.$fExceptionExitCode1_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.824717304 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info;
         const 0;
 },
 sat_s8j8w_entry() //  [R1]
         { info_tbl: [(c8jJe,
                       label: sat_s8j8w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jJk; else goto c8jJl;
       c8jJk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jJl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8jJb_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jJq; else goto c8jJc;
       u8jJq: // global
           call _c8jJb(R1) args: 0, res: 0, upd: 0;
       c8jJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jJb() //  [R1]
         { info_tbl: [(c8jJb,
                       label: block_c8jJb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJb: // global
           _s8j8l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jJh_info;
           R4 = _s8j8l::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jJh() //  [R1, R2]
         { info_tbl: [(c8jJh,
                       label: block_c8jJh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jJp; else goto c8jJo;
       c8jJp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8jJo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8D_entry() //  [R1]
         { info_tbl: [(c8jJD,
                       label: sat_s8j8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jJK; else goto c8jJL;
       c8jJK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jJL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8jJA_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jJS; else goto c8jJB;
       u8jJS: // global
           call _c8jJA(R1) args: 0, res: 0, upd: 0;
       c8jJB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jJA() //  [R1]
         { info_tbl: [(c8jJA,
                       label: block_c8jJA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jJO; else goto c8jJN;
       c8jJO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jJN: // global
           _s8j8y::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8jJH_info;
           R4 = Hp - 14;
           R3 = _s8j8y::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jJH() //  [R1, R2]
         { info_tbl: [(c8jJH,
                       label: block_c8jJH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jJR; else goto c8jJQ;
       c8jJR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8jJQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8E_entry() //  [R1]
         { info_tbl: [(c8jJT,
                       label: sat_s8j8E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jJT: // global
           _s8j8E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8jJU; else goto c8jJV;
       c8jJV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8jJX; else goto c8jJW;
       c8jJX: // global
           HpAlloc = 32;
           goto c8jJU;
       c8jJU: // global
           R1 = _s8j8E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jJW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j8E::P64;
           _s8j8l::P64 = P64[_s8j8E::P64 + 16];
           _s8j8n::P64 = P64[_s8j8E::P64 + 24];
           I64[Hp - 24] = sat_s8j8D_info;
           P64[Hp - 8] = _s8j8l::P64;
           P64[Hp] = _s8j8n::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8jK2,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jK2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8jK3; else goto c8jK4;
       c8jK3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jK4: // global
           I64[Sp - 24] = block_c8jIT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8jKg; else goto c8jIU;
       u8jKg: // global
           call _c8jIT(R1) args: 0, res: 0, upd: 0;
       c8jIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jIT() //  [R1]
         { info_tbl: [(c8jIT,
                       label: block_c8jIT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jIT: // global
           if (R1 & 7 == 1) goto c8jJZ; else goto c8jK0;
       c8jJZ: // global
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8jK0: // global
           I64[Sp] = block_c8jIZ_info;
           _s8j8n::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j8n::P64;
           if (R1 & 7 != 0) goto u8jKf; else goto c8jJ0;
       u8jKf: // global
           call _c8jIZ(R1) args: 0, res: 0, upd: 0;
       c8jJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jIZ() //  [R1]
         { info_tbl: [(c8jIZ,
                       label: block_c8jIZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jIZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8jKa; else goto c8jK9;
       c8jKa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jK9: // global
           _s8j8l::P64 = P64[Sp + 16];
           _s8j8n::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c8jKc; else goto c8jKe;
       c8jKc: // global
           I64[Hp - 48] = sat_s8j8w_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           _c8jJ7::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c8jJ7::P64;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8jKe: // global
           I64[Hp - 48] = sat_s8j8E_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.828886459 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cshow_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cshow_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_info;
         const 0;
 },
 sat_s8j8N_entry() //  [R1]
         { info_tbl: [(c8jKy,
                       label: sat_s8j8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jKy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8jKE; else goto c8jKF;
       c8jKE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jKF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8jKv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8jKK; else goto c8jKw;
       u8jKK: // global
           call _c8jKv(R1) args: 0, res: 0, upd: 0;
       c8jKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jKv() //  [R1]
         { info_tbl: [(c8jKv,
                       label: block_c8jKv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jKv: // global
           I64[Sp] = block_c8jKB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jKB() //  [R1, R2]
         { info_tbl: [(c8jKB,
                       label: block_c8jKB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jKB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jKJ; else goto c8jKI;
       c8jKJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8jKI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fExceptionExitCode_$cshow_entry() //  [R2]
         { info_tbl: [(c8jKP,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jKP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8jKQ; else goto c8jKR;
       c8jKQ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jKR: // global
           I64[Sp - 8] = block_c8jKl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jKX; else goto c8jKm;
       u8jKX: // global
           call _c8jKl(R1) args: 0, res: 0, upd: 0;
       c8jKm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jKl() //  [R1]
         { info_tbl: [(c8jKl,
                       label: block_c8jKl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jKl: // global
           if (R1 & 7 == 1) goto c8jKM; else goto c8jKN;
       c8jKM: // global
           R1 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jKN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jKW; else goto c8jKV;
       c8jKW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jKV: // global
           _s8j8H::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j8N_info;
           P64[Hp] = _s8j8H::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.830866911 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode1_closure" {
     GHC.IO.Exception.$fShowExitCode1_closure:
         const GHC.IO.Exception.$fShowExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8jL2,
                       label: GHC.IO.Exception.$fShowExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jL2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionArrayException1_closure+1;
           call GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.831720527 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowList_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowList_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8jL9,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jL9: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowExitCode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.83248979 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_closure" {
     GHC.IO.Exception.$fShowExitCode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const GHC.IO.Exception.$fShowExitCode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.833091918 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme1_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.83367486 UTC

[section ""cstring" . GHC.IO.Exception.$fReadExitCode5_bytes" {
     GHC.IO.Exception.$fReadExitCode5_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.834379554 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode4_closure" {
     GHC.IO.Exception.$fReadExitCode4_closure:
         const GHC.IO.Exception.$fReadExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode4_entry() //  [R1]
         { info_tbl: [(c8jLi,
                       label: GHC.IO.Exception.$fReadExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jLi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jLj; else goto c8jLk;
       c8jLj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jLk: // global
           (_c8jLf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jLf::I64 == 0) goto c8jLh; else goto c8jLg;
       c8jLh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jLg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jLf::I64;
           R2 = GHC.IO.Exception.$fReadExitCode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.835262728 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fReadExitCode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.835811072 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode3_closure" {
     GHC.IO.Exception.$fReadExitCode3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.837551914 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode2_closure" {
     GHC.IO.Exception.$fReadExitCode2_closure:
         const GHC.IO.Exception.$fReadExitCode2_info;
         const 0;
 },
 sat_s8j8T_entry() //  [R1]
         { info_tbl: [(c8jLu,
                       label: sat_s8j8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jLu: // global
           R2 = GHC.IO.Exception.ExitSuccess_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j93_entry() //  [R1, R2]
         { info_tbl: [(c8jLX,
                       label: sat_s8j93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jLX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jM1; else goto c8jM0;
       c8jM1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jM0: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _s8j8R::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j94_entry() //  [R1, R2]
         { info_tbl: [(c8jM2,
                       label: sat_s8j94_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jM2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jM6; else goto c8jM5;
       c8jM6: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jM5: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8j93_info;
           P64[Hp] = _s8j8R::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Exception.$fReadExitCode3_closure+1;
           R2 = GHC.Read.$fReadInt2_closure+1;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j97_entry() //  [R1]
         { info_tbl: [(c8jM7,
                       label: sat_s8j97_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jM7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jM8; else goto c8jM9;
       c8jM8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jM9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8jLD_info;
           _s8j8R::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8j8R::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8jMm; else goto c8jLE;
       u8jMm: // global
           call _c8jLD(R1) args: 0, res: 0, upd: 0;
       c8jLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8jLD() //  [R1]
         { info_tbl: [(c8jLD,
                       label: block_c8jLD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jLD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jMc; else goto c8jMb;
       c8jMc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jMb: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8jMe; else goto c8jMi;
       c8jMe: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8jMi: // global
           I64[Hp - 8] = sat_s8j94_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8jMf_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jMf() //  [R1]
         { info_tbl: [(c8jMf,
                       label: block_c8jMf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jMf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jMl; else goto c8jMk;
       c8jMl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8jMk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode2_entry() //  [R2, R3]
         { info_tbl: [(c8jMo,
                       label: GHC.IO.Exception.$fReadExitCode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jMo: // global
           _s8j8R::P64 = R3;
           _s8j8Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8jMp; else goto c8jMq;
       c8jMq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8jMs; else goto c8jMr;
       c8jMs: // global
           HpAlloc = 16;
           goto c8jMp;
       c8jMp: // global
           R3 = _s8j8R::P64;
           R2 = _s8j8Q::P64;
           R1 = GHC.IO.Exception.$fReadExitCode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jMr: // global
           I64[Hp - 8] = sat_s8j8T_info;
           P64[Hp] = _s8j8R::P64;
           I64[Sp - 24] = block_c8jLx_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme1_closure+4;
           P64[Sp - 16] = _s8j8Q::P64;
           P64[Sp - 8] = _s8j8R::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jLx() //  [R1]
         { info_tbl: [(c8jLx,
                       label: block_c8jLx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jLx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8jMv; else goto c8jMu;
       c8jMv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8jMu: // global
           I64[Hp - 40] = sat_s8j97_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.840403593 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode1_closure" {
     GHC.IO.Exception.$fReadExitCode1_closure:
         const GHC.IO.Exception.$fReadExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8jMA,
                       label: GHC.IO.Exception.$fReadExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jMA: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.841468084 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_info;
         const 0;
 },
 sat_s8j99_entry() //  [R1]
         { info_tbl: [(c8jML,
                       label: sat_s8j99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jML: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jMM; else goto c8jMN;
       c8jMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8jMO,
                       label: GHC.IO.Exception.$fReadExitCode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jMO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8jMS; else goto c8jMR;
       c8jMS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8jMR: // global
           I64[Hp - 16] = sat_s8j99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.842732771 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8jMZ,
                       label: GHC.IO.Exception.$fReadExitCode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jMZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jN0; else goto c8jN1;
       c8jN0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jN1: // global
           (_c8jMW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jMW::I64 == 0) goto c8jMY; else goto c8jMX;
       c8jMY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jMX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jMW::I64;
           R2 = GHC.IO.Exception.$fReadExitCode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.843861037 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode6_closure" {
     GHC.IO.Exception.$fReadExitCode6_closure:
         const GHC.IO.Exception.$fReadExitCode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode6_entry() //  [R1]
         { info_tbl: [(c8jN8,
                       label: GHC.IO.Exception.$fReadExitCode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jN8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jN9; else goto c8jNa;
       c8jN9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jNa: // global
           (_c8jN5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8jN5::I64 == 0) goto c8jN7; else goto c8jN6;
       c8jN7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8jN6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8jN5::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.844883141 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadList_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadList_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadList_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadList_entry() //  [R2]
         { info_tbl: [(c8jNf,
                       label: GHC.IO.Exception.$fReadExitCode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNf: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode6_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.845692455 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_closure" {
     GHC.IO.Exception.$fReadExitCode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure+1;
         const GHC.IO.Exception.$fReadExitCode_$creadList_closure+1;
         const GHC.IO.Exception.$fReadExitCode1_closure+2;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.846853657 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8jNt,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jNu; else goto c8jNv;
       c8jNu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jNv: // global
           I64[Sp - 16] = block_c8jNm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jO6; else goto c8jNn;
       u8jO6: // global
           call _c8jNm(R1) args: 0, res: 0, upd: 0;
       c8jNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jNm() //  [R1]
         { info_tbl: [(c8jNm,
                       label: block_c8jNm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNm: // global
           _s8j9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jNq; else goto c8jNr;
       c8jNq: // global
           I64[Sp + 8] = block_c8jNy_info;
           R1 = _s8j9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jO4; else goto c8jNA;
       u8jO4: // global
           call _c8jNy(R1) args: 0, res: 0, upd: 0;
       c8jNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jNr: // global
           I64[Sp] = block_c8jNN_info;
           _s8j9f::P64 = P64[R1 + 6];
           R1 = _s8j9b::P64;
           P64[Sp + 8] = _s8j9f::P64;
           if (R1 & 7 != 0) goto u8jO5; else goto c8jNP;
       u8jO5: // global
           call _c8jNN(R1) args: 0, res: 0, upd: 0;
       c8jNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jNy() //  [R1]
         { info_tbl: [(c8jNy,
                       label: block_c8jNy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNy: // global
           if (R1 & 7 == 1) goto u8jO3; else goto c8jNK;
       u8jO3: // global
           Sp = Sp + 8;
           call _c8jNV() args: 0, res: 0, upd: 0;
       c8jNK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jNN() //  [R1]
         { info_tbl: [(c8jNN,
                       label: block_c8jNN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNN: // global
           if (R1 & 7 == 1) goto u8jO2; else goto c8jNZ;
       u8jO2: // global
           Sp = Sp + 16;
           call _c8jNV() args: 0, res: 0, upd: 0;
       c8jNZ: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8jNV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jNV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.848935499 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$ccompare_closure" {
     GHC.IO.Exception.$fOrdExitCode_$ccompare_closure:
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8jOk,
                       label: GHC.IO.Exception.$fOrdExitCode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jOk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jOl; else goto c8jOm;
       c8jOl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jOm: // global
           I64[Sp - 16] = block_c8jOd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jOV; else goto c8jOe;
       u8jOV: // global
           call _c8jOd(R1) args: 0, res: 0, upd: 0;
       c8jOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jOd() //  [R1]
         { info_tbl: [(c8jOd,
                       label: block_c8jOd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jOd: // global
           _s8j9j::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jOh; else goto c8jOi;
       c8jOh: // global
           I64[Sp + 8] = block_c8jOp_info;
           R1 = _s8j9j::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jOT; else goto c8jOr;
       u8jOT: // global
           call _c8jOp(R1) args: 0, res: 0, upd: 0;
       c8jOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jOi: // global
           I64[Sp] = block_c8jOE_info;
           _s8j9n::P64 = P64[R1 + 6];
           R1 = _s8j9j::P64;
           P64[Sp + 8] = _s8j9n::P64;
           if (R1 & 7 != 0) goto u8jOU; else goto c8jOG;
       u8jOU: // global
           call _c8jOE(R1) args: 0, res: 0, upd: 0;
       c8jOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jOp() //  [R1]
         { info_tbl: [(c8jOp,
                       label: block_c8jOp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jOp: // global
           if (R1 & 7 == 1) goto c8jOx; else goto c8jOB;
       c8jOx: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jOB: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jOE() //  [R1]
         { info_tbl: [(c8jOE,
                       label: block_c8jOE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jOE: // global
           if (R1 & 7 == 1) goto c8jOM; else goto c8jOQ;
       c8jOM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jOQ: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.851088449 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c==_closure" {
     GHC.IO.Exception.$fEqExitCode_$c==_closure:
         const GHC.IO.Exception.$fEqExitCode_$c==_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8jP7,
                       label: GHC.IO.Exception.$fEqExitCode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jP7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jP8; else goto c8jP9;
       c8jP8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jP9: // global
           I64[Sp - 16] = block_c8jP0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jPK; else goto c8jP1;
       u8jPK: // global
           call _c8jP0(R1) args: 0, res: 0, upd: 0;
       c8jP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jP0() //  [R1]
         { info_tbl: [(c8jP0,
                       label: block_c8jP0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jP0: // global
           _s8j9r::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jP4; else goto c8jP5;
       c8jP4: // global
           I64[Sp + 8] = block_c8jPc_info;
           R1 = _s8j9r::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jPI; else goto c8jPe;
       u8jPI: // global
           call _c8jPc(R1) args: 0, res: 0, upd: 0;
       c8jPe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jP5: // global
           I64[Sp] = block_c8jPr_info;
           _s8j9v::P64 = P64[R1 + 6];
           R1 = _s8j9r::P64;
           P64[Sp + 8] = _s8j9v::P64;
           if (R1 & 7 != 0) goto u8jPJ; else goto c8jPt;
       u8jPJ: // global
           call _c8jPr(R1) args: 0, res: 0, upd: 0;
       c8jPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jPc() //  [R1]
         { info_tbl: [(c8jPc,
                       label: block_c8jPc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jPc: // global
           if (R1 & 7 == 1) goto c8jPk; else goto u8jPH;
       c8jPk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8jPH: // global
           Sp = Sp + 8;
           call _c8jPz() args: 0, res: 0, upd: 0;
     }
 },
 _c8jPr() //  [R1]
         { info_tbl: [(c8jPr,
                       label: block_c8jPr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jPr: // global
           if (R1 & 7 == 1) goto u8jPG; else goto c8jPD;
       u8jPG: // global
           Sp = Sp + 16;
           call _c8jPz() args: 0, res: 0, upd: 0;
       c8jPD: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8jPz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jPz: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.853516038 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c/=_closure" {
     GHC.IO.Exception.$fEqExitCode_$c/=_closure:
         const GHC.IO.Exception.$fEqExitCode_$c/=_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8jPY,
                       label: GHC.IO.Exception.$fEqExitCode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jPZ; else goto c8jQ0;
       c8jPZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jQ0: // global
           I64[Sp - 16] = block_c8jPR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jQV; else goto c8jPS;
       u8jQV: // global
           call _c8jPR(R1) args: 0, res: 0, upd: 0;
       c8jPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jPR() //  [R1]
         { info_tbl: [(c8jPR,
                       label: block_c8jPR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jPR: // global
           _s8j9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jPV; else goto c8jPW;
       c8jPV: // global
           I64[Sp + 8] = block_c8jQ3_info;
           R1 = _s8j9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jQT; else goto c8jQ5;
       u8jQT: // global
           call _c8jQ3(R1) args: 0, res: 0, upd: 0;
       c8jQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jPW: // global
           I64[Sp] = block_c8jQi_info;
           _s8j9D::P64 = P64[R1 + 6];
           R1 = _s8j9z::P64;
           P64[Sp + 8] = _s8j9D::P64;
           if (R1 & 7 != 0) goto u8jQU; else goto c8jQk;
       u8jQU: // global
           call _c8jQi(R1) args: 0, res: 0, upd: 0;
       c8jQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jQ3() //  [R1]
         { info_tbl: [(c8jQ3,
                       label: block_c8jQ3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQ3: // global
           if (R1 & 7 == 1) goto u8jQR; else goto u8jQS;
       u8jQR: // global
           Sp = Sp + 8;
           call _c8jQL() args: 0, res: 0, upd: 0;
       u8jQS: // global
           Sp = Sp + 8;
           call _c8jQK() args: 0, res: 0, upd: 0;
     }
 },
 _c8jQi() //  [R1]
         { info_tbl: [(c8jQi,
                       label: block_c8jQi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQi: // global
           if (R1 & 7 == 1) goto u8jQO; else goto c8jQA;
       u8jQO: // global
           Sp = Sp + 16;
           call _c8jQK() args: 0, res: 0, upd: 0;
       c8jQA: // global
           I64[Sp] = block_c8jQt_info;
           _s8j9F::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9F::P64;
           if (R1 & 7 != 0) goto u8jQY; else goto c8jQu;
       u8jQY: // global
           call _c8jQt(R1) args: 0, res: 0, upd: 0;
       c8jQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jQt() //  [R1]
         { info_tbl: [(c8jQt,
                       label: block_c8jQt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQt: // global
           I64[Sp] = block_c8jQy_info;
           _s8j9H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9H::I64;
           if (R1 & 7 != 0) goto u8jR0; else goto c8jQC;
       u8jR0: // global
           call _c8jQy(R1) args: 0, res: 0, upd: 0;
       c8jQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jQy() //  [R1]
         { info_tbl: [(c8jQy,
                       label: block_c8jQy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQy: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8jQP; else goto u8jQQ;
       u8jQP: // global
           Sp = Sp + 16;
           call _c8jQL() args: 0, res: 0, upd: 0;
       u8jQQ: // global
           Sp = Sp + 16;
           call _c8jQK() args: 0, res: 0, upd: 0;
     }
 },
 _c8jQL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jQK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jQK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.85559402 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_closure" {
     GHC.IO.Exception.$fEqExitCode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqExitCode_$c==_closure+2;
         const GHC.IO.Exception.$fEqExitCode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.856916241 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8jRe,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jRe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jRf; else goto c8jRg;
       c8jRf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jRg: // global
           I64[Sp - 16] = block_c8jR7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jSb; else goto c8jR8;
       u8jSb: // global
           call _c8jR7(R1) args: 0, res: 0, upd: 0;
       c8jR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jR7() //  [R1]
         { info_tbl: [(c8jR7,
                       label: block_c8jR7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jR7: // global
           _s8j9L::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jRb; else goto c8jRc;
       c8jRb: // global
           I64[Sp + 8] = block_c8jRj_info;
           R1 = _s8j9L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jS9; else goto c8jRl;
       u8jS9: // global
           call _c8jRj(R1) args: 0, res: 0, upd: 0;
       c8jRl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jRc: // global
           I64[Sp] = block_c8jRy_info;
           _s8j9Q::P64 = P64[R1 + 6];
           R1 = _s8j9L::P64;
           P64[Sp + 8] = _s8j9Q::P64;
           if (R1 & 7 != 0) goto u8jSa; else goto c8jRA;
       u8jSa: // global
           call _c8jRy(R1) args: 0, res: 0, upd: 0;
       c8jRA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jRj() //  [R1]
         { info_tbl: [(c8jRj,
                       label: block_c8jRj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jRj: // global
           if (R1 & 7 == 1) goto u8jS7; else goto u8jS8;
       u8jS7: // global
           Sp = Sp + 8;
           call _c8jS0() args: 0, res: 0, upd: 0;
       u8jS8: // global
           Sp = Sp + 8;
           call _c8jS1() args: 0, res: 0, upd: 0;
     }
 },
 _c8jRy() //  [R1]
         { info_tbl: [(c8jRy,
                       label: block_c8jRy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jRy: // global
           if (R1 & 7 == 1) goto u8jS4; else goto c8jRQ;
       u8jS4: // global
           Sp = Sp + 16;
           call _c8jS0() args: 0, res: 0, upd: 0;
       c8jRQ: // global
           I64[Sp] = block_c8jRJ_info;
           _s8j9S::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9S::P64;
           if (R1 & 7 != 0) goto u8jSe; else goto c8jRK;
       u8jSe: // global
           call _c8jRJ(R1) args: 0, res: 0, upd: 0;
       c8jRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jRJ() //  [R1]
         { info_tbl: [(c8jRJ,
                       label: block_c8jRJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jRJ: // global
           I64[Sp] = block_c8jRO_info;
           _s8j9U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9U::I64;
           if (R1 & 7 != 0) goto u8jSg; else goto c8jRS;
       u8jSg: // global
           call _c8jRO(R1) args: 0, res: 0, upd: 0;
       c8jRS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jRO() //  [R1]
         { info_tbl: [(c8jRO,
                       label: block_c8jRO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jRO: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8jS6; else goto u8jS5;
       u8jS6: // global
           Sp = Sp + 16;
           call _c8jS0() args: 0, res: 0, upd: 0;
       u8jS5: // global
           Sp = Sp + 16;
           call _c8jS1() args: 0, res: 0, upd: 0;
     }
 },
 _c8jS0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jS0: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jS1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jS1: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.859692223 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmax_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmax_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmax_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8jSu,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jSu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jSv; else goto c8jSw;
       c8jSv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jSw: // global
           I64[Sp - 16] = block_c8jSn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jTa; else goto c8jSo;
       u8jTa: // global
           call _c8jSn(R1) args: 0, res: 0, upd: 0;
       c8jSo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jSn() //  [R1]
         { info_tbl: [(c8jSn,
                       label: block_c8jSn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jSn: // global
           _s8j9Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jSr; else goto c8jSs;
       c8jSr: // global
           R1 = _s8j9Y::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jSs: // global
           I64[Sp - 8] = block_c8jSC_info;
           _s8ja0::P64 = R1;
           _s8ja1::P64 = P64[R1 + 6];
           R1 = _s8j9Y::P64;
           P64[Sp] = _s8ja1::P64;
           P64[Sp + 8] = _s8ja0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jT9; else goto c8jSE;
       u8jT9: // global
           call _c8jSC(R1) args: 0, res: 0, upd: 0;
       c8jSE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jSC() //  [R1]
         { info_tbl: [(c8jSC,
                       label: block_c8jSC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jSC: // global
           if (R1 & 7 == 1) goto u8jT7; else goto c8jSU;
       u8jT7: // global
           Sp = Sp + 16;
           call _c8jT4() args: 0, res: 0, upd: 0;
       c8jSU: // global
           I64[Sp - 8] = block_c8jSN_info;
           _s8ja2::P64 = R1;
           _s8ja3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ja3::P64;
           P64[Sp + 8] = _s8ja2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jTb; else goto c8jSO;
       u8jTb: // global
           call _c8jSN(R1) args: 0, res: 0, upd: 0;
       c8jSO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jSN() //  [R1]
         { info_tbl: [(c8jSN,
                       label: block_c8jSN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jSN: // global
           I64[Sp] = block_c8jSS_info;
           _s8ja5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ja5::I64;
           if (R1 & 7 != 0) goto u8jTd; else goto c8jSW;
       u8jTd: // global
           call _c8jSS(R1) args: 0, res: 0, upd: 0;
       c8jSW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jSS() //  [R1]
         { info_tbl: [(c8jSS,
                       label: block_c8jSS_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jSS: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8jT8; else goto c8jT5;
       u8jT8: // global
           Sp = Sp + 24;
           call _c8jT4() args: 0, res: 0, upd: 0;
       c8jT5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jT4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jT4: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.862424236 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8jTq,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jTq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jTr; else goto c8jTs;
       c8jTr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jTs: // global
           I64[Sp - 16] = block_c8jTj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jUn; else goto c8jTk;
       u8jUn: // global
           call _c8jTj(R1) args: 0, res: 0, upd: 0;
       c8jTk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jTj() //  [R1]
         { info_tbl: [(c8jTj,
                       label: block_c8jTj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jTj: // global
           _s8jaa::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jTn; else goto c8jTo;
       c8jTn: // global
           I64[Sp + 8] = block_c8jTv_info;
           R1 = _s8jaa::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jUl; else goto c8jTx;
       u8jUl: // global
           call _c8jTv(R1) args: 0, res: 0, upd: 0;
       c8jTx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jTo: // global
           I64[Sp] = block_c8jTK_info;
           _s8jae::P64 = P64[R1 + 6];
           R1 = _s8jaa::P64;
           P64[Sp + 8] = _s8jae::P64;
           if (R1 & 7 != 0) goto u8jUm; else goto c8jTM;
       u8jUm: // global
           call _c8jTK(R1) args: 0, res: 0, upd: 0;
       c8jTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jTv() //  [R1]
         { info_tbl: [(c8jTv,
                       label: block_c8jTv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jTv: // global
           if (R1 & 7 == 1) goto u8jUj; else goto u8jUk;
       u8jUj: // global
           Sp = Sp + 8;
           call _c8jUc() args: 0, res: 0, upd: 0;
       u8jUk: // global
           Sp = Sp + 8;
           call _c8jUd() args: 0, res: 0, upd: 0;
     }
 },
 _c8jTK() //  [R1]
         { info_tbl: [(c8jTK,
                       label: block_c8jTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jTK: // global
           if (R1 & 7 == 1) goto u8jUg; else goto c8jU2;
       u8jUg: // global
           Sp = Sp + 16;
           call _c8jUc() args: 0, res: 0, upd: 0;
       c8jU2: // global
           I64[Sp] = block_c8jTV_info;
           _s8jag::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8jag::P64;
           if (R1 & 7 != 0) goto u8jUq; else goto c8jTW;
       u8jUq: // global
           call _c8jTV(R1) args: 0, res: 0, upd: 0;
       c8jTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jTV() //  [R1]
         { info_tbl: [(c8jTV,
                       label: block_c8jTV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jTV: // global
           I64[Sp] = block_c8jU0_info;
           _s8jai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jai::I64;
           if (R1 & 7 != 0) goto u8jUs; else goto c8jU4;
       u8jUs: // global
           call _c8jU0(R1) args: 0, res: 0, upd: 0;
       c8jU4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jU0() //  [R1]
         { info_tbl: [(c8jU0,
                       label: block_c8jU0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jU0: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8jUi; else goto u8jUh;
       u8jUi: // global
           Sp = Sp + 16;
           call _c8jUc() args: 0, res: 0, upd: 0;
       u8jUh: // global
           Sp = Sp + 16;
           call _c8jUd() args: 0, res: 0, upd: 0;
     }
 },
 _c8jUc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jUd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUd: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.864682121 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8jUz,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUz: // global
           _s8jan::P64 = R3;
           R3 = R2;
           R2 = _s8jan::P64;
           call GHC.IO.Exception.$fOrdExitCode_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.866040947 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmin_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmin_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmin_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8jUN,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8jUO; else goto c8jUP;
       c8jUO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jUP: // global
           I64[Sp - 16] = block_c8jUG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jVy; else goto c8jUH;
       u8jVy: // global
           call _c8jUG(R1) args: 0, res: 0, upd: 0;
       c8jUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jUG() //  [R1]
         { info_tbl: [(c8jUG,
                       label: block_c8jUG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUG: // global
           _s8jao::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jUK; else goto c8jUL;
       c8jUK: // global
           I64[Sp + 8] = block_c8jUS_info;
           R1 = _s8jao::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8jVw; else goto c8jUU;
       u8jVw: // global
           call _c8jUS() args: 0, res: 0, upd: 0;
       c8jUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jUL: // global
           I64[Sp - 8] = block_c8jV1_info;
           _s8jaq::P64 = R1;
           _s8jas::P64 = P64[R1 + 6];
           R1 = _s8jao::P64;
           P64[Sp] = _s8jas::P64;
           P64[Sp + 8] = _s8jaq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jVx; else goto c8jV3;
       u8jVx: // global
           call _c8jV1(R1) args: 0, res: 0, upd: 0;
       c8jV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jUS() //  []
         { info_tbl: [(c8jUS,
                       label: block_c8jUS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jUS: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jV1() //  [R1]
         { info_tbl: [(c8jV1,
                       label: block_c8jV1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jV1: // global
           if (R1 & 7 == 1) goto c8jV9; else goto c8jVj;
       c8jV9: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jVj: // global
           I64[Sp - 8] = block_c8jVc_info;
           _s8jat::P64 = R1;
           _s8jau::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8jau::P64;
           P64[Sp + 8] = _s8jat::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8jVz; else goto c8jVd;
       u8jVz: // global
           call _c8jVc(R1) args: 0, res: 0, upd: 0;
       c8jVd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jVc() //  [R1]
         { info_tbl: [(c8jVc,
                       label: block_c8jVc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jVc: // global
           I64[Sp] = block_c8jVh_info;
           _s8jaw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jaw::I64;
           if (R1 & 7 != 0) goto u8jVA; else goto c8jVl;
       u8jVA: // global
           call _c8jVh(R1) args: 0, res: 0, upd: 0;
       c8jVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jVh() //  [R1]
         { info_tbl: [(c8jVh,
                       label: block_c8jVh_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jVh: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c8jVt; else goto c8jVu;
       c8jVt: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8jVu: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.868127249 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_closure" {
     GHC.IO.Exception.$fOrdExitCode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqExitCode_closure+1;
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.869343698 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8jVM,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jVM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jVN; else goto c8jVO;
       c8jVN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jVO: // global
           I64[Sp - 16] = block_c8jVF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jWn; else goto c8jVG;
       u8jWn: // global
           call _c8jVF(R1) args: 0, res: 0, upd: 0;
       c8jVG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jVF() //  [R1]
         { info_tbl: [(c8jVF,
                       label: block_c8jVF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jVF: // global
           _s8jaB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jVJ; else goto c8jVK;
       c8jVJ: // global
           I64[Sp] = block_c8jVR_info;
           _s8jaD::P64 = P64[R1 + 7];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaD::P64;
           if (R1 & 7 != 0) goto u8jWl; else goto c8jVT;
       u8jWl: // global
           call _c8jVR(R1) args: 0, res: 0, upd: 0;
       c8jVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jVK: // global
           I64[Sp] = block_c8jW6_info;
           _s8jaH::P64 = P64[R1 + 6];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaH::P64;
           if (R1 & 7 != 0) goto u8jWm; else goto c8jW8;
       u8jWm: // global
           call _c8jW6(R1) args: 0, res: 0, upd: 0;
       c8jW8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jVR() //  [R1]
         { info_tbl: [(c8jVR,
                       label: block_c8jVR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jVR: // global
           if (R1 & 7 == 1) goto c8jVZ; else goto c8jW3;
       c8jVZ: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c8jW3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jW6() //  [R1]
         { info_tbl: [(c8jW6,
                       label: block_c8jW6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jW6: // global
           if (R1 & 7 == 1) goto c8jWe; else goto c8jWi;
       c8jWe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jWi: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.871475148 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdArrayException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8jWz,
                       label: GHC.IO.Exception.$fOrdArrayException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jWz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jWA; else goto c8jWB;
       c8jWA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jWB: // global
           I64[Sp - 16] = block_c8jWs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jXa; else goto c8jWt;
       u8jXa: // global
           call _c8jWs(R1) args: 0, res: 0, upd: 0;
       c8jWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jWs() //  [R1]
         { info_tbl: [(c8jWs,
                       label: block_c8jWs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jWs: // global
           _s8jaM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jWw; else goto c8jWx;
       c8jWw: // global
           I64[Sp] = block_c8jWE_info;
           _s8jaO::P64 = P64[R1 + 7];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaO::P64;
           if (R1 & 7 != 0) goto u8jX8; else goto c8jWG;
       u8jX8: // global
           call _c8jWE(R1) args: 0, res: 0, upd: 0;
       c8jWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jWx: // global
           I64[Sp] = block_c8jWT_info;
           _s8jaS::P64 = P64[R1 + 6];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaS::P64;
           if (R1 & 7 != 0) goto u8jX9; else goto c8jWV;
       u8jX9: // global
           call _c8jWT(R1) args: 0, res: 0, upd: 0;
       c8jWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jWE() //  [R1]
         { info_tbl: [(c8jWE,
                       label: block_c8jWE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jWE: // global
           if (R1 & 7 == 1) goto c8jWM; else goto c8jWQ;
       c8jWM: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8jWQ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jWT() //  [R1]
         { info_tbl: [(c8jWT,
                       label: block_c8jWT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jWT: // global
           if (R1 & 7 == 1) goto c8jX1; else goto c8jX5;
       c8jX1: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8jX5: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.873761954 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c==_closure" {
     GHC.IO.Exception.$fEqArrayException_$c==_closure:
         const GHC.IO.Exception.$fEqArrayException_$c==_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8jXm,
                       label: GHC.IO.Exception.$fEqArrayException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jXm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jXn; else goto c8jXo;
       c8jXn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jXo: // global
           I64[Sp - 16] = block_c8jXf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jXZ; else goto c8jXg;
       u8jXZ: // global
           call _c8jXf(R1) args: 0, res: 0, upd: 0;
       c8jXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jXf() //  [R1]
         { info_tbl: [(c8jXf,
                       label: block_c8jXf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jXf: // global
           _s8jaX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jXj; else goto c8jXk;
       c8jXj: // global
           I64[Sp] = block_c8jXr_info;
           _s8jaZ::P64 = P64[R1 + 7];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jaZ::P64;
           if (R1 & 7 != 0) goto u8jXX; else goto c8jXt;
       u8jXX: // global
           call _c8jXr(R1) args: 0, res: 0, upd: 0;
       c8jXt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jXk: // global
           I64[Sp] = block_c8jXG_info;
           _s8jb3::P64 = P64[R1 + 6];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jb3::P64;
           if (R1 & 7 != 0) goto u8jXY; else goto c8jXI;
       u8jXY: // global
           call _c8jXG(R1) args: 0, res: 0, upd: 0;
       c8jXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jXr() //  [R1]
         { info_tbl: [(c8jXr,
                       label: block_c8jXr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jXr: // global
           if (R1 & 7 == 1) goto c8jXz; else goto u8jXW;
       c8jXz: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8jXW: // global
           Sp = Sp + 16;
           call _c8jXO() args: 0, res: 0, upd: 0;
     }
 },
 _c8jXG() //  [R1]
         { info_tbl: [(c8jXG,
                       label: block_c8jXG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jXG: // global
           if (R1 & 7 == 1) goto u8jXV; else goto c8jXS;
       u8jXV: // global
           Sp = Sp + 16;
           call _c8jXO() args: 0, res: 0, upd: 0;
       c8jXS: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8jXO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jXO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.876239507 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c/=_closure" {
     GHC.IO.Exception.$fEqArrayException_$c/=_closure:
         const GHC.IO.Exception.$fEqArrayException_$c/=_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8jYd,
                       label: GHC.IO.Exception.$fEqArrayException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jYd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jYe; else goto c8jYf;
       c8jYe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jYf: // global
           I64[Sp - 16] = block_c8jY6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8jZi; else goto c8jY7;
       u8jZi: // global
           call _c8jY6(R1) args: 0, res: 0, upd: 0;
       c8jY7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jY6() //  [R1]
         { info_tbl: [(c8jY6,
                       label: block_c8jY6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jY6: // global
           _s8jb8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jYa; else goto c8jYb;
       c8jYa: // global
           I64[Sp] = block_c8jYi_info;
           _s8jba::P64 = P64[R1 + 7];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jba::P64;
           if (R1 & 7 != 0) goto u8jZg; else goto c8jYk;
       u8jZg: // global
           call _c8jYi(R1) args: 0, res: 0, upd: 0;
       c8jYk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jYb: // global
           I64[Sp] = block_c8jYI_info;
           _s8jbf::P64 = P64[R1 + 6];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jbf::P64;
           if (R1 & 7 != 0) goto u8jZh; else goto c8jYK;
       u8jZh: // global
           call _c8jYI(R1) args: 0, res: 0, upd: 0;
       c8jYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jYi() //  [R1]
         { info_tbl: [(c8jYi,
                       label: block_c8jYi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jYi: // global
           if (R1 & 7 == 1) goto c8jYr; else goto u8jZd;
       c8jYr: // global
           _s8jba::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jYo_info;
           R3 = P64[R1 + 7];
           R2 = _s8jba::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8jZd: // global
           Sp = Sp + 16;
           call _c8jZ1() args: 0, res: 0, upd: 0;
     }
 },
 _c8jYo() //  [R1]
         { info_tbl: [(c8jYo,
                       label: block_c8jYo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jYo: // global
           if (R1 & 7 == 1) goto u8jZe; else goto u8jZf;
       u8jZe: // global
           Sp = Sp + 8;
           call _c8jZ1() args: 0, res: 0, upd: 0;
       u8jZf: // global
           Sp = Sp + 8;
           call _c8jZ5() args: 0, res: 0, upd: 0;
     }
 },
 _c8jYI() //  [R1]
         { info_tbl: [(c8jYI,
                       label: block_c8jYI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jYI: // global
           if (R1 & 7 == 1) goto u8jZa; else goto c8jYV;
       u8jZa: // global
           Sp = Sp + 16;
           call _c8jZ1() args: 0, res: 0, upd: 0;
       c8jYV: // global
           _s8jbf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jYT_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbf::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8jYT() //  [R1]
         { info_tbl: [(c8jYT,
                       label: block_c8jYT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jYT: // global
           if (R1 & 7 == 1) goto u8jZb; else goto u8jZc;
       u8jZb: // global
           Sp = Sp + 8;
           call _c8jZ1() args: 0, res: 0, upd: 0;
       u8jZc: // global
           Sp = Sp + 8;
           call _c8jZ5() args: 0, res: 0, upd: 0;
     }
 },
 _c8jZ1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZ1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8jZ5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZ5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.880759379 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_closure" {
     GHC.IO.Exception.$fEqArrayException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqArrayException_$c==_closure+2;
         const GHC.IO.Exception.$fEqArrayException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.88222602 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8jZA,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8jZB; else goto c8jZC;
       c8jZB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8jZC: // global
           I64[Sp - 16] = block_c8jZt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k0F; else goto c8jZu;
       u8k0F: // global
           call _c8jZt(R1) args: 0, res: 0, upd: 0;
       c8jZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jZt() //  [R1]
         { info_tbl: [(c8jZt,
                       label: block_c8jZt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZt: // global
           _s8jbk::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8jZx; else goto c8jZy;
       c8jZx: // global
           I64[Sp] = block_c8jZF_info;
           _s8jbn::P64 = P64[R1 + 7];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbn::P64;
           if (R1 & 7 != 0) goto u8k0D; else goto c8jZH;
       u8k0D: // global
           call _c8jZF(R1) args: 0, res: 0, upd: 0;
       c8jZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8jZy: // global
           I64[Sp] = block_c8k05_info;
           _s8jbs::P64 = P64[R1 + 6];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbs::P64;
           if (R1 & 7 != 0) goto u8k0E; else goto c8k07;
       u8k0E: // global
           call _c8k05(R1) args: 0, res: 0, upd: 0;
       c8k07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8jZF() //  [R1]
         { info_tbl: [(c8jZF,
                       label: block_c8jZF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZF: // global
           if (R1 & 7 == 1) goto c8jZO; else goto u8k0A;
       c8jZO: // global
           _s8jbn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8jZL_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbn::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8k0A: // global
           Sp = Sp + 16;
           call _c8k0s() args: 0, res: 0, upd: 0;
     }
 },
 _c8jZL() //  [R1]
         { info_tbl: [(c8jZL,
                       label: block_c8jZL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jZL: // global
           if (R1 & 7 == 1) goto u8k0B; else goto u8k0C;
       u8k0B: // global
           Sp = Sp + 8;
           call _c8k0s() args: 0, res: 0, upd: 0;
       u8k0C: // global
           Sp = Sp + 8;
           call _c8k0o() args: 0, res: 0, upd: 0;
     }
 },
 _c8k05() //  [R1]
         { info_tbl: [(c8k05,
                       label: block_c8k05_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k05: // global
           if (R1 & 7 == 1) goto u8k0x; else goto c8k0i;
       u8k0x: // global
           Sp = Sp + 16;
           call _c8k0o() args: 0, res: 0, upd: 0;
       c8k0i: // global
           _s8jbs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8k0g_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8k0g() //  [R1]
         { info_tbl: [(c8k0g,
                       label: block_c8k0g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k0g: // global
           if (R1 & 7 == 1) goto u8k0y; else goto u8k0z;
       u8k0y: // global
           Sp = Sp + 8;
           call _c8k0s() args: 0, res: 0, upd: 0;
       u8k0z: // global
           Sp = Sp + 8;
           call _c8k0o() args: 0, res: 0, upd: 0;
     }
 },
 _c8k0s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k0s: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k0o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k0o: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.885097533 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmax_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmax_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8k0X,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k0X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8k0Y; else goto c8k0Z;
       c8k0Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8k0Z: // global
           I64[Sp - 16] = block_c8k0Q_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k21; else goto c8k0R;
       u8k21: // global
           call _c8k0Q(R1) args: 0, res: 0, upd: 0;
       c8k0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k0Q() //  [R1]
         { info_tbl: [(c8k0Q,
                       label: block_c8k0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k0Q: // global
           _s8jbx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8k0U; else goto c8k0V;
       c8k0U: // global
           I64[Sp - 8] = block_c8k12_info;
           _s8jbz::P64 = R1;
           _s8jbA::P64 = P64[R1 + 7];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbA::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k1Z; else goto c8k14;
       u8k1Z: // global
           call _c8k12(R1) args: 0, res: 0, upd: 0;
       c8k14: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k0V: // global
           I64[Sp - 8] = block_c8k1s_info;
           _s8jbz::P64 = R1;
           _s8jbF::P64 = P64[R1 + 6];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbF::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k20; else goto c8k1u;
       u8k20: // global
           call _c8k1s(R1) args: 0, res: 0, upd: 0;
       c8k1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k12() //  [R1]
         { info_tbl: [(c8k12,
                       label: block_c8k12_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k12: // global
           if (R1 & 7 == 1) goto c8k1b; else goto u8k1W;
       c8k1b: // global
           I64[Sp] = block_c8k18_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8k1W: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8k1p() args: 0, res: 0, upd: 0;
     }
 },
 _c8k18() //  [R1]
         { info_tbl: [(c8k18,
                       label: block_c8k18_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k18: // global
           if (R1 & 7 == 1) goto u8k1X; else goto u8k1Y;
       u8k1X: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8k1p() args: 0, res: 0, upd: 0;
       u8k1Y: // global
           Sp = Sp + 16;
           call _c8k1L() args: 0, res: 0, upd: 0;
     }
 },
 _c8k1p() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k1p: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k1s() //  [R1]
         { info_tbl: [(c8k1s,
                       label: block_c8k1s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k1s: // global
           if (R1 & 7 == 1) goto u8k1U; else goto c8k1F;
       u8k1U: // global
           Sp = Sp + 16;
           call _c8k1L() args: 0, res: 0, upd: 0;
       c8k1F: // global
           I64[Sp] = block_c8k1D_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8k1D() //  [R1]
         { info_tbl: [(c8k1D,
                       label: block_c8k1D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k1D: // global
           if (R1 & 7 == 1) goto c8k1P; else goto u8k1V;
       c8k1P: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8k1V: // global
           Sp = Sp + 16;
           call _c8k1L() args: 0, res: 0, upd: 0;
     }
 },
 _c8k1L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k1L: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.888005462 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8k2i,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8k2j; else goto c8k2k;
       c8k2j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8k2k: // global
           I64[Sp - 16] = block_c8k2b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k3n; else goto c8k2c;
       u8k3n: // global
           call _c8k2b(R1) args: 0, res: 0, upd: 0;
       c8k2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k2b() //  [R1]
         { info_tbl: [(c8k2b,
                       label: block_c8k2b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2b: // global
           _s8jbL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8k2f; else goto c8k2g;
       c8k2f: // global
           I64[Sp] = block_c8k2n_info;
           _s8jbN::P64 = P64[R1 + 7];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbN::P64;
           if (R1 & 7 != 0) goto u8k3l; else goto c8k2p;
       u8k3l: // global
           call _c8k2n(R1) args: 0, res: 0, upd: 0;
       c8k2p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k2g: // global
           I64[Sp] = block_c8k2N_info;
           _s8jbS::P64 = P64[R1 + 6];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbS::P64;
           if (R1 & 7 != 0) goto u8k3m; else goto c8k2P;
       u8k3m: // global
           call _c8k2N(R1) args: 0, res: 0, upd: 0;
       c8k2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k2n() //  [R1]
         { info_tbl: [(c8k2n,
                       label: block_c8k2n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2n: // global
           if (R1 & 7 == 1) goto c8k2w; else goto u8k3i;
       c8k2w: // global
           _s8jbN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8k2t_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbN::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8k3i: // global
           Sp = Sp + 16;
           call _c8k3a() args: 0, res: 0, upd: 0;
     }
 },
 _c8k2t() //  [R1]
         { info_tbl: [(c8k2t,
                       label: block_c8k2t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2t: // global
           if (R1 & 7 == 1) goto u8k3j; else goto u8k3k;
       u8k3j: // global
           Sp = Sp + 8;
           call _c8k3a() args: 0, res: 0, upd: 0;
       u8k3k: // global
           Sp = Sp + 8;
           call _c8k36() args: 0, res: 0, upd: 0;
     }
 },
 _c8k2N() //  [R1]
         { info_tbl: [(c8k2N,
                       label: block_c8k2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2N: // global
           if (R1 & 7 == 1) goto u8k3f; else goto c8k30;
       u8k3f: // global
           Sp = Sp + 16;
           call _c8k36() args: 0, res: 0, upd: 0;
       c8k30: // global
           _s8jbS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8k2Y_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbS::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8k2Y() //  [R1]
         { info_tbl: [(c8k2Y,
                       label: block_c8k2Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k2Y: // global
           if (R1 & 7 == 1) goto u8k3g; else goto u8k3h;
       u8k3g: // global
           Sp = Sp + 8;
           call _c8k3a() args: 0, res: 0, upd: 0;
       u8k3h: // global
           Sp = Sp + 8;
           call _c8k36() args: 0, res: 0, upd: 0;
     }
 },
 _c8k3a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3a: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k36() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k36: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.890991221 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8k3y,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3y: // global
           _s8jbY::P64 = R3;
           R3 = R2;
           R2 = _s8jbY::P64;
           call GHC.IO.Exception.$fOrdArrayException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.892557096 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmin_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmin_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8k3M,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8k3N; else goto c8k3O;
       c8k3N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8k3O: // global
           I64[Sp - 16] = block_c8k3F_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k4Q; else goto c8k3G;
       u8k4Q: // global
           call _c8k3F(R1) args: 0, res: 0, upd: 0;
       c8k3G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k3F() //  [R1]
         { info_tbl: [(c8k3F,
                       label: block_c8k3F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3F: // global
           _s8jbZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8k3J; else goto c8k3K;
       c8k3J: // global
           I64[Sp - 8] = block_c8k3R_info;
           _s8jc1::P64 = R1;
           _s8jc2::P64 = P64[R1 + 7];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc2::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k4O; else goto c8k3T;
       u8k4O: // global
           call _c8k3R(R1) args: 0, res: 0, upd: 0;
       c8k3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k3K: // global
           I64[Sp - 8] = block_c8k4h_info;
           _s8jc1::P64 = R1;
           _s8jc7::P64 = P64[R1 + 6];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc7::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k4P; else goto c8k4j;
       u8k4P: // global
           call _c8k4h(R1) args: 0, res: 0, upd: 0;
       c8k4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k3R() //  [R1]
         { info_tbl: [(c8k3R,
                       label: block_c8k3R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3R: // global
           if (R1 & 7 == 1) goto c8k40; else goto u8k4M;
       c8k40: // global
           I64[Sp] = block_c8k3X_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8k4M: // global
           Sp = Sp + 16;
           call _c8k4E() args: 0, res: 0, upd: 0;
     }
 },
 _c8k3X() //  [R1]
         { info_tbl: [(c8k3X,
                       label: block_c8k3X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k3X: // global
           if (R1 & 7 == 1) goto u8k4N; else goto c8k46;
       u8k4N: // global
           Sp = Sp + 16;
           call _c8k4E() args: 0, res: 0, upd: 0;
       c8k46: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k4h() //  [R1]
         { info_tbl: [(c8k4h,
                       label: block_c8k4h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k4h: // global
           if (R1 & 7 == 1) goto u8k4J; else goto c8k4u;
       u8k4J: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8k4A() args: 0, res: 0, upd: 0;
       c8k4u: // global
           I64[Sp] = block_c8k4s_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8k4s() //  [R1]
         { info_tbl: [(c8k4s,
                       label: block_c8k4s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k4s: // global
           if (R1 & 7 == 1) goto u8k4K; else goto u8k4L;
       u8k4K: // global
           Sp = Sp + 16;
           call _c8k4E() args: 0, res: 0, upd: 0;
       u8k4L: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8k4A() args: 0, res: 0, upd: 0;
     }
 },
 _c8k4E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k4E: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k4A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k4A: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.894774683 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_closure" {
     GHC.IO.Exception.$fOrdArrayException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqArrayException_closure+1;
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.896208085 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c==_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c==_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c==_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8k59,
                       label: GHC.IO.Exception.$fEqAsyncException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k59: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8k5a; else goto c8k5b;
       c8k5a: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8k5b: // global
           I64[Sp - 16] = block_c8k50_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k6s; else goto c8k51;
       u8k6s: // global
           call _c8k50(R1) args: 0, res: 0, upd: 0;
       c8k51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k50() //  [R1]
         { info_tbl: [(c8k50,
                       label: block_c8k50_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k50: // global
           _s8jcd::P64 = P64[Sp + 8];
           _c8k58::P64 = R1 & 7;
           if (_c8k58::P64 < 3) goto u8k6e; else goto u8k6f;
       u8k6e: // global
           if (_c8k58::P64 < 2) goto c8k54; else goto c8k55;
       c8k54: // global
           I64[Sp + 8] = block_c8k5e_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k6o; else goto c8k5g;
       u8k6o: // global
           call _c8k5e(R1) args: 0, res: 0, upd: 0;
       c8k5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k55: // global
           I64[Sp + 8] = block_c8k5t_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k6p; else goto c8k5v;
       u8k6p: // global
           call _c8k5t(R1) args: 0, res: 0, upd: 0;
       c8k5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8k6f: // global
           if (_c8k58::P64 < 4) goto c8k56; else goto c8k57;
       c8k56: // global
           I64[Sp + 8] = block_c8k5I_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k6q; else goto c8k5K;
       u8k6q: // global
           call _c8k5I(R1) args: 0, res: 0, upd: 0;
       c8k5K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k57: // global
           I64[Sp + 8] = block_c8k5X_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k6r; else goto c8k5Z;
       u8k6r: // global
           call _c8k5X(R1) args: 0, res: 0, upd: 0;
       c8k5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k5e() //  [R1]
         { info_tbl: [(c8k5e,
                       label: block_c8k5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k5e: // global
           if (R1 & 7 == 1) goto u8k6g; else goto u8k6h;
       u8k6g: // global
           Sp = Sp + 8;
           call _c8k69() args: 0, res: 0, upd: 0;
       u8k6h: // global
           Sp = Sp + 8;
           call _c8k65() args: 0, res: 0, upd: 0;
     }
 },
 _c8k5t() //  [R1]
         { info_tbl: [(c8k5t,
                       label: block_c8k5t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k5t: // global
           if (R1 & 7 == 2) goto u8k6i; else goto u8k6j;
       u8k6i: // global
           Sp = Sp + 8;
           call _c8k69() args: 0, res: 0, upd: 0;
       u8k6j: // global
           Sp = Sp + 8;
           call _c8k65() args: 0, res: 0, upd: 0;
     }
 },
 _c8k5I() //  [R1]
         { info_tbl: [(c8k5I,
                       label: block_c8k5I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k5I: // global
           if (R1 & 7 == 3) goto u8k6k; else goto u8k6l;
       u8k6k: // global
           Sp = Sp + 8;
           call _c8k69() args: 0, res: 0, upd: 0;
       u8k6l: // global
           Sp = Sp + 8;
           call _c8k65() args: 0, res: 0, upd: 0;
     }
 },
 _c8k5X() //  [R1]
         { info_tbl: [(c8k5X,
                       label: block_c8k5X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k5X: // global
           if (R1 & 7 == 4) goto u8k6m; else goto u8k6n;
       u8k6m: // global
           Sp = Sp + 8;
           call _c8k69() args: 0, res: 0, upd: 0;
       u8k6n: // global
           Sp = Sp + 8;
           call _c8k65() args: 0, res: 0, upd: 0;
     }
 },
 _c8k69() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k69: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k65() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k65: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.899140008 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c/=_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c/=_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c/=_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8k6O,
                       label: GHC.IO.Exception.$fEqAsyncException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8k6P; else goto c8k6Q;
       c8k6P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8k6Q: // global
           I64[Sp - 16] = block_c8k6F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8k87; else goto c8k6G;
       u8k87: // global
           call _c8k6F(R1) args: 0, res: 0, upd: 0;
       c8k6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k6F() //  [R1]
         { info_tbl: [(c8k6F,
                       label: block_c8k6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k6F: // global
           _s8jck::P64 = P64[Sp + 8];
           _c8k6N::P64 = R1 & 7;
           if (_c8k6N::P64 < 3) goto u8k7T; else goto u8k7U;
       u8k7T: // global
           if (_c8k6N::P64 < 2) goto c8k6J; else goto c8k6K;
       c8k6J: // global
           I64[Sp + 8] = block_c8k6T_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k83; else goto c8k6V;
       u8k83: // global
           call _c8k6T(R1) args: 0, res: 0, upd: 0;
       c8k6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k6K: // global
           I64[Sp + 8] = block_c8k78_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k84; else goto c8k7a;
       u8k84: // global
           call _c8k78(R1) args: 0, res: 0, upd: 0;
       c8k7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8k7U: // global
           if (_c8k6N::P64 < 4) goto c8k6L; else goto c8k6M;
       c8k6L: // global
           I64[Sp + 8] = block_c8k7n_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k85; else goto c8k7p;
       u8k85: // global
           call _c8k7n(R1) args: 0, res: 0, upd: 0;
       c8k7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8k6M: // global
           I64[Sp + 8] = block_c8k7C_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8k86; else goto c8k7E;
       u8k86: // global
           call _c8k7C(R1) args: 0, res: 0, upd: 0;
       c8k7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k6T() //  [R1]
         { info_tbl: [(c8k6T,
                       label: block_c8k6T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k6T: // global
           if (R1 & 7 == 1) goto u8k7V; else goto u8k7W;
       u8k7V: // global
           Sp = Sp + 8;
           call _c8k7O() args: 0, res: 0, upd: 0;
       u8k7W: // global
           Sp = Sp + 8;
           call _c8k7K() args: 0, res: 0, upd: 0;
     }
 },
 _c8k78() //  [R1]
         { info_tbl: [(c8k78,
                       label: block_c8k78_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k78: // global
           if (R1 & 7 == 2) goto u8k7X; else goto u8k7Y;
       u8k7X: // global
           Sp = Sp + 8;
           call _c8k7O() args: 0, res: 0, upd: 0;
       u8k7Y: // global
           Sp = Sp + 8;
           call _c8k7K() args: 0, res: 0, upd: 0;
     }
 },
 _c8k7n() //  [R1]
         { info_tbl: [(c8k7n,
                       label: block_c8k7n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k7n: // global
           if (R1 & 7 == 3) goto u8k7Z; else goto u8k80;
       u8k7Z: // global
           Sp = Sp + 8;
           call _c8k7O() args: 0, res: 0, upd: 0;
       u8k80: // global
           Sp = Sp + 8;
           call _c8k7K() args: 0, res: 0, upd: 0;
     }
 },
 _c8k7C() //  [R1]
         { info_tbl: [(c8k7C,
                       label: block_c8k7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k7C: // global
           if (R1 & 7 == 4) goto u8k81; else goto u8k82;
       u8k81: // global
           Sp = Sp + 8;
           call _c8k7O() args: 0, res: 0, upd: 0;
       u8k82: // global
           Sp = Sp + 8;
           call _c8k7K() args: 0, res: 0, upd: 0;
     }
 },
 _c8k7O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k7O: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8k7K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k7K: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.901389282 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_closure" {
     GHC.IO.Exception.$fEqAsyncException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqAsyncException_$c==_closure+2;
         const GHC.IO.Exception.$fEqAsyncException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.902167882 UTC

[section ""data" . GHC.IO.Exception.ioe_filename_closure" {
     GHC.IO.Exception.ioe_filename_closure:
         const GHC.IO.Exception.ioe_filename_info;
 },
 GHC.IO.Exception.ioe_filename_entry() //  [R2]
         { info_tbl: [(c8k8n,
                       label: GHC.IO.Exception.ioe_filename_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k8o; else goto c8k8p;
       c8k8o: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_filename_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k8p: // global
           I64[Sp - 8] = block_c8k8k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k8t; else goto c8k8l;
       u8k8t: // global
           call _c8k8k(R1) args: 0, res: 0, upd: 0;
       c8k8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k8k() //  [R1]
         { info_tbl: [(c8k8k,
                       label: block_c8k8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8k: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.903303003 UTC

[section ""data" . GHC.IO.Exception.ioe_errno_closure" {
     GHC.IO.Exception.ioe_errno_closure:
         const GHC.IO.Exception.ioe_errno_info;
 },
 GHC.IO.Exception.ioe_errno_entry() //  [R2]
         { info_tbl: [(c8k8B,
                       label: GHC.IO.Exception.ioe_errno_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k8C; else goto c8k8D;
       c8k8C: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_errno_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k8D: // global
           I64[Sp - 8] = block_c8k8y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k8H; else goto c8k8z;
       u8k8H: // global
           call _c8k8y(R1) args: 0, res: 0, upd: 0;
       c8k8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k8y() //  [R1]
         { info_tbl: [(c8k8y,
                       label: block_c8k8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8y: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.904493419 UTC

[section ""data" . GHC.IO.Exception.ioe_description_closure" {
     GHC.IO.Exception.ioe_description_closure:
         const GHC.IO.Exception.ioe_description_info;
 },
 GHC.IO.Exception.ioe_description_entry() //  [R2]
         { info_tbl: [(c8k8P,
                       label: GHC.IO.Exception.ioe_description_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k8Q; else goto c8k8R;
       c8k8Q: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_description_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k8R: // global
           I64[Sp - 8] = block_c8k8M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k8V; else goto c8k8N;
       u8k8V: // global
           call _c8k8M(R1) args: 0, res: 0, upd: 0;
       c8k8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k8M() //  [R1]
         { info_tbl: [(c8k8M,
                       label: block_c8k8M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k8M: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.905668018 UTC

[section ""data" . GHC.IO.Exception.ioe_location_closure" {
     GHC.IO.Exception.ioe_location_closure:
         const GHC.IO.Exception.ioe_location_info;
 },
 GHC.IO.Exception.ioe_location_entry() //  [R2]
         { info_tbl: [(c8k93,
                       label: GHC.IO.Exception.ioe_location_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k93: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k94; else goto c8k95;
       c8k94: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_location_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k95: // global
           I64[Sp - 8] = block_c8k90_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k99; else goto c8k91;
       u8k99: // global
           call _c8k90(R1) args: 0, res: 0, upd: 0;
       c8k91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k90() //  [R1]
         { info_tbl: [(c8k90,
                       label: block_c8k90_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k90: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.906789701 UTC

[section ""data" . GHC.IO.Exception.ioe_type_closure" {
     GHC.IO.Exception.ioe_type_closure:
         const GHC.IO.Exception.ioe_type_info;
 },
 GHC.IO.Exception.ioe_type_entry() //  [R2]
         { info_tbl: [(c8k9h,
                       label: GHC.IO.Exception.ioe_type_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k9i; else goto c8k9j;
       c8k9i: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_type_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k9j: // global
           I64[Sp - 8] = block_c8k9e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k9n; else goto c8k9f;
       u8k9n: // global
           call _c8k9e(R1) args: 0, res: 0, upd: 0;
       c8k9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k9e() //  [R1]
         { info_tbl: [(c8k9e,
                       label: block_c8k9e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9e: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.907960821 UTC

[section ""data" . GHC.IO.Exception.ioe_handle_closure" {
     GHC.IO.Exception.ioe_handle_closure:
         const GHC.IO.Exception.ioe_handle_info;
 },
 GHC.IO.Exception.ioe_handle_entry() //  [R2]
         { info_tbl: [(c8k9v,
                       label: GHC.IO.Exception.ioe_handle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8k9w; else goto c8k9x;
       c8k9w: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_handle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k9x: // global
           I64[Sp - 8] = block_c8k9s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8k9B; else goto c8k9t;
       u8k9B: // global
           call _c8k9s(R1) args: 0, res: 0, upd: 0;
       c8k9t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k9s() //  [R1]
         { info_tbl: [(c8k9s,
                       label: block_c8k9s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9s: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.909054837 UTC

[section ""data" . GHC.IO.Exception.userError_closure" {
     GHC.IO.Exception.userError_closure:
         const GHC.IO.Exception.userError_info;
 },
 GHC.IO.Exception.userError_entry() //  [R2]
         { info_tbl: [(c8k9H,
                       label: GHC.IO.Exception.userError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9H: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8k9L; else goto c8k9K;
       c8k9L: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.IO.Exception.userError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8k9K: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.909942379 UTC

[section ""cstring" . GHC.IO.Exception.unsupportedOperation2_bytes" {
     GHC.IO.Exception.unsupportedOperation2_bytes:
         I8[] [79,112,101,114,97,116,105,111,110,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.910678739 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation1_closure" {
     GHC.IO.Exception.unsupportedOperation1_closure:
         const GHC.IO.Exception.unsupportedOperation1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.unsupportedOperation1_entry() //  [R1]
         { info_tbl: [(c8k9S,
                       label: GHC.IO.Exception.unsupportedOperation1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8k9T; else goto c8k9U;
       c8k9T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8k9U: // global
           (_c8k9P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8k9P::I64 == 0) goto c8k9R; else goto c8k9Q;
       c8k9R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8k9Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8k9P::I64;
           R2 = GHC.IO.Exception.unsupportedOperation2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.91156367 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation_closure" {
     GHC.IO.Exception.unsupportedOperation_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Exception.unsupportedOperation1_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.912171577 UTC

[section ""data" . GHC.IO.Exception.untangle1_closure" {
     GHC.IO.Exception.untangle1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.913021937 UTC

[section ""data" . GHC.IO.Exception.untangle4_closure" {
     GHC.IO.Exception.untangle4_closure:
         const GHC.IO.Exception.untangle4_info;
 },
 GHC.IO.Exception.untangle4_entry() //  [R2]
         { info_tbl: [(c8ka2,
                       label: GHC.IO.Exception.untangle4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ka2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ka3; else goto c8ka4;
       c8ka3: // global
           R2 = R2;
           R1 = GHC.IO.Exception.untangle4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ka4: // global
           I64[Sp - 8] = block_c8k9Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kac; else goto c8ka0;
       u8kac: // global
           call _c8k9Z(R1) args: 0, res: 0, upd: 0;
       c8ka0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8k9Z() //  [R1]
         { info_tbl: [(c8k9Z,
                       label: block_c8k9Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k9Z: // global
           if (I64[R1 + 7] == 124) goto c8kab; else goto c8kaa;
       c8kab: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kaa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.914113712 UTC

[section ""cstring" . GHC.IO.Exception.untangle3_bytes" {
     GHC.IO.Exception.untangle3_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.914809825 UTC

[section ""data" . GHC.IO.Exception.untangle2_closure" {
     GHC.IO.Exception.untangle2_closure:
         const GHC.IO.Exception.untangle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.untangle2_entry() //  [R1]
         { info_tbl: [(c8kaj,
                       label: GHC.IO.Exception.untangle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kaj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kak; else goto c8kal;
       c8kak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kal: // global
           (_c8kag::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kag::I64 == 0) goto c8kai; else goto c8kah;
       c8kai: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kah: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kag::I64;
           R2 = GHC.IO.Exception.untangle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.916928649 UTC

[section ""data" . GHC.IO.Exception.untangle_closure" {
     GHC.IO.Exception.untangle_closure:
         const GHC.IO.Exception.untangle_info;
         const 0;
 },
 sat_s8jdq_entry() //  [R1]
         { info_tbl: [(c8kb2,
                       label: sat_s8jdq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kb2: // global
           R3 = GHC.IO.Exception.untangle2_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jdr_entry() //  [R1]
         { info_tbl: [(c8kb5,
                       label: sat_s8jdr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kb5: // global
           _s8jdr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8kb6; else goto c8kb7;
       c8kb7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kb9; else goto c8kb8;
       c8kb9: // global
           HpAlloc = 24;
           goto c8kb6;
       c8kb6: // global
           R1 = _s8jdr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kb8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jdr::P64;
           _s8jdi::P64 = P64[_s8jdr::P64 + 16];
           _s8jdp::P64 = P64[_s8jdr::P64 + 24];
           I64[Hp - 16] = sat_s8jdq_info;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 16;
           R2 = _s8jdi::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jds_entry() //  [R1]
         { info_tbl: [(c8kba,
                       label: sat_s8jds_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kba: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8kbe; else goto c8kbd;
       c8kbe: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kbd: // global
           _s8jdi::P64 = P64[R1 + 16];
           _s8jdp::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8jdr_info;
           P64[Hp - 8] = _s8jdi::P64;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.untangle_entry() //  [R2, R3]
         { info_tbl: [(c8kbf,
                       label: GHC.IO.Exception.untangle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kbf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8kbg; else goto c8kbh;
       c8kbg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.untangle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kbh: // global
           I64[Sp - 16] = block_c8kaq_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.CString.unpackCStringUtf8#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kaq() //  [R1]
         { info_tbl: [(c8kaq,
                       label: block_c8kaq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kaq: // global
           I64[Sp] = block_c8kau_info;
           R3 = R1;
           R2 = GHC.IO.Exception.untangle4_closure+1;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kau() //  [R1, R2]
         { info_tbl: [(c8kau,
                       label: block_c8kau_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kau: // global
           I64[Sp - 8] = block_c8kay_info;
           _s8jdl::P64 = R1;
           R1 = R2;
           P64[Sp] = _s8jdl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kbE; else goto c8kaz;
       u8kbE: // global
           call _c8kay(R1) args: 0, res: 0, upd: 0;
       c8kaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kay() //  [R1]
         { info_tbl: [(c8kay,
                       label: block_c8kay_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kay: // global
           if (R1 & 7 == 1) goto c8kbq; else goto c8kbs;
       c8kbq: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp] = GHC.Types.[]_closure+1;
           call _c8kaO() args: 0, res: 0, upd: 0;
       c8kbs: // global
           I64[Sp - 8] = block_c8kaE_info;
           _s8jdv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jdv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kbF; else goto c8kaF;
       u8kbF: // global
           call _c8kaE(R1) args: 0, res: 0, upd: 0;
       c8kaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kaE() //  [R1]
         { info_tbl: [(c8kaE,
                       label: block_c8kaE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kaE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kbv; else goto c8kbu;
       c8kbv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kbu: // global
           _s8jdl::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 124) goto c8kby; else goto c8kbx;
       c8kby: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.IO.Exception.untangle1_closure+1;
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 16] = _s8jdl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           goto u8kbI;
       c8kbx: // global
           Hp = Hp - 24;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           P64[Sp + 16] = _s8jdl::P64;
           Sp = Sp + 8;
           goto u8kbI;
       u8kbI: // global
           call _c8kaO() args: 0, res: 0, upd: 0;
     }
 },
 _c8kaO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kaO: // global
           Hp = Hp + 32;
           _s8jdo::P64 = P64[Sp + 8];
           _s8jdp::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto c8kbm; else goto c8kbl;
       c8kbm: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c8kaN_info;
           R2 = _s8jdp::P64;
           R1 = _s8jdo::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8kbl: // global
           I64[Hp - 24] = sat_s8jds_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = _s8jdo::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8kaN() //  [R1, R2]
         { info_tbl: [(c8kaN,
                       label: block_c8kaN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kaN: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c8kaO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.920961243 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8kbX,
                       label: GHC.IO.Exception.$fOrdAsyncException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kbX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kbY; else goto c8kbZ;
       c8kbY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kbZ: // global
           I64[Sp - 16] = block_c8kbO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kdI; else goto c8kbP;
       u8kdI: // global
           call _c8kbO(R1) args: 0, res: 0, upd: 0;
       c8kbP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kbO() //  [R1]
         { info_tbl: [(c8kbO,
                       label: block_c8kbO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kbO: // global
           _s8jdB::P64 = P64[Sp + 8];
           _c8kbW::P64 = R1 & 7;
           if (_c8kbW::P64 < 3) goto u8kdm; else goto u8kdn;
       u8kdm: // global
           if (_c8kbW::P64 < 2) goto c8kbS; else goto c8kbT;
       c8kbS: // global
           I64[Sp + 8] = block_c8kc2_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kdE; else goto c8kc4;
       u8kdE: // global
           call _c8kc2(R1) args: 0, res: 0, upd: 0;
       c8kc4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kbT: // global
           I64[Sp + 8] = block_c8kcp_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kdF; else goto c8kcr;
       u8kdF: // global
           call _c8kcp(R1) args: 0, res: 0, upd: 0;
       c8kcr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8kdn: // global
           if (_c8kbW::P64 < 4) goto c8kbU; else goto c8kbV;
       c8kbU: // global
           I64[Sp + 8] = block_c8kcM_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kdG; else goto c8kcO;
       u8kdG: // global
           call _c8kcM(R1) args: 0, res: 0, upd: 0;
       c8kcO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kbV: // global
           I64[Sp + 8] = block_c8kd5_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kdH; else goto c8kd7;
       u8kdH: // global
           call _c8kd5(R1) args: 0, res: 0, upd: 0;
       c8kd7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kc2() //  [R1]
         { info_tbl: [(c8kc2,
                       label: block_c8kc2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kc2: // global
           _c8kdl::P64 = R1 & 7;
           if (_c8kdl::P64 < 2) goto u8kds; else goto u8kdo;
       u8kds: // global
           Sp = Sp + 8;
           call _c8kdh() args: 0, res: 0, upd: 0;
       u8kdo: // global
           if (_c8kdl::P64 != 3) goto u8kdu; else goto u8kdu;
       u8kdu: // global
           Sp = Sp + 8;
           call _c8kd2() args: 0, res: 0, upd: 0;
     }
 },
 _c8kcp() //  [R1]
         { info_tbl: [(c8kcp,
                       label: block_c8kcp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kcp: // global
           _c8kdk::P64 = R1 & 7;
           if (_c8kdk::P64 < 3) goto u8kdp; else goto u8kdq;
       u8kdp: // global
           if (_c8kdk::P64 < 2) goto u8kdw; else goto u8kdv;
       u8kdw: // global
           Sp = Sp + 8;
           call _c8kdd() args: 0, res: 0, upd: 0;
       u8kdv: // global
           Sp = Sp + 8;
           call _c8kdh() args: 0, res: 0, upd: 0;
       u8kdq: // global
           if (_c8kdk::P64 < 4) goto u8kdy; else goto u8kdy;
       u8kdy: // global
           Sp = Sp + 8;
           call _c8kd2() args: 0, res: 0, upd: 0;
     }
 },
 _c8kcM() //  [R1]
         { info_tbl: [(c8kcM,
                       label: block_c8kcM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kcM: // global
           _c8kdj::P64 = R1 & 7;
           if (_c8kdj::P64 != 3) goto u8kdr; else goto u8kdz;
       u8kdr: // global
           if (_c8kdj::P64 != 4) goto u8kdB; else goto u8kdA;
       u8kdB: // global
           Sp = Sp + 8;
           call _c8kdd() args: 0, res: 0, upd: 0;
       u8kdA: // global
           Sp = Sp + 8;
           call _c8kd2() args: 0, res: 0, upd: 0;
       u8kdz: // global
           Sp = Sp + 8;
           call _c8kdh() args: 0, res: 0, upd: 0;
     }
 },
 _c8kd2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kd2: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kd5() //  [R1]
         { info_tbl: [(c8kd5,
                       label: block_c8kd5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kd5: // global
           if (R1 & 7 == 4) goto u8kdC; else goto u8kdD;
       u8kdC: // global
           Sp = Sp + 8;
           call _c8kdh() args: 0, res: 0, upd: 0;
       u8kdD: // global
           Sp = Sp + 8;
           call _c8kdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8kdh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kdh: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kdd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kdd: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.924298563 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8ke6,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ke6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ke7; else goto c8ke8;
       c8ke7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ke8: // global
           I64[Sp - 16] = block_c8kdX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kfw; else goto c8kdY;
       u8kfw: // global
           call _c8kdX(R1) args: 0, res: 0, upd: 0;
       c8kdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kdX() //  [R1]
         { info_tbl: [(c8kdX,
                       label: block_c8kdX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kdX: // global
           _s8jdI::P64 = P64[Sp + 8];
           _c8ke5::P64 = R1 & 7;
           if (_c8ke5::P64 < 3) goto u8kfg; else goto u8kfh;
       u8kfg: // global
           if (_c8ke5::P64 < 2) goto c8ke1; else goto c8ke2;
       c8ke1: // global
           I64[Sp + 8] = block_c8keb_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kfs; else goto c8ked;
       u8kfs: // global
           call _c8keb(R1) args: 0, res: 0, upd: 0;
       c8ked: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ke2: // global
           I64[Sp + 8] = block_c8key_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kft; else goto c8keA;
       u8kft: // global
           call _c8key(R1) args: 0, res: 0, upd: 0;
       c8keA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8kfh: // global
           if (_c8ke5::P64 < 4) goto c8ke3; else goto c8ke4;
       c8ke3: // global
           I64[Sp + 8] = block_c8keR_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kfu; else goto c8keT;
       u8kfu: // global
           call _c8keR(R1) args: 0, res: 0, upd: 0;
       c8keT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ke4: // global
           I64[Sp + 8] = block_c8kf6_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kfv; else goto c8kf8;
       u8kfv: // global
           call _c8kf6() args: 0, res: 0, upd: 0;
       c8kf8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8keb() //  [R1]
         { info_tbl: [(c8keb,
                       label: block_c8keb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8keb: // global
           _c8kff::P64 = R1 & 7;
           if (_c8kff::P64 < 2) goto u8kfk; else goto u8kfi;
       u8kfk: // global
           Sp = Sp + 8;
           call _c8keZ() args: 0, res: 0, upd: 0;
       u8kfi: // global
           if (_c8kff::P64 != 3) goto u8kfm; else goto u8kfm;
       u8kfm: // global
           Sp = Sp + 8;
           call _c8kf3() args: 0, res: 0, upd: 0;
     }
 },
 _c8key() //  [R1]
         { info_tbl: [(c8key,
                       label: block_c8key_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8key: // global
           _c8kfe::P64 = R1 & 7;
           if (_c8kfe::P64 != 3) goto u8kfj; else goto u8kfn;
       u8kfj: // global
           if (_c8kfe::P64 != 4) goto u8kfp; else goto u8kfo;
       u8kfp: // global
           Sp = Sp + 8;
           call _c8keZ() args: 0, res: 0, upd: 0;
       u8kfo: // global
           Sp = Sp + 8;
           goto u8kfA;
       u8kfn: // global
           Sp = Sp + 8;
           goto u8kfA;
       u8kfA: // global
           call _c8kf3() args: 0, res: 0, upd: 0;
     }
 },
 _c8keR() //  [R1]
         { info_tbl: [(c8keR,
                       label: block_c8keR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8keR: // global
           if (R1 & 7 == 4) goto u8kfq; else goto u8kfr;
       u8kfq: // global
           Sp = Sp + 8;
           call _c8kf3() args: 0, res: 0, upd: 0;
       u8kfr: // global
           Sp = Sp + 8;
           call _c8keZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8kf3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kf3: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8keZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8keZ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kf6() //  []
         { info_tbl: [(c8kf6,
                       label: block_c8kf6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kf6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.927335872 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8kfR,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kfS; else goto c8kfT;
       c8kfS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kfT: // global
           I64[Sp - 16] = block_c8kfI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8khh; else goto c8kfJ;
       u8khh: // global
           call _c8kfI(R1) args: 0, res: 0, upd: 0;
       c8kfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kfI() //  [R1]
         { info_tbl: [(c8kfI,
                       label: block_c8kfI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kfI: // global
           _s8jdO::P64 = P64[Sp + 8];
           _c8kfQ::P64 = R1 & 7;
           if (_c8kfQ::P64 < 3) goto u8kh1; else goto u8kh2;
       u8kh1: // global
           if (_c8kfQ::P64 < 2) goto c8kfM; else goto c8kfN;
       c8kfM: // global
           I64[Sp + 8] = block_c8kfW_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8khd; else goto c8kfY;
       u8khd: // global
           call _c8kfW(R1) args: 0, res: 0, upd: 0;
       c8kfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kfN: // global
           I64[Sp + 8] = block_c8kgj_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8khe; else goto c8kgl;
       u8khe: // global
           call _c8kgj(R1) args: 0, res: 0, upd: 0;
       c8kgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8kh2: // global
           if (_c8kfQ::P64 < 4) goto c8kfO; else goto c8kfP;
       c8kfO: // global
           I64[Sp + 8] = block_c8kgC_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8khf; else goto c8kgE;
       u8khf: // global
           call _c8kgC(R1) args: 0, res: 0, upd: 0;
       c8kgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kfP: // global
           I64[Sp + 8] = block_c8kgR_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8khg; else goto c8kgT;
       u8khg: // global
           call _c8kgR() args: 0, res: 0, upd: 0;
       c8kgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kfW() //  [R1]
         { info_tbl: [(c8kfW,
                       label: block_c8kfW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kfW: // global
           _c8kh0::P64 = R1 & 7;
           if (_c8kh0::P64 < 2) goto u8kh5; else goto u8kh3;
       u8kh5: // global
           Sp = Sp + 8;
           call _c8kgK() args: 0, res: 0, upd: 0;
       u8kh3: // global
           if (_c8kh0::P64 != 3) goto u8kh7; else goto u8kh7;
       u8kh7: // global
           Sp = Sp + 8;
           call _c8kgO() args: 0, res: 0, upd: 0;
     }
 },
 _c8kgj() //  [R1]
         { info_tbl: [(c8kgj,
                       label: block_c8kgj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kgj: // global
           _c8kgZ::P64 = R1 & 7;
           if (_c8kgZ::P64 != 3) goto u8kh4; else goto u8kh8;
       u8kh4: // global
           if (_c8kgZ::P64 != 4) goto u8kha; else goto u8kh9;
       u8kha: // global
           Sp = Sp + 8;
           call _c8kgK() args: 0, res: 0, upd: 0;
       u8kh9: // global
           Sp = Sp + 8;
           goto u8khl;
       u8kh8: // global
           Sp = Sp + 8;
           goto u8khl;
       u8khl: // global
           call _c8kgO() args: 0, res: 0, upd: 0;
     }
 },
 _c8kgC() //  [R1]
         { info_tbl: [(c8kgC,
                       label: block_c8kgC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kgC: // global
           if (R1 & 7 == 4) goto u8khb; else goto u8khc;
       u8khb: // global
           Sp = Sp + 8;
           call _c8kgO() args: 0, res: 0, upd: 0;
       u8khc: // global
           Sp = Sp + 8;
           call _c8kgK() args: 0, res: 0, upd: 0;
     }
 },
 _c8kgO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kgO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kgK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kgK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kgR() //  []
         { info_tbl: [(c8kgR,
                       label: block_c8kgR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kgR: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.930292211 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmax_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmax_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8khC,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8khC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8khD; else goto c8khE;
       c8khD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8khE: // global
           I64[Sp - 16] = block_c8kht_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kiB; else goto c8khu;
       u8kiB: // global
           call _c8kht(R1) args: 0, res: 0, upd: 0;
       c8khu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kht() //  [R1]
         { info_tbl: [(c8kht,
                       label: block_c8kht_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kht: // global
           _s8jdV::P64 = P64[Sp + 8];
           _c8khB::P64 = R1 & 7;
           if (_c8khB::P64 < 3) goto u8kir; else goto u8kis;
       u8kir: // global
           if (_c8khB::P64 < 2) goto c8khx; else goto c8khy;
       c8khx: // global
           R1 = _s8jdV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8khy: // global
           I64[Sp + 8] = block_c8khK_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kiy; else goto c8khM;
       u8kiy: // global
           call _c8khK(R1) args: 0, res: 0, upd: 0;
       c8khM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8kis: // global
           if (_c8khB::P64 < 4) goto c8khz; else goto c8khA;
       c8khz: // global
           I64[Sp + 8] = block_c8ki3_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kiz; else goto c8ki5;
       u8kiz: // global
           call _c8ki3(R1) args: 0, res: 0, upd: 0;
       c8ki5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8khA: // global
           I64[Sp + 8] = block_c8kii_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kiA; else goto c8kik;
       u8kiA: // global
           call _c8kii() args: 0, res: 0, upd: 0;
       c8kik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8khK() //  [R1]
         { info_tbl: [(c8khK,
                       label: block_c8khK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8khK: // global
           _c8kiq::P64 = R1 & 7;
           if (_c8kiq::P64 != 3) goto u8kit; else goto u8kiu;
       u8kit: // global
           if (_c8kiq::P64 != 4) goto c8khS; else goto u8kiv;
       c8khS: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8kiv: // global
           Sp = Sp + 8;
           call _c8kif() args: 0, res: 0, upd: 0;
       u8kiu: // global
           Sp = Sp + 8;
           call _c8kib() args: 0, res: 0, upd: 0;
     }
 },
 _c8ki3() //  [R1]
         { info_tbl: [(c8ki3,
                       label: block_c8ki3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ki3: // global
           if (R1 & 7 == 4) goto u8kiw; else goto u8kix;
       u8kiw: // global
           Sp = Sp + 8;
           call _c8kif() args: 0, res: 0, upd: 0;
       u8kix: // global
           Sp = Sp + 8;
           call _c8kib() args: 0, res: 0, upd: 0;
     }
 },
 _c8kif() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kif: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kib() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kib: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kii() //  []
         { info_tbl: [(c8kii,
                       label: block_c8kii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kii: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.933202477 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8kiT,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kiT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kiU; else goto c8kiV;
       c8kiU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kiV: // global
           I64[Sp - 16] = block_c8kiK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kkj; else goto c8kiL;
       u8kkj: // global
           call _c8kiK(R1) args: 0, res: 0, upd: 0;
       c8kiL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kiK() //  [R1]
         { info_tbl: [(c8kiK,
                       label: block_c8kiK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kiK: // global
           _s8je2::P64 = P64[Sp + 8];
           _c8kiS::P64 = R1 & 7;
           if (_c8kiS::P64 < 3) goto u8kk3; else goto u8kk4;
       u8kk3: // global
           if (_c8kiS::P64 < 2) goto c8kiO; else goto c8kiP;
       c8kiO: // global
           I64[Sp + 8] = block_c8kiY_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kkf; else goto c8kj0;
       u8kkf: // global
           call _c8kiY(R1) args: 0, res: 0, upd: 0;
       c8kj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kiP: // global
           I64[Sp + 8] = block_c8kjl_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kkg; else goto c8kjn;
       u8kkg: // global
           call _c8kjl(R1) args: 0, res: 0, upd: 0;
       c8kjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8kk4: // global
           if (_c8kiS::P64 < 4) goto c8kiQ; else goto c8kiR;
       c8kiQ: // global
           I64[Sp + 8] = block_c8kjE_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kkh; else goto c8kjG;
       u8kkh: // global
           call _c8kjE(R1) args: 0, res: 0, upd: 0;
       c8kjG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kiR: // global
           I64[Sp + 8] = block_c8kjT_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8kki; else goto c8kjV;
       u8kki: // global
           call _c8kjT() args: 0, res: 0, upd: 0;
       c8kjV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kiY() //  [R1]
         { info_tbl: [(c8kiY,
                       label: block_c8kiY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kiY: // global
           _c8kk2::P64 = R1 & 7;
           if (_c8kk2::P64 < 2) goto u8kk7; else goto u8kk5;
       u8kk7: // global
           Sp = Sp + 8;
           call _c8kjM() args: 0, res: 0, upd: 0;
       u8kk5: // global
           if (_c8kk2::P64 != 3) goto u8kk9; else goto u8kk9;
       u8kk9: // global
           Sp = Sp + 8;
           call _c8kjQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8kjl() //  [R1]
         { info_tbl: [(c8kjl,
                       label: block_c8kjl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kjl: // global
           _c8kk1::P64 = R1 & 7;
           if (_c8kk1::P64 != 3) goto u8kk6; else goto u8kka;
       u8kk6: // global
           if (_c8kk1::P64 != 4) goto u8kkc; else goto u8kkb;
       u8kkc: // global
           Sp = Sp + 8;
           call _c8kjM() args: 0, res: 0, upd: 0;
       u8kkb: // global
           Sp = Sp + 8;
           goto u8kkn;
       u8kka: // global
           Sp = Sp + 8;
           goto u8kkn;
       u8kkn: // global
           call _c8kjQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8kjE() //  [R1]
         { info_tbl: [(c8kjE,
                       label: block_c8kjE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kjE: // global
           if (R1 & 7 == 4) goto u8kkd; else goto u8kke;
       u8kkd: // global
           Sp = Sp + 8;
           call _c8kjQ() args: 0, res: 0, upd: 0;
       u8kke: // global
           Sp = Sp + 8;
           call _c8kjM() args: 0, res: 0, upd: 0;
     }
 },
 _c8kjQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kjQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kjM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kjM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kjT() //  []
         { info_tbl: [(c8kjT,
                       label: block_c8kjT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kjT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.935932954 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8kkv,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kkv: // global
           _s8je9::P64 = R3;
           R3 = R2;
           R2 = _s8je9::P64;
           call GHC.IO.Exception.$fOrdAsyncException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.937348648 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmin_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmin_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8kkL,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kkL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kkM; else goto c8kkN;
       c8kkM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kkN: // global
           I64[Sp - 16] = block_c8kkC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8klG; else goto c8kkD;
       u8klG: // global
           call _c8kkC(R1) args: 0, res: 0, upd: 0;
       c8kkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kkC() //  [R1]
         { info_tbl: [(c8kkC,
                       label: block_c8kkC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kkC: // global
           _s8jea::P64 = P64[Sp + 8];
           _c8kkK::P64 = R1 & 7;
           if (_c8kkK::P64 < 3) goto u8klA; else goto u8klB;
       u8klA: // global
           if (_c8kkK::P64 < 2) goto c8kkG; else goto c8kkH;
       c8kkG: // global
           I64[Sp + 8] = block_c8kkQ_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8klD; else goto c8kkS;
       u8klD: // global
           call _c8kkQ() args: 0, res: 0, upd: 0;
       c8kkS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kkH: // global
           I64[Sp + 8] = block_c8kkZ_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8klE; else goto c8kl1;
       u8klE: // global
           call _c8kkZ(R1) args: 0, res: 0, upd: 0;
       c8kl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8klB: // global
           if (_c8kkK::P64 < 4) goto c8kkI; else goto c8kkJ;
       c8kkI: // global
           I64[Sp + 8] = block_c8kli_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8klF; else goto c8klk;
       u8klF: // global
           call _c8kli(R1) args: 0, res: 0, upd: 0;
       c8klk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kkJ: // global
           R1 = _s8jea::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kkQ() //  []
         { info_tbl: [(c8kkQ,
                       label: block_c8kkQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kkQ: // global
           R1 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kkZ() //  [R1]
         { info_tbl: [(c8kkZ,
                       label: block_c8kkZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kkZ: // global
           _c8klz::P64 = R1 & 7;
           if (_c8klz::P64 == 3) goto c8klf; else goto u8klC;
       u8klC: // global
           if (_c8klz::P64 == 4) goto c8klf; else goto c8kl7;
       c8klf: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kl7: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kli() //  [R1]
         { info_tbl: [(c8kli,
                       label: block_c8kli_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kli: // global
           if (R1 & 7 == 4) goto c8klu; else goto c8klq;
       c8klu: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8klq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.93927393 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_closure" {
     GHC.IO.Exception.$fOrdAsyncException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqAsyncException_closure+1;
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.939884314 UTC

[section ""cstring" . GHC.IO.Exception.$trModule4_bytes" {
     GHC.IO.Exception.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.940483458 UTC

[section ""data" . GHC.IO.Exception.$trModule3_closure" {
     GHC.IO.Exception.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.941077343 UTC

[section ""cstring" . GHC.IO.Exception.$trModule2_bytes" {
     GHC.IO.Exception.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.941672732 UTC

[section ""data" . GHC.IO.Exception.$trModule1_closure" {
     GHC.IO.Exception.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.942264744 UTC

[section ""data" . GHC.IO.Exception.$trModule_closure" {
     GHC.IO.Exception.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Exception.$trModule3_closure+1;
         const GHC.IO.Exception.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.942823827 UTC

[section ""data" . $krep_r8j3f_closure" {
     $krep_r8j3f_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.943435913 UTC

[section ""data" . $krep1_r8j3g_closure" {
     $krep1_r8j3g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.944059174 UTC

[section ""data" . $krep2_r8j3h_closure" {
     $krep2_r8j3h_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.944656313 UTC

[section ""data" . $krep3_r8j3i_closure" {
     $krep3_r8j3i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.94528607 UTC

[section ""data" . $krep4_r8j3j_closure" {
     $krep4_r8j3j_closure:
         const :_con_info;
         const $krep1_r8j3g_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.94811416 UTC

[section ""data" . $krep5_r8j3k_closure" {
     $krep5_r8j3k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.948724374 UTC

[section ""data" . $krep6_r8j3l_closure" {
     $krep6_r8j3l_closure:
         const :_con_info;
         const $krep3_r8j3i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.949659642 UTC

[section ""data" . $krep7_r8j3m_closure" {
     $krep7_r8j3m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8j3l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.950280108 UTC

[section ""data" . $krep8_r8j3n_closure" {
     $krep8_r8j3n_closure:
         const :_con_info;
         const $krep2_r8j3h_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.950819194 UTC

[section ""data" . $krep9_r8j3o_closure" {
     $krep9_r8j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8j3n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.951361907 UTC

[section ""data" . $krep10_r8j3p_closure" {
     $krep10_r8j3p_closure:
         const :_con_info;
         const $krep9_r8j3o_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.951954295 UTC

[section ""data" . $krep11_r8j3q_closure" {
     $krep11_r8j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep10_r8j3p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.952512798 UTC

[section ""data" . $krep12_r8j3r_closure" {
     $krep12_r8j3r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.953064435 UTC

[section ""data" . $krep13_r8j3s_closure" {
     $krep13_r8j3s_closure:
         const :_con_info;
         const $krep12_r8j3r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.953677937 UTC

[section ""data" . $krep14_r8j3t_closure" {
     $krep14_r8j3t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Exception.$tcException_closure;
         const $krep13_r8j3s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.954289244 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.954804592 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.955366331 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
         const GHC.Types.krep$*_closure;
         const 5532209509574600699;
         const 13011219155706606307;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.956017746 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.956592946 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.957113466 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.957708532 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure+1;
         const 6834741829236713234;
         const 5957659317954655195;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.958925341 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_entry() //  [R1]
         { info_tbl: [(c8klS,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8klS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8klT; else goto c8klU;
       c8klT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8klU: // global
           (_c8klK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8klK::I64 == 0) goto c8klM; else goto c8klL;
       c8klM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8klL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8klK::I64;
           I64[Sp - 24] = block_c8klN_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 13011219155706606307;
           R2 = 5532209509574600699;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8klN() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8klN,
                       label: block_c8klN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8klN: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8klO() args: 0, res: 0, upd: 0;
     }
 },
 _c8klO() //  []
         { info_tbl: [(c8klO,
                       label: block_c8klO_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8klO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8klX; else goto c8klW;
       c8klX: // global
           HpAlloc = 48;
           I64[Sp] = block_c8klO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8klW: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.960449993 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.961020866 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.962034283 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13946898568638194917;
         const 3504019511763148288;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.962623408 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.96319388 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.96371196 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.964252689 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure+1;
         const 13856829326869447687;
         const 12209020643191939554;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.965325261 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_entry() //  [R1]
         { info_tbl: [(c8kmb,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kmc; else goto c8kmd;
       c8kmc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kmd: // global
           (_c8km3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8km3::I64 == 0) goto c8km5; else goto c8km4;
       c8km5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8km4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8km3::I64;
           I64[Sp - 24] = block_c8km6_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3504019511763148288;
           R2 = 13946898568638194917;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8km6() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8km6,
                       label: block_c8km6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8km6: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8km7() args: 0, res: 0, upd: 0;
     }
 },
 _c8km7() //  []
         { info_tbl: [(c8km7,
                       label: block_c8km7_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8km7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kmg; else goto c8kmf;
       c8kmg: // global
           HpAlloc = 48;
           I64[Sp] = block_c8km7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kmf: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.966737508 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock5_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock5_bytes:
         I8[] [68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.967245892 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock4_closure" {
     GHC.IO.Exception.$fExceptionDeadlock4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.967818727 UTC

[section ""data" . GHC.IO.Exception.$tcDeadlock_closure" {
     GHC.IO.Exception.$tcDeadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
         const GHC.Types.krep$*_closure;
         const 18363794241794644491;
         const 11186984538024031318;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.968423371 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock1_closure" {
     GHC.IO.Exception.$tc'Deadlock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcDeadlock_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.968989728 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Deadlock3_bytes" {
     GHC.IO.Exception.$tc'Deadlock3_bytes:
         I8[] [39,68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.96951007 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock2_closure" {
     GHC.IO.Exception.$tc'Deadlock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Deadlock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.970041638 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock_closure" {
     GHC.IO.Exception.$tc'Deadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Deadlock2_closure+1;
         const GHC.IO.Exception.$tc'Deadlock1_closure+1;
         const 8732553870978897242;
         const 16079179228471909431;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.971090184 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock3_closure" {
     GHC.IO.Exception.$fExceptionDeadlock3_closure:
         const GHC.IO.Exception.$fExceptionDeadlock3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock3_entry() //  [R1]
         { info_tbl: [(c8kmu,
                       label: GHC.IO.Exception.$fExceptionDeadlock3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmu: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kmv; else goto c8kmw;
       c8kmv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kmw: // global
           (_c8kmm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kmm::I64 == 0) goto c8kmo; else goto c8kmn;
       c8kmo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kmn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kmm::I64;
           I64[Sp - 24] = block_c8kmp_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kmp() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kmp,
                       label: block_c8kmp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmp: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kmq() args: 0, res: 0, upd: 0;
     }
 },
 _c8kmq() //  []
         { info_tbl: [(c8kmq,
                       label: block_c8kmq_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kmz; else goto c8kmy;
       c8kmz: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kmq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kmy: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.972963396 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kmJ,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kmN; else goto c8kmO;
       c8kmN: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kmO: // global
           I64[Sp - 8] = block_c8kmG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kn9; else goto c8kmH;
       u8kn9: // global
           call _c8kmG(R1) args: 0, res: 0, upd: 0;
       c8kmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kmG() //  [R1]
         { info_tbl: [(c8kmG,
                       label: block_c8kmG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmG: // global
           I64[Sp - 8] = block_c8kmM_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kmM() //  [R1]
         { info_tbl: [(c8kmM,
                       label: block_c8kmM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmM: // global
           I64[Sp] = block_c8kmT_info;
           R3 = GHC.IO.Exception.$fExceptionDeadlock3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kmT() //  [R1]
         { info_tbl: [(c8kmT,
                       label: block_c8kmT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kmT: // global
           if (R1 & 7 == 1) goto c8kn0; else goto c8kn4;
       c8kn0: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kn4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kn7; else goto c8kn6;
       c8kn7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kn6: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.97498644 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fShowDeadlock_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$ctoException_entry() //  [R2]
         { info_tbl: [(c8knf,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8knj; else goto c8kni;
       c8knj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kni: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionDeadlock_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.975860345 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes:
         I8[] [65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.976434163 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.976989456 UTC

[section ""data" . GHC.IO.Exception.$tcAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tcAllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13160607835047152551;
         const 6828489586181860176;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.977589889 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAllocationLimitExceeded_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.978189273 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes:
         I8[] [39,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.978754872 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.979313675 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure+1;
         const 14911686161474736107;
         const 16735957051754280572;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.981710831 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_entry() //  [R1]
         { info_tbl: [(c8knv,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knv: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8knw; else goto c8knx;
       c8knw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8knx: // global
           (_c8knn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8knn::I64 == 0) goto c8knp; else goto c8kno;
       c8knp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kno: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8knn::I64;
           I64[Sp - 24] = block_c8knq_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6828489586181860176;
           R2 = 13160607835047152551;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8knq() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8knq,
                       label: block_c8knq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knq: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8knr() args: 0, res: 0, upd: 0;
     }
 },
 _c8knr() //  []
         { info_tbl: [(c8knr,
                       label: block_c8knr_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8knA; else goto c8knz;
       c8knA: // global
           HpAlloc = 48;
           I64[Sp] = block_c8knr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8knz: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.983240599 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed4_bytes:
         I8[] [67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.983789511 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed3_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.984352794 UTC

[section ""data" . GHC.IO.Exception.$tcCompactionFailed_closure" {
     GHC.IO.Exception.$tcCompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7633933266579528523;
         const 6393060685738357435;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.984896044 UTC

[section ""data" . $krep15_r8j3u_closure" {
     $krep15_r8j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcCompactionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.985822648 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed1_closure" {
     GHC.IO.Exception.$tc'CompactionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep15_r8j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.986342701 UTC

[section ""cstring" . GHC.IO.Exception.$tc'CompactionFailed3_bytes" {
     GHC.IO.Exception.$tc'CompactionFailed3_bytes:
         I8[] [39,67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.986861155 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed2_closure" {
     GHC.IO.Exception.$tc'CompactionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'CompactionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.987408156 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed_closure" {
     GHC.IO.Exception.$tc'CompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed2_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed1_closure+4;
         const 5917738941224226344;
         const 8436844331187314000;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.988539023 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed2_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed2_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed2_entry() //  [R1]
         { info_tbl: [(c8knO,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knO: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8knP; else goto c8knQ;
       c8knP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8knQ: // global
           (_c8knG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8knG::I64 == 0) goto c8knI; else goto c8knH;
       c8knI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8knH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8knG::I64;
           I64[Sp - 24] = block_c8knJ_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6393060685738357435;
           R2 = 7633933266579528523;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8knJ() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8knJ,
                       label: block_c8knJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knJ: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8knK() args: 0, res: 0, upd: 0;
     }
 },
 _c8knK() //  []
         { info_tbl: [(c8knK,
                       label: block_c8knK_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8knK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8knT; else goto c8knS;
       c8knT: // global
           HpAlloc = 48;
           I64[Sp] = block_c8knK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8knS: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.989995202 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAssertionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionAssertionFailed4_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.990523781 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed3_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.991096052 UTC

[section ""data" . GHC.IO.Exception.$tcAssertionFailed_closure" {
     GHC.IO.Exception.$tcAssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7013231185527166567;
         const 11481669896152761825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.991664988 UTC

[section ""data" . $krep16_r8j3v_closure" {
     $krep16_r8j3v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAssertionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.992227938 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed1_closure" {
     GHC.IO.Exception.$tc'AssertionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep16_r8j3v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.992775234 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AssertionFailed3_bytes" {
     GHC.IO.Exception.$tc'AssertionFailed3_bytes:
         I8[] [39,65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.993339905 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed2_closure" {
     GHC.IO.Exception.$tc'AssertionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AssertionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.993867572 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed_closure" {
     GHC.IO.Exception.$tc'AssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed2_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed1_closure+4;
         const 6421416346863765662;
         const 16131786633010342764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.994985296 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed2_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed2_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed2_entry() //  [R1]
         { info_tbl: [(c8ko7,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ko7: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8ko8; else goto c8ko9;
       c8ko8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ko9: // global
           (_c8knZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8knZ::I64 == 0) goto c8ko1; else goto c8ko0;
       c8ko1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ko0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8knZ::I64;
           I64[Sp - 24] = block_c8ko2_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11481669896152761825;
           R2 = 7013231185527166567;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8ko2() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8ko2,
                       label: block_c8ko2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ko2: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8ko3() args: 0, res: 0, upd: 0;
     }
 },
 _c8ko3() //  []
         { info_tbl: [(c8ko3,
                       label: block_c8ko3_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ko3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8koc; else goto c8kob;
       c8koc: // global
           HpAlloc = 48;
           I64[Sp] = block_c8ko3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kob: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.996909451 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kom,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8koq; else goto c8kor;
       c8koq: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kor: // global
           I64[Sp - 8] = block_c8koj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8koM; else goto c8kok;
       u8koM: // global
           call _c8koj(R1) args: 0, res: 0, upd: 0;
       c8kok: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8koj() //  [R1]
         { info_tbl: [(c8koj,
                       label: block_c8koj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8koj: // global
           I64[Sp - 8] = block_c8kop_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kop() //  [R1]
         { info_tbl: [(c8kop,
                       label: block_c8kop_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kop: // global
           I64[Sp] = block_c8kow_info;
           R3 = GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kow() //  [R1]
         { info_tbl: [(c8kow,
                       label: block_c8kow_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kow: // global
           if (R1 & 7 == 1) goto c8koD; else goto c8koH;
       c8koD: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8koH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8koK; else goto c8koJ;
       c8koK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8koJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.998807649 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fShowAssertionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8koS,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8koS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8koW; else goto c8koV;
       c8koW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8koV: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAssertionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:24.999672434 UTC

[section ""cstring" . lvl38_r8j3w_bytes" {
     lvl38_r8j3w_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,32,102,97,105,108,101,100,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.0024801 UTC

[section ""data" . GHC.IO.Exception.assertError1_closure" {
     GHC.IO.Exception.assertError1_closure:
         const GHC.IO.Exception.assertError1_info;
         const 0;
 },
 sat_s8jfa_entry() //  [R1]
         { info_tbl: [(c8kpt,
                       label: sat_s8jfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kpt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8kpu; else goto c8kpv;
       c8kpu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kpv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8kpr_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8kpr() //  [R1]
         { info_tbl: [(c8kpr,
                       label: block_c8kpr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kpr: // global
           R3 = R1;
           R2 = GHC.Exception.errorCallWithCallStackException9_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 n_s8jf5_entry() //  [R1]
         { info_tbl: [(c8kpD,
                       label: n_s8jf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kpD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8kpE; else goto c8kpF;
       c8kpE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kpF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8kph_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8kpM; else goto c8kpi;
       u8kpM: // global
           call _c8kph(R1) args: 0, res: 0, upd: 0;
       c8kpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8kph() //  [R1]
         { info_tbl: [(c8kph,
                       label: block_c8kph_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kph: // global
           if (R1 & 7 == 1) goto c8kpA; else goto c8kpB;
       c8kpA: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8kpB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kpL; else goto c8kpK;
       c8kpL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8kpK: // global
           I64[Hp - 40] = sat_s8jfa_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException11_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jff_entry() //  [R1]
         { info_tbl: [(c8kq1,
                       label: sat_s8jff_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kq1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kq2; else goto c8kq3;
       c8kq2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfo_entry() //  [R1]
         { info_tbl: [(c8kqq,
                       label: sat_s8jfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kqr; else goto c8kqs;
       c8kqr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kqs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.errorCallWithCallStackException1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8jfj_entry() //  [R1, R2]
         { info_tbl: [(c8kqx,
                       label: go_s8jfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8kqy; else goto c8kqz;
       c8kqy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kqz: // global
           I64[Sp - 24] = block_c8kqf_info;
           _s8jfj::P64 = R1;
           _s8jf5::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s8jf5::P64;
           P64[Sp - 8] = _s8jfj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8kqG; else goto c8kqg;
       u8kqG: // global
           call _c8kqf(R1) args: 0, res: 0, upd: 0;
       c8kqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kqf() //  [R1]
         { info_tbl: [(c8kqf,
                       label: block_c8kqf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqf: // global
           if (R1 & 7 == 1) goto c8kqu; else goto c8kqv;
       c8kqu: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8kqv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8kqF; else goto c8kqE;
       c8kqF: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kqE: // global
           _s8jfm::P64 = P64[R1 + 6];
           _s8jfn::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _s8jfn::P64;
           I64[Hp - 40] = sat_s8jfo_info;
           P64[Hp - 24] = _s8jfm::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jfr_entry() //  [R1]
         { info_tbl: [(c8kqJ,
                       label: sat_s8jfr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqJ: // global
           _s8jfr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8kqK; else goto c8kqL;
       c8kqL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kqN; else goto c8kqM;
       c8kqN: // global
           HpAlloc = 16;
           goto c8kqK;
       c8kqK: // global
           R1 = _s8jfr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kqM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfr::P64;
           _s8jf5::P64 = P64[_s8jfr::P64 + 16];
           _s8jfb::P64 = P64[_s8jfr::P64 + 24];
           I64[Hp - 8] = go_s8jfj_info;
           P64[Hp] = _s8jf5::P64;
           I64[Sp - 24] = block_c8kqH_info;
           R2 = _s8jfb::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s8jfj_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8kqH() //  [R1]
         { info_tbl: [(c8kqH,
                       label: block_c8kqH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqH: // global
           R3 = R1;
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp + 8;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jft_entry() //  [R1]
         { info_tbl: [(c8kqV,
                       label: sat_s8jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kqV: // global
           _s8jft::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8kqW; else goto c8kqX;
       c8kqX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kqZ; else goto c8kqY;
       c8kqZ: // global
           HpAlloc = 24;
           goto c8kqW;
       c8kqW: // global
           R1 = _s8jft::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jft::P64;
           _s8jf2::P64 = P64[_s8jft::P64 + 16];
           _s8jf3::P64 = P64[_s8jft::P64 + 24];
           I64[Hp - 16] = n_s8jf5_info;
           P64[Hp] = _s8jf3::P64;
           I64[Sp - 32] = block_c8kpN_info;
           R2 = _s8jf2::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Stack.Types.getCallStack_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8kpN() //  [R1]
         { info_tbl: [(c8kpN,
                       label: block_c8kpN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kpN: // global
           _c8kpd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kqS; else goto c8kqT;
       c8kqS: // global
           I64[Sp + 8] = block_c8kpR_info;
           R1 = _c8kpd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8krf; else goto c8kpS;
       u8krf: // global
           call _c8kpR(R1) args: 0, res: 0, upd: 0;
       c8kpS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       c8kqT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8krd; else goto c8krc;
       c8krd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8krc: // global
           I64[Hp - 48] = sat_s8jfr_info;
           P64[Hp - 32] = _c8kpd::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException6_closure;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _c8kpR() //  [R1]
         { info_tbl: [(c8kpR,
                       label: block_c8kpR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kpR: // global
           if (R1 & 7 == 1) goto c8kr4; else goto c8kr6;
       c8kr4: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8kr6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kr9; else goto c8kr8;
       c8kr9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8kr8: // global
           _s8jfd::P64 = P64[R1 + 6];
           _s8jfe::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_s8jff_info;
           P64[Hp - 24] = _s8jfe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8jfd::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfu_entry() //  [R1]
         { info_tbl: [(c8krg,
                       label: sat_s8jfu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krg: // global
           _s8jfu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8krh; else goto c8kri;
       c8kri: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8krk; else goto c8krj;
       c8krk: // global
           HpAlloc = 32;
           goto c8krh;
       c8krh: // global
           R1 = _s8jfu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8krj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfu::P64;
           _s8jf2::P64 = P64[_s8jfu::P64 + 16];
           _s8jf3::P64 = P64[_s8jfu::P64 + 24];
           I64[Hp - 24] = sat_s8jft_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R3 = Hp - 24;
           R2 = lvl38_r8j3w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfv_entry() //  [R1]
         { info_tbl: [(c8krl,
                       label: sat_s8jfv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krl: // global
           _s8jfv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8krm; else goto c8krn;
       c8krn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8krp; else goto c8kro;
       c8krp: // global
           HpAlloc = 32;
           goto c8krm;
       c8krm: // global
           R1 = _s8jfv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfv::P64;
           _s8jf2::P64 = P64[_s8jfv::P64 + 16];
           _s8jf3::P64 = P64[_s8jfv::P64 + 24];
           I64[Hp - 24] = sat_s8jfu_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R2 = Hp - 24;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.assertError1_entry() //  [R2, R3]
         { info_tbl: [(c8krq,
                       label: GHC.IO.Exception.assertError1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8kru; else goto c8krt;
       c8kru: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8krt: // global
           I64[Hp - 24] = sat_s8jfv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.008060439 UTC

[section ""data" . GHC.IO.Exception.assertError_closure" {
     GHC.IO.Exception.assertError_closure:
         const GHC.IO.Exception.assertError_info;
         const 0;
 },
 GHC.IO.Exception.assertError_entry() //  [R2, R3, R4]
         { info_tbl: [(c8krG,
                       label: GHC.IO.Exception.assertError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8krH; else goto c8krI;
       c8krH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8krI: // global
           I64[Sp - 24] = block_c8krz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8krV; else goto c8krA;
       u8krV: // global
           call _c8krz(R1) args: 0, res: 0, upd: 0;
       c8krA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8krz() //  [R1]
         { info_tbl: [(c8krz,
                       label: block_c8krz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krz: // global
           if (R1 & 7 == 1) goto c8krD; else goto c8krE;
       c8krD: // global
           I64[Sp] = block_c8krL_info;
           R1 = GHC.Stack.CCS.currentCallStack_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c8krE: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8krL() //  [R1]
         { info_tbl: [(c8krL,
                       label: block_c8krL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krL: // global
           I64[Sp + 16] = block_c8krN_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Exception.assertError1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8krN() //  [R1]
         { info_tbl: [(c8krN,
                       label: block_c8krN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8krN: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.009425402 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes:
         I8[] [83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.009976155 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.010528746 UTC

[section ""data" . GHC.IO.Exception.$tcSomeAsyncException_closure" {
     GHC.IO.Exception.$tcSomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
         const GHC.Types.krep$*_closure;
         const 7698277271892269964;
         const 12603180528693821542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.011105715 UTC

[section ""data" . $krep17_r8j3x_closure" {
     $krep17_r8j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcSomeAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.011669094 UTC

[section ""data" . $krep18_r8j3y_closure" {
     $krep18_r8j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r8j3r_closure+2;
         const $krep17_r8j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.012219576 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException1_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r8j3t_closure+1;
         const $krep18_r8j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.012764217 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SomeAsyncException3_bytes" {
     GHC.IO.Exception.$tc'SomeAsyncException3_bytes:
         I8[] [39,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.013724297 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException2_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SomeAsyncException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.014281623 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException2_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException1_closure+4;
         const 2590663161510005226;
         const 12089333203895315586;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.015479494 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_entry() //  [R1]
         { info_tbl: [(c8ks7,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ks7: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8ks8; else goto c8ks9;
       c8ks8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ks9: // global
           (_c8krZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8krZ::I64 == 0) goto c8ks1; else goto c8ks0;
       c8ks1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ks0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8krZ::I64;
           I64[Sp - 24] = block_c8ks2_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12603180528693821542;
           R2 = 7698277271892269964;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8ks2() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8ks2,
                       label: block_c8ks2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ks2: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8ks3() args: 0, res: 0, upd: 0;
     }
 },
 _c8ks3() //  []
         { info_tbl: [(c8ks3,
                       label: block_c8ks3_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ks3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8ksc; else goto c8ksb;
       c8ksc: // global
           HpAlloc = 48;
           I64[Sp] = block_c8ks3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8ksb: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.017419782 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8ksm,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ksm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ksq; else goto c8ksr;
       c8ksq: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ksr: // global
           I64[Sp - 8] = block_c8ksj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ksM; else goto c8ksk;
       u8ksM: // global
           call _c8ksj(R1) args: 0, res: 0, upd: 0;
       c8ksk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ksj() //  [R1]
         { info_tbl: [(c8ksj,
                       label: block_c8ksj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ksj: // global
           I64[Sp - 8] = block_c8ksp_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ksp() //  [R1]
         { info_tbl: [(c8ksp,
                       label: block_c8ksp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ksp: // global
           I64[Sp] = block_c8ksw_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ksw() //  [R1]
         { info_tbl: [(c8ksw,
                       label: block_c8ksw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ksw: // global
           if (R1 & 7 == 1) goto c8ksD; else goto c8ksH;
       c8ksD: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ksH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ksK; else goto c8ksJ;
       c8ksK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ksJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.019029181 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fShowSomeAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8ksS,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ksS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ksW; else goto c8ksV;
       c8ksW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ksV: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionSomeAsyncException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.020642381 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionFromException_closure" {
     GHC.IO.Exception.asyncExceptionFromException_closure:
         const GHC.IO.Exception.asyncExceptionFromException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionFromException_entry() //  [R2, R3]
         { info_tbl: [(c8kt4,
                       label: GHC.IO.Exception.asyncExceptionFromException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kt4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8kt8; else goto c8kt9;
       c8kt8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionFromException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kt9: // global
           I64[Sp - 16] = block_c8kt1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ktX; else goto c8kt2;
       u8ktX: // global
           call _c8kt1(R1) args: 0, res: 0, upd: 0;
       c8kt2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kt1() //  [R1]
         { info_tbl: [(c8kt1,
                       label: block_c8kt1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kt1: // global
           I64[Sp - 8] = block_c8kt7_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kt7() //  [R1]
         { info_tbl: [(c8kt7,
                       label: block_c8kt7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kt7: // global
           I64[Sp] = block_c8kte_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kte() //  [R1]
         { info_tbl: [(c8kte,
                       label: block_c8kte_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kte: // global
           if (R1 & 7 == 1) goto u8ktV; else goto c8kty;
       u8ktV: // global
           Sp = Sp + 24;
           call _c8ktL() args: 0, res: 0, upd: 0;
       c8kty: // global
           _s8jfW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8kto_info;
           R1 = _s8jfW::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kto() //  [R1]
         { info_tbl: [(c8kto,
                       label: block_c8kto_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kto: // global
           I64[Sp - 8] = block_c8kts_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kts() //  [R1]
         { info_tbl: [(c8kts,
                       label: block_c8kts_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kts: // global
           I64[Sp] = block_c8ktw_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ktw() //  [R1]
         { info_tbl: [(c8ktw,
                       label: block_c8ktw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ktw: // global
           I64[Sp] = block_c8ktE_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ktE() //  [R1]
         { info_tbl: [(c8ktE,
                       label: block_c8ktE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ktE: // global
           if (R1 & 7 == 1) goto u8ktW; else goto c8ktP;
       u8ktW: // global
           Sp = Sp + 24;
           call _c8ktL() args: 0, res: 0, upd: 0;
       c8ktP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ktS; else goto c8ktR;
       c8ktS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ktR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ktL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ktL: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.022904949 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionToException_closure" {
     GHC.IO.Exception.asyncExceptionToException_closure:
         const GHC.IO.Exception.asyncExceptionToException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionToException_entry() //  [R2, R3]
         { info_tbl: [(c8ku5,
                       label: GHC.IO.Exception.asyncExceptionToException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ku5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ku9; else goto c8ku8;
       c8ku9: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionToException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ku8: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.023781599 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException11_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException11_bytes:
         I8[] [65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.024371434 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException10_closure" {
     GHC.IO.Exception.$fExceptionAsyncException10_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.024921307 UTC

[section ""data" . GHC.IO.Exception.$tcAsyncException_closure" {
     GHC.IO.Exception.$tcAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
         const GHC.Types.krep$*_closure;
         const 3223192752092240512;
         const 6151543105744102738;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.025555367 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow1_closure" {
     GHC.IO.Exception.$tc'HeapOverflow1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.027452376 UTC

[section ""cstring" . GHC.IO.Exception.$tc'StackOverflow2_bytes" {
     GHC.IO.Exception.$tc'StackOverflow2_bytes:
         I8[] [39,83,116,97,99,107,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.02802117 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow1_closure" {
     GHC.IO.Exception.$tc'StackOverflow1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'StackOverflow2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.028567021 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow_closure" {
     GHC.IO.Exception.$tc'StackOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'StackOverflow1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 7140728310745047686;
         const 9210977118047764825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.029144674 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HeapOverflow3_bytes" {
     GHC.IO.Exception.$tc'HeapOverflow3_bytes:
         I8[] [39,72,101,97,112,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.029691356 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow2_closure" {
     GHC.IO.Exception.$tc'HeapOverflow2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HeapOverflow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.030250873 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow_closure" {
     GHC.IO.Exception.$tc'HeapOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow2_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 6603650813243937168;
         const 2046005135570222520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.030858559 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ThreadKilled2_bytes" {
     GHC.IO.Exception.$tc'ThreadKilled2_bytes:
         I8[] [39,84,104,114,101,97,100,75,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.031426499 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled1_closure" {
     GHC.IO.Exception.$tc'ThreadKilled1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ThreadKilled2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.031982805 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled_closure" {
     GHC.IO.Exception.$tc'ThreadKilled_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ThreadKilled1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 13600447017231937444;
         const 101896852196063416;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.032532002 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserInterrupt2_bytes" {
     GHC.IO.Exception.$tc'UserInterrupt2_bytes:
         I8[] [39,85,115,101,114,73,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.033082834 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt1_closure" {
     GHC.IO.Exception.$tc'UserInterrupt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserInterrupt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.033906115 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt_closure" {
     GHC.IO.Exception.$tc'UserInterrupt_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserInterrupt1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 1214873852534998649;
         const 13851718192780849484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.035095399 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException9_closure" {
     GHC.IO.Exception.$fExceptionAsyncException9_closure:
         const GHC.IO.Exception.$fExceptionAsyncException9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException9_entry() //  [R1]
         { info_tbl: [(c8kul,
                       label: GHC.IO.Exception.$fExceptionAsyncException9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kul: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kum; else goto c8kun;
       c8kum: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kun: // global
           (_c8kud::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kud::I64 == 0) goto c8kuf; else goto c8kue;
       c8kuf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kue: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kud::I64;
           I64[Sp - 24] = block_c8kug_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6151543105744102738;
           R2 = 3223192752092240512;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kug() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kug,
                       label: block_c8kug_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kug: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kuh() args: 0, res: 0, upd: 0;
     }
 },
 _c8kuh() //  []
         { info_tbl: [(c8kuh,
                       label: block_c8kuh_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kuq; else goto c8kup;
       c8kuq: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kuh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kup: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.036587598 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException7_bytes" {
     GHC.IO.Exception.$fExceptionArrayException7_bytes:
         I8[] [65,114,114,97,121,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.037109729 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException6_closure" {
     GHC.IO.Exception.$fExceptionArrayException6_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionArrayException7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.037686091 UTC

[section ""data" . GHC.IO.Exception.$tcArrayException_closure" {
     GHC.IO.Exception.$tcArrayException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException6_closure+1;
         const GHC.Types.krep$*_closure;
         const 14361659568498315305;
         const 6805143727974531880;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.038282843 UTC

[section ""data" . $krep19_r8j3z_closure" {
     $krep19_r8j3z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcArrayException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.038840421 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds1_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep19_r8j3z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.039407756 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes" {
     GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes:
         I8[] [39,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.039963211 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds2_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.040557875 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds2_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 14241149568806879436;
         const 10551655754853710333;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.041118485 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UndefinedElement2_bytes" {
     GHC.IO.Exception.$tc'UndefinedElement2_bytes:
         I8[] [39,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.041688507 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement1_closure" {
     GHC.IO.Exception.$tc'UndefinedElement1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UndefinedElement2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.042244398 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement_closure" {
     GHC.IO.Exception.$tc'UndefinedElement_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UndefinedElement1_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 9439210122732754255;
         const 8562757414325900819;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.043439434 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException5_closure" {
     GHC.IO.Exception.$fExceptionArrayException5_closure:
         const GHC.IO.Exception.$fExceptionArrayException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException5_entry() //  [R1]
         { info_tbl: [(c8kuE,
                       label: GHC.IO.Exception.$fExceptionArrayException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuE: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kuF; else goto c8kuG;
       c8kuF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kuG: // global
           (_c8kuw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kuw::I64 == 0) goto c8kuy; else goto c8kux;
       c8kuy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kux: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kuw::I64;
           I64[Sp - 24] = block_c8kuz_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionArrayException6_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6805143727974531880;
           R2 = 14361659568498315305;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kuz() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kuz,
                       label: block_c8kuz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuz: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kuA() args: 0, res: 0, upd: 0;
     }
 },
 _c8kuA() //  []
         { info_tbl: [(c8kuA,
                       label: block_c8kuA_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kuJ; else goto c8kuI;
       c8kuJ: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kuA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kuI: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.046010819 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kuT,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kuX; else goto c8kuY;
       c8kuX: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kuY: // global
           I64[Sp - 8] = block_c8kuQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kvj; else goto c8kuR;
       u8kvj: // global
           call _c8kuQ(R1) args: 0, res: 0, upd: 0;
       c8kuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kuQ() //  [R1]
         { info_tbl: [(c8kuQ,
                       label: block_c8kuQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuQ: // global
           I64[Sp - 8] = block_c8kuW_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kuW() //  [R1]
         { info_tbl: [(c8kuW,
                       label: block_c8kuW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kuW: // global
           I64[Sp] = block_c8kv3_info;
           R3 = GHC.IO.Exception.$fExceptionArrayException5_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kv3() //  [R1]
         { info_tbl: [(c8kv3,
                       label: block_c8kv3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kv3: // global
           if (R1 & 7 == 1) goto c8kva; else goto c8kve;
       c8kva: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kve: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kvh; else goto c8kvg;
       c8kvh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kvg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.04762596 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fShowArrayException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kvp,
                       label: GHC.IO.Exception.$fExceptionArrayException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kvt; else goto c8kvs;
       c8kvt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kvs: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionArrayException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.048502273 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException5_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException5_bytes:
         I8[] [70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.049069512 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException4_closure" {
     GHC.IO.Exception.$fExceptionFixIOException4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.049660131 UTC

[section ""data" . GHC.IO.Exception.$tcFixIOException_closure" {
     GHC.IO.Exception.$tcFixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
         const GHC.Types.krep$*_closure;
         const 175794591112768165;
         const 12820711924146365796;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.050270871 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException1_closure" {
     GHC.IO.Exception.$tc'FixIOException1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcFixIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.050869022 UTC

[section ""cstring" . GHC.IO.Exception.$tc'FixIOException3_bytes" {
     GHC.IO.Exception.$tc'FixIOException3_bytes:
         I8[] [39,70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.051426279 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException2_closure" {
     GHC.IO.Exception.$tc'FixIOException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'FixIOException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.051980552 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException_closure" {
     GHC.IO.Exception.$tc'FixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'FixIOException2_closure+1;
         const GHC.IO.Exception.$tc'FixIOException1_closure+1;
         const 1253631570386628537;
         const 15724415228749653558;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.053084409 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException3_closure" {
     GHC.IO.Exception.$fExceptionFixIOException3_closure:
         const GHC.IO.Exception.$fExceptionFixIOException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException3_entry() //  [R1]
         { info_tbl: [(c8kvF,
                       label: GHC.IO.Exception.$fExceptionFixIOException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvF: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kvG; else goto c8kvH;
       c8kvG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kvH: // global
           (_c8kvx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kvx::I64 == 0) goto c8kvz; else goto c8kvy;
       c8kvz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kvy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kvx::I64;
           I64[Sp - 24] = block_c8kvA_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12820711924146365796;
           R2 = 175794591112768165;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kvA() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kvA,
                       label: block_c8kvA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvA: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kvB() args: 0, res: 0, upd: 0;
     }
 },
 _c8kvB() //  []
         { info_tbl: [(c8kvB,
                       label: block_c8kvB_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kvK; else goto c8kvJ;
       c8kvK: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kvB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kvJ: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.055039732 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kvU,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kvY; else goto c8kvZ;
       c8kvY: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kvZ: // global
           I64[Sp - 8] = block_c8kvR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kwk; else goto c8kvS;
       u8kwk: // global
           call _c8kvR(R1) args: 0, res: 0, upd: 0;
       c8kvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kvR() //  [R1]
         { info_tbl: [(c8kvR,
                       label: block_c8kvR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvR: // global
           I64[Sp - 8] = block_c8kvX_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kvX() //  [R1]
         { info_tbl: [(c8kvX,
                       label: block_c8kvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kvX: // global
           I64[Sp] = block_c8kw4_info;
           R3 = GHC.IO.Exception.$fExceptionFixIOException3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kw4() //  [R1]
         { info_tbl: [(c8kw4,
                       label: block_c8kw4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kw4: // global
           if (R1 & 7 == 1) goto c8kwb; else goto c8kwf;
       c8kwb: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kwf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kwi; else goto c8kwh;
       c8kwi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kwh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.056620557 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fShowFixIOException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kwq,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kwu; else goto c8kwt;
       c8kwu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kwt: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionFixIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.057615949 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode6_bytes" {
     GHC.IO.Exception.$fExceptionExitCode6_bytes:
         I8[] [69,120,105,116,67,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.058209778 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode5_closure" {
     GHC.IO.Exception.$fExceptionExitCode5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionExitCode6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.058796209 UTC

[section ""data" . GHC.IO.Exception.$tcExitCode_closure" {
     GHC.IO.Exception.$tcExitCode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode5_closure+1;
         const GHC.Types.krep$*_closure;
         const 8177210543059932106;
         const 3694335570555580912;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.059418269 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess1_closure" {
     GHC.IO.Exception.$tc'ExitSuccess1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcExitCode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.059976767 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitSuccess3_bytes" {
     GHC.IO.Exception.$tc'ExitSuccess3_bytes:
         I8[] [39,69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.060496834 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess2_closure" {
     GHC.IO.Exception.$tc'ExitSuccess2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitSuccess3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.062151014 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess_closure" {
     GHC.IO.Exception.$tc'ExitSuccess_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess2_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 6011095708053053284;
         const 14896688531190285489;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.062784753 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure1_closure" {
     GHC.IO.Exception.$tc'ExitFailure1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r8j3f_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.063375262 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitFailure3_bytes" {
     GHC.IO.Exception.$tc'ExitFailure3_bytes:
         I8[] [39,69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.06393777 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure2_closure" {
     GHC.IO.Exception.$tc'ExitFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.064468162 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure_closure" {
     GHC.IO.Exception.$tc'ExitFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure2_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure1_closure+4;
         const 13149331685465745995;
         const 10453046320643141131;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.066017032 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode4_closure" {
     GHC.IO.Exception.$fExceptionExitCode4_closure:
         const GHC.IO.Exception.$fExceptionExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode4_entry() //  [R1]
         { info_tbl: [(c8kwG,
                       label: GHC.IO.Exception.$fExceptionExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwG: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kwH; else goto c8kwI;
       c8kwH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kwI: // global
           (_c8kwy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kwy::I64 == 0) goto c8kwA; else goto c8kwz;
       c8kwA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kwz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kwy::I64;
           I64[Sp - 24] = block_c8kwB_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionExitCode5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3694335570555580912;
           R2 = 8177210543059932106;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kwB() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kwB,
                       label: block_c8kwB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwB: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kwC() args: 0, res: 0, upd: 0;
     }
 },
 _c8kwC() //  []
         { info_tbl: [(c8kwC,
                       label: block_c8kwC_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kwL; else goto c8kwK;
       c8kwL: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kwC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kwK: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.06794682 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kwV,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kwZ; else goto c8kx0;
       c8kwZ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kx0: // global
           I64[Sp - 8] = block_c8kwS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kxl; else goto c8kwT;
       u8kxl: // global
           call _c8kwS(R1) args: 0, res: 0, upd: 0;
       c8kwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kwS() //  [R1]
         { info_tbl: [(c8kwS,
                       label: block_c8kwS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwS: // global
           I64[Sp - 8] = block_c8kwY_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kwY() //  [R1]
         { info_tbl: [(c8kwY,
                       label: block_c8kwY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kwY: // global
           I64[Sp] = block_c8kx5_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kx5() //  [R1]
         { info_tbl: [(c8kx5,
                       label: block_c8kx5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kx5: // global
           if (R1 & 7 == 1) goto c8kxc; else goto c8kxg;
       c8kxc: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kxg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kxj; else goto c8kxi;
       c8kxj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kxi: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.071473637 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_closure" {
     GHC.IO.Exception.$fExceptionExitCode_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fShowExitCode_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kxr,
                       label: GHC.IO.Exception.$fExceptionExitCode_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kxv; else goto c8kxu;
       c8kxv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kxu: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionExitCode_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.072623017 UTC

[section ""cstring" . GHC.IO.Exception.$tcIOErrorType2_bytes" {
     GHC.IO.Exception.$tcIOErrorType2_bytes:
         I8[] [73,79,69,114,114,111,114,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.073521142 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType1_closure" {
     GHC.IO.Exception.$tcIOErrorType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tcIOErrorType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.074229499 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType_closure" {
     GHC.IO.Exception.$tcIOErrorType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tcIOErrorType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13260403802836574836;
         const 9962456285013293537;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.074876923 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists1_closure" {
     GHC.IO.Exception.$tc'AlreadyExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOErrorType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.075512145 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AlreadyExists3_bytes" {
     GHC.IO.Exception.$tc'AlreadyExists3_bytes:
         I8[] [39,65,108,114,101,97,100,121,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.076113112 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists2_closure" {
     GHC.IO.Exception.$tc'AlreadyExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.076743817 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists_closure" {
     GHC.IO.Exception.$tc'AlreadyExists_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists2_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 13383994725479033447;
         const 16077735236426702934;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.077567311 UTC

[section ""cstring" . GHC.IO.Exception.$tc'NoSuchThing2_bytes" {
     GHC.IO.Exception.$tc'NoSuchThing2_bytes:
         I8[] [39,78,111,83,117,99,104,84,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.078290841 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing1_closure" {
     GHC.IO.Exception.$tc'NoSuchThing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'NoSuchThing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.078960127 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing_closure" {
     GHC.IO.Exception.$tc'NoSuchThing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'NoSuchThing1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 1065788776620214811;
         const 7708272823769791518;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.079641604 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceBusy2_bytes" {
     GHC.IO.Exception.$tc'ResourceBusy2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,66,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.080238751 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy1_closure" {
     GHC.IO.Exception.$tc'ResourceBusy1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceBusy2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.080904933 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy_closure" {
     GHC.IO.Exception.$tc'ResourceBusy_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceBusy1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 81041156937828521;
         const 16732677038738772765;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.081743045 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceExhausted2_bytes" {
     GHC.IO.Exception.$tc'ResourceExhausted2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.082436427 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted1_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceExhausted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.083091379 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceExhausted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 661664682644939150;
         const 17978068149744050586;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.0837935 UTC

[section ""cstring" . GHC.IO.Exception.$tc'EOF2_bytes" {
     GHC.IO.Exception.$tc'EOF2_bytes:
         I8[] [39,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.084476605 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF1_closure" {
     GHC.IO.Exception.$tc'EOF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'EOF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.085199589 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF_closure" {
     GHC.IO.Exception.$tc'EOF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'EOF1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 15446447841260182649;
         const 9615135582901540009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.085923328 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IllegalOperation2_bytes" {
     GHC.IO.Exception.$tc'IllegalOperation2_bytes:
         I8[] [39,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.086492738 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation1_closure" {
     GHC.IO.Exception.$tc'IllegalOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IllegalOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.087185149 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation_closure" {
     GHC.IO.Exception.$tc'IllegalOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IllegalOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2997750042243464947;
         const 13732497530673208550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.087906386 UTC

[section ""cstring" . GHC.IO.Exception.$tc'PermissionDenied2_bytes" {
     GHC.IO.Exception.$tc'PermissionDenied2_bytes:
         I8[] [39,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.088554818 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied1_closure" {
     GHC.IO.Exception.$tc'PermissionDenied1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'PermissionDenied2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.08933391 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied_closure" {
     GHC.IO.Exception.$tc'PermissionDenied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'PermissionDenied1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17002959889944859215;
         const 11679101384562499698;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.090128899 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserError2_bytes" {
     GHC.IO.Exception.$tc'UserError2_bytes:
         I8[] [39,85,115,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.090792174 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError1_closure" {
     GHC.IO.Exception.$tc'UserError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.091430113 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError_closure" {
     GHC.IO.Exception.$tc'UserError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2110707588451626880;
         const 793010194601470118;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.092080794 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes:
         I8[] [39,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.092698565 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.093462418 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 7774786765253276509;
         const 11159080782866109022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.094185536 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SystemError2_bytes" {
     GHC.IO.Exception.$tc'SystemError2_bytes:
         I8[] [39,83,121,115,116,101,109,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.094936827 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError1_closure" {
     GHC.IO.Exception.$tc'SystemError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SystemError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.095640565 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError_closure" {
     GHC.IO.Exception.$tc'SystemError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SystemError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14723310935893761222;
         const 8619015840207109406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.096379227 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ProtocolError2_bytes" {
     GHC.IO.Exception.$tc'ProtocolError2_bytes:
         I8[] [39,80,114,111,116,111,99,111,108,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.098191943 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError1_closure" {
     GHC.IO.Exception.$tc'ProtocolError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ProtocolError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.098952588 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError_closure" {
     GHC.IO.Exception.$tc'ProtocolError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ProtocolError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2348878698518162749;
         const 1616623917153004368;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.099616017 UTC

[section ""cstring" . GHC.IO.Exception.$tc'OtherError2_bytes" {
     GHC.IO.Exception.$tc'OtherError2_bytes:
         I8[] [39,79,116,104,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.100307273 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError1_closure" {
     GHC.IO.Exception.$tc'OtherError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'OtherError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.100869268 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError_closure" {
     GHC.IO.Exception.$tc'OtherError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'OtherError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 11457353566076247204;
         const 7448318885269020484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.101622271 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InvalidArgument2_bytes" {
     GHC.IO.Exception.$tc'InvalidArgument2_bytes:
         I8[] [39,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.102362297 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument1_closure" {
     GHC.IO.Exception.$tc'InvalidArgument1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InvalidArgument2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.102991876 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument_closure" {
     GHC.IO.Exception.$tc'InvalidArgument_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InvalidArgument1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2877905627043716713;
         const 870624010466166536;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.103815576 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InappropriateType2_bytes" {
     GHC.IO.Exception.$tc'InappropriateType2_bytes:
         I8[] [39,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.104450693 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType1_closure" {
     GHC.IO.Exception.$tc'InappropriateType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InappropriateType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.105089898 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType_closure" {
     GHC.IO.Exception.$tc'InappropriateType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InappropriateType1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 12194312324817842633;
         const 15900888301186079347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.106216355 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HardwareFault2_bytes" {
     GHC.IO.Exception.$tc'HardwareFault2_bytes:
         I8[] [39,72,97,114,100,119,97,114,101,70,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.106784282 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault1_closure" {
     GHC.IO.Exception.$tc'HardwareFault1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HardwareFault2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.107353681 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault_closure" {
     GHC.IO.Exception.$tc'HardwareFault_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HardwareFault1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 56378797976289033;
         const 18431513512258190916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.107970428 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsupportedOperation2_bytes" {
     GHC.IO.Exception.$tc'UnsupportedOperation2_bytes:
         I8[] [39,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.108530847 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation1_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsupportedOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.109064631 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsupportedOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 8512525638220727204;
         const 8859286885870192330;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.109680185 UTC

[section ""cstring" . GHC.IO.Exception.$tc'TimeExpired2_bytes" {
     GHC.IO.Exception.$tc'TimeExpired2_bytes:
         I8[] [39,84,105,109,101,69,120,112,105,114,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.110232128 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired1_closure" {
     GHC.IO.Exception.$tc'TimeExpired1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'TimeExpired2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.110757767 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired_closure" {
     GHC.IO.Exception.$tc'TimeExpired_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'TimeExpired1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 10911629093425571025;
         const 350480745296812363;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.111349015 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceVanished2_bytes" {
     GHC.IO.Exception.$tc'ResourceVanished2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.111845623 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished1_closure" {
     GHC.IO.Exception.$tc'ResourceVanished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceVanished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.11241691 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished_closure" {
     GHC.IO.Exception.$tc'ResourceVanished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceVanished1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14859807110076739958;
         const 15612633629389469803;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.113001791 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Interrupted2_bytes" {
     GHC.IO.Exception.$tc'Interrupted2_bytes:
         I8[] [39,73,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.113611554 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted1_closure" {
     GHC.IO.Exception.$tc'Interrupted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Interrupted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.114185655 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted_closure" {
     GHC.IO.Exception.$tc'Interrupted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Interrupted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17492795632142579451;
         const 15910845476779721305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.114813642 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException6_bytes" {
     GHC.IO.Exception.$fExceptionIOException6_bytes:
         I8[] [73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.115381441 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException5_closure" {
     GHC.IO.Exception.$fExceptionIOException5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionIOException6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.115957906 UTC

[section ""data" . GHC.IO.Exception.$tcIOException_closure" {
     GHC.IO.Exception.$tcIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionIOException5_closure+1;
         const GHC.Types.krep$*_closure;
         const 10434000377887324342;
         const 16509375198449321302;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.116583263 UTC

[section ""data" . $krep20_r8j3A_closure" {
     $krep20_r8j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.117193362 UTC

[section ""data" . $krep21_r8j3B_closure" {
     $krep21_r8j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8j3q_closure+1;
         const $krep20_r8j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.118315318 UTC

[section ""data" . $krep22_r8j3C_closure" {
     $krep22_r8j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8j3k_closure+1;
         const $krep21_r8j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.118904387 UTC

[section ""data" . $krep23_r8j3D_closure" {
     $krep23_r8j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep22_r8j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.119526171 UTC

[section ""data" . $krep24_r8j3E_closure" {
     $krep24_r8j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep23_r8j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.120097203 UTC

[section ""data" . $krep25_r8j3F_closure" {
     $krep25_r8j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const $krep24_r8j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.12067066 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError1_closure" {
     GHC.IO.Exception.$tc'IOError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8j3m_closure+1;
         const $krep25_r8j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.121258495 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IOError3_bytes" {
     GHC.IO.Exception.$tc'IOError3_bytes:
         I8[] [39,73,79,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.121823641 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError2_closure" {
     GHC.IO.Exception.$tc'IOError2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IOError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.122408969 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError_closure" {
     GHC.IO.Exception.$tc'IOError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IOError2_closure+1;
         const GHC.IO.Exception.$tc'IOError1_closure+4;
         const 16489485703680136625;
         const 16514523686887444952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.123645393 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException4_closure" {
     GHC.IO.Exception.$fExceptionIOException4_closure:
         const GHC.IO.Exception.$fExceptionIOException4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException4_entry() //  [R1]
         { info_tbl: [(c8kxH,
                       label: GHC.IO.Exception.$fExceptionIOException4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxH: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8kxI; else goto c8kxJ;
       c8kxI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kxJ: // global
           (_c8kxz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kxz::I64 == 0) goto c8kxB; else goto c8kxA;
       c8kxB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kxA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kxz::I64;
           I64[Sp - 24] = block_c8kxC_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionIOException5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 16509375198449321302;
           R2 = 10434000377887324342;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8kxC() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8kxC,
                       label: block_c8kxC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxC: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8kxD() args: 0, res: 0, upd: 0;
     }
 },
 _c8kxD() //  []
         { info_tbl: [(c8kxD,
                       label: block_c8kxD_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8kxM; else goto c8kxL;
       c8kxM: // global
           HpAlloc = 48;
           I64[Sp] = block_c8kxD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8kxL: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.12567394 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kxW,
                       label: GHC.IO.Exception.$fExceptionIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ky0; else goto c8ky1;
       c8ky0: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ky1: // global
           I64[Sp - 8] = block_c8kxT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kym; else goto c8kxU;
       u8kym: // global
           call _c8kxT(R1) args: 0, res: 0, upd: 0;
       c8kxU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kxT() //  [R1]
         { info_tbl: [(c8kxT,
                       label: block_c8kxT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxT: // global
           I64[Sp - 8] = block_c8kxZ_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kxZ() //  [R1]
         { info_tbl: [(c8kxZ,
                       label: block_c8kxZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kxZ: // global
           I64[Sp] = block_c8ky6_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ky6() //  [R1]
         { info_tbl: [(c8ky6,
                       label: block_c8ky6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ky6: // global
           if (R1 & 7 == 1) goto c8kyd; else goto c8kyh;
       c8kyd: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kyh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kyk; else goto c8kyj;
       c8kyk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kyj: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.127299252 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_closure" {
     GHC.IO.Exception.$fExceptionIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Exception.$fShowIOException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kys,
                       label: GHC.IO.Exception.$fExceptionIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kys: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kyw; else goto c8kyv;
       c8kyw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kyv: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.129864737 UTC

[section ""data" . GHC.IO.Exception.ioError1_closure" {
     GHC.IO.Exception.ioError1_closure:
         const GHC.IO.Exception.ioError1_info;
         const 0;
 },
 sat_s8jh2_entry() //  [R1]
         { info_tbl: [(c8kyF,
                       label: sat_s8jh2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kyF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kyG; else goto c8kyH;
       c8kyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.ioError1_entry() //  [R2]
         { info_tbl: [(c8kyI,
                       label: GHC.IO.Exception.ioError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kyI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kyM; else goto c8kyL;
       c8kyM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.ioError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kyL: // global
           I64[Hp - 16] = sat_s8jh2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.131071636 UTC

[section ""data" . GHC.IO.Exception.ioException_closure" {
     GHC.IO.Exception.ioException_closure:
         const GHC.IO.Exception.ioException_info;
         const 0;
 },
 GHC.IO.Exception.ioException_entry() //  [R2]
         { info_tbl: [(c8kyR,
                       label: GHC.IO.Exception.ioException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kyR: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.131913904 UTC

[section ""data" . GHC.IO.Exception.ioError_closure" {
     GHC.IO.Exception.ioError_closure:
         const GHC.IO.Exception.ioError_info;
         const 0;
 },
 GHC.IO.Exception.ioError_entry() //  [R2]
         { info_tbl: [(c8kyY,
                       label: GHC.IO.Exception.ioError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kyY: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.13262551 UTC

[section ""data" . GHC.IO.Exception.$fxExceptionIOException_closure" {
     GHC.IO.Exception.$fxExceptionIOException_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Exception.$fExceptionIOException_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.133705945 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kz8,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kz8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kzc; else goto c8kzd;
       c8kzc: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kzd: // global
           I64[Sp - 8] = block_c8kz5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kzy; else goto c8kz6;
       u8kzy: // global
           call _c8kz5(R1) args: 0, res: 0, upd: 0;
       c8kz6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kz5() //  [R1]
         { info_tbl: [(c8kz5,
                       label: block_c8kz5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kz5: // global
           I64[Sp - 8] = block_c8kzb_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kzb() //  [R1]
         { info_tbl: [(c8kzb,
                       label: block_c8kzb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzb: // global
           I64[Sp] = block_c8kzi_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kzi() //  [R1]
         { info_tbl: [(c8kzi,
                       label: block_c8kzi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzi: // global
           if (R1 & 7 == 1) goto c8kzp; else goto c8kzt;
       c8kzp: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kzt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kzw; else goto c8kzv;
       c8kzw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kzv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.135294179 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kzE,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kzI; else goto c8kzH;
       c8kzI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kzH: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.136407141 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnMVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnMVar_entry() //  [R1]
         { info_tbl: [(c8kzP,
                       label: GHC.IO.Exception.blockedIndefinitelyOnMVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kzQ; else goto c8kzR;
       c8kzQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kzR: // global
           (_c8kzM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kzM::I64 == 0) goto c8kzO; else goto c8kzN;
       c8kzO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kzN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kzM::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.137753925 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kzZ,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kA3; else goto c8kA4;
       c8kA3: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kA4: // global
           I64[Sp - 8] = block_c8kzW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kAp; else goto c8kzX;
       u8kAp: // global
           call _c8kzW(R1) args: 0, res: 0, upd: 0;
       c8kzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kzW() //  [R1]
         { info_tbl: [(c8kzW,
                       label: block_c8kzW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kzW: // global
           I64[Sp - 8] = block_c8kA2_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kA2() //  [R1]
         { info_tbl: [(c8kA2,
                       label: block_c8kA2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kA2: // global
           I64[Sp] = block_c8kA9_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kA9() //  [R1]
         { info_tbl: [(c8kA9,
                       label: block_c8kA9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kA9: // global
           if (R1 & 7 == 1) goto c8kAg; else goto c8kAk;
       c8kAg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kAk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kAn; else goto c8kAm;
       c8kAn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kAm: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.139285345 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kAv,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kAv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kAz; else goto c8kAy;
       c8kAz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kAy: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.14034912 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnSTM_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnSTM_entry() //  [R1]
         { info_tbl: [(c8kAG,
                       label: GHC.IO.Exception.blockedIndefinitelyOnSTM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kAG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kAH; else goto c8kAI;
       c8kAH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kAI: // global
           (_c8kAD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kAD::I64 == 0) goto c8kAF; else goto c8kAE;
       c8kAF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kAE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kAD::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.141868076 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8kBH_srtd" {
     u8kBH_srtd:
         const S8ji8_srt+688;
         const 35;
         const 25771900929;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kAQ,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kAQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kAU; else goto c8kAV;
       c8kAU: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kAV: // global
           I64[Sp - 8] = block_c8kAN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kBE; else goto c8kAO;
       u8kBE: // global
           call _c8kAN(R1) args: 0, res: 0, upd: 0;
       c8kAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8kBI_srtd" {
     u8kBI_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8kAN() //  [R1]
         { info_tbl: [(c8kAN,
                       label: block_c8kAN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kAN: // global
           I64[Sp - 8] = block_c8kAT_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8kBJ_srtd" {
     u8kBJ_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8kAT() //  [R1]
         { info_tbl: [(c8kAT,
                       label: block_c8kAT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kAT: // global
           I64[Sp] = block_c8kB0_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kB0() //  [R1]
         { info_tbl: [(c8kB0,
                       label: block_c8kB0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kB0: // global
           if (R1 & 7 == 1) goto u8kBC; else goto c8kBg;
       u8kBC: // global
           Sp = Sp + 16;
           call _c8kBs() args: 0, res: 0, upd: 0;
       c8kBg: // global
           _s8jhi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8kBa_info;
           R1 = _s8jhi::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kBa() //  [R1]
         { info_tbl: [(c8kBa,
                       label: block_c8kBa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kBa: // global
           I64[Sp - 8] = block_c8kBe_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kBe() //  [R1]
         { info_tbl: [(c8kBe,
                       label: block_c8kBe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kBe: // global
           I64[Sp] = block_c8kBl_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kBl() //  [R1]
         { info_tbl: [(c8kBl,
                       label: block_c8kBl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kBl: // global
           if (R1 & 7 == 1) goto u8kBD; else goto c8kBw;
       u8kBD: // global
           Sp = Sp + 16;
           call _c8kBs() args: 0, res: 0, upd: 0;
       c8kBw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kBz; else goto c8kBy;
       c8kBz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kBy: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kBs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kBs: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.144086443 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kBP,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kBP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kBT; else goto c8kBS;
       c8kBT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kBS: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.145216728 UTC

[section ""data" . GHC.IO.Exception.allocationLimitExceeded_closure" {
     GHC.IO.Exception.allocationLimitExceeded_closure:
         const GHC.IO.Exception.allocationLimitExceeded_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.allocationLimitExceeded_entry() //  [R1]
         { info_tbl: [(c8kC0,
                       label: GHC.IO.Exception.allocationLimitExceeded_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kC1; else goto c8kC2;
       c8kC1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kC2: // global
           (_c8kBX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kBX::I64 == 0) goto c8kBZ; else goto c8kBY;
       c8kBZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kBY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kBX::I64;
           R2 = GHC.IO.Exception.AllocationLimitExceeded_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.146538293 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kCa,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kCa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kCe; else goto c8kCf;
       c8kCe: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kCf: // global
           I64[Sp - 8] = block_c8kC7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kCA; else goto c8kC8;
       u8kCA: // global
           call _c8kC7(R1) args: 0, res: 0, upd: 0;
       c8kC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kC7() //  [R1]
         { info_tbl: [(c8kC7,
                       label: block_c8kC7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kC7: // global
           I64[Sp - 8] = block_c8kCd_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kCd() //  [R1]
         { info_tbl: [(c8kCd,
                       label: block_c8kCd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kCd: // global
           I64[Sp] = block_c8kCk_info;
           R3 = GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kCk() //  [R1]
         { info_tbl: [(c8kCk,
                       label: block_c8kCk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kCk: // global
           if (R1 & 7 == 1) goto c8kCr; else goto c8kCv;
       c8kCr: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kCv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kCy; else goto c8kCx;
       c8kCy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kCx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.148158354 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fShowCompactionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kCG,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kCG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kCK; else goto c8kCJ;
       c8kCK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kCJ: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionCompactionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.149019146 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactMutable2_bytes" {
     GHC.IO.Exception.cannotCompactMutable2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,109,117,116,97,98,108,101,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.149778962 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable1_closure" {
     GHC.IO.Exception.cannotCompactMutable1_closure:
         const GHC.IO.Exception.cannotCompactMutable1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable1_entry() //  [R1]
         { info_tbl: [(c8kCR,
                       label: GHC.IO.Exception.cannotCompactMutable1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kCR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kCS; else goto c8kCT;
       c8kCS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kCT: // global
           (_c8kCO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kCO::I64 == 0) goto c8kCQ; else goto c8kCP;
       c8kCQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kCP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kCO::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.150828913 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable_closure" {
     GHC.IO.Exception.cannotCompactMutable_closure:
         const GHC.IO.Exception.cannotCompactMutable_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable_entry() //  [R1]
         { info_tbl: [(c8kD0,
                       label: GHC.IO.Exception.cannotCompactMutable_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kD0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kD1; else goto c8kD2;
       c8kD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kD2: // global
           (_c8kCX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kCX::I64 == 0) goto c8kCZ; else goto c8kCY;
       c8kCZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kCY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kCX::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.151783011 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactPinned2_bytes" {
     GHC.IO.Exception.cannotCompactPinned2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,112,105,110,110,101,100,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.152487237 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned1_closure" {
     GHC.IO.Exception.cannotCompactPinned1_closure:
         const GHC.IO.Exception.cannotCompactPinned1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned1_entry() //  [R1]
         { info_tbl: [(c8kD9,
                       label: GHC.IO.Exception.cannotCompactPinned1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kD9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kDa; else goto c8kDb;
       c8kDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kDb: // global
           (_c8kD6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kD6::I64 == 0) goto c8kD8; else goto c8kD7;
       c8kD8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kD7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kD6::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.153593478 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned_closure" {
     GHC.IO.Exception.cannotCompactPinned_closure:
         const GHC.IO.Exception.cannotCompactPinned_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned_entry() //  [R1]
         { info_tbl: [(c8kDi,
                       label: GHC.IO.Exception.cannotCompactPinned_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kDj; else goto c8kDk;
       c8kDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kDk: // global
           (_c8kDf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kDf::I64 == 0) goto c8kDh; else goto c8kDg;
       c8kDh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kDg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kDf::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.154498624 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactFunction2_bytes" {
     GHC.IO.Exception.cannotCompactFunction2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,102,117,110,99,116,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.155193913 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction1_closure" {
     GHC.IO.Exception.cannotCompactFunction1_closure:
         const GHC.IO.Exception.cannotCompactFunction1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction1_entry() //  [R1]
         { info_tbl: [(c8kDr,
                       label: GHC.IO.Exception.cannotCompactFunction1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kDs; else goto c8kDt;
       c8kDs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kDt: // global
           (_c8kDo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kDo::I64 == 0) goto c8kDq; else goto c8kDp;
       c8kDq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kDp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kDo::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.156241745 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction_closure" {
     GHC.IO.Exception.cannotCompactFunction_closure:
         const GHC.IO.Exception.cannotCompactFunction_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction_entry() //  [R1]
         { info_tbl: [(c8kDA,
                       label: GHC.IO.Exception.cannotCompactFunction_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kDB; else goto c8kDC;
       c8kDB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kDC: // global
           (_c8kDx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kDx::I64 == 0) goto c8kDz; else goto c8kDy;
       c8kDz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kDy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kDx::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.157856718 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8kEB_srtd" {
     u8kEB_srtd:
         const S8ji8_srt+688;
         const 47;
         const 105553118363649;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8kDK,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kDO; else goto c8kDP;
       c8kDO: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kDP: // global
           I64[Sp - 8] = block_c8kDH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kEy; else goto c8kDI;
       u8kEy: // global
           call _c8kDH(R1) args: 0, res: 0, upd: 0;
       c8kDI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8kEC_srtd" {
     u8kEC_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8kDH() //  [R1]
         { info_tbl: [(c8kDH,
                       label: block_c8kDH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDH: // global
           I64[Sp - 8] = block_c8kDN_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8kED_srtd" {
     u8kED_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8kDN() //  [R1]
         { info_tbl: [(c8kDN,
                       label: block_c8kDN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDN: // global
           I64[Sp] = block_c8kDU_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kDU() //  [R1]
         { info_tbl: [(c8kDU,
                       label: block_c8kDU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kDU: // global
           if (R1 & 7 == 1) goto u8kEw; else goto c8kEa;
       u8kEw: // global
           Sp = Sp + 16;
           call _c8kEm() args: 0, res: 0, upd: 0;
       c8kEa: // global
           _s8jhB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8kE4_info;
           R1 = _s8jhB::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kE4() //  [R1]
         { info_tbl: [(c8kE4,
                       label: block_c8kE4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kE4: // global
           I64[Sp - 8] = block_c8kE8_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kE8() //  [R1]
         { info_tbl: [(c8kE8,
                       label: block_c8kE8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kE8: // global
           I64[Sp] = block_c8kEf_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kEf() //  [R1]
         { info_tbl: [(c8kEf,
                       label: block_c8kEf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kEf: // global
           if (R1 & 7 == 1) goto u8kEx; else goto c8kEq;
       u8kEx: // global
           Sp = Sp + 16;
           call _c8kEm() args: 0, res: 0, upd: 0;
       c8kEq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kEt; else goto c8kEs;
       c8kEt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kEs: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8kEm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kEm: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.160070856 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fShowAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8kEJ,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kEJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kEN; else goto c8kEM;
       c8kEN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kEM: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAsyncException_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.161169802 UTC

[section ""data" . GHC.IO.Exception.heapOverflow_closure" {
     GHC.IO.Exception.heapOverflow_closure:
         const GHC.IO.Exception.heapOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.heapOverflow_entry() //  [R1]
         { info_tbl: [(c8kEU,
                       label: GHC.IO.Exception.heapOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kEU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kEV; else goto c8kEW;
       c8kEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kEW: // global
           (_c8kER::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kER::I64 == 0) goto c8kET; else goto c8kES;
       c8kET: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kES: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kER::I64;
           R2 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.162237824 UTC

[section ""data" . GHC.IO.Exception.stackOverflow_closure" {
     GHC.IO.Exception.stackOverflow_closure:
         const GHC.IO.Exception.stackOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.stackOverflow_entry() //  [R1]
         { info_tbl: [(c8kF3,
                       label: GHC.IO.Exception.stackOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kF3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kF4; else goto c8kF5;
       c8kF4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kF5: // global
           (_c8kF0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kF0::I64 == 0) goto c8kF2; else goto c8kF1;
       c8kF2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kF1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kF0::I64;
           R2 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.163388542 UTC

[section ""data" . GHC.IO.Exception.IOError_closure" {
     GHC.IO.Exception.IOError_closure:
         const GHC.IO.Exception.IOError_info;
 },
 GHC.IO.Exception.IOError_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8kFb,
                       label: GHC.IO.Exception.IOError_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8kFf; else goto c8kFe;
       c8kFf: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.IOError_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8kFe: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.16446487 UTC

[section ""data" . GHC.IO.Exception.AlreadyExists_closure" {
     GHC.IO.Exception.AlreadyExists_closure:
         const GHC.IO.Exception.AlreadyExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.165151943 UTC

[section ""data" . GHC.IO.Exception.NoSuchThing_closure" {
     GHC.IO.Exception.NoSuchThing_closure:
         const GHC.IO.Exception.NoSuchThing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.165912612 UTC

[section ""data" . GHC.IO.Exception.ResourceBusy_closure" {
     GHC.IO.Exception.ResourceBusy_closure:
         const GHC.IO.Exception.ResourceBusy_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.166586567 UTC

[section ""data" . GHC.IO.Exception.ResourceExhausted_closure" {
     GHC.IO.Exception.ResourceExhausted_closure:
         const GHC.IO.Exception.ResourceExhausted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.167273082 UTC

[section ""data" . GHC.IO.Exception.EOF_closure" {
     GHC.IO.Exception.EOF_closure:
         const GHC.IO.Exception.EOF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.167986931 UTC

[section ""data" . GHC.IO.Exception.IllegalOperation_closure" {
     GHC.IO.Exception.IllegalOperation_closure:
         const GHC.IO.Exception.IllegalOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.168704566 UTC

[section ""data" . GHC.IO.Exception.PermissionDenied_closure" {
     GHC.IO.Exception.PermissionDenied_closure:
         const GHC.IO.Exception.PermissionDenied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.169437289 UTC

[section ""data" . GHC.IO.Exception.UserError_closure" {
     GHC.IO.Exception.UserError_closure:
         const GHC.IO.Exception.UserError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.170046378 UTC

[section ""data" . GHC.IO.Exception.UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.UnsatisfiedConstraints_closure:
         const GHC.IO.Exception.UnsatisfiedConstraints_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.17074875 UTC

[section ""data" . GHC.IO.Exception.SystemError_closure" {
     GHC.IO.Exception.SystemError_closure:
         const GHC.IO.Exception.SystemError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.171331068 UTC

[section ""data" . GHC.IO.Exception.ProtocolError_closure" {
     GHC.IO.Exception.ProtocolError_closure:
         const GHC.IO.Exception.ProtocolError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.171985783 UTC

[section ""data" . GHC.IO.Exception.OtherError_closure" {
     GHC.IO.Exception.OtherError_closure:
         const GHC.IO.Exception.OtherError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.17274839 UTC

[section ""data" . GHC.IO.Exception.InvalidArgument_closure" {
     GHC.IO.Exception.InvalidArgument_closure:
         const GHC.IO.Exception.InvalidArgument_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.17372473 UTC

[section ""data" . GHC.IO.Exception.InappropriateType_closure" {
     GHC.IO.Exception.InappropriateType_closure:
         const GHC.IO.Exception.InappropriateType_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.175644032 UTC

[section ""data" . GHC.IO.Exception.HardwareFault_closure" {
     GHC.IO.Exception.HardwareFault_closure:
         const GHC.IO.Exception.HardwareFault_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.176153935 UTC

[section ""data" . GHC.IO.Exception.UnsupportedOperation_closure" {
     GHC.IO.Exception.UnsupportedOperation_closure:
         const GHC.IO.Exception.UnsupportedOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.176722356 UTC

[section ""data" . GHC.IO.Exception.TimeExpired_closure" {
     GHC.IO.Exception.TimeExpired_closure:
         const GHC.IO.Exception.TimeExpired_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.177340937 UTC

[section ""data" . GHC.IO.Exception.ResourceVanished_closure" {
     GHC.IO.Exception.ResourceVanished_closure:
         const GHC.IO.Exception.ResourceVanished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.177915476 UTC

[section ""data" . GHC.IO.Exception.Interrupted_closure" {
     GHC.IO.Exception.Interrupted_closure:
         const GHC.IO.Exception.Interrupted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.178436595 UTC

[section ""data" . GHC.IO.Exception.ExitSuccess_closure" {
     GHC.IO.Exception.ExitSuccess_closure:
         const GHC.IO.Exception.ExitSuccess_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.179318611 UTC

[section ""data" . GHC.IO.Exception.ExitFailure_closure" {
     GHC.IO.Exception.ExitFailure_closure:
         const GHC.IO.Exception.ExitFailure_info;
 },
 GHC.IO.Exception.ExitFailure_entry() //  [R2]
         { info_tbl: [(c8kFl,
                       label: GHC.IO.Exception.ExitFailure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kFp; else goto c8kFo;
       c8kFp: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.ExitFailure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kFo: // global
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.180192619 UTC

[section ""data" . GHC.IO.Exception.FixIOException_closure" {
     GHC.IO.Exception.FixIOException_closure:
         const GHC.IO.Exception.FixIOException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.18090572 UTC

[section ""data" . GHC.IO.Exception.IndexOutOfBounds_closure" {
     GHC.IO.Exception.IndexOutOfBounds_closure:
         const GHC.IO.Exception.IndexOutOfBounds_info;
 },
 GHC.IO.Exception.IndexOutOfBounds_entry() //  [R2]
         { info_tbl: [(c8kFv,
                       label: GHC.IO.Exception.IndexOutOfBounds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kFz; else goto c8kFy;
       c8kFz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.IndexOutOfBounds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kFy: // global
           I64[Hp - 8] = GHC.IO.Exception.IndexOutOfBounds_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.181894173 UTC

[section ""data" . GHC.IO.Exception.UndefinedElement_closure" {
     GHC.IO.Exception.UndefinedElement_closure:
         const GHC.IO.Exception.UndefinedElement_info;
 },
 GHC.IO.Exception.UndefinedElement_entry() //  [R2]
         { info_tbl: [(c8kFF,
                       label: GHC.IO.Exception.UndefinedElement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8kFJ; else goto c8kFI;
       c8kFJ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.UndefinedElement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kFI: // global
           I64[Hp - 8] = GHC.IO.Exception.UndefinedElement_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.182709756 UTC

[section ""data" . GHC.IO.Exception.StackOverflow_closure" {
     GHC.IO.Exception.StackOverflow_closure:
         const GHC.IO.Exception.StackOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.183277881 UTC

[section ""data" . GHC.IO.Exception.HeapOverflow_closure" {
     GHC.IO.Exception.HeapOverflow_closure:
         const GHC.IO.Exception.HeapOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.183861216 UTC

[section ""data" . GHC.IO.Exception.ThreadKilled_closure" {
     GHC.IO.Exception.ThreadKilled_closure:
         const GHC.IO.Exception.ThreadKilled_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.184370954 UTC

[section ""data" . GHC.IO.Exception.UserInterrupt_closure" {
     GHC.IO.Exception.UserInterrupt_closure:
         const GHC.IO.Exception.UserInterrupt_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.185162917 UTC

[section ""data" . GHC.IO.Exception.SomeAsyncException_closure" {
     GHC.IO.Exception.SomeAsyncException_closure:
         const GHC.IO.Exception.SomeAsyncException_info;
 },
 GHC.IO.Exception.SomeAsyncException_entry() //  [R2, R3]
         { info_tbl: [(c8kFP,
                       label: GHC.IO.Exception.SomeAsyncException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kFT; else goto c8kFS;
       c8kFT: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.SomeAsyncException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kFS: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.186731037 UTC

[section ""data" . GHC.IO.Exception.AllocationLimitExceeded_closure" {
     GHC.IO.Exception.AllocationLimitExceeded_closure:
         const GHC.IO.Exception.AllocationLimitExceeded_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.187270599 UTC

[section ""data" . GHC.IO.Exception.Deadlock_closure" {
     GHC.IO.Exception.Deadlock_closure:
         const GHC.IO.Exception.Deadlock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.187832297 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.188410039 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.189047678 UTC

[GHC.IO.Exception.IOError_con_entry() //  [R1]
         { info_tbl: [(c8kFU,
                       label: GHC.IO.Exception.IOError_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,79,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.189802643 UTC

[section ""relreadonly" . GHC.IO.Exception.IOErrorType_closure_tbl" {
     GHC.IO.Exception.IOErrorType_closure_tbl:
         const GHC.IO.Exception.AlreadyExists_closure+1;
         const GHC.IO.Exception.NoSuchThing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.IO.Exception.PermissionDenied_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.IO.Exception.UnsatisfiedConstraints_closure+1;
         const GHC.IO.Exception.SystemError_closure+1;
         const GHC.IO.Exception.ProtocolError_closure+1;
         const GHC.IO.Exception.OtherError_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Exception.HardwareFault_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.IO.Exception.TimeExpired_closure+1;
         const GHC.IO.Exception.ResourceVanished_closure+1;
         const GHC.IO.Exception.Interrupted_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.190582041 UTC

[GHC.IO.Exception.AlreadyExists_con_entry() //  [R1]
         { info_tbl: [(c8kFV,
                       label: GHC.IO.Exception.AlreadyExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,114,101,97,100,121,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.191286009 UTC

[GHC.IO.Exception.NoSuchThing_con_entry() //  [R1]
         { info_tbl: [(c8kFW,
                       label: GHC.IO.Exception.NoSuchThing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,78,111,83,117,99,104,84,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFW: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.192013774 UTC

[GHC.IO.Exception.ResourceBusy_con_entry() //  [R1]
         { info_tbl: [(c8kFX,
                       label: GHC.IO.Exception.ResourceBusy_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,66,117,115,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.192768941 UTC

[GHC.IO.Exception.ResourceExhausted_con_entry() //  [R1]
         { info_tbl: [(c8kFY,
                       label: GHC.IO.Exception.ResourceExhausted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.193535388 UTC

[GHC.IO.Exception.EOF_con_entry() //  [R1]
         { info_tbl: [(c8kFZ,
                       label: GHC.IO.Exception.EOF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,79,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kFZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.194231049 UTC

[GHC.IO.Exception.IllegalOperation_con_entry() //  [R1]
         { info_tbl: [(c8kG0,
                       label: GHC.IO.Exception.IllegalOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.194963103 UTC

[GHC.IO.Exception.PermissionDenied_con_entry() //  [R1]
         { info_tbl: [(c8kG1,
                       label: GHC.IO.Exception.PermissionDenied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 6
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.195703057 UTC

[GHC.IO.Exception.UserError_con_entry() //  [R1]
         { info_tbl: [(c8kG2,
                       label: GHC.IO.Exception.UserError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 7
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.196416093 UTC

[GHC.IO.Exception.UnsatisfiedConstraints_con_entry() //  [R1]
         { info_tbl: [(c8kG3,
                       label: GHC.IO.Exception.UnsatisfiedConstraints_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 8
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.197126561 UTC

[GHC.IO.Exception.SystemError_con_entry() //  [R1]
         { info_tbl: [(c8kG4,
                       label: GHC.IO.Exception.SystemError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 9
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,121,115,116,101,109,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.198205697 UTC

[GHC.IO.Exception.ProtocolError_con_entry() //  [R1]
         { info_tbl: [(c8kG5,
                       label: GHC.IO.Exception.ProtocolError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 10
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,114,111,116,111,99,111,108,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG5: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.198926449 UTC

[GHC.IO.Exception.OtherError_con_entry() //  [R1]
         { info_tbl: [(c8kG6,
                       label: GHC.IO.Exception.OtherError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 11
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,79,116,104,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.199626294 UTC

[GHC.IO.Exception.InvalidArgument_con_entry() //  [R1]
         { info_tbl: [(c8kG7,
                       label: GHC.IO.Exception.InvalidArgument_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 12
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.200321146 UTC

[GHC.IO.Exception.InappropriateType_con_entry() //  [R1]
         { info_tbl: [(c8kG8,
                       label: GHC.IO.Exception.InappropriateType_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 13
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.201013623 UTC

[GHC.IO.Exception.HardwareFault_con_entry() //  [R1]
         { info_tbl: [(c8kG9,
                       label: GHC.IO.Exception.HardwareFault_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 14
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,97,114,100,119,97,114,101,70,97,117,108,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kG9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.201772258 UTC

[GHC.IO.Exception.UnsupportedOperation_con_entry() //  [R1]
         { info_tbl: [(c8kGa,
                       label: GHC.IO.Exception.UnsupportedOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 15
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGa: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.20250093 UTC

[GHC.IO.Exception.TimeExpired_con_entry() //  [R1]
         { info_tbl: [(c8kGb,
                       label: GHC.IO.Exception.TimeExpired_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 16
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,105,109,101,69,120,112,105,114,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.203216648 UTC

[GHC.IO.Exception.ResourceVanished_con_entry() //  [R1]
         { info_tbl: [(c8kGc,
                       label: GHC.IO.Exception.ResourceVanished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 17
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.20394231 UTC

[GHC.IO.Exception.Interrupted_con_entry() //  [R1]
         { info_tbl: [(c8kGd,
                       label: GHC.IO.Exception.Interrupted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 18
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,116,101,114,114,117,112,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.2046795 UTC

[GHC.IO.Exception.ExitSuccess_con_entry() //  [R1]
         { info_tbl: [(c8kGe,
                       label: GHC.IO.Exception.ExitSuccess_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,83,117,99,99,101,115,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGe: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.205391544 UTC

[GHC.IO.Exception.ExitFailure_con_entry() //  [R1]
         { info_tbl: [(c8kGf,
                       label: GHC.IO.Exception.ExitFailure_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGf: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.206052679 UTC

[section ""relreadonly" . GHC.IO.Exception.FixIOException_closure_tbl" {
     GHC.IO.Exception.FixIOException_closure_tbl:
         const GHC.IO.Exception.FixIOException_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.207683314 UTC

[GHC.IO.Exception.FixIOException_con_entry() //  [R1]
         { info_tbl: [(c8kGg,
                       label: GHC.IO.Exception.FixIOException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,70,105,120,73,79,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.208434164 UTC

[GHC.IO.Exception.IndexOutOfBounds_con_entry() //  [R1]
         { info_tbl: [(c8kGh,
                       label: GHC.IO.Exception.IndexOutOfBounds_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.209172605 UTC

[GHC.IO.Exception.UndefinedElement_con_entry() //  [R1]
         { info_tbl: [(c8kGi,
                       label: GHC.IO.Exception.UndefinedElement_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGi: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.210164531 UTC

[section ""relreadonly" . GHC.IO.Exception.AsyncException_closure_tbl" {
     GHC.IO.Exception.AsyncException_closure_tbl:
         const GHC.IO.Exception.StackOverflow_closure+1;
         const GHC.IO.Exception.HeapOverflow_closure+2;
         const GHC.IO.Exception.ThreadKilled_closure+3;
         const GHC.IO.Exception.UserInterrupt_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.210773066 UTC

[GHC.IO.Exception.StackOverflow_con_entry() //  [R1]
         { info_tbl: [(c8kGj,
                       label: GHC.IO.Exception.StackOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,116,97,99,107,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.211473002 UTC

[GHC.IO.Exception.HeapOverflow_con_entry() //  [R1]
         { info_tbl: [(c8kGk,
                       label: GHC.IO.Exception.HeapOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,101,97,112,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGk: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.21220561 UTC

[GHC.IO.Exception.ThreadKilled_con_entry() //  [R1]
         { info_tbl: [(c8kGl,
                       label: GHC.IO.Exception.ThreadKilled_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,104,114,101,97,100,75,105,108,108,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGl: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.212937735 UTC

[GHC.IO.Exception.UserInterrupt_con_entry() //  [R1]
         { info_tbl: [(c8kGm,
                       label: GHC.IO.Exception.UserInterrupt_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,73,110,116,101,114,114,117,112,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGm: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.213678542 UTC

[GHC.IO.Exception.SomeAsyncException_con_entry() //  [R1]
         { info_tbl: [(c8kGn,
                       label: GHC.IO.Exception.SomeAsyncException_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.214332229 UTC

[section ""relreadonly" . GHC.IO.Exception.AllocationLimitExceeded_closure_tbl" {
     GHC.IO.Exception.AllocationLimitExceeded_closure_tbl:
         const GHC.IO.Exception.AllocationLimitExceeded_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.214937745 UTC

[GHC.IO.Exception.AllocationLimitExceeded_con_entry() //  [R1]
         { info_tbl: [(c8kGo,
                       label: GHC.IO.Exception.AllocationLimitExceeded_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.215573344 UTC

[section ""relreadonly" . GHC.IO.Exception.Deadlock_closure_tbl" {
     GHC.IO.Exception.Deadlock_closure_tbl:
         const GHC.IO.Exception.Deadlock_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.216171584 UTC

[GHC.IO.Exception.Deadlock_con_entry() //  [R1]
         { info_tbl: [(c8kGp,
                       label: GHC.IO.Exception.Deadlock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,68,101,97,100,108,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.216822945 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.217453233 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_entry() //  [R1]
         { info_tbl: [(c8kGq,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGq: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.218123596 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.218724617 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_entry() //  [R1]
         { info_tbl: [(c8kGr,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGr: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.219384844 UTC

[section ""relreadonly" . S8ji8_srt" {
     S8ji8_srt:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fExceptionDeadlock1_closure;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
         const GHC.IO.Exception.$fShowDeadlock1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException3_closure;
         const GHC.IO.Exception.$fExceptionAsyncException5_closure;
         const GHC.IO.Exception.$fExceptionAsyncException7_closure;
         const GHC.IO.Exception.$w$cshowsPrec1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
         const GHC.IO.Exception.$fExceptionFixIOException1_closure;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowFixIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec4_closure;
         const lvl1_r8j2E_closure;
         const lvl3_r8j2G_closure;
         const lvl5_r8j2I_closure;
         const lvl7_r8j2K_closure;
         const lvl9_r8j2M_closure;
         const lvl11_r8j2O_closure;
         const lvl13_r8j2Q_closure;
         const lvl15_r8j2S_closure;
         const lvl17_r8j2U_closure;
         const lvl19_r8j2W_closure;
         const lvl21_r8j2Y_closure;
         const lvl23_r8j30_closure;
         const lvl25_r8j32_closure;
         const lvl27_r8j34_closure;
         const lvl29_r8j36_closure;
         const lvl31_r8j38_closure;
         const lvl33_r8j3a_closure;
         const lvl35_r8j3c_closure;
         const lvl37_r8j3e_closure;
         const GHC.IO.Exception.$fExceptionIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowIOException1_closure;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
         const GHC.IO.Exception.$fShowExitCode1_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Exception.$fReadExitCode2_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme1_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Exception.$fReadExitCode1_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const GHC.IO.Exception.$fReadExitCode6_closure;
         const GHC.IO.Exception.untangle2_closure;
         const GHC.IO.Exception.untangle_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
         const GHC.Exception.errorCallWithCallStackException9_closure;
         const GHC.Exception.errorCallWithCallStackException11_closure;
         const GHC.Exception.errorCallWithCallStackException6_closure;
         const GHC.IO.Exception.assertError1_closure;
         const GHC.IO.Exception.assertError_closure;
         const GHC.Stack.CCS.currentCallStack_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.asyncExceptionFromException_closure;
         const GHC.IO.Exception.asyncExceptionToException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fExceptionArrayException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fExceptionExitCode_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Exception.ioError1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
         const GHC.IO.Exception.cannotCompactMutable1_closure;
         const GHC.IO.Exception.cannotCompactPinned1_closure;
         const GHC.IO.Exception.cannotCompactFunction1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.220835616 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:25.221373954 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,77,86,97,114,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.22216716 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_entry() //  [R1]
         { info_tbl: [(c8kGy,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kGz; else goto c8kGA;
       c8kGz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kGA: // global
           (_c8kGv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kGv::I64 == 0) goto c8kGx; else goto c8kGw;
       c8kGx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kGw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kGv::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.223315214 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(c8kGI,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kGJ; else goto c8kGK;
       c8kGJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kGK: // global
           I64[Sp - 16] = block_c8kGF_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kGO; else goto c8kGG;
       u8kGO: // global
           call _c8kGF() args: 0, res: 0, upd: 0;
       c8kGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kGF() //  []
         { info_tbl: [(c8kGF,
                       label: block_c8kGF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGF: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.224568962 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_entry() //  [R2]
         { info_tbl: [(c8kGW,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kGX; else goto c8kGY;
       c8kGX: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kGY: // global
           I64[Sp - 8] = block_c8kGT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kH2; else goto c8kGU;
       u8kH2: // global
           call _c8kGT() args: 0, res: 0, upd: 0;
       c8kGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kGT() //  []
         { info_tbl: [(c8kGT,
                       label: block_c8kGT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kGT: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.226045914 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8kHa,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kHb; else goto c8kHc;
       c8kHb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kHc: // global
           I64[Sp - 16] = block_c8kH7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kHg; else goto c8kH8;
       u8kHg: // global
           call _c8kH7() args: 0, res: 0, upd: 0;
       c8kH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kH7() //  []
         { info_tbl: [(c8kH7,
                       label: block_c8kH7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kH7: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.227197886 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(c8kHl,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHl: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.227944272 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.228521863 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,83,84,77,32,116,114,97,110,115,97,99,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.229311694 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_entry() //  [R1]
         { info_tbl: [(c8kHu,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kHv; else goto c8kHw;
       c8kHv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kHw: // global
           (_c8kHr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kHr::I64 == 0) goto c8kHt; else goto c8kHs;
       c8kHt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kHs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kHr::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.230431581 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_entry() //  [R2,
                                                                          R3, R4]
         { info_tbl: [(c8kHE,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kHF; else goto c8kHG;
       c8kHF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kHG: // global
           I64[Sp - 16] = block_c8kHB_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kHK; else goto c8kHC;
       u8kHK: // global
           call _c8kHB() args: 0, res: 0, upd: 0;
       c8kHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kHB() //  []
         { info_tbl: [(c8kHB,
                       label: block_c8kHB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHB: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.23166763 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_entry() //  [R2]
         { info_tbl: [(c8kHS,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kHT; else goto c8kHU;
       c8kHT: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kHU: // global
           I64[Sp - 8] = block_c8kHP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kHY; else goto c8kHQ;
       u8kHY: // global
           call _c8kHP() args: 0, res: 0, upd: 0;
       c8kHQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kHP() //  []
         { info_tbl: [(c8kHP,
                       label: block_c8kHP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kHP: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.232886851 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8kI6,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kI6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kI7; else goto c8kI8;
       c8kI7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kI8: // global
           I64[Sp - 16] = block_c8kI3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kIc; else goto c8kI4;
       u8kIc: // global
           call _c8kI3() args: 0, res: 0, upd: 0;
       c8kI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kI3() //  []
         { info_tbl: [(c8kI3,
                       label: block_c8kI3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kI3: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.234028409 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8kIh,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIh: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.234802592 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.235398892 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock2_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock2_bytes:
         I8[] [60,60,100,101,97,100,108,111,99,107,62,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.23614474 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock1_closure" {
     GHC.IO.Exception.$fExceptionDeadlock1_closure:
         const GHC.IO.Exception.$fExceptionDeadlock1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock1_entry() //  [R1]
         { info_tbl: [(c8kIq,
                       label: GHC.IO.Exception.$fExceptionDeadlock1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kIr; else goto c8kIs;
       c8kIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kIs: // global
           (_c8kIn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kIn::I64 == 0) goto c8kIp; else goto c8kIo;
       c8kIp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kIo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kIn::I64;
           R2 = GHC.IO.Exception.$fExceptionDeadlock2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.237266686 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8kIA,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kIB; else goto c8kIC;
       c8kIB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kIC: // global
           I64[Sp - 16] = block_c8kIx_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kIG; else goto c8kIy;
       u8kIG: // global
           call _c8kIx() args: 0, res: 0, upd: 0;
       c8kIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kIx() //  []
         { info_tbl: [(c8kIx,
                       label: block_c8kIx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIx: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.238536618 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cshow_entry() //  [R2]
         { info_tbl: [(c8kIO,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kIP; else goto c8kIQ;
       c8kIP: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kIQ: // global
           I64[Sp - 8] = block_c8kIL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kIU; else goto c8kIM;
       u8kIU: // global
           call _c8kIL() args: 0, res: 0, upd: 0;
       c8kIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kIL() //  []
         { info_tbl: [(c8kIL,
                       label: block_c8kIL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIL: // global
           R1 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.239688599 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock1_closure" {
     GHC.IO.Exception.$fShowDeadlock1_closure:
         const GHC.IO.Exception.$fShowDeadlock1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock1_entry() //  [R2, R3]
         { info_tbl: [(c8kJ2,
                       label: GHC.IO.Exception.$fShowDeadlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kJ3; else goto c8kJ4;
       c8kJ3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kJ4: // global
           I64[Sp - 16] = block_c8kIZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kJ8; else goto c8kJ0;
       u8kJ8: // global
           call _c8kIZ() args: 0, res: 0, upd: 0;
       c8kJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kIZ() //  []
         { info_tbl: [(c8kIZ,
                       label: block_c8kIZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kIZ: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.240821272 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowList_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowList_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8kJd,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJd: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowDeadlock1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.241614392 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_closure" {
     GHC.IO.Exception.$fShowDeadlock_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.242178022 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes:
         I8[] [97,108,108,111,99,97,116,105,111,110,32,108,105,109,105,116,32,101,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.242884481 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_entry() //  [R1]
         { info_tbl: [(c8kJm,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kJn; else goto c8kJo;
       c8kJn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kJo: // global
           (_c8kJj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kJj::I64 == 0) goto c8kJl; else goto c8kJk;
       c8kJl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kJk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kJj::I64;
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.245046231 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_entry() //  [R2,
                                                                         R3, R4]
         { info_tbl: [(c8kJw,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kJx; else goto c8kJy;
       c8kJx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kJy: // global
           I64[Sp - 16] = block_c8kJt_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kJC; else goto c8kJu;
       u8kJC: // global
           call _c8kJt() args: 0, res: 0, upd: 0;
       c8kJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kJt() //  []
         { info_tbl: [(c8kJt,
                       label: block_c8kJt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJt: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.246676417 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_entry() //  [R2]
         { info_tbl: [(c8kJK,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kJL; else goto c8kJM;
       c8kJL: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kJM: // global
           I64[Sp - 8] = block_c8kJH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kJQ; else goto c8kJI;
       u8kJQ: // global
           call _c8kJH() args: 0, res: 0, upd: 0;
       c8kJI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kJH() //  []
         { info_tbl: [(c8kJH,
                       label: block_c8kJH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJH: // global
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.247888855 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8kJY,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kJZ; else goto c8kK0;
       c8kJZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kK0: // global
           I64[Sp - 16] = block_c8kJV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kK4; else goto c8kJW;
       u8kK4: // global
           call _c8kJV() args: 0, res: 0, upd: 0;
       c8kJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kJV() //  []
         { info_tbl: [(c8kJV,
                       label: block_c8kJV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kJV: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.248999005 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c8kK9,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kK9: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.249752009 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.250338955 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed1_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed1_bytes:
         I8[] [99,111,109,112,97,99,116,105,111,110,32,102,97,105,108,101,100,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.251202426 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec2_closure" {
     GHC.IO.Exception.$w$cshowsPrec2_closure:
         const GHC.IO.Exception.$w$cshowsPrec2_info;
 },
 sat_s8j4q_entry() //  [R1]
         { info_tbl: [(c8kKk,
                       label: sat_s8j4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kKl; else goto c8kKm;
       c8kKl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kKm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec2_entry() //  [R2]
         { info_tbl: [(c8kKn,
                       label: GHC.IO.Exception.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8kKr; else goto c8kKq;
       c8kKr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kKq: // global
           I64[Hp - 16] = sat_s8j4q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.252415857 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(c8kKw,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKw: // global
           R2 = R3;
           call GHC.IO.Exception.$w$cshowsPrec2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.25327995 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_entry() //  [R2]
         { info_tbl: [(c8kKD,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKD: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.254120683 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(c8kKK,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec2_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.254852081 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure+2;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.255574287 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_entry() //  [R3,
                                                                 R4]
         { info_tbl: [(c8kKR,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKR: // global
           _s8j4x::P64 = R3;
           R3 = R4;
           R2 = _s8j4x::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.256402921 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed1_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed1_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed1_info;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed1_entry() //  [R2]
         { info_tbl: [(c8kKY,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kKY: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.257222983 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8kL5,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kL5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.++_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.257970702 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.258828401 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8kLf,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kLj; else goto c8kLk;
       c8kLj: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kLk: // global
           I64[Sp - 8] = block_c8kLc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kLq; else goto c8kLd;
       u8kLq: // global
           call _c8kLc(R1) args: 0, res: 0, upd: 0;
       c8kLd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLc() //  [R1]
         { info_tbl: [(c8kLc,
                       label: block_c8kLc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLc: // global
           I64[Sp - 8] = block_c8kLi_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLi() //  [R1]
         { info_tbl: [(c8kLi,
                       label: block_c8kLi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLi: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.260229491 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_entry() //  [R2,
                                                                    R3, R4]
         { info_tbl: [(c8kLy,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8kLG; else goto c8kLH;
       c8kLG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kLH: // global
           I64[Sp - 16] = block_c8kLv_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kLO; else goto c8kLw;
       u8kLO: // global
           call _c8kLv(R1) args: 0, res: 0, upd: 0;
       c8kLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLv() //  [R1]
         { info_tbl: [(c8kLv,
                       label: block_c8kLv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLv: // global
           I64[Sp - 8] = block_c8kLB_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLB() //  [R1]
         { info_tbl: [(c8kLB,
                       label: block_c8kLB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLB: // global
           _s8j4L::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8kLF_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4L::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8kLF() //  [R1]
         { info_tbl: [(c8kLF,
                       label: block_c8kLF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLF: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.262228213 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException1_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException1_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException1_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException1_entry() //  [R2, R3]
         { info_tbl: [(c8kLW,
                       label: GHC.IO.Exception.$fShowSomeAsyncException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8kM4; else goto c8kM5;
       c8kM4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kM5: // global
           I64[Sp - 16] = block_c8kLT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kMc; else goto c8kLU;
       u8kMc: // global
           call _c8kLT(R1) args: 0, res: 0, upd: 0;
       c8kLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLT() //  [R1]
         { info_tbl: [(c8kLT,
                       label: block_c8kLT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLT: // global
           I64[Sp - 8] = block_c8kLZ_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kLZ() //  [R1]
         { info_tbl: [(c8kLZ,
                       label: block_c8kLZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kLZ: // global
           _s8j4S::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8kM3_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4S::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8kM3() //  [R1]
         { info_tbl: [(c8kM3,
                       label: block_c8kM3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kM3: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.263643166 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c8kMh,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMh: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowSomeAsyncException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.264366753 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.26493339 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException8_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException8_bytes:
         I8[] [115,116,97,99,107,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.265704275 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException7_closure" {
     GHC.IO.Exception.$fExceptionAsyncException7_closure:
         const GHC.IO.Exception.$fExceptionAsyncException7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException7_entry() //  [R1]
         { info_tbl: [(c8kMq,
                       label: GHC.IO.Exception.$fExceptionAsyncException7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kMr; else goto c8kMs;
       c8kMr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kMs: // global
           (_c8kMn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kMn::I64 == 0) goto c8kMp; else goto c8kMo;
       c8kMp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kMo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kMn::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.266558563 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException6_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException6_bytes:
         I8[] [104,101,97,112,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.26726917 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException5_closure" {
     GHC.IO.Exception.$fExceptionAsyncException5_closure:
         const GHC.IO.Exception.$fExceptionAsyncException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException5_entry() //  [R1]
         { info_tbl: [(c8kMz,
                       label: GHC.IO.Exception.$fExceptionAsyncException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kMA; else goto c8kMB;
       c8kMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kMB: // global
           (_c8kMw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kMw::I64 == 0) goto c8kMy; else goto c8kMx;
       c8kMy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kMx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kMw::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.268154726 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException4_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException4_bytes:
         I8[] [116,104,114,101,97,100,32,107,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.268869515 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException3_closure" {
     GHC.IO.Exception.$fExceptionAsyncException3_closure:
         const GHC.IO.Exception.$fExceptionAsyncException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException3_entry() //  [R1]
         { info_tbl: [(c8kMI,
                       label: GHC.IO.Exception.$fExceptionAsyncException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kMJ; else goto c8kMK;
       c8kMJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kMK: // global
           (_c8kMF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kMF::I64 == 0) goto c8kMH; else goto c8kMG;
       c8kMH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kMG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kMF::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.269754914 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException2_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException2_bytes:
         I8[] [117,115,101,114,32,105,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.270500507 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException1_closure" {
     GHC.IO.Exception.$fExceptionAsyncException1_closure:
         const GHC.IO.Exception.$fExceptionAsyncException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException1_entry() //  [R1]
         { info_tbl: [(c8kMR,
                       label: GHC.IO.Exception.$fExceptionAsyncException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kMS; else goto c8kMT;
       c8kMS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kMT: // global
           (_c8kMO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kMO::I64 == 0) goto c8kMQ; else goto c8kMP;
       c8kMQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kMP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kMO::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.271762532 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec1_closure" {
     GHC.IO.Exception.$w$cshowsPrec1_closure:
         const GHC.IO.Exception.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(c8kN7,
                       label: GHC.IO.Exception.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kN7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kN8; else goto c8kN9;
       c8kN8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kN9: // global
           I64[Sp - 16] = block_c8kMY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kNo; else goto c8kMZ;
       u8kNo: // global
           call _c8kMY(R1) args: 0, res: 0, upd: 0;
       c8kMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kMY() //  [R1]
         { info_tbl: [(c8kMY,
                       label: block_c8kMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kMY: // global
           _s8j4Y::P64 = P64[Sp + 8];
           _c8kN6::P64 = R1 & 7;
           if (_c8kN6::P64 < 3) goto u8kNm; else goto u8kNn;
       u8kNm: // global
           if (_c8kN6::P64 < 2) goto c8kN2; else goto c8kN3;
       c8kN2: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kN3: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8kNn: // global
           if (_c8kN6::P64 < 4) goto c8kN4; else goto c8kN5;
       c8kN4: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kN5: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.273124066 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_entry() //  [R3,
                                                                R4]
         { info_tbl: [(c8kNt,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kNt: // global
           _s8j51::P64 = R3;
           R3 = R4;
           R2 = _s8j51::P64;
           call GHC.IO.Exception.$w$cshowsPrec1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.274518286 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8kNJ,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kNJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kNK; else goto c8kNL;
       c8kNK: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kNL: // global
           I64[Sp - 8] = block_c8kNA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kO0; else goto c8kNB;
       u8kO0: // global
           call _c8kNA(R1) args: 0, res: 0, upd: 0;
       c8kNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kNA() //  [R1]
         { info_tbl: [(c8kNA,
                       label: block_c8kNA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kNA: // global
           _c8kNI::P64 = R1 & 7;
           if (_c8kNI::P64 < 3) goto u8kNY; else goto u8kNZ;
       u8kNY: // global
           if (_c8kNI::P64 < 2) goto c8kNE; else goto c8kNF;
       c8kNE: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8kNF: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8kNZ: // global
           if (_c8kNI::P64 < 4) goto c8kNG; else goto c8kNH;
       c8kNG: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8kNH: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.275848349 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8kO5,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kO5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.276599801 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_closure" {
     GHC.IO.Exception.$fShowAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.277196342 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException4_bytes" {
     GHC.IO.Exception.$fExceptionArrayException4_bytes:
         I8[] [97,114,114,97,121,32,105,110,100,101,120,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.277781136 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException3_bytes" {
     GHC.IO.Exception.$fExceptionArrayException3_bytes:
         I8[] [58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.278260583 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException2_bytes" {
     GHC.IO.Exception.$fExceptionArrayException2_bytes:
         I8[] [117,110,100,101,102,105,110,101,100,32,97,114,114,97,121,32,101,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.280131513 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec_closure" {
     GHC.IO.Exception.$w$cshowsPrec_closure:
         const GHC.IO.Exception.$w$cshowsPrec_info;
 },
 sat_s8j5e_entry() //  [R1]
         { info_tbl: [(c8kOv,
                       label: sat_s8j5e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kOw; else goto c8kOx;
       c8kOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5f_entry() //  [R1]
         { info_tbl: [(c8kOC,
                       label: sat_s8j5f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kOC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8kOD; else goto c8kOE;
       c8kOD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kOE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8kOl_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8kOK; else goto c8kOm;
       u8kOK: // global
           call _c8kOl(R1) args: 0, res: 0, upd: 0;
       c8kOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8kOl() //  [R1]
         { info_tbl: [(c8kOl,
                       label: block_c8kOl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kOl: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kOz; else goto c8kOA;
       c8kOz: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8kOA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8kOJ; else goto c8kOI;
       c8kOJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8kOI: // global
           I64[Hp - 24] = sat_s8j5e_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5k_entry() //  [R1]
         { info_tbl: [(c8kP1,
                       label: sat_s8j5k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kP1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kP2; else goto c8kP3;
       c8kP2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kP3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5l_entry() //  [R1]
         { info_tbl: [(c8kP8,
                       label: sat_s8j5l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kP8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8kP9; else goto c8kPa;
       c8kP9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kPa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8kOR_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8kPg; else goto c8kOS;
       u8kPg: // global
           call _c8kOR(R1) args: 0, res: 0, upd: 0;
       c8kOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8kOR() //  [R1]
         { info_tbl: [(c8kOR,
                       label: block_c8kOR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kOR: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kP5; else goto c8kP6;
       c8kP5: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8kP6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8kPf; else goto c8kPe;
       c8kPf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8kPe: // global
           I64[Hp - 24] = sat_s8j5k_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8kPl,
                       label: GHC.IO.Exception.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kPl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kPm; else goto c8kPn;
       c8kPm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kPn: // global
           I64[Sp - 16] = block_c8kOc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kPu; else goto c8kOd;
       u8kPu: // global
           call _c8kOc(R1) args: 0, res: 0, upd: 0;
       c8kOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kOc() //  [R1]
         { info_tbl: [(c8kOc,
                       label: block_c8kOc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kOc: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kPi; else goto c8kPj;
       c8kPi: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8kPt; else goto c8kPp;
       c8kPp: // global
           _s8j5a::P64 = P64[_s8j59::P64 + 7];
           I64[Hp - 24] = sat_s8j5f_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5a::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8kPj: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8kPt; else goto c8kPs;
       c8kPt: // global
           HpAlloc = 32;
           R1 = _s8j59::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8kPs: // global
           _s8j5g::P64 = P64[_s8j59::P64 + 6];
           I64[Hp - 24] = sat_s8j5l_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5g::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException2_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.283346502 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_entry() //  [R3,
                                                                     R4]
         { info_tbl: [(c8kPz,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kPz: // global
           _s8j5n::P64 = R3;
           R3 = R4;
           R2 = _s8j5n::P64;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.284067118 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException1_closure" {
     GHC.IO.Exception.$fExceptionArrayException1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.284743839 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshow_entry() //  [R2]
         { info_tbl: [(c8kPG,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kPG: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.285862678 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_$cshowList_closure" {
     GHC.IO.Exception.$fShowArrayException_$cshowList_closure:
         const GHC.IO.Exception.$fShowArrayException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowArrayException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8kPN,
                       label: GHC.IO.Exception.$fShowArrayException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kPN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.286558235 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_closure" {
     GHC.IO.Exception.$fShowArrayException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowArrayException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.28711956 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException2_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException2_bytes:
         I8[] [99,121,99,108,105,99,32,101,118,97,108,117,97,116,105,111,110,32,105,110,32,102,105,120,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.289043269 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException1_closure" {
     GHC.IO.Exception.$fExceptionFixIOException1_closure:
         const GHC.IO.Exception.$fExceptionFixIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException1_entry() //  [R1]
         { info_tbl: [(c8kPW,
                       label: GHC.IO.Exception.$fExceptionFixIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kPW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kPX; else goto c8kPY;
       c8kPX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kPY: // global
           (_c8kPT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kPT::I64 == 0) goto c8kPV; else goto c8kPU;
       c8kPV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kPU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kPT::I64;
           R2 = GHC.IO.Exception.$fExceptionFixIOException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.290186529 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8kQ6,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kQ7; else goto c8kQ8;
       c8kQ7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kQ8: // global
           I64[Sp - 16] = block_c8kQ3_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kQc; else goto c8kQ4;
       u8kQc: // global
           call _c8kQ3() args: 0, res: 0, upd: 0;
       c8kQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kQ3() //  []
         { info_tbl: [(c8kQ3,
                       label: block_c8kQ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQ3: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.291444223 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8kQk,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8kQl; else goto c8kQm;
       c8kQl: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8kQm: // global
           I64[Sp - 8] = block_c8kQh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8kQq; else goto c8kQi;
       u8kQq: // global
           call _c8kQh() args: 0, res: 0, upd: 0;
       c8kQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kQh() //  []
         { info_tbl: [(c8kQh,
                       label: block_c8kQh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQh: // global
           R1 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.292628007 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException1_closure" {
     GHC.IO.Exception.$fShowFixIOException1_closure:
         const GHC.IO.Exception.$fShowFixIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8kQy,
                       label: GHC.IO.Exception.$fShowFixIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kQz; else goto c8kQA;
       c8kQz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kQA: // global
           I64[Sp - 16] = block_c8kQv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kQE; else goto c8kQw;
       u8kQE: // global
           call _c8kQv() args: 0, res: 0, upd: 0;
       c8kQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kQv() //  []
         { info_tbl: [(c8kQv,
                       label: block_c8kQv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQv: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.293778738 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8kQJ,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQJ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowFixIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.294507289 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_closure" {
     GHC.IO.Exception.$fShowFixIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.29547637 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c==_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c==_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c==_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8kQU,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kR0; else goto c8kR1;
       c8kR0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kR1: // global
           I64[Sp - 16] = block_c8kQQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kRl; else goto c8kQR;
       u8kRl: // global
           call _c8kQQ(R1) args: 0, res: 0, upd: 0;
       c8kQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kQQ() //  [R1]
         { info_tbl: [(c8kQQ,
                       label: block_c8kQQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQQ: // global
           _s8j5G::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8kQZ_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5G::I64;
           if (R1 & 7 != 0) goto u8kRk; else goto c8kR6;
       u8kRk: // global
           call _c8kQZ(R1) args: 0, res: 0, upd: 0;
       c8kR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kQZ() //  [R1]
         { info_tbl: [(c8kQZ,
                       label: block_c8kQZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kQZ: // global
           R1 = I64[((%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.297071259 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c/=_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c/=_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8kRu,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kRA; else goto c8kRB;
       c8kRA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kRB: // global
           I64[Sp - 16] = block_c8kRq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kRZ; else goto c8kRr;
       u8kRZ: // global
           call _c8kRq(R1) args: 0, res: 0, upd: 0;
       c8kRr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kRq() //  [R1]
         { info_tbl: [(c8kRq,
                       label: block_c8kRq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kRq: // global
           _s8j5N::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8kRz_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5N::I64;
           if (R1 & 7 != 0) goto u8kRY; else goto c8kRG;
       u8kRY: // global
           call _c8kRz(R1) args: 0, res: 0, upd: 0;
       c8kRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kRz() //  [R1]
         { info_tbl: [(c8kRz,
                       label: block_c8kRz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kRz: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) goto c8kRV; else goto c8kRU;
       c8kRV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8kRU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.298557219 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_closure" {
     GHC.IO.Exception.$fEqIOErrorType_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOErrorType_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.299105601 UTC

[section ""cstring" . lvl_r8j2D_bytes" {
     lvl_r8j2D_bytes:
         I8[] [97,108,114,101,97,100,121,32,101,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.299798417 UTC

[section ""data" . lvl1_r8j2E_closure" {
     lvl1_r8j2E_closure:
         const lvl1_r8j2E_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8j2E_entry() //  [R1]
         { info_tbl: [(c8kS6,
                       label: lvl1_r8j2E_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kS7; else goto c8kS8;
       c8kS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kS8: // global
           (_c8kS3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kS3::I64 == 0) goto c8kS5; else goto c8kS4;
       c8kS5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kS4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kS3::I64;
           R2 = lvl_r8j2D_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.300648946 UTC

[section ""cstring" . lvl2_r8j2F_bytes" {
     lvl2_r8j2F_bytes:
         I8[] [100,111,101,115,32,110,111,116,32,101,120,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.301368935 UTC

[section ""data" . lvl3_r8j2G_closure" {
     lvl3_r8j2G_closure:
         const lvl3_r8j2G_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8j2G_entry() //  [R1]
         { info_tbl: [(c8kSf,
                       label: lvl3_r8j2G_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSg; else goto c8kSh;
       c8kSg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kSh: // global
           (_c8kSc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSc::I64 == 0) goto c8kSe; else goto c8kSd;
       c8kSe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSc::I64;
           R2 = lvl2_r8j2F_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.302207701 UTC

[section ""cstring" . lvl4_r8j2H_bytes" {
     lvl4_r8j2H_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,98,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.302918402 UTC

[section ""data" . lvl5_r8j2I_closure" {
     lvl5_r8j2I_closure:
         const lvl5_r8j2I_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8j2I_entry() //  [R1]
         { info_tbl: [(c8kSo,
                       label: lvl5_r8j2I_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSp; else goto c8kSq;
       c8kSp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kSq: // global
           (_c8kSl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSl::I64 == 0) goto c8kSn; else goto c8kSm;
       c8kSn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSl::I64;
           R2 = lvl4_r8j2H_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.303768714 UTC

[section ""cstring" . lvl6_r8j2J_bytes" {
     lvl6_r8j2J_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,101,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.304511837 UTC

[section ""data" . lvl7_r8j2K_closure" {
     lvl7_r8j2K_closure:
         const lvl7_r8j2K_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r8j2K_entry() //  [R1]
         { info_tbl: [(c8kSx,
                       label: lvl7_r8j2K_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSy; else goto c8kSz;
       c8kSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kSz: // global
           (_c8kSu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSu::I64 == 0) goto c8kSw; else goto c8kSv;
       c8kSw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSu::I64;
           R2 = lvl6_r8j2J_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.305456521 UTC

[section ""cstring" . lvl8_r8j2L_bytes" {
     lvl8_r8j2L_bytes:
         I8[] [101,110,100,32,111,102,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.306173329 UTC

[section ""data" . lvl9_r8j2M_closure" {
     lvl9_r8j2M_closure:
         const lvl9_r8j2M_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r8j2M_entry() //  [R1]
         { info_tbl: [(c8kSG,
                       label: lvl9_r8j2M_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSH; else goto c8kSI;
       c8kSH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kSI: // global
           (_c8kSD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSD::I64 == 0) goto c8kSF; else goto c8kSE;
       c8kSF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSD::I64;
           R2 = lvl8_r8j2L_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.307042004 UTC

[section ""cstring" . lvl10_r8j2N_bytes" {
     lvl10_r8j2N_bytes:
         I8[] [105,108,108,101,103,97,108,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.30775217 UTC

[section ""data" . lvl11_r8j2O_closure" {
     lvl11_r8j2O_closure:
         const lvl11_r8j2O_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8j2O_entry() //  [R1]
         { info_tbl: [(c8kSP,
                       label: lvl11_r8j2O_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSQ; else goto c8kSR;
       c8kSQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kSR: // global
           (_c8kSM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSM::I64 == 0) goto c8kSO; else goto c8kSN;
       c8kSO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSM::I64;
           R2 = lvl10_r8j2N_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.308594642 UTC

[section ""cstring" . lvl12_r8j2P_bytes" {
     lvl12_r8j2P_bytes:
         I8[] [112,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.309597002 UTC

[section ""data" . lvl13_r8j2Q_closure" {
     lvl13_r8j2Q_closure:
         const lvl13_r8j2Q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r8j2Q_entry() //  [R1]
         { info_tbl: [(c8kSY,
                       label: lvl13_r8j2Q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kSY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kSZ; else goto c8kT0;
       c8kSZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kT0: // global
           (_c8kSV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kSV::I64 == 0) goto c8kSX; else goto c8kSW;
       c8kSX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kSW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kSV::I64;
           R2 = lvl12_r8j2P_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.310503733 UTC

[section ""cstring" . lvl14_r8j2R_bytes" {
     lvl14_r8j2R_bytes:
         I8[] [117,115,101,114,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.311243605 UTC

[section ""data" . lvl15_r8j2S_closure" {
     lvl15_r8j2S_closure:
         const lvl15_r8j2S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_r8j2S_entry() //  [R1]
         { info_tbl: [(c8kT7,
                       label: lvl15_r8j2S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kT7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kT8; else goto c8kT9;
       c8kT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kT9: // global
           (_c8kT4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kT4::I64 == 0) goto c8kT6; else goto c8kT5;
       c8kT6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kT5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kT4::I64;
           R2 = lvl14_r8j2R_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.312118308 UTC

[section ""cstring" . lvl16_r8j2T_bytes" {
     lvl16_r8j2T_bytes:
         I8[] [117,110,115,97,116,105,115,102,105,101,100,32,99,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.312839938 UTC

[section ""data" . lvl17_r8j2U_closure" {
     lvl17_r8j2U_closure:
         const lvl17_r8j2U_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_r8j2U_entry() //  [R1]
         { info_tbl: [(c8kTg,
                       label: lvl17_r8j2U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kTh; else goto c8kTi;
       c8kTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kTi: // global
           (_c8kTd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTd::I64 == 0) goto c8kTf; else goto c8kTe;
       c8kTf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTd::I64;
           R2 = lvl16_r8j2T_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.313752537 UTC

[section ""cstring" . lvl18_r8j2V_bytes" {
     lvl18_r8j2V_bytes:
         I8[] [115,121,115,116,101,109,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.314454859 UTC

[section ""data" . lvl19_r8j2W_closure" {
     lvl19_r8j2W_closure:
         const lvl19_r8j2W_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r8j2W_entry() //  [R1]
         { info_tbl: [(c8kTp,
                       label: lvl19_r8j2W_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kTq; else goto c8kTr;
       c8kTq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kTr: // global
           (_c8kTm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTm::I64 == 0) goto c8kTo; else goto c8kTn;
       c8kTo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTm::I64;
           R2 = lvl18_r8j2V_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.315349245 UTC

[section ""cstring" . lvl20_r8j2X_bytes" {
     lvl20_r8j2X_bytes:
         I8[] [112,114,111,116,111,99,111,108,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.316084868 UTC

[section ""data" . lvl21_r8j2Y_closure" {
     lvl21_r8j2Y_closure:
         const lvl21_r8j2Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_r8j2Y_entry() //  [R1]
         { info_tbl: [(c8kTy,
                       label: lvl21_r8j2Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kTz; else goto c8kTA;
       c8kTz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kTA: // global
           (_c8kTv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTv::I64 == 0) goto c8kTx; else goto c8kTw;
       c8kTx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTv::I64;
           R2 = lvl20_r8j2X_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.316980614 UTC

[section ""cstring" . lvl22_r8j2Z_bytes" {
     lvl22_r8j2Z_bytes:
         I8[] [102,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.317747469 UTC

[section ""data" . lvl23_r8j30_closure" {
     lvl23_r8j30_closure:
         const lvl23_r8j30_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_r8j30_entry() //  [R1]
         { info_tbl: [(c8kTH,
                       label: lvl23_r8j30_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kTI; else goto c8kTJ;
       c8kTI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kTJ: // global
           (_c8kTE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTE::I64 == 0) goto c8kTG; else goto c8kTF;
       c8kTG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTE::I64;
           R2 = lvl22_r8j2Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.318667062 UTC

[section ""cstring" . lvl24_r8j31_bytes" {
     lvl24_r8j31_bytes:
         I8[] [105,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.319395178 UTC

[section ""data" . lvl25_r8j32_closure" {
     lvl25_r8j32_closure:
         const lvl25_r8j32_info;
         const 0;
         const 0;
         const 0;
 },
 lvl25_r8j32_entry() //  [R1]
         { info_tbl: [(c8kTQ,
                       label: lvl25_r8j32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kTR; else goto c8kTS;
       c8kTR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kTS: // global
           (_c8kTN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTN::I64 == 0) goto c8kTP; else goto c8kTO;
       c8kTP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTN::I64;
           R2 = lvl24_r8j31_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.320325601 UTC

[section ""cstring" . lvl26_r8j33_bytes" {
     lvl26_r8j33_bytes:
         I8[] [105,110,97,112,112,114,111,112,114,105,97,116,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.32108507 UTC

[section ""data" . lvl27_r8j34_closure" {
     lvl27_r8j34_closure:
         const lvl27_r8j34_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_r8j34_entry() //  [R1]
         { info_tbl: [(c8kTZ,
                       label: lvl27_r8j34_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kU0; else goto c8kU1;
       c8kU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kU1: // global
           (_c8kTW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kTW::I64 == 0) goto c8kTY; else goto c8kTX;
       c8kTY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kTX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kTW::I64;
           R2 = lvl26_r8j33_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.322253502 UTC

[section ""cstring" . lvl28_r8j35_bytes" {
     lvl28_r8j35_bytes:
         I8[] [104,97,114,100,119,97,114,101,32,102,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.322987238 UTC

[section ""data" . lvl29_r8j36_closure" {
     lvl29_r8j36_closure:
         const lvl29_r8j36_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_r8j36_entry() //  [R1]
         { info_tbl: [(c8kU8,
                       label: lvl29_r8j36_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kU8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kU9; else goto c8kUa;
       c8kU9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kUa: // global
           (_c8kU5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kU5::I64 == 0) goto c8kU7; else goto c8kU6;
       c8kU7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kU6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kU5::I64;
           R2 = lvl28_r8j35_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.323860501 UTC

[section ""cstring" . lvl30_r8j37_bytes" {
     lvl30_r8j37_bytes:
         I8[] [117,110,115,117,112,112,111,114,116,101,100,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.324605532 UTC

[section ""data" . lvl31_r8j38_closure" {
     lvl31_r8j38_closure:
         const lvl31_r8j38_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_r8j38_entry() //  [R1]
         { info_tbl: [(c8kUh,
                       label: lvl31_r8j38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kUh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kUi; else goto c8kUj;
       c8kUi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kUj: // global
           (_c8kUe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kUe::I64 == 0) goto c8kUg; else goto c8kUf;
       c8kUg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kUf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kUe::I64;
           R2 = lvl30_r8j37_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.325523566 UTC

[section ""cstring" . lvl32_r8j39_bytes" {
     lvl32_r8j39_bytes:
         I8[] [116,105,109,101,111,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.326286744 UTC

[section ""data" . lvl33_r8j3a_closure" {
     lvl33_r8j3a_closure:
         const lvl33_r8j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_r8j3a_entry() //  [R1]
         { info_tbl: [(c8kUq,
                       label: lvl33_r8j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kUq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kUr; else goto c8kUs;
       c8kUr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kUs: // global
           (_c8kUn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kUn::I64 == 0) goto c8kUp; else goto c8kUo;
       c8kUp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kUo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kUn::I64;
           R2 = lvl32_r8j39_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.328309068 UTC

[section ""cstring" . lvl34_r8j3b_bytes" {
     lvl34_r8j3b_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,118,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.329054049 UTC

[section ""data" . lvl35_r8j3c_closure" {
     lvl35_r8j3c_closure:
         const lvl35_r8j3c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_r8j3c_entry() //  [R1]
         { info_tbl: [(c8kUz,
                       label: lvl35_r8j3c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kUz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kUA; else goto c8kUB;
       c8kUA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kUB: // global
           (_c8kUw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kUw::I64 == 0) goto c8kUy; else goto c8kUx;
       c8kUy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kUx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kUw::I64;
           R2 = lvl34_r8j3b_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.32995491 UTC

[section ""cstring" . lvl36_r8j3d_bytes" {
     lvl36_r8j3d_bytes:
         I8[] [105,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.330634966 UTC

[section ""data" . lvl37_r8j3e_closure" {
     lvl37_r8j3e_closure:
         const lvl37_r8j3e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_r8j3e_entry() //  [R1]
         { info_tbl: [(c8kUI,
                       label: lvl37_r8j3e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kUJ; else goto c8kUK;
       c8kUJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8kUK: // global
           (_c8kUF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8kUF::I64 == 0) goto c8kUH; else goto c8kUG;
       c8kUH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8kUG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8kUF::I64;
           R2 = lvl36_r8j3d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.332196244 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec4_closure" {
     GHC.IO.Exception.$w$cshowsPrec4_closure:
         const GHC.IO.Exception.$w$cshowsPrec4_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec4_entry() //  [R2, R3]
         { info_tbl: [(c8kVd,
                       label: GHC.IO.Exception.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kVd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8kVe; else goto c8kVf;
       c8kVe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kVf: // global
           I64[Sp - 16] = block_c8kUP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8kWb; else goto c8kUQ;
       u8kWb: // global
           call _c8kUP(R1) args: 0, res: 0, upd: 0;
       c8kUQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kUP() //  [R1]
         { info_tbl: [(c8kUP,
                       label: block_c8kUP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kUP: // global
           _s8j5S::P64 = P64[Sp + 8];
           switch [0 .. 18] (%MO_UU_Conv_W32_W64(I32[I64[R1 - 1] + 20])) {
               case 0 : goto c8kUT;
               case 1 : goto c8kUU;
               case 2 : goto c8kUV;
               case 3 : goto c8kUW;
               case 4 : goto c8kUX;
               case 5 : goto c8kUY;
               case 6 : goto c8kUZ;
               case 7 : goto c8kV0;
               case 8 : goto c8kV1;
               case 9 : goto c8kV2;
               case 10 : goto c8kV3;
               case 11 : goto c8kV4;
               case 12 : goto c8kV5;
               case 13 : goto c8kV6;
               case 14 : goto c8kV7;
               case 15 : goto c8kV8;
               case 16 : goto c8kV9;
               case 17 : goto c8kVa;
               case 18 : goto c8kVb;
           }
       c8kVb: // global
           R3 = _s8j5S::P64;
           R2 = lvl37_r8j3e_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kVa: // global
           R3 = _s8j5S::P64;
           R2 = lvl35_r8j3c_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV9: // global
           R3 = _s8j5S::P64;
           R2 = lvl33_r8j3a_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV8: // global
           R3 = _s8j5S::P64;
           R2 = lvl31_r8j38_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV7: // global
           R3 = _s8j5S::P64;
           R2 = lvl29_r8j36_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV6: // global
           R3 = _s8j5S::P64;
           R2 = lvl27_r8j34_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV5: // global
           R3 = _s8j5S::P64;
           R2 = lvl25_r8j32_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV4: // global
           R3 = _s8j5S::P64;
           R2 = lvl23_r8j30_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV3: // global
           R3 = _s8j5S::P64;
           R2 = lvl21_r8j2Y_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV2: // global
           R3 = _s8j5S::P64;
           R2 = lvl19_r8j2W_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV1: // global
           R3 = _s8j5S::P64;
           R2 = lvl17_r8j2U_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kV0: // global
           R3 = _s8j5S::P64;
           R2 = lvl15_r8j2S_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUZ: // global
           R3 = _s8j5S::P64;
           R2 = lvl13_r8j2Q_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUY: // global
           R3 = _s8j5S::P64;
           R2 = lvl11_r8j2O_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUX: // global
           R3 = _s8j5S::P64;
           R2 = lvl9_r8j2M_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUW: // global
           R3 = _s8j5S::P64;
           R2 = lvl7_r8j2K_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUV: // global
           R3 = _s8j5S::P64;
           R2 = lvl5_r8j2I_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUU: // global
           R3 = _s8j5S::P64;
           R2 = lvl3_r8j2G_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8kUT: // global
           R3 = _s8j5S::P64;
           R2 = lvl1_r8j2E_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.334461033 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c8kWg,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWg: // global
           _s8j5V::P64 = R3;
           R3 = R4;
           R2 = _s8j5V::P64;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.335301648 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshow_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshow_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshow_entry() //  [R2]
         { info_tbl: [(c8kWn,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWn: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.33615534 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8kWu,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWu: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.336892023 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_closure" {
     GHC.IO.Exception.$fShowIOErrorType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.340397176 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c==_closure" {
     GHC.IO.Exception.$fEqIOException_$c==_closure:
         const GHC.IO.Exception.$fEqIOException_$c==_info;
 },
 GHC.IO.Exception.$fEqIOException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8kWE,
                       label: GHC.IO.Exception.$fEqIOException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWE: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c8kWV; else goto c8kWW;
       c8kWV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8kWW: // global
           I64[Sp - 16] = block_c8kWB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8l1y; else goto c8kWC;
       u8l1y: // global
           call _c8kWB(R1) args: 0, res: 0, upd: 0;
       c8kWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kWB() //  [R1]
         { info_tbl: [(c8kWB,
                       label: block_c8kWB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWB: // global
           I64[Sp - 40] = block_c8kWH_info;
           _s8j63::P64 = P64[R1 + 7];
           _s8j64::P64 = P64[R1 + 15];
           _s8j65::P64 = P64[R1 + 23];
           _s8j66::P64 = P64[R1 + 31];
           _s8j67::P64 = P64[R1 + 39];
           _s8j68::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8j65::P64;
           P64[Sp - 24] = _s8j66::P64;
           P64[Sp - 16] = _s8j67::P64;
           P64[Sp - 8] = _s8j68::P64;
           P64[Sp] = _s8j64::P64;
           P64[Sp + 8] = _s8j63::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8l1x; else goto c8kWI;
       u8l1x: // global
           call _c8kWH(R1) args: 0, res: 0, upd: 0;
       c8kWI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kWH() //  [R1]
         { info_tbl: [(c8kWH,
                       label: block_c8kWH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWH: // global
           I64[Sp - 40] = block_c8kWM_info;
           _s8j6a::P64 = P64[R1 + 7];
           _s8j6c::P64 = P64[R1 + 23];
           _s8j6d::P64 = P64[R1 + 31];
           _s8j6e::P64 = P64[R1 + 39];
           _s8j6f::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _s8j6c::P64;
           P64[Sp - 24] = _s8j6d::P64;
           P64[Sp - 16] = _s8j6e::P64;
           P64[Sp - 8] = _s8j6f::P64;
           P64[Sp] = _s8j6a::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8l1z; else goto c8kWN;
       u8l1z: // global
           call _c8kWM(R1) args: 0, res: 0, upd: 0;
       c8kWN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kWM() //  [R1]
         { info_tbl: [(c8kWM,
                       label: block_c8kWM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWM: // global
           _s8j6h::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8kWU_info;
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _s8j6h::I64;
           if (R1 & 7 != 0) goto u8l1A; else goto c8kX3;
       u8l1A: // global
           call _c8kWU(R1) args: 0, res: 0, upd: 0;
       c8kX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kWU() //  [R1]
         { info_tbl: [(c8kWU,
                       label: block_c8kWU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kWU: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 80]) goto c8kXl; else goto u8l1e;
       c8kXl: // global
           I64[Sp] = block_c8kXk_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8l1e: // global
           Sp = Sp + 96;
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _c8kXk() //  [R1]
         { info_tbl: [(c8kXk,
                       label: block_c8kXk_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXk: // global
           if (R1 & 7 == 1) goto u8l1f; else goto c8kZk;
       u8l1f: // global
           Sp = Sp + 96;
           call _c8l0N() args: 0, res: 0, upd: 0;
       c8kZk: // global
           I64[Sp] = block_c8kXw_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto u8l1C; else goto c8kZl;
       u8l1C: // global
           call _c8kXw(R1) args: 0, res: 0, upd: 0;
       c8kZl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kXw() //  [R1]
         { info_tbl: [(c8kXw,
                       label: block_c8kXw_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXw: // global
           _s8j6a::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8kZs; else goto c8kZI;
       c8kZs: // global
           I64[Sp] = block_c8kZp_info;
           R1 = _s8j6a::P64;
           if (R1 & 7 != 0) goto u8l1E; else goto c8kZt;
       u8l1E: // global
           call _c8kZp(R1) args: 0, res: 0, upd: 0;
       c8kZt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kZI: // global
           I64[Sp] = block_c8kZG_info;
           _s8j6J::P64 = P64[R1 + 6];
           R1 = _s8j6a::P64;
           P64[Sp + 88] = _s8j6J::P64;
           if (R1 & 7 != 0) goto u8l1F; else goto c8kZJ;
       u8l1F: // global
           call _c8kZG(R1) args: 0, res: 0, upd: 0;
       c8kZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kZp() //  [R1]
         { info_tbl: [(c8kZp,
                       label: block_c8kZp_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZp: // global
           if (R1 & 7 == 1) goto u8l1n; else goto u8l1o;
       u8l1n: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8l1o: // global
           Sp = Sp + 96;
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _c8kZG() //  [R1]
         { info_tbl: [(c8kZG,
                       label: block_c8kZG_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZG: // global
           if (R1 & 7 == 1) goto u8l1g; else goto c8kZU;
       u8l1g: // global
           Sp = Sp + 96;
           call _c8l0N() args: 0, res: 0, upd: 0;
       c8kZU: // global
           I64[Sp] = block_c8kZS_info;
           _s8j6L::P64 = P64[R1 + 6];
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _s8j6L::P64;
           if (R1 & 7 != 0) goto u8l1X; else goto c8kZV;
       u8l1X: // global
           call _c8kZS(R1) args: 0, res: 0, upd: 0;
       c8kZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kZS() //  [R1]
         { info_tbl: [(c8kZS,
                       label: block_c8kZS_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZS: // global
           _s8j6L::P64 = P64[Sp + 88];
           if (R1 & 7 == 1) goto c8l02; else goto c8l0x;
       c8l02: // global
           I64[Sp] = block_c8kZZ_info;
           _s8j6O::P64 = P64[R1 + 15];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6O::P64;
           if (R1 & 7 != 0) goto u8l1Z; else goto c8l03;
       u8l1Z: // global
           call _c8kZZ(R1) args: 0, res: 0, upd: 0;
       c8l03: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8l0x: // global
           I64[Sp] = block_c8l0v_info;
           _s8j6X::P64 = P64[R1 + 14];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6X::P64;
           if (R1 & 7 != 0) goto u8l20; else goto c8l0y;
       u8l20: // global
           call _c8l0v(R1) args: 0, res: 0, upd: 0;
       c8l0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kZZ() //  [R1]
         { info_tbl: [(c8kZZ,
                       label: block_c8kZZ_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZZ: // global
           if (R1 & 7 == 1) goto c8l0o; else goto u8l1k;
       c8l0o: // global
           if (P64[Sp + 88] == P64[R1 + 15]) goto u8l1l; else goto u8l1m;
       u8l1l: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8l1m: // global
           Sp = Sp + 96;
           goto u8l23;
       u8l1k: // global
           Sp = Sp + 96;
           goto u8l23;
       u8l23: // global
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _c8l0v() //  [R1]
         { info_tbl: [(c8l0v,
                       label: block_c8l0v_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l0v: // global
           if (R1 & 7 == 1) goto u8l1h; else goto c8l0X;
       u8l1h: // global
           Sp = Sp + 96;
           goto u8l26;
       c8l0X: // global
           if (P64[Sp + 88] == P64[R1 + 14]) goto u8l1i; else goto u8l1j;
       u8l1i: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8l1j: // global
           Sp = Sp + 96;
           goto u8l26;
       u8l26: // global
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6m: // global
           I64[Sp + 8] = block_c8kXB_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8kXB() //  [R1]
         { info_tbl: [(c8kXB,
                       label: block_c8kXB_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXB: // global
           if (R1 & 7 == 1) goto u8l1p; else goto c8kYt;
       u8l1p: // global
           Sp = Sp + 80;
           call _c8l0N() args: 0, res: 0, upd: 0;
       c8kYt: // global
           I64[Sp] = block_c8kXN_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto u8l1G; else goto c8kYu;
       u8l1G: // global
           call _c8kXN(R1) args: 0, res: 0, upd: 0;
       c8kYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kXN() //  [R1]
         { info_tbl: [(c8kXN,
                       label: block_c8kXN_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXN: // global
           _s8j6e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kYB; else goto c8kYR;
       c8kYB: // global
           I64[Sp + 8] = block_c8kYy_info;
           R1 = _s8j6e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8l1I; else goto c8kYC;
       u8l1I: // global
           call _c8kYy(R1) args: 0, res: 0, upd: 0;
       c8kYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kYR: // global
           I64[Sp + 8] = block_c8kYP_info;
           _s8j6y::P64 = P64[R1 + 6];
           R1 = _s8j6e::P64;
           P64[Sp + 72] = _s8j6y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8l1J; else goto c8kYS;
       u8l1J: // global
           call _c8kYP(R1) args: 0, res: 0, upd: 0;
       c8kYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kYy() //  [R1]
         { info_tbl: [(c8kYy,
                       label: block_c8kYy_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kYy: // global
           if (R1 & 7 == 1) goto u8l1t; else goto u8l1u;
       u8l1t: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8l1u: // global
           Sp = Sp + 72;
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _c8kYP() //  [R1]
         { info_tbl: [(c8kYP,
                       label: block_c8kYP_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kYP: // global
           if (R1 & 7 == 1) goto u8l1q; else goto c8kZ8;
       u8l1q: // global
           Sp = Sp + 72;
           call _c8l0N() args: 0, res: 0, upd: 0;
       c8kZ8: // global
           I64[Sp] = block_c8kZ1_info;
           _s8j6A::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8j6A::P64;
           if (R1 & 7 != 0) goto u8l1Q; else goto c8kZ2;
       u8l1Q: // global
           call _c8kZ1(R1) args: 0, res: 0, upd: 0;
       c8kZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kZ1() //  [R1]
         { info_tbl: [(c8kZ1,
                       label: block_c8kZ1_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZ1: // global
           I64[Sp] = block_c8kZ6_info;
           _s8j6C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 64];
           I64[Sp + 64] = _s8j6C::I64;
           if (R1 & 7 != 0) goto u8l1S; else goto c8kZa;
       u8l1S: // global
           call _c8kZ6(R1) args: 0, res: 0, upd: 0;
       c8kZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kZ6() //  [R1]
         { info_tbl: [(c8kZ6,
                       label: block_c8kZ6_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kZ6: // global
           if (I64[Sp + 64] == I64[R1 + 7]) goto u8l1r; else goto u8l1s;
       u8l1r: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8l1s: // global
           Sp = Sp + 72;
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6o: // global
           I64[Sp - 8] = block_c8kXS_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8l27; else goto c8kXU;
       u8l27: // global
           call _c8kXS(R1) args: 0, res: 0, upd: 0;
       c8kXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kXS() //  [R1]
         { info_tbl: [(c8kXS,
                       label: block_c8kXS_info
                       rep:StackRep [False, True, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXS: // global
           _s8j6f::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8kY1; else goto c8kYh;
       c8kY1: // global
           I64[Sp + 64] = block_c8kXY_info;
           R1 = _s8j6f::P64;
           Sp = Sp + 64;
           if (R1 & 7 != 0) goto u8l1K; else goto c8kY2;
       u8l1K: // global
           call _c8kXY(R1) args: 0, res: 0, upd: 0;
       c8kY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8kYh: // global
           I64[Sp + 56] = block_c8kYf_info;
           _s8j6s::P64 = P64[R1 + 6];
           R1 = _s8j6f::P64;
           P64[Sp + 64] = _s8j6s::P64;
           Sp = Sp + 56;
           if (R1 & 7 != 0) goto u8l1L; else goto c8kYi;
       u8l1L: // global
           call _c8kYf(R1) args: 0, res: 0, upd: 0;
       c8kYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8kXY() //  [R1]
         { info_tbl: [(c8kXY,
                       label: block_c8kXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kXY: // global
           if (R1 & 7 == 1) goto c8kY8; else goto u8l1w;
       c8kY8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8l1w: // global
           Sp = Sp + 8;
           call _c8l0N() args: 0, res: 0, upd: 0;
     }
 },
 _c8kYf() //  [R1]
         { info_tbl: [(c8kYf,
                       label: block_c8kYf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8kYf: // global
           if (R1 & 7 == 1) goto u8l1v; else goto c8kYs;
       u8l1v: // global
           Sp = Sp + 16;
           call _c8l0N() args: 0, res: 0, upd: 0;
       c8kYs: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8l0N() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l0N: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.346837107 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c/=_closure" {
     GHC.IO.Exception.$fEqIOException_$c/=_closure:
         const GHC.IO.Exception.$fEqIOException_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8l2i,
                       label: GHC.IO.Exception.$fEqIOException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l2i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8l2j; else goto c8l2k;
       c8l2j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8l2k: // global
           I64[Sp - 8] = block_c8l2c_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Exception.$fEqIOException_$c==_entry(R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8l2c() //  [R1]
         { info_tbl: [(c8l2c,
                       label: block_c8l2c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l2c: // global
           if (R1 & 7 == 1) goto c8l2f; else goto c8l2g;
       c8l2f: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8l2g: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.347897358 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_closure" {
     GHC.IO.Exception.$fEqIOException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOException_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.348679658 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException1_closure" {
     GHC.IO.Exception.$fExceptionIOException1_closure:
         const GHC.IO.Exception.$fExceptionIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException1_entry() //  [R1]
         { info_tbl: [(c8l2x,
                       label: GHC.IO.Exception.$fExceptionIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l2y; else goto c8l2z;
       c8l2y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l2z: // global
           (_c8l2u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8l2u::I64 == 0) goto c8l2w; else goto c8l2v;
       c8l2w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8l2v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8l2u::I64;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.349620407 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException3_bytes" {
     GHC.IO.Exception.$fExceptionIOException3_bytes:
         I8[] [32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.350158517 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException2_bytes" {
     GHC.IO.Exception.$fExceptionIOException2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.353667553 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec3_closure" {
     GHC.IO.Exception.$w$cshowsPrec3_closure:
         const GHC.IO.Exception.$w$cshowsPrec3_info;
         const 0;
 },
 sat_s8j7k_entry() //  [R1]
         { info_tbl: [(c8l34,
                       label: sat_s8j7k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l34: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7l_entry() //  [R1]
         { info_tbl: [(c8l37,
                       label: sat_s8j7l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l37: // global
           _s8j7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l38; else goto c8l39;
       c8l39: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l3b; else goto c8l3a;
       c8l3b: // global
           HpAlloc = 24;
           goto c8l38;
       c8l38: // global
           R1 = _s8j7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l3a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7l::P64;
           _s8j7e::P64 = P64[_s8j7l::P64 + 16];
           _s8j7h::P64 = P64[_s8j7l::P64 + 24];
           I64[Hp - 16] = sat_s8j7k_info;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 16;
           R2 = _s8j7h::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7m_entry() //  [R1]
         { info_tbl: [(c8l3g,
                       label: sat_s8j7m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l3h; else goto c8l3i;
       c8l3h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l3i: // global
           I64[Sp - 16] = block_c8l2Q_info;
           _s8j7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s8j7e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8l3o; else goto c8l2R;
       u8l3o: // global
           call _c8l2Q(R1) args: 0, res: 0, upd: 0;
       c8l2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l2Q() //  [R1]
         { info_tbl: [(c8l2Q,
                       label: block_c8l2Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l2Q: // global
           _s8j7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8l3d; else goto c8l3e;
       c8l3d: // global
           R1 = _s8j7e::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8l3e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8l3n; else goto c8l3m;
       c8l3n: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l3m: // global
           I64[Hp - 24] = sat_s8j7l_info;
           P64[Hp - 8] = _s8j7e::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionIOException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8j7g_entry() //  [R1]
         { info_tbl: [(c8l3p,
                       label: karg_s8j7g_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3p: // global
           _s8j7g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l3q; else goto c8l3r;
       c8l3r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8l3t; else goto c8l3s;
       c8l3t: // global
           HpAlloc = 32;
           goto c8l3q;
       c8l3q: // global
           R1 = _s8j7g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l3s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7g::P64;
           _s8j7a::P64 = P64[_s8j7g::P64 + 16];
           _s8j7c::P64 = P64[_s8j7g::P64 + 24];
           _s8j7e::P64 = P64[_s8j7g::P64 + 32];
           I64[Hp - 24] = sat_s8j7m_info;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 24;
           R2 = _s8j7a::P64;
           Sp = Sp - 16;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7q_entry() //  [R1]
         { info_tbl: [(c8l3E,
                       label: sat_s8j7q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3E: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_s8j7f_entry() //  [R1]
         { info_tbl: [(c8l3L,
                       label: eta_s8j7f_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3L: // global
           _s8j7f::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8l3M; else goto c8l3N;
       c8l3N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8l3P; else goto c8l3O;
       c8l3P: // global
           HpAlloc = 40;
           goto c8l3M;
       c8l3M: // global
           R1 = _s8j7f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l3O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7f::P64;
           _s8j7a::P64 = P64[_s8j7f::P64 + 16];
           _s8j7b::P64 = P64[_s8j7f::P64 + 24];
           _s8j7c::P64 = P64[_s8j7f::P64 + 32];
           _s8j7e::P64 = P64[_s8j7f::P64 + 40];
           I64[Hp - 32] = karg_s8j7g_info;
           P64[Hp - 16] = _s8j7a::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           I64[Sp - 32] = block_c8l3u_info;
           R1 = _s8j7b::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8l3V; else goto c8l3v;
       u8l3V: // global
           call _c8l3u(R1) args: 0, res: 0, upd: 0;
       c8l3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8l3u() //  [R1]
         { info_tbl: [(c8l3u,
                       label: block_c8l3u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3u: // global
           _c8l2I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8l3I; else goto c8l3J;
       c8l3I: // global
           R1 = _c8l2I::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8l3J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l3U; else goto c8l3T;
       c8l3U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8l3T: // global
           I64[Hp - 16] = sat_s8j7q_info;
           P64[Hp] = _c8l2I::P64;
           R3 = Hp - 16;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7x_entry() //  [R1]
         { info_tbl: [(c8l4o,
                       label: sat_s8j7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l4p; else goto c8l4q;
       c8l4p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l4q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7y_entry() //  [R1]
         { info_tbl: [(c8l4r,
                       label: sat_s8j7y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l4v; else goto c8l4u;
       c8l4v: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l4u: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7x_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7z_entry() //  [R1]
         { info_tbl: [(c8l4w,
                       label: sat_s8j7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4w: // global
           _s8j7z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l4x; else goto c8l4y;
       c8l4y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l4A; else goto c8l4z;
       c8l4A: // global
           HpAlloc = 24;
           goto c8l4x;
       c8l4x: // global
           R1 = _s8j7z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7z::P64;
           _s8j7f::P64 = P64[_s8j7z::P64 + 16];
           _s8j7v::P64 = P64[_s8j7z::P64 + 24];
           I64[Hp - 16] = sat_s8j7y_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7v::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7D_entry() //  [R1]
         { info_tbl: [(c8l4P,
                       label: sat_s8j7D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l4Q; else goto c8l4R;
       c8l4Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l4R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7E_entry() //  [R1]
         { info_tbl: [(c8l4S,
                       label: sat_s8j7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l4W; else goto c8l4V;
       c8l4W: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l4V: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7D_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7F_entry() //  [R1]
         { info_tbl: [(c8l4X,
                       label: sat_s8j7F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l4X: // global
           _s8j7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l4Y; else goto c8l4Z;
       c8l4Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l51; else goto c8l50;
       c8l51: // global
           HpAlloc = 24;
           goto c8l4Y;
       c8l4Y: // global
           R1 = _s8j7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l50: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7F::P64;
           _s8j7f::P64 = P64[_s8j7F::P64 + 16];
           _s8j7A::P64 = P64[_s8j7F::P64 + 24];
           I64[Hp - 16] = sat_s8j7E_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7A::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7H_entry() //  [R1]
         { info_tbl: [(c8l58,
                       label: sat_s8j7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l58: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8l5f,
                       label: GHC.IO.Exception.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l5f: // global
           _s8j7d::P64 = R6;
           _s8j7c::P64 = R5;
           _s8j7b::P64 = R4;
           _s8j7a::P64 = R3;
           _s8j79::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l5g; else goto c8l5h;
       c8l5h: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8l5j; else goto c8l5i;
       c8l5j: // global
           HpAlloc = 48;
           goto c8l5g;
       c8l5g: // global
           R6 = _s8j7d::P64;
           R5 = _s8j7c::P64;
           R4 = _s8j7b::P64;
           R3 = _s8j7a::P64;
           R2 = _s8j79::P64;
           R1 = GHC.IO.Exception.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8l5i: // global
           I64[Hp - 40] = eta_s8j7f_info;
           P64[Hp - 24] = _s8j7a::P64;
           P64[Hp - 16] = _s8j7b::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_c8l3W_info;
           R1 = _s8j7d::P64;
           P64[Sp - 8] = _s8j79::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8l5H; else goto c8l3X;
       u8l5H: // global
           call _c8l3W(R1) args: 0, res: 0, upd: 0;
       c8l3X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l3W() //  [R1]
         { info_tbl: [(c8l3W,
                       label: block_c8l3W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l3W: // global
           if (R1 & 7 == 1) goto c8l5c; else goto c8l5d;
       c8l5c: // global
           _s8j79::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8l41_info;
           R1 = _s8j79::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8l5F; else goto c8l42;
       u8l5F: // global
           call _c8l41(R1) args: 0, res: 0, upd: 0;
       c8l42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8l5d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l5C; else goto c8l5B;
       c8l5C: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l5B: // global
           _s8j7G::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j7H_info;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = _s8j7G::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8l41() //  [R1]
         { info_tbl: [(c8l41,
                       label: block_c8l41_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l41: // global
           if (R1 & 7 == 1) goto c8l5o; else goto c8l5q;
       c8l5o: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8l5q: // global
           I64[Sp] = block_c8l47_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u8l5G; else goto c8l48;
       u8l5G: // global
           call _c8l47(R1) args: 0, res: 0, upd: 0;
       c8l48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l47() //  [R1]
         { info_tbl: [(c8l47,
                       label: block_c8l47_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l47: // global
           _c8l2E::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8l5s; else goto c8l5w;
       c8l5s: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8l5z; else goto c8l5u;
       c8l5u: // global
           _s8j7v::P64 = P64[_s8j7u::P64 + 7];
           I64[Hp - 24] = sat_s8j7z_info;
           P64[Hp - 8] = _c8l2E::P64;
           P64[Hp] = _s8j7v::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8l5w: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8l5z; else goto c8l5y;
       c8l5z: // global
           HpAlloc = 32;
           R1 = _s8j7u::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l5y: // global
           _s8j7A::P64 = P64[_s8j7u::P64 + 6];
           I64[Hp - 24] = sat_s8j7F_info;
           P64[Hp - 8] = _c8l2E::P64;
           P64[Hp] = _s8j7A::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.360109951 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_entry() //  [R2,
                                                                  R3, R4]
         { info_tbl: [(c8l5P,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l5P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l5Q; else goto c8l5R;
       c8l5Q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8l5R: // global
           I64[Sp - 16] = block_c8l5M_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8l5V; else goto c8l5N;
       u8l5V: // global
           call _c8l5M(R1) args: 0, res: 0, upd: 0;
       c8l5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l5M() //  [R1]
         { info_tbl: [(c8l5M,
                       label: block_c8l5M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l5M: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.361472074 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8l63,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l63: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8l64; else goto c8l65;
       c8l64: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8l65: // global
           I64[Sp - 8] = block_c8l60_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8l69; else goto c8l61;
       u8l69: // global
           call _c8l60(R1) args: 0, res: 0, upd: 0;
       c8l61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l60() //  [R1]
         { info_tbl: [(c8l60,
                       label: block_c8l60_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l60: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = GHC.Types.[]_closure+1;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.36277104 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException1_closure" {
     GHC.IO.Exception.$fShowIOException1_closure:
         const GHC.IO.Exception.$fShowIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8l6h,
                       label: GHC.IO.Exception.$fShowIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l6i; else goto c8l6j;
       c8l6i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8l6j: // global
           I64[Sp - 16] = block_c8l6e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8l6n; else goto c8l6f;
       u8l6n: // global
           call _c8l6e(R1) args: 0, res: 0, upd: 0;
       c8l6f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l6e() //  [R1]
         { info_tbl: [(c8l6e,
                       label: block_c8l6e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6e: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.363932615 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8l6s,
                       label: GHC.IO.Exception.$fShowIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6s: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.364700902 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_closure" {
     GHC.IO.Exception.$fShowIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.365749074 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_$cto_closure" {
     GHC.IO.Exception.$fGenericExitCode_$cto_closure:
         const GHC.IO.Exception.$fGenericExitCode_$cto_info;
 },
 GHC.IO.Exception.$fGenericExitCode_$cto_entry() //  [R2]
         { info_tbl: [(c8l6F,
                       label: GHC.IO.Exception.$fGenericExitCode_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8l6G; else goto c8l6H;
       c8l6G: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8l6H: // global
           I64[Sp - 8] = block_c8l6z_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l6z() //  [R1]
         { info_tbl: [(c8l6z,
                       label: block_c8l6z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6z: // global
           if (R1 & 7 == 1) goto c8l6C; else goto c8l6D;
       c8l6C: // global
           I64[Sp] = block_c8l6K_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8l6X; else goto c8l6M;
       u8l6X: // global
           call _c8l6K() args: 0, res: 0, upd: 0;
       c8l6M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8l6D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8l6W; else goto c8l6V;
       c8l6W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l6V: // global
           _s8j8f::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = _s8j8f::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8l6K() //  []
         { info_tbl: [(c8l6K,
                       label: block_c8l6K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l6K: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.367047466 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode2_closure" {
     GHC.IO.Exception.$fGenericExitCode2_closure:
         const GHC.Generics.L1_con_info;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.367941287 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode1_closure" {
     GHC.IO.Exception.$fGenericExitCode1_closure:
         const GHC.IO.Exception.$fGenericExitCode1_info;
 },
 GHC.IO.Exception.$fGenericExitCode1_entry() //  [R2]
         { info_tbl: [(c8l79,
                       label: GHC.IO.Exception.$fGenericExitCode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l79: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8l7a; else goto c8l7b;
       c8l7a: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8l7b: // global
           I64[Sp - 8] = block_c8l72_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8l7l; else goto c8l73;
       u8l7l: // global
           call _c8l72(R1) args: 0, res: 0, upd: 0;
       c8l73: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l72() //  [R1]
         { info_tbl: [(c8l72,
                       label: block_c8l72_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l72: // global
           if (R1 & 7 == 1) goto c8l76; else goto c8l77;
       c8l76: // global
           R1 = GHC.IO.Exception.$fGenericExitCode2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8l77: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8l7k; else goto c8l7j;
       c8l7k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l7j: // global
           _s8j8i::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _s8j8i::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.369108576 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_closure" {
     GHC.IO.Exception.$fGenericExitCode_closure:
         const GHC.Generics.C:Generic_con_info;
         const GHC.IO.Exception.$fGenericExitCode1_closure+1;
         const GHC.IO.Exception.$fGenericExitCode_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.369723885 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode3_bytes" {
     GHC.IO.Exception.$fExceptionExitCode3_bytes:
         I8[] [69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.370615784 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode2_closure" {
     GHC.IO.Exception.$fExceptionExitCode2_closure:
         const GHC.IO.Exception.$fExceptionExitCode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode2_entry() //  [R1]
         { info_tbl: [(c8l7s,
                       label: GHC.IO.Exception.$fExceptionExitCode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l7t; else goto c8l7u;
       c8l7t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l7u: // global
           (_c8l7p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8l7p::I64 == 0) goto c8l7r; else goto c8l7q;
       c8l7r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8l7q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8l7p::I64;
           R2 = GHC.IO.Exception.$fExceptionExitCode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.371774823 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode1_bytes" {
     GHC.IO.Exception.$fExceptionExitCode1_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.374146643 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info;
         const 0;
 },
 sat_s8j8w_entry() //  [R1]
         { info_tbl: [(c8l7U,
                       label: sat_s8j8w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8l80; else goto c8l81;
       c8l80: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l81: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8l7R_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8l86; else goto c8l7S;
       u8l86: // global
           call _c8l7R(R1) args: 0, res: 0, upd: 0;
       c8l7S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8l7R() //  [R1]
         { info_tbl: [(c8l7R,
                       label: block_c8l7R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7R: // global
           _s8j8l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8l7X_info;
           R4 = _s8j8l::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8l7X() //  [R1, R2]
         { info_tbl: [(c8l7X,
                       label: block_c8l7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l85; else goto c8l84;
       c8l85: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8l84: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8D_entry() //  [R1]
         { info_tbl: [(c8l8j,
                       label: sat_s8j8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l8j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8l8q; else goto c8l8r;
       c8l8q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l8r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8l8g_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8l8y; else goto c8l8h;
       u8l8y: // global
           call _c8l8g(R1) args: 0, res: 0, upd: 0;
       c8l8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8l8g() //  [R1]
         { info_tbl: [(c8l8g,
                       label: block_c8l8g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l8g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l8u; else goto c8l8t;
       c8l8u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8l8t: // global
           _s8j8y::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8l8n_info;
           R4 = Hp - 14;
           R3 = _s8j8y::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8l8n() //  [R1, R2]
         { info_tbl: [(c8l8n,
                       label: block_c8l8n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l8n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l8x; else goto c8l8w;
       c8l8x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8l8w: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8E_entry() //  [R1]
         { info_tbl: [(c8l8z,
                       label: sat_s8j8E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l8z: // global
           _s8j8E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8l8A; else goto c8l8B;
       c8l8B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8l8D; else goto c8l8C;
       c8l8D: // global
           HpAlloc = 32;
           goto c8l8A;
       c8l8A: // global
           R1 = _s8j8E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l8C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j8E::P64;
           _s8j8l::P64 = P64[_s8j8E::P64 + 16];
           _s8j8n::P64 = P64[_s8j8E::P64 + 24];
           I64[Hp - 24] = sat_s8j8D_info;
           P64[Hp - 8] = _s8j8l::P64;
           P64[Hp] = _s8j8n::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8l8I,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l8I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8l8J; else goto c8l8K;
       c8l8J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8l8K: // global
           I64[Sp - 24] = block_c8l7z_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8l8W; else goto c8l7A;
       u8l8W: // global
           call _c8l7z(R1) args: 0, res: 0, upd: 0;
       c8l7A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l7z() //  [R1]
         { info_tbl: [(c8l7z,
                       label: block_c8l7z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7z: // global
           if (R1 & 7 == 1) goto c8l8F; else goto c8l8G;
       c8l8F: // global
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8l8G: // global
           I64[Sp] = block_c8l7F_info;
           _s8j8n::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j8n::P64;
           if (R1 & 7 != 0) goto u8l8V; else goto c8l7G;
       u8l8V: // global
           call _c8l7F(R1) args: 0, res: 0, upd: 0;
       c8l7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l7F() //  [R1]
         { info_tbl: [(c8l7F,
                       label: block_c8l7F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l7F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8l8Q; else goto c8l8P;
       c8l8Q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l8P: // global
           _s8j8l::P64 = P64[Sp + 16];
           _s8j8n::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c8l8S; else goto c8l8U;
       c8l8S: // global
           I64[Hp - 48] = sat_s8j8w_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           _c8l7N::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c8l7N::P64;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8l8U: // global
           I64[Hp - 48] = sat_s8j8E_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.379683574 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cshow_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cshow_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_info;
         const 0;
 },
 sat_s8j8N_entry() //  [R1]
         { info_tbl: [(c8l9e,
                       label: sat_s8j8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8l9k; else goto c8l9l;
       c8l9k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8l9l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8l9b_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8l9q; else goto c8l9c;
       u8l9q: // global
           call _c8l9b(R1) args: 0, res: 0, upd: 0;
       c8l9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8l9b() //  [R1]
         { info_tbl: [(c8l9b,
                       label: block_c8l9b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9b: // global
           I64[Sp] = block_c8l9h_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8l9h() //  [R1, R2]
         { info_tbl: [(c8l9h,
                       label: block_c8l9h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l9p; else goto c8l9o;
       c8l9p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8l9o: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fExceptionExitCode_$cshow_entry() //  [R2]
         { info_tbl: [(c8l9v,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8l9w; else goto c8l9x;
       c8l9w: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8l9x: // global
           I64[Sp - 8] = block_c8l91_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8l9D; else goto c8l92;
       u8l9D: // global
           call _c8l91(R1) args: 0, res: 0, upd: 0;
       c8l92: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l91() //  [R1]
         { info_tbl: [(c8l91,
                       label: block_c8l91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l91: // global
           if (R1 & 7 == 1) goto c8l9s; else goto c8l9t;
       c8l9s: // global
           R1 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8l9t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8l9C; else goto c8l9B;
       c8l9C: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8l9B: // global
           _s8j8H::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j8N_info;
           P64[Hp] = _s8j8H::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.382396902 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode1_closure" {
     GHC.IO.Exception.$fShowExitCode1_closure:
         const GHC.IO.Exception.$fShowExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8l9I,
                       label: GHC.IO.Exception.$fShowExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9I: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionArrayException1_closure+1;
           call GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.383557725 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowList_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowList_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8l9P,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9P: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowExitCode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.384486947 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_closure" {
     GHC.IO.Exception.$fShowExitCode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const GHC.IO.Exception.$fShowExitCode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.385265928 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme1_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.385997637 UTC

[section ""cstring" . GHC.IO.Exception.$fReadExitCode5_bytes" {
     GHC.IO.Exception.$fReadExitCode5_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.387027975 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode4_closure" {
     GHC.IO.Exception.$fReadExitCode4_closure:
         const GHC.IO.Exception.$fReadExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode4_entry() //  [R1]
         { info_tbl: [(c8l9Y,
                       label: GHC.IO.Exception.$fReadExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8l9Z; else goto c8la0;
       c8l9Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8la0: // global
           (_c8l9V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8l9V::I64 == 0) goto c8l9X; else goto c8l9W;
       c8l9X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8l9W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8l9V::I64;
           R2 = GHC.IO.Exception.$fReadExitCode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.388212114 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fReadExitCode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.389059189 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode3_closure" {
     GHC.IO.Exception.$fReadExitCode3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.391213237 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode2_closure" {
     GHC.IO.Exception.$fReadExitCode2_closure:
         const GHC.IO.Exception.$fReadExitCode2_info;
         const 0;
 },
 sat_s8j8T_entry() //  [R1]
         { info_tbl: [(c8laa,
                       label: sat_s8j8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laa: // global
           R2 = GHC.IO.Exception.ExitSuccess_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j93_entry() //  [R1, R2]
         { info_tbl: [(c8laD,
                       label: sat_s8j93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8laH; else goto c8laG;
       c8laH: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8laG: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _s8j8R::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j94_entry() //  [R1, R2]
         { info_tbl: [(c8laI,
                       label: sat_s8j94_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8laM; else goto c8laL;
       c8laM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8laL: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8j93_info;
           P64[Hp] = _s8j8R::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Exception.$fReadExitCode3_closure+1;
           R2 = GHC.Read.$fReadInt2_closure+1;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j97_entry() //  [R1]
         { info_tbl: [(c8laN,
                       label: sat_s8j97_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8laO; else goto c8laP;
       c8laO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8laP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8laj_info;
           _s8j8R::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8j8R::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8lb2; else goto c8lak;
       u8lb2: // global
           call _c8laj(R1) args: 0, res: 0, upd: 0;
       c8lak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8laj() //  [R1]
         { info_tbl: [(c8laj,
                       label: block_c8laj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8laS; else goto c8laR;
       c8laS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8laR: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8laU; else goto c8laY;
       c8laU: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8laY: // global
           I64[Hp - 8] = sat_s8j94_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8laV_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8laV() //  [R1]
         { info_tbl: [(c8laV,
                       label: block_c8laV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8laV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lb1; else goto c8lb0;
       c8lb1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8lb0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode2_entry() //  [R2, R3]
         { info_tbl: [(c8lb4,
                       label: GHC.IO.Exception.$fReadExitCode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lb4: // global
           _s8j8R::P64 = R3;
           _s8j8Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8lb5; else goto c8lb6;
       c8lb6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lb8; else goto c8lb7;
       c8lb8: // global
           HpAlloc = 16;
           goto c8lb5;
       c8lb5: // global
           R3 = _s8j8R::P64;
           R2 = _s8j8Q::P64;
           R1 = GHC.IO.Exception.$fReadExitCode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lb7: // global
           I64[Hp - 8] = sat_s8j8T_info;
           P64[Hp] = _s8j8R::P64;
           I64[Sp - 24] = block_c8lad_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme1_closure+4;
           P64[Sp - 16] = _s8j8Q::P64;
           P64[Sp - 8] = _s8j8R::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lad() //  [R1]
         { info_tbl: [(c8lad,
                       label: block_c8lad_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lad: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lbb; else goto c8lba;
       c8lbb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lba: // global
           I64[Hp - 40] = sat_s8j97_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.395326875 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode1_closure" {
     GHC.IO.Exception.$fReadExitCode1_closure:
         const GHC.IO.Exception.$fReadExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8lbg,
                       label: GHC.IO.Exception.$fReadExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbg: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.396644866 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_info;
         const 0;
 },
 sat_s8j99_entry() //  [R1]
         { info_tbl: [(c8lbr,
                       label: sat_s8j99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lbs; else goto c8lbt;
       c8lbs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lbt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8lbu,
                       label: GHC.IO.Exception.$fReadExitCode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lby; else goto c8lbx;
       c8lby: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lbx: // global
           I64[Hp - 16] = sat_s8j99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.398378691 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8lbF,
                       label: GHC.IO.Exception.$fReadExitCode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lbG; else goto c8lbH;
       c8lbG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lbH: // global
           (_c8lbC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lbC::I64 == 0) goto c8lbE; else goto c8lbD;
       c8lbE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lbD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lbC::I64;
           R2 = GHC.IO.Exception.$fReadExitCode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.401801075 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode6_closure" {
     GHC.IO.Exception.$fReadExitCode6_closure:
         const GHC.IO.Exception.$fReadExitCode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode6_entry() //  [R1]
         { info_tbl: [(c8lbO,
                       label: GHC.IO.Exception.$fReadExitCode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lbP; else goto c8lbQ;
       c8lbP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lbQ: // global
           (_c8lbL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lbL::I64 == 0) goto c8lbN; else goto c8lbM;
       c8lbN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lbM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lbL::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.402862225 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadList_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadList_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadList_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadList_entry() //  [R2]
         { info_tbl: [(c8lbV,
                       label: GHC.IO.Exception.$fReadExitCode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lbV: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode6_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.403645859 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_closure" {
     GHC.IO.Exception.$fReadExitCode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure+1;
         const GHC.IO.Exception.$fReadExitCode_$creadList_closure+1;
         const GHC.IO.Exception.$fReadExitCode1_closure+2;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.404783096 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8lc9,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lc9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lca; else goto c8lcb;
       c8lca: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lcb: // global
           I64[Sp - 16] = block_c8lc2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lcM; else goto c8lc3;
       u8lcM: // global
           call _c8lc2(R1) args: 0, res: 0, upd: 0;
       c8lc3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lc2() //  [R1]
         { info_tbl: [(c8lc2,
                       label: block_c8lc2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lc2: // global
           _s8j9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lc6; else goto c8lc7;
       c8lc6: // global
           I64[Sp + 8] = block_c8lce_info;
           R1 = _s8j9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lcK; else goto c8lcg;
       u8lcK: // global
           call _c8lce(R1) args: 0, res: 0, upd: 0;
       c8lcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lc7: // global
           I64[Sp] = block_c8lct_info;
           _s8j9f::P64 = P64[R1 + 6];
           R1 = _s8j9b::P64;
           P64[Sp + 8] = _s8j9f::P64;
           if (R1 & 7 != 0) goto u8lcL; else goto c8lcv;
       u8lcL: // global
           call _c8lct(R1) args: 0, res: 0, upd: 0;
       c8lcv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lce() //  [R1]
         { info_tbl: [(c8lce,
                       label: block_c8lce_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lce: // global
           if (R1 & 7 == 1) goto u8lcJ; else goto c8lcq;
       u8lcJ: // global
           Sp = Sp + 8;
           call _c8lcB() args: 0, res: 0, upd: 0;
       c8lcq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lct() //  [R1]
         { info_tbl: [(c8lct,
                       label: block_c8lct_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lct: // global
           if (R1 & 7 == 1) goto u8lcI; else goto c8lcF;
       u8lcI: // global
           Sp = Sp + 16;
           call _c8lcB() args: 0, res: 0, upd: 0;
       c8lcF: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8lcB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lcB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.406855697 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$ccompare_closure" {
     GHC.IO.Exception.$fOrdExitCode_$ccompare_closure:
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8ld0,
                       label: GHC.IO.Exception.$fOrdExitCode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ld0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ld1; else goto c8ld2;
       c8ld1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ld2: // global
           I64[Sp - 16] = block_c8lcT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ldB; else goto c8lcU;
       u8ldB: // global
           call _c8lcT(R1) args: 0, res: 0, upd: 0;
       c8lcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lcT() //  [R1]
         { info_tbl: [(c8lcT,
                       label: block_c8lcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lcT: // global
           _s8j9j::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lcX; else goto c8lcY;
       c8lcX: // global
           I64[Sp + 8] = block_c8ld5_info;
           R1 = _s8j9j::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ldz; else goto c8ld7;
       u8ldz: // global
           call _c8ld5(R1) args: 0, res: 0, upd: 0;
       c8ld7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lcY: // global
           I64[Sp] = block_c8ldk_info;
           _s8j9n::P64 = P64[R1 + 6];
           R1 = _s8j9j::P64;
           P64[Sp + 8] = _s8j9n::P64;
           if (R1 & 7 != 0) goto u8ldA; else goto c8ldm;
       u8ldA: // global
           call _c8ldk(R1) args: 0, res: 0, upd: 0;
       c8ldm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ld5() //  [R1]
         { info_tbl: [(c8ld5,
                       label: block_c8ld5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ld5: // global
           if (R1 & 7 == 1) goto c8ldd; else goto c8ldh;
       c8ldd: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ldh: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ldk() //  [R1]
         { info_tbl: [(c8ldk,
                       label: block_c8ldk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ldk: // global
           if (R1 & 7 == 1) goto c8lds; else goto c8ldw;
       c8lds: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ldw: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.408949185 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c==_closure" {
     GHC.IO.Exception.$fEqExitCode_$c==_closure:
         const GHC.IO.Exception.$fEqExitCode_$c==_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8ldN,
                       label: GHC.IO.Exception.$fEqExitCode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ldN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ldO; else goto c8ldP;
       c8ldO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ldP: // global
           I64[Sp - 16] = block_c8ldG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8leq; else goto c8ldH;
       u8leq: // global
           call _c8ldG(R1) args: 0, res: 0, upd: 0;
       c8ldH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ldG() //  [R1]
         { info_tbl: [(c8ldG,
                       label: block_c8ldG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ldG: // global
           _s8j9r::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ldK; else goto c8ldL;
       c8ldK: // global
           I64[Sp + 8] = block_c8ldS_info;
           R1 = _s8j9r::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8leo; else goto c8ldU;
       u8leo: // global
           call _c8ldS(R1) args: 0, res: 0, upd: 0;
       c8ldU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ldL: // global
           I64[Sp] = block_c8le7_info;
           _s8j9v::P64 = P64[R1 + 6];
           R1 = _s8j9r::P64;
           P64[Sp + 8] = _s8j9v::P64;
           if (R1 & 7 != 0) goto u8lep; else goto c8le9;
       u8lep: // global
           call _c8le7(R1) args: 0, res: 0, upd: 0;
       c8le9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ldS() //  [R1]
         { info_tbl: [(c8ldS,
                       label: block_c8ldS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ldS: // global
           if (R1 & 7 == 1) goto c8le0; else goto u8len;
       c8le0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8len: // global
           Sp = Sp + 8;
           call _c8lef() args: 0, res: 0, upd: 0;
     }
 },
 _c8le7() //  [R1]
         { info_tbl: [(c8le7,
                       label: block_c8le7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8le7: // global
           if (R1 & 7 == 1) goto u8lem; else goto c8lej;
       u8lem: // global
           Sp = Sp + 16;
           call _c8lef() args: 0, res: 0, upd: 0;
       c8lej: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8lef() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lef: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.411342223 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c/=_closure" {
     GHC.IO.Exception.$fEqExitCode_$c/=_closure:
         const GHC.IO.Exception.$fEqExitCode_$c/=_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8leE,
                       label: GHC.IO.Exception.$fEqExitCode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8leE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8leF; else goto c8leG;
       c8leF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8leG: // global
           I64[Sp - 16] = block_c8lex_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lfB; else goto c8ley;
       u8lfB: // global
           call _c8lex(R1) args: 0, res: 0, upd: 0;
       c8ley: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lex() //  [R1]
         { info_tbl: [(c8lex,
                       label: block_c8lex_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lex: // global
           _s8j9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8leB; else goto c8leC;
       c8leB: // global
           I64[Sp + 8] = block_c8leJ_info;
           R1 = _s8j9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lfz; else goto c8leL;
       u8lfz: // global
           call _c8leJ(R1) args: 0, res: 0, upd: 0;
       c8leL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8leC: // global
           I64[Sp] = block_c8leY_info;
           _s8j9D::P64 = P64[R1 + 6];
           R1 = _s8j9z::P64;
           P64[Sp + 8] = _s8j9D::P64;
           if (R1 & 7 != 0) goto u8lfA; else goto c8lf0;
       u8lfA: // global
           call _c8leY(R1) args: 0, res: 0, upd: 0;
       c8lf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8leJ() //  [R1]
         { info_tbl: [(c8leJ,
                       label: block_c8leJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8leJ: // global
           if (R1 & 7 == 1) goto u8lfx; else goto u8lfy;
       u8lfx: // global
           Sp = Sp + 8;
           call _c8lfr() args: 0, res: 0, upd: 0;
       u8lfy: // global
           Sp = Sp + 8;
           call _c8lfq() args: 0, res: 0, upd: 0;
     }
 },
 _c8leY() //  [R1]
         { info_tbl: [(c8leY,
                       label: block_c8leY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8leY: // global
           if (R1 & 7 == 1) goto u8lfu; else goto c8lfg;
       u8lfu: // global
           Sp = Sp + 16;
           call _c8lfq() args: 0, res: 0, upd: 0;
       c8lfg: // global
           I64[Sp] = block_c8lf9_info;
           _s8j9F::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9F::P64;
           if (R1 & 7 != 0) goto u8lfE; else goto c8lfa;
       u8lfE: // global
           call _c8lf9(R1) args: 0, res: 0, upd: 0;
       c8lfa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lf9() //  [R1]
         { info_tbl: [(c8lf9,
                       label: block_c8lf9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lf9: // global
           I64[Sp] = block_c8lfe_info;
           _s8j9H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9H::I64;
           if (R1 & 7 != 0) goto u8lfG; else goto c8lfi;
       u8lfG: // global
           call _c8lfe(R1) args: 0, res: 0, upd: 0;
       c8lfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lfe() //  [R1]
         { info_tbl: [(c8lfe,
                       label: block_c8lfe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfe: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8lfv; else goto u8lfw;
       u8lfv: // global
           Sp = Sp + 16;
           call _c8lfr() args: 0, res: 0, upd: 0;
       u8lfw: // global
           Sp = Sp + 16;
           call _c8lfq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lfr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfr: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lfq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.413420144 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_closure" {
     GHC.IO.Exception.$fEqExitCode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqExitCode_$c==_closure+2;
         const GHC.IO.Exception.$fEqExitCode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.414745607 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8lfU,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lfV; else goto c8lfW;
       c8lfV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lfW: // global
           I64[Sp - 16] = block_c8lfN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lgR; else goto c8lfO;
       u8lgR: // global
           call _c8lfN(R1) args: 0, res: 0, upd: 0;
       c8lfO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lfN() //  [R1]
         { info_tbl: [(c8lfN,
                       label: block_c8lfN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfN: // global
           _s8j9L::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lfR; else goto c8lfS;
       c8lfR: // global
           I64[Sp + 8] = block_c8lfZ_info;
           R1 = _s8j9L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lgP; else goto c8lg1;
       u8lgP: // global
           call _c8lfZ(R1) args: 0, res: 0, upd: 0;
       c8lg1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lfS: // global
           I64[Sp] = block_c8lge_info;
           _s8j9Q::P64 = P64[R1 + 6];
           R1 = _s8j9L::P64;
           P64[Sp + 8] = _s8j9Q::P64;
           if (R1 & 7 != 0) goto u8lgQ; else goto c8lgg;
       u8lgQ: // global
           call _c8lge(R1) args: 0, res: 0, upd: 0;
       c8lgg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lfZ() //  [R1]
         { info_tbl: [(c8lfZ,
                       label: block_c8lfZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lfZ: // global
           if (R1 & 7 == 1) goto u8lgN; else goto u8lgO;
       u8lgN: // global
           Sp = Sp + 8;
           call _c8lgG() args: 0, res: 0, upd: 0;
       u8lgO: // global
           Sp = Sp + 8;
           call _c8lgH() args: 0, res: 0, upd: 0;
     }
 },
 _c8lge() //  [R1]
         { info_tbl: [(c8lge,
                       label: block_c8lge_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lge: // global
           if (R1 & 7 == 1) goto u8lgK; else goto c8lgw;
       u8lgK: // global
           Sp = Sp + 16;
           call _c8lgG() args: 0, res: 0, upd: 0;
       c8lgw: // global
           I64[Sp] = block_c8lgp_info;
           _s8j9S::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9S::P64;
           if (R1 & 7 != 0) goto u8lgU; else goto c8lgq;
       u8lgU: // global
           call _c8lgp(R1) args: 0, res: 0, upd: 0;
       c8lgq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lgp() //  [R1]
         { info_tbl: [(c8lgp,
                       label: block_c8lgp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lgp: // global
           I64[Sp] = block_c8lgu_info;
           _s8j9U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9U::I64;
           if (R1 & 7 != 0) goto u8lgW; else goto c8lgy;
       u8lgW: // global
           call _c8lgu(R1) args: 0, res: 0, upd: 0;
       c8lgy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lgu() //  [R1]
         { info_tbl: [(c8lgu,
                       label: block_c8lgu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lgu: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8lgM; else goto u8lgL;
       u8lgM: // global
           Sp = Sp + 16;
           call _c8lgG() args: 0, res: 0, upd: 0;
       u8lgL: // global
           Sp = Sp + 16;
           call _c8lgH() args: 0, res: 0, upd: 0;
     }
 },
 _c8lgG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lgG: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lgH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lgH: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.417540766 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmax_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmax_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmax_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8lha,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lha: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8lhb; else goto c8lhc;
       c8lhb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lhc: // global
           I64[Sp - 16] = block_c8lh3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lhQ; else goto c8lh4;
       u8lhQ: // global
           call _c8lh3(R1) args: 0, res: 0, upd: 0;
       c8lh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lh3() //  [R1]
         { info_tbl: [(c8lh3,
                       label: block_c8lh3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lh3: // global
           _s8j9Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lh7; else goto c8lh8;
       c8lh7: // global
           R1 = _s8j9Y::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lh8: // global
           I64[Sp - 8] = block_c8lhi_info;
           _s8ja0::P64 = R1;
           _s8ja1::P64 = P64[R1 + 6];
           R1 = _s8j9Y::P64;
           P64[Sp] = _s8ja1::P64;
           P64[Sp + 8] = _s8ja0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lhP; else goto c8lhk;
       u8lhP: // global
           call _c8lhi(R1) args: 0, res: 0, upd: 0;
       c8lhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lhi() //  [R1]
         { info_tbl: [(c8lhi,
                       label: block_c8lhi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lhi: // global
           if (R1 & 7 == 1) goto u8lhN; else goto c8lhA;
       u8lhN: // global
           Sp = Sp + 16;
           call _c8lhK() args: 0, res: 0, upd: 0;
       c8lhA: // global
           I64[Sp - 8] = block_c8lht_info;
           _s8ja2::P64 = R1;
           _s8ja3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ja3::P64;
           P64[Sp + 8] = _s8ja2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lhR; else goto c8lhu;
       u8lhR: // global
           call _c8lht(R1) args: 0, res: 0, upd: 0;
       c8lhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lht() //  [R1]
         { info_tbl: [(c8lht,
                       label: block_c8lht_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lht: // global
           I64[Sp] = block_c8lhy_info;
           _s8ja5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ja5::I64;
           if (R1 & 7 != 0) goto u8lhT; else goto c8lhC;
       u8lhT: // global
           call _c8lhy(R1) args: 0, res: 0, upd: 0;
       c8lhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lhy() //  [R1]
         { info_tbl: [(c8lhy,
                       label: block_c8lhy_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lhy: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8lhO; else goto c8lhL;
       u8lhO: // global
           Sp = Sp + 24;
           call _c8lhK() args: 0, res: 0, upd: 0;
       c8lhL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lhK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lhK: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.420159996 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8li6,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8li6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8li7; else goto c8li8;
       c8li7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8li8: // global
           I64[Sp - 16] = block_c8lhZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lj3; else goto c8li0;
       u8lj3: // global
           call _c8lhZ(R1) args: 0, res: 0, upd: 0;
       c8li0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lhZ() //  [R1]
         { info_tbl: [(c8lhZ,
                       label: block_c8lhZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lhZ: // global
           _s8jaa::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8li3; else goto c8li4;
       c8li3: // global
           I64[Sp + 8] = block_c8lib_info;
           R1 = _s8jaa::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lj1; else goto c8lid;
       u8lj1: // global
           call _c8lib(R1) args: 0, res: 0, upd: 0;
       c8lid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8li4: // global
           I64[Sp] = block_c8liq_info;
           _s8jae::P64 = P64[R1 + 6];
           R1 = _s8jaa::P64;
           P64[Sp + 8] = _s8jae::P64;
           if (R1 & 7 != 0) goto u8lj2; else goto c8lis;
       u8lj2: // global
           call _c8liq(R1) args: 0, res: 0, upd: 0;
       c8lis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lib() //  [R1]
         { info_tbl: [(c8lib,
                       label: block_c8lib_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lib: // global
           if (R1 & 7 == 1) goto u8liZ; else goto u8lj0;
       u8liZ: // global
           Sp = Sp + 8;
           call _c8liS() args: 0, res: 0, upd: 0;
       u8lj0: // global
           Sp = Sp + 8;
           call _c8liT() args: 0, res: 0, upd: 0;
     }
 },
 _c8liq() //  [R1]
         { info_tbl: [(c8liq,
                       label: block_c8liq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8liq: // global
           if (R1 & 7 == 1) goto u8liW; else goto c8liI;
       u8liW: // global
           Sp = Sp + 16;
           call _c8liS() args: 0, res: 0, upd: 0;
       c8liI: // global
           I64[Sp] = block_c8liB_info;
           _s8jag::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8jag::P64;
           if (R1 & 7 != 0) goto u8lj6; else goto c8liC;
       u8lj6: // global
           call _c8liB(R1) args: 0, res: 0, upd: 0;
       c8liC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8liB() //  [R1]
         { info_tbl: [(c8liB,
                       label: block_c8liB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8liB: // global
           I64[Sp] = block_c8liG_info;
           _s8jai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jai::I64;
           if (R1 & 7 != 0) goto u8lj8; else goto c8liK;
       u8lj8: // global
           call _c8liG(R1) args: 0, res: 0, upd: 0;
       c8liK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8liG() //  [R1]
         { info_tbl: [(c8liG,
                       label: block_c8liG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8liG: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8liY; else goto u8liX;
       u8liY: // global
           Sp = Sp + 16;
           call _c8liS() args: 0, res: 0, upd: 0;
       u8liX: // global
           Sp = Sp + 16;
           call _c8liT() args: 0, res: 0, upd: 0;
     }
 },
 _c8liS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8liS: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8liT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8liT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.422373306 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8ljf,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljf: // global
           _s8jan::P64 = R3;
           R3 = R2;
           R2 = _s8jan::P64;
           call GHC.IO.Exception.$fOrdExitCode_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.423743611 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmin_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmin_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmin_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8ljt,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8lju; else goto c8ljv;
       c8lju: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ljv: // global
           I64[Sp - 16] = block_c8ljm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lke; else goto c8ljn;
       u8lke: // global
           call _c8ljm(R1) args: 0, res: 0, upd: 0;
       c8ljn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ljm() //  [R1]
         { info_tbl: [(c8ljm,
                       label: block_c8ljm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljm: // global
           _s8jao::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ljq; else goto c8ljr;
       c8ljq: // global
           I64[Sp + 8] = block_c8ljy_info;
           R1 = _s8jao::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lkc; else goto c8ljA;
       u8lkc: // global
           call _c8ljy() args: 0, res: 0, upd: 0;
       c8ljA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ljr: // global
           I64[Sp - 8] = block_c8ljH_info;
           _s8jaq::P64 = R1;
           _s8jas::P64 = P64[R1 + 6];
           R1 = _s8jao::P64;
           P64[Sp] = _s8jas::P64;
           P64[Sp + 8] = _s8jaq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lkd; else goto c8ljJ;
       u8lkd: // global
           call _c8ljH(R1) args: 0, res: 0, upd: 0;
       c8ljJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ljy() //  []
         { info_tbl: [(c8ljy,
                       label: block_c8ljy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljy: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ljH() //  [R1]
         { info_tbl: [(c8ljH,
                       label: block_c8ljH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljH: // global
           if (R1 & 7 == 1) goto c8ljP; else goto c8ljZ;
       c8ljP: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ljZ: // global
           I64[Sp - 8] = block_c8ljS_info;
           _s8jat::P64 = R1;
           _s8jau::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8jau::P64;
           P64[Sp + 8] = _s8jat::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lkf; else goto c8ljT;
       u8lkf: // global
           call _c8ljS(R1) args: 0, res: 0, upd: 0;
       c8ljT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ljS() //  [R1]
         { info_tbl: [(c8ljS,
                       label: block_c8ljS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljS: // global
           I64[Sp] = block_c8ljX_info;
           _s8jaw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jaw::I64;
           if (R1 & 7 != 0) goto u8lkg; else goto c8lk1;
       u8lkg: // global
           call _c8ljX(R1) args: 0, res: 0, upd: 0;
       c8lk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ljX() //  [R1]
         { info_tbl: [(c8ljX,
                       label: block_c8ljX_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ljX: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c8lk9; else goto c8lka;
       c8lk9: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lka: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.425779287 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_closure" {
     GHC.IO.Exception.$fOrdExitCode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqExitCode_closure+1;
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.426956438 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8lks,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lks: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lkt; else goto c8lku;
       c8lkt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lku: // global
           I64[Sp - 16] = block_c8lkl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ll3; else goto c8lkm;
       u8ll3: // global
           call _c8lkl(R1) args: 0, res: 0, upd: 0;
       c8lkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lkl() //  [R1]
         { info_tbl: [(c8lkl,
                       label: block_c8lkl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lkl: // global
           _s8jaB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lkp; else goto c8lkq;
       c8lkp: // global
           I64[Sp] = block_c8lkx_info;
           _s8jaD::P64 = P64[R1 + 7];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaD::P64;
           if (R1 & 7 != 0) goto u8ll1; else goto c8lkz;
       u8ll1: // global
           call _c8lkx(R1) args: 0, res: 0, upd: 0;
       c8lkz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lkq: // global
           I64[Sp] = block_c8lkM_info;
           _s8jaH::P64 = P64[R1 + 6];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaH::P64;
           if (R1 & 7 != 0) goto u8ll2; else goto c8lkO;
       u8ll2: // global
           call _c8lkM(R1) args: 0, res: 0, upd: 0;
       c8lkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lkx() //  [R1]
         { info_tbl: [(c8lkx,
                       label: block_c8lkx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lkx: // global
           if (R1 & 7 == 1) goto c8lkF; else goto c8lkJ;
       c8lkF: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c8lkJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lkM() //  [R1]
         { info_tbl: [(c8lkM,
                       label: block_c8lkM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lkM: // global
           if (R1 & 7 == 1) goto c8lkU; else goto c8lkY;
       c8lkU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lkY: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.429028341 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdArrayException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8llf,
                       label: GHC.IO.Exception.$fOrdArrayException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8llf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8llg; else goto c8llh;
       c8llg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8llh: // global
           I64[Sp - 16] = block_c8ll8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8llQ; else goto c8ll9;
       u8llQ: // global
           call _c8ll8(R1) args: 0, res: 0, upd: 0;
       c8ll9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ll8() //  [R1]
         { info_tbl: [(c8ll8,
                       label: block_c8ll8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ll8: // global
           _s8jaM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8llc; else goto c8lld;
       c8llc: // global
           I64[Sp] = block_c8llk_info;
           _s8jaO::P64 = P64[R1 + 7];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaO::P64;
           if (R1 & 7 != 0) goto u8llO; else goto c8llm;
       u8llO: // global
           call _c8llk(R1) args: 0, res: 0, upd: 0;
       c8llm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lld: // global
           I64[Sp] = block_c8llz_info;
           _s8jaS::P64 = P64[R1 + 6];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaS::P64;
           if (R1 & 7 != 0) goto u8llP; else goto c8llB;
       u8llP: // global
           call _c8llz(R1) args: 0, res: 0, upd: 0;
       c8llB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8llk() //  [R1]
         { info_tbl: [(c8llk,
                       label: block_c8llk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8llk: // global
           if (R1 & 7 == 1) goto c8lls; else goto c8llw;
       c8lls: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8llw: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8llz() //  [R1]
         { info_tbl: [(c8llz,
                       label: block_c8llz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8llz: // global
           if (R1 & 7 == 1) goto c8llH; else goto c8llL;
       c8llH: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8llL: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.431266712 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c==_closure" {
     GHC.IO.Exception.$fEqArrayException_$c==_closure:
         const GHC.IO.Exception.$fEqArrayException_$c==_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8lm2,
                       label: GHC.IO.Exception.$fEqArrayException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lm2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lm3; else goto c8lm4;
       c8lm3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lm4: // global
           I64[Sp - 16] = block_c8llV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lmF; else goto c8llW;
       u8lmF: // global
           call _c8llV(R1) args: 0, res: 0, upd: 0;
       c8llW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8llV() //  [R1]
         { info_tbl: [(c8llV,
                       label: block_c8llV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8llV: // global
           _s8jaX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8llZ; else goto c8lm0;
       c8llZ: // global
           I64[Sp] = block_c8lm7_info;
           _s8jaZ::P64 = P64[R1 + 7];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jaZ::P64;
           if (R1 & 7 != 0) goto u8lmD; else goto c8lm9;
       u8lmD: // global
           call _c8lm7(R1) args: 0, res: 0, upd: 0;
       c8lm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lm0: // global
           I64[Sp] = block_c8lmm_info;
           _s8jb3::P64 = P64[R1 + 6];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jb3::P64;
           if (R1 & 7 != 0) goto u8lmE; else goto c8lmo;
       u8lmE: // global
           call _c8lmm(R1) args: 0, res: 0, upd: 0;
       c8lmo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lm7() //  [R1]
         { info_tbl: [(c8lm7,
                       label: block_c8lm7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lm7: // global
           if (R1 & 7 == 1) goto c8lmf; else goto u8lmC;
       c8lmf: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8lmC: // global
           Sp = Sp + 16;
           call _c8lmu() args: 0, res: 0, upd: 0;
     }
 },
 _c8lmm() //  [R1]
         { info_tbl: [(c8lmm,
                       label: block_c8lmm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lmm: // global
           if (R1 & 7 == 1) goto u8lmB; else goto c8lmy;
       u8lmB: // global
           Sp = Sp + 16;
           call _c8lmu() args: 0, res: 0, upd: 0;
       c8lmy: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8lmu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lmu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.434044249 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c/=_closure" {
     GHC.IO.Exception.$fEqArrayException_$c/=_closure:
         const GHC.IO.Exception.$fEqArrayException_$c/=_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8lmT,
                       label: GHC.IO.Exception.$fEqArrayException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lmT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lmU; else goto c8lmV;
       c8lmU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lmV: // global
           I64[Sp - 16] = block_c8lmM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lnY; else goto c8lmN;
       u8lnY: // global
           call _c8lmM(R1) args: 0, res: 0, upd: 0;
       c8lmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lmM() //  [R1]
         { info_tbl: [(c8lmM,
                       label: block_c8lmM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lmM: // global
           _s8jb8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lmQ; else goto c8lmR;
       c8lmQ: // global
           I64[Sp] = block_c8lmY_info;
           _s8jba::P64 = P64[R1 + 7];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jba::P64;
           if (R1 & 7 != 0) goto u8lnW; else goto c8ln0;
       u8lnW: // global
           call _c8lmY(R1) args: 0, res: 0, upd: 0;
       c8ln0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lmR: // global
           I64[Sp] = block_c8lno_info;
           _s8jbf::P64 = P64[R1 + 6];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jbf::P64;
           if (R1 & 7 != 0) goto u8lnX; else goto c8lnq;
       u8lnX: // global
           call _c8lno(R1) args: 0, res: 0, upd: 0;
       c8lnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lmY() //  [R1]
         { info_tbl: [(c8lmY,
                       label: block_c8lmY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lmY: // global
           if (R1 & 7 == 1) goto c8ln7; else goto u8lnT;
       c8ln7: // global
           _s8jba::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ln4_info;
           R3 = P64[R1 + 7];
           R2 = _s8jba::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8lnT: // global
           Sp = Sp + 16;
           call _c8lnH() args: 0, res: 0, upd: 0;
     }
 },
 _c8ln4() //  [R1]
         { info_tbl: [(c8ln4,
                       label: block_c8ln4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ln4: // global
           if (R1 & 7 == 1) goto u8lnU; else goto u8lnV;
       u8lnU: // global
           Sp = Sp + 8;
           call _c8lnH() args: 0, res: 0, upd: 0;
       u8lnV: // global
           Sp = Sp + 8;
           call _c8lnL() args: 0, res: 0, upd: 0;
     }
 },
 _c8lno() //  [R1]
         { info_tbl: [(c8lno,
                       label: block_c8lno_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lno: // global
           if (R1 & 7 == 1) goto u8lnQ; else goto c8lnB;
       u8lnQ: // global
           Sp = Sp + 16;
           call _c8lnH() args: 0, res: 0, upd: 0;
       c8lnB: // global
           _s8jbf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lnz_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbf::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lnz() //  [R1]
         { info_tbl: [(c8lnz,
                       label: block_c8lnz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lnz: // global
           if (R1 & 7 == 1) goto u8lnR; else goto u8lnS;
       u8lnR: // global
           Sp = Sp + 8;
           call _c8lnH() args: 0, res: 0, upd: 0;
       u8lnS: // global
           Sp = Sp + 8;
           call _c8lnL() args: 0, res: 0, upd: 0;
     }
 },
 _c8lnH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lnH: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lnL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lnL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.436110696 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_closure" {
     GHC.IO.Exception.$fEqArrayException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqArrayException_$c==_closure+2;
         const GHC.IO.Exception.$fEqArrayException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.437446616 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8log,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8log: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8loh; else goto c8loi;
       c8loh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8loi: // global
           I64[Sp - 16] = block_c8lo9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lpl; else goto c8loa;
       u8lpl: // global
           call _c8lo9(R1) args: 0, res: 0, upd: 0;
       c8loa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lo9() //  [R1]
         { info_tbl: [(c8lo9,
                       label: block_c8lo9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lo9: // global
           _s8jbk::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lod; else goto c8loe;
       c8lod: // global
           I64[Sp] = block_c8lol_info;
           _s8jbn::P64 = P64[R1 + 7];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbn::P64;
           if (R1 & 7 != 0) goto u8lpj; else goto c8lon;
       u8lpj: // global
           call _c8lol(R1) args: 0, res: 0, upd: 0;
       c8lon: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8loe: // global
           I64[Sp] = block_c8loL_info;
           _s8jbs::P64 = P64[R1 + 6];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbs::P64;
           if (R1 & 7 != 0) goto u8lpk; else goto c8loN;
       u8lpk: // global
           call _c8loL(R1) args: 0, res: 0, upd: 0;
       c8loN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lol() //  [R1]
         { info_tbl: [(c8lol,
                       label: block_c8lol_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lol: // global
           if (R1 & 7 == 1) goto c8lou; else goto u8lpg;
       c8lou: // global
           _s8jbn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lor_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbn::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8lpg: // global
           Sp = Sp + 16;
           call _c8lp8() args: 0, res: 0, upd: 0;
     }
 },
 _c8lor() //  [R1]
         { info_tbl: [(c8lor,
                       label: block_c8lor_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lor: // global
           if (R1 & 7 == 1) goto u8lph; else goto u8lpi;
       u8lph: // global
           Sp = Sp + 8;
           call _c8lp8() args: 0, res: 0, upd: 0;
       u8lpi: // global
           Sp = Sp + 8;
           call _c8lp4() args: 0, res: 0, upd: 0;
     }
 },
 _c8loL() //  [R1]
         { info_tbl: [(c8loL,
                       label: block_c8loL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8loL: // global
           if (R1 & 7 == 1) goto u8lpd; else goto c8loY;
       u8lpd: // global
           Sp = Sp + 16;
           call _c8lp4() args: 0, res: 0, upd: 0;
       c8loY: // global
           _s8jbs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8loW_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8loW() //  [R1]
         { info_tbl: [(c8loW,
                       label: block_c8loW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8loW: // global
           if (R1 & 7 == 1) goto u8lpe; else goto u8lpf;
       u8lpe: // global
           Sp = Sp + 8;
           call _c8lp8() args: 0, res: 0, upd: 0;
       u8lpf: // global
           Sp = Sp + 8;
           call _c8lp4() args: 0, res: 0, upd: 0;
     }
 },
 _c8lp8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lp8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lp4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lp4: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.440311531 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmax_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmax_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8lpD,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lpD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lpE; else goto c8lpF;
       c8lpE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lpF: // global
           I64[Sp - 16] = block_c8lpw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lqH; else goto c8lpx;
       u8lqH: // global
           call _c8lpw(R1) args: 0, res: 0, upd: 0;
       c8lpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lpw() //  [R1]
         { info_tbl: [(c8lpw,
                       label: block_c8lpw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lpw: // global
           _s8jbx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lpA; else goto c8lpB;
       c8lpA: // global
           I64[Sp - 8] = block_c8lpI_info;
           _s8jbz::P64 = R1;
           _s8jbA::P64 = P64[R1 + 7];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbA::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lqF; else goto c8lpK;
       u8lqF: // global
           call _c8lpI(R1) args: 0, res: 0, upd: 0;
       c8lpK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lpB: // global
           I64[Sp - 8] = block_c8lq8_info;
           _s8jbz::P64 = R1;
           _s8jbF::P64 = P64[R1 + 6];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbF::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lqG; else goto c8lqa;
       u8lqG: // global
           call _c8lq8(R1) args: 0, res: 0, upd: 0;
       c8lqa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lpI() //  [R1]
         { info_tbl: [(c8lpI,
                       label: block_c8lpI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lpI: // global
           if (R1 & 7 == 1) goto c8lpR; else goto u8lqC;
       c8lpR: // global
           I64[Sp] = block_c8lpO_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8lqC: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8lq5() args: 0, res: 0, upd: 0;
     }
 },
 _c8lpO() //  [R1]
         { info_tbl: [(c8lpO,
                       label: block_c8lpO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lpO: // global
           if (R1 & 7 == 1) goto u8lqD; else goto u8lqE;
       u8lqD: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8lq5() args: 0, res: 0, upd: 0;
       u8lqE: // global
           Sp = Sp + 16;
           call _c8lqr() args: 0, res: 0, upd: 0;
     }
 },
 _c8lq5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lq5: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lq8() //  [R1]
         { info_tbl: [(c8lq8,
                       label: block_c8lq8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lq8: // global
           if (R1 & 7 == 1) goto u8lqA; else goto c8lql;
       u8lqA: // global
           Sp = Sp + 16;
           call _c8lqr() args: 0, res: 0, upd: 0;
       c8lql: // global
           I64[Sp] = block_c8lqj_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lqj() //  [R1]
         { info_tbl: [(c8lqj,
                       label: block_c8lqj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lqj: // global
           if (R1 & 7 == 1) goto c8lqv; else goto u8lqB;
       c8lqv: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8lqB: // global
           Sp = Sp + 16;
           call _c8lqr() args: 0, res: 0, upd: 0;
     }
 },
 _c8lqr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lqr: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.443222314 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8lqY,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lqZ; else goto c8lr0;
       c8lqZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lr0: // global
           I64[Sp - 16] = block_c8lqR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ls3; else goto c8lqS;
       u8ls3: // global
           call _c8lqR(R1) args: 0, res: 0, upd: 0;
       c8lqS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lqR() //  [R1]
         { info_tbl: [(c8lqR,
                       label: block_c8lqR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lqR: // global
           _s8jbL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lqV; else goto c8lqW;
       c8lqV: // global
           I64[Sp] = block_c8lr3_info;
           _s8jbN::P64 = P64[R1 + 7];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbN::P64;
           if (R1 & 7 != 0) goto u8ls1; else goto c8lr5;
       u8ls1: // global
           call _c8lr3(R1) args: 0, res: 0, upd: 0;
       c8lr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lqW: // global
           I64[Sp] = block_c8lrt_info;
           _s8jbS::P64 = P64[R1 + 6];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbS::P64;
           if (R1 & 7 != 0) goto u8ls2; else goto c8lrv;
       u8ls2: // global
           call _c8lrt(R1) args: 0, res: 0, upd: 0;
       c8lrv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lr3() //  [R1]
         { info_tbl: [(c8lr3,
                       label: block_c8lr3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lr3: // global
           if (R1 & 7 == 1) goto c8lrc; else goto u8lrY;
       c8lrc: // global
           _s8jbN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lr9_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbN::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8lrY: // global
           Sp = Sp + 16;
           call _c8lrQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8lr9() //  [R1]
         { info_tbl: [(c8lr9,
                       label: block_c8lr9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lr9: // global
           if (R1 & 7 == 1) goto u8lrZ; else goto u8ls0;
       u8lrZ: // global
           Sp = Sp + 8;
           call _c8lrQ() args: 0, res: 0, upd: 0;
       u8ls0: // global
           Sp = Sp + 8;
           call _c8lrM() args: 0, res: 0, upd: 0;
     }
 },
 _c8lrt() //  [R1]
         { info_tbl: [(c8lrt,
                       label: block_c8lrt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lrt: // global
           if (R1 & 7 == 1) goto u8lrV; else goto c8lrG;
       u8lrV: // global
           Sp = Sp + 16;
           call _c8lrM() args: 0, res: 0, upd: 0;
       c8lrG: // global
           _s8jbS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lrE_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbS::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lrE() //  [R1]
         { info_tbl: [(c8lrE,
                       label: block_c8lrE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lrE: // global
           if (R1 & 7 == 1) goto u8lrW; else goto u8lrX;
       u8lrW: // global
           Sp = Sp + 8;
           call _c8lrQ() args: 0, res: 0, upd: 0;
       u8lrX: // global
           Sp = Sp + 8;
           call _c8lrM() args: 0, res: 0, upd: 0;
     }
 },
 _c8lrQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lrQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lrM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lrM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.445392156 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8lse,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lse: // global
           _s8jbY::P64 = R3;
           R3 = R2;
           R2 = _s8jbY::P64;
           call GHC.IO.Exception.$fOrdArrayException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.446913224 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmin_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmin_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8lss,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lss: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lst; else goto c8lsu;
       c8lst: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lsu: // global
           I64[Sp - 16] = block_c8lsl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ltw; else goto c8lsm;
       u8ltw: // global
           call _c8lsl(R1) args: 0, res: 0, upd: 0;
       c8lsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lsl() //  [R1]
         { info_tbl: [(c8lsl,
                       label: block_c8lsl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lsl: // global
           _s8jbZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lsp; else goto c8lsq;
       c8lsp: // global
           I64[Sp - 8] = block_c8lsx_info;
           _s8jc1::P64 = R1;
           _s8jc2::P64 = P64[R1 + 7];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc2::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ltu; else goto c8lsz;
       u8ltu: // global
           call _c8lsx(R1) args: 0, res: 0, upd: 0;
       c8lsz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lsq: // global
           I64[Sp - 8] = block_c8lsX_info;
           _s8jc1::P64 = R1;
           _s8jc7::P64 = P64[R1 + 6];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc7::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ltv; else goto c8lsZ;
       u8ltv: // global
           call _c8lsX(R1) args: 0, res: 0, upd: 0;
       c8lsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lsx() //  [R1]
         { info_tbl: [(c8lsx,
                       label: block_c8lsx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lsx: // global
           if (R1 & 7 == 1) goto c8lsG; else goto u8lts;
       c8lsG: // global
           I64[Sp] = block_c8lsD_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8lts: // global
           Sp = Sp + 16;
           call _c8ltk() args: 0, res: 0, upd: 0;
     }
 },
 _c8lsD() //  [R1]
         { info_tbl: [(c8lsD,
                       label: block_c8lsD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lsD: // global
           if (R1 & 7 == 1) goto u8ltt; else goto c8lsM;
       u8ltt: // global
           Sp = Sp + 16;
           call _c8ltk() args: 0, res: 0, upd: 0;
       c8lsM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lsX() //  [R1]
         { info_tbl: [(c8lsX,
                       label: block_c8lsX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lsX: // global
           if (R1 & 7 == 1) goto u8ltp; else goto c8lta;
       u8ltp: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8ltg() args: 0, res: 0, upd: 0;
       c8lta: // global
           I64[Sp] = block_c8lt8_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lt8() //  [R1]
         { info_tbl: [(c8lt8,
                       label: block_c8lt8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lt8: // global
           if (R1 & 7 == 1) goto u8ltq; else goto u8ltr;
       u8ltq: // global
           Sp = Sp + 16;
           call _c8ltk() args: 0, res: 0, upd: 0;
       u8ltr: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8ltg() args: 0, res: 0, upd: 0;
     }
 },
 _c8ltk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ltk: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ltg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ltg: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.449075333 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_closure" {
     GHC.IO.Exception.$fOrdArrayException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqArrayException_closure+1;
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.451323163 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c==_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c==_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c==_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8ltP,
                       label: GHC.IO.Exception.$fEqAsyncException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ltP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ltQ; else goto c8ltR;
       c8ltQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ltR: // global
           I64[Sp - 16] = block_c8ltG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lv8; else goto c8ltH;
       u8lv8: // global
           call _c8ltG(R1) args: 0, res: 0, upd: 0;
       c8ltH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ltG() //  [R1]
         { info_tbl: [(c8ltG,
                       label: block_c8ltG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ltG: // global
           _s8jcd::P64 = P64[Sp + 8];
           _c8ltO::P64 = R1 & 7;
           if (_c8ltO::P64 < 3) goto u8luU; else goto u8luV;
       u8luU: // global
           if (_c8ltO::P64 < 2) goto c8ltK; else goto c8ltL;
       c8ltK: // global
           I64[Sp + 8] = block_c8ltU_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lv4; else goto c8ltW;
       u8lv4: // global
           call _c8ltU(R1) args: 0, res: 0, upd: 0;
       c8ltW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ltL: // global
           I64[Sp + 8] = block_c8lu9_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lv5; else goto c8lub;
       u8lv5: // global
           call _c8lu9(R1) args: 0, res: 0, upd: 0;
       c8lub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8luV: // global
           if (_c8ltO::P64 < 4) goto c8ltM; else goto c8ltN;
       c8ltM: // global
           I64[Sp + 8] = block_c8luo_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lv6; else goto c8luq;
       u8lv6: // global
           call _c8luo(R1) args: 0, res: 0, upd: 0;
       c8luq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ltN: // global
           I64[Sp + 8] = block_c8luD_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lv7; else goto c8luF;
       u8lv7: // global
           call _c8luD(R1) args: 0, res: 0, upd: 0;
       c8luF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ltU() //  [R1]
         { info_tbl: [(c8ltU,
                       label: block_c8ltU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ltU: // global
           if (R1 & 7 == 1) goto u8luW; else goto u8luX;
       u8luW: // global
           Sp = Sp + 8;
           call _c8luP() args: 0, res: 0, upd: 0;
       u8luX: // global
           Sp = Sp + 8;
           call _c8luL() args: 0, res: 0, upd: 0;
     }
 },
 _c8lu9() //  [R1]
         { info_tbl: [(c8lu9,
                       label: block_c8lu9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lu9: // global
           if (R1 & 7 == 2) goto u8luY; else goto u8luZ;
       u8luY: // global
           Sp = Sp + 8;
           call _c8luP() args: 0, res: 0, upd: 0;
       u8luZ: // global
           Sp = Sp + 8;
           call _c8luL() args: 0, res: 0, upd: 0;
     }
 },
 _c8luo() //  [R1]
         { info_tbl: [(c8luo,
                       label: block_c8luo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8luo: // global
           if (R1 & 7 == 3) goto u8lv0; else goto u8lv1;
       u8lv0: // global
           Sp = Sp + 8;
           call _c8luP() args: 0, res: 0, upd: 0;
       u8lv1: // global
           Sp = Sp + 8;
           call _c8luL() args: 0, res: 0, upd: 0;
     }
 },
 _c8luD() //  [R1]
         { info_tbl: [(c8luD,
                       label: block_c8luD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8luD: // global
           if (R1 & 7 == 4) goto u8lv2; else goto u8lv3;
       u8lv2: // global
           Sp = Sp + 8;
           call _c8luP() args: 0, res: 0, upd: 0;
       u8lv3: // global
           Sp = Sp + 8;
           call _c8luL() args: 0, res: 0, upd: 0;
     }
 },
 _c8luP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8luP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8luL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8luL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.454295084 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c/=_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c/=_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c/=_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8lvu,
                       label: GHC.IO.Exception.$fEqAsyncException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lvu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lvv; else goto c8lvw;
       c8lvv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lvw: // global
           I64[Sp - 16] = block_c8lvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lwN; else goto c8lvm;
       u8lwN: // global
           call _c8lvl(R1) args: 0, res: 0, upd: 0;
       c8lvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lvl() //  [R1]
         { info_tbl: [(c8lvl,
                       label: block_c8lvl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lvl: // global
           _s8jck::P64 = P64[Sp + 8];
           _c8lvt::P64 = R1 & 7;
           if (_c8lvt::P64 < 3) goto u8lwz; else goto u8lwA;
       u8lwz: // global
           if (_c8lvt::P64 < 2) goto c8lvp; else goto c8lvq;
       c8lvp: // global
           I64[Sp + 8] = block_c8lvz_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lwJ; else goto c8lvB;
       u8lwJ: // global
           call _c8lvz(R1) args: 0, res: 0, upd: 0;
       c8lvB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lvq: // global
           I64[Sp + 8] = block_c8lvO_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lwK; else goto c8lvQ;
       u8lwK: // global
           call _c8lvO(R1) args: 0, res: 0, upd: 0;
       c8lvQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lwA: // global
           if (_c8lvt::P64 < 4) goto c8lvr; else goto c8lvs;
       c8lvr: // global
           I64[Sp + 8] = block_c8lw3_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lwL; else goto c8lw5;
       u8lwL: // global
           call _c8lw3(R1) args: 0, res: 0, upd: 0;
       c8lw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lvs: // global
           I64[Sp + 8] = block_c8lwi_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lwM; else goto c8lwk;
       u8lwM: // global
           call _c8lwi(R1) args: 0, res: 0, upd: 0;
       c8lwk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lvz() //  [R1]
         { info_tbl: [(c8lvz,
                       label: block_c8lvz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lvz: // global
           if (R1 & 7 == 1) goto u8lwB; else goto u8lwC;
       u8lwB: // global
           Sp = Sp + 8;
           call _c8lwu() args: 0, res: 0, upd: 0;
       u8lwC: // global
           Sp = Sp + 8;
           call _c8lwq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lvO() //  [R1]
         { info_tbl: [(c8lvO,
                       label: block_c8lvO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lvO: // global
           if (R1 & 7 == 2) goto u8lwD; else goto u8lwE;
       u8lwD: // global
           Sp = Sp + 8;
           call _c8lwu() args: 0, res: 0, upd: 0;
       u8lwE: // global
           Sp = Sp + 8;
           call _c8lwq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lw3() //  [R1]
         { info_tbl: [(c8lw3,
                       label: block_c8lw3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lw3: // global
           if (R1 & 7 == 3) goto u8lwF; else goto u8lwG;
       u8lwF: // global
           Sp = Sp + 8;
           call _c8lwu() args: 0, res: 0, upd: 0;
       u8lwG: // global
           Sp = Sp + 8;
           call _c8lwq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lwi() //  [R1]
         { info_tbl: [(c8lwi,
                       label: block_c8lwi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lwi: // global
           if (R1 & 7 == 4) goto u8lwH; else goto u8lwI;
       u8lwH: // global
           Sp = Sp + 8;
           call _c8lwu() args: 0, res: 0, upd: 0;
       u8lwI: // global
           Sp = Sp + 8;
           call _c8lwq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lwu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lwu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lwq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lwq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.45640317 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_closure" {
     GHC.IO.Exception.$fEqAsyncException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqAsyncException_$c==_closure+2;
         const GHC.IO.Exception.$fEqAsyncException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.457208313 UTC

[section ""data" . GHC.IO.Exception.ioe_filename_closure" {
     GHC.IO.Exception.ioe_filename_closure:
         const GHC.IO.Exception.ioe_filename_info;
 },
 GHC.IO.Exception.ioe_filename_entry() //  [R2]
         { info_tbl: [(c8lx3,
                       label: GHC.IO.Exception.ioe_filename_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lx3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lx4; else goto c8lx5;
       c8lx4: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_filename_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lx5: // global
           I64[Sp - 8] = block_c8lx0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lx9; else goto c8lx1;
       u8lx9: // global
           call _c8lx0(R1) args: 0, res: 0, upd: 0;
       c8lx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lx0() //  [R1]
         { info_tbl: [(c8lx0,
                       label: block_c8lx0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lx0: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.458427998 UTC

[section ""data" . GHC.IO.Exception.ioe_errno_closure" {
     GHC.IO.Exception.ioe_errno_closure:
         const GHC.IO.Exception.ioe_errno_info;
 },
 GHC.IO.Exception.ioe_errno_entry() //  [R2]
         { info_tbl: [(c8lxh,
                       label: GHC.IO.Exception.ioe_errno_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lxi; else goto c8lxj;
       c8lxi: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_errno_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lxj: // global
           I64[Sp - 8] = block_c8lxe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lxn; else goto c8lxf;
       u8lxn: // global
           call _c8lxe(R1) args: 0, res: 0, upd: 0;
       c8lxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lxe() //  [R1]
         { info_tbl: [(c8lxe,
                       label: block_c8lxe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxe: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.459595598 UTC

[section ""data" . GHC.IO.Exception.ioe_description_closure" {
     GHC.IO.Exception.ioe_description_closure:
         const GHC.IO.Exception.ioe_description_info;
 },
 GHC.IO.Exception.ioe_description_entry() //  [R2]
         { info_tbl: [(c8lxv,
                       label: GHC.IO.Exception.ioe_description_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lxw; else goto c8lxx;
       c8lxw: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_description_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lxx: // global
           I64[Sp - 8] = block_c8lxs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lxB; else goto c8lxt;
       u8lxB: // global
           call _c8lxs(R1) args: 0, res: 0, upd: 0;
       c8lxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lxs() //  [R1]
         { info_tbl: [(c8lxs,
                       label: block_c8lxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxs: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.460741589 UTC

[section ""data" . GHC.IO.Exception.ioe_location_closure" {
     GHC.IO.Exception.ioe_location_closure:
         const GHC.IO.Exception.ioe_location_info;
 },
 GHC.IO.Exception.ioe_location_entry() //  [R2]
         { info_tbl: [(c8lxJ,
                       label: GHC.IO.Exception.ioe_location_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lxK; else goto c8lxL;
       c8lxK: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_location_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lxL: // global
           I64[Sp - 8] = block_c8lxG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lxP; else goto c8lxH;
       u8lxP: // global
           call _c8lxG(R1) args: 0, res: 0, upd: 0;
       c8lxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lxG() //  [R1]
         { info_tbl: [(c8lxG,
                       label: block_c8lxG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxG: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.461974267 UTC

[section ""data" . GHC.IO.Exception.ioe_type_closure" {
     GHC.IO.Exception.ioe_type_closure:
         const GHC.IO.Exception.ioe_type_info;
 },
 GHC.IO.Exception.ioe_type_entry() //  [R2]
         { info_tbl: [(c8lxX,
                       label: GHC.IO.Exception.ioe_type_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lxY; else goto c8lxZ;
       c8lxY: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_type_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lxZ: // global
           I64[Sp - 8] = block_c8lxU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ly3; else goto c8lxV;
       u8ly3: // global
           call _c8lxU(R1) args: 0, res: 0, upd: 0;
       c8lxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lxU() //  [R1]
         { info_tbl: [(c8lxU,
                       label: block_c8lxU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lxU: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.46318863 UTC

[section ""data" . GHC.IO.Exception.ioe_handle_closure" {
     GHC.IO.Exception.ioe_handle_closure:
         const GHC.IO.Exception.ioe_handle_info;
 },
 GHC.IO.Exception.ioe_handle_entry() //  [R2]
         { info_tbl: [(c8lyb,
                       label: GHC.IO.Exception.ioe_handle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lyc; else goto c8lyd;
       c8lyc: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_handle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lyd: // global
           I64[Sp - 8] = block_c8ly8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lyh; else goto c8ly9;
       u8lyh: // global
           call _c8ly8(R1) args: 0, res: 0, upd: 0;
       c8ly9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ly8() //  [R1]
         { info_tbl: [(c8ly8,
                       label: block_c8ly8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ly8: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.464364232 UTC

[section ""data" . GHC.IO.Exception.userError_closure" {
     GHC.IO.Exception.userError_closure:
         const GHC.IO.Exception.userError_info;
 },
 GHC.IO.Exception.userError_entry() //  [R2]
         { info_tbl: [(c8lyn,
                       label: GHC.IO.Exception.userError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8lyr; else goto c8lyq;
       c8lyr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.IO.Exception.userError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lyq: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.46532216 UTC

[section ""cstring" . GHC.IO.Exception.unsupportedOperation2_bytes" {
     GHC.IO.Exception.unsupportedOperation2_bytes:
         I8[] [79,112,101,114,97,116,105,111,110,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.466059017 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation1_closure" {
     GHC.IO.Exception.unsupportedOperation1_closure:
         const GHC.IO.Exception.unsupportedOperation1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.unsupportedOperation1_entry() //  [R1]
         { info_tbl: [(c8lyy,
                       label: GHC.IO.Exception.unsupportedOperation1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lyz; else goto c8lyA;
       c8lyz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lyA: // global
           (_c8lyv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lyv::I64 == 0) goto c8lyx; else goto c8lyw;
       c8lyx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lyw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lyv::I64;
           R2 = GHC.IO.Exception.unsupportedOperation2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.466996695 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation_closure" {
     GHC.IO.Exception.unsupportedOperation_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Exception.unsupportedOperation1_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.467707957 UTC

[section ""data" . GHC.IO.Exception.untangle1_closure" {
     GHC.IO.Exception.untangle1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.468856482 UTC

[section ""data" . GHC.IO.Exception.untangle4_closure" {
     GHC.IO.Exception.untangle4_closure:
         const GHC.IO.Exception.untangle4_info;
 },
 GHC.IO.Exception.untangle4_entry() //  [R2]
         { info_tbl: [(c8lyI,
                       label: GHC.IO.Exception.untangle4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8lyJ; else goto c8lyK;
       c8lyJ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.untangle4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lyK: // global
           I64[Sp - 8] = block_c8lyF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lyS; else goto c8lyG;
       u8lyS: // global
           call _c8lyF(R1) args: 0, res: 0, upd: 0;
       c8lyG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lyF() //  [R1]
         { info_tbl: [(c8lyF,
                       label: block_c8lyF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyF: // global
           if (I64[R1 + 7] == 124) goto c8lyR; else goto c8lyQ;
       c8lyR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lyQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.470412976 UTC

[section ""cstring" . GHC.IO.Exception.untangle3_bytes" {
     GHC.IO.Exception.untangle3_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.471369205 UTC

[section ""data" . GHC.IO.Exception.untangle2_closure" {
     GHC.IO.Exception.untangle2_closure:
         const GHC.IO.Exception.untangle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.untangle2_entry() //  [R1]
         { info_tbl: [(c8lyZ,
                       label: GHC.IO.Exception.untangle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lz0; else goto c8lz1;
       c8lz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lz1: // global
           (_c8lyW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lyW::I64 == 0) goto c8lyY; else goto c8lyX;
       c8lyY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lyX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lyW::I64;
           R2 = GHC.IO.Exception.untangle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.474319669 UTC

[section ""data" . GHC.IO.Exception.untangle_closure" {
     GHC.IO.Exception.untangle_closure:
         const GHC.IO.Exception.untangle_info;
         const 0;
 },
 sat_s8jdq_entry() //  [R1]
         { info_tbl: [(c8lzI,
                       label: sat_s8jdq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzI: // global
           R3 = GHC.IO.Exception.untangle2_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jdr_entry() //  [R1]
         { info_tbl: [(c8lzL,
                       label: sat_s8jdr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzL: // global
           _s8jdr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8lzM; else goto c8lzN;
       c8lzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lzP; else goto c8lzO;
       c8lzP: // global
           HpAlloc = 24;
           goto c8lzM;
       c8lzM: // global
           R1 = _s8jdr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lzO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jdr::P64;
           _s8jdi::P64 = P64[_s8jdr::P64 + 16];
           _s8jdp::P64 = P64[_s8jdr::P64 + 24];
           I64[Hp - 16] = sat_s8jdq_info;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 16;
           R2 = _s8jdi::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jds_entry() //  [R1]
         { info_tbl: [(c8lzQ,
                       label: sat_s8jds_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8lzU; else goto c8lzT;
       c8lzU: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lzT: // global
           _s8jdi::P64 = P64[R1 + 16];
           _s8jdp::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8jdr_info;
           P64[Hp - 8] = _s8jdi::P64;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.untangle_entry() //  [R2, R3]
         { info_tbl: [(c8lzV,
                       label: GHC.IO.Exception.untangle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8lzW; else goto c8lzX;
       c8lzW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.untangle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lzX: // global
           I64[Sp - 16] = block_c8lz6_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.CString.unpackCStringUtf8#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lz6() //  [R1]
         { info_tbl: [(c8lz6,
                       label: block_c8lz6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lz6: // global
           I64[Sp] = block_c8lza_info;
           R3 = R1;
           R2 = GHC.IO.Exception.untangle4_closure+1;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lza() //  [R1, R2]
         { info_tbl: [(c8lza,
                       label: block_c8lza_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lza: // global
           I64[Sp - 8] = block_c8lze_info;
           _s8jdl::P64 = R1;
           R1 = R2;
           P64[Sp] = _s8jdl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lAk; else goto c8lzf;
       u8lAk: // global
           call _c8lze(R1) args: 0, res: 0, upd: 0;
       c8lzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lze() //  [R1]
         { info_tbl: [(c8lze,
                       label: block_c8lze_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lze: // global
           if (R1 & 7 == 1) goto c8lA6; else goto c8lA8;
       c8lA6: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp] = GHC.Types.[]_closure+1;
           call _c8lzu() args: 0, res: 0, upd: 0;
       c8lA8: // global
           I64[Sp - 8] = block_c8lzk_info;
           _s8jdv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jdv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lAl; else goto c8lzl;
       u8lAl: // global
           call _c8lzk(R1) args: 0, res: 0, upd: 0;
       c8lzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lzk() //  [R1]
         { info_tbl: [(c8lzk,
                       label: block_c8lzk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lAb; else goto c8lAa;
       c8lAb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lAa: // global
           _s8jdl::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 124) goto c8lAe; else goto c8lAd;
       c8lAe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.IO.Exception.untangle1_closure+1;
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 16] = _s8jdl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           goto u8lAo;
       c8lAd: // global
           Hp = Hp - 24;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           P64[Sp + 16] = _s8jdl::P64;
           Sp = Sp + 8;
           goto u8lAo;
       u8lAo: // global
           call _c8lzu() args: 0, res: 0, upd: 0;
     }
 },
 _c8lzu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzu: // global
           Hp = Hp + 32;
           _s8jdo::P64 = P64[Sp + 8];
           _s8jdp::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto c8lA2; else goto c8lA1;
       c8lA2: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c8lzt_info;
           R2 = _s8jdp::P64;
           R1 = _s8jdo::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8lA1: // global
           I64[Hp - 24] = sat_s8jds_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = _s8jdo::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8lzt() //  [R1, R2]
         { info_tbl: [(c8lzt,
                       label: block_c8lzt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lzt: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c8lzu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.483007811 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8lAD,
                       label: GHC.IO.Exception.$fOrdAsyncException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lAD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lAE; else goto c8lAF;
       c8lAE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lAF: // global
           I64[Sp - 16] = block_c8lAu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lCo; else goto c8lAv;
       u8lCo: // global
           call _c8lAu(R1) args: 0, res: 0, upd: 0;
       c8lAv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lAu() //  [R1]
         { info_tbl: [(c8lAu,
                       label: block_c8lAu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lAu: // global
           _s8jdB::P64 = P64[Sp + 8];
           _c8lAC::P64 = R1 & 7;
           if (_c8lAC::P64 < 3) goto u8lC2; else goto u8lC3;
       u8lC2: // global
           if (_c8lAC::P64 < 2) goto c8lAy; else goto c8lAz;
       c8lAy: // global
           I64[Sp + 8] = block_c8lAI_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lCk; else goto c8lAK;
       u8lCk: // global
           call _c8lAI(R1) args: 0, res: 0, upd: 0;
       c8lAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lAz: // global
           I64[Sp + 8] = block_c8lB5_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lCl; else goto c8lB7;
       u8lCl: // global
           call _c8lB5(R1) args: 0, res: 0, upd: 0;
       c8lB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lC3: // global
           if (_c8lAC::P64 < 4) goto c8lAA; else goto c8lAB;
       c8lAA: // global
           I64[Sp + 8] = block_c8lBs_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lCm; else goto c8lBu;
       u8lCm: // global
           call _c8lBs(R1) args: 0, res: 0, upd: 0;
       c8lBu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lAB: // global
           I64[Sp + 8] = block_c8lBL_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lCn; else goto c8lBN;
       u8lCn: // global
           call _c8lBL(R1) args: 0, res: 0, upd: 0;
       c8lBN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lAI() //  [R1]
         { info_tbl: [(c8lAI,
                       label: block_c8lAI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lAI: // global
           _c8lC1::P64 = R1 & 7;
           if (_c8lC1::P64 < 2) goto u8lC8; else goto u8lC4;
       u8lC8: // global
           Sp = Sp + 8;
           call _c8lBX() args: 0, res: 0, upd: 0;
       u8lC4: // global
           if (_c8lC1::P64 != 3) goto u8lCa; else goto u8lCa;
       u8lCa: // global
           Sp = Sp + 8;
           call _c8lBI() args: 0, res: 0, upd: 0;
     }
 },
 _c8lB5() //  [R1]
         { info_tbl: [(c8lB5,
                       label: block_c8lB5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lB5: // global
           _c8lC0::P64 = R1 & 7;
           if (_c8lC0::P64 < 3) goto u8lC5; else goto u8lC6;
       u8lC5: // global
           if (_c8lC0::P64 < 2) goto u8lCc; else goto u8lCb;
       u8lCc: // global
           Sp = Sp + 8;
           call _c8lBT() args: 0, res: 0, upd: 0;
       u8lCb: // global
           Sp = Sp + 8;
           call _c8lBX() args: 0, res: 0, upd: 0;
       u8lC6: // global
           if (_c8lC0::P64 < 4) goto u8lCe; else goto u8lCe;
       u8lCe: // global
           Sp = Sp + 8;
           call _c8lBI() args: 0, res: 0, upd: 0;
     }
 },
 _c8lBs() //  [R1]
         { info_tbl: [(c8lBs,
                       label: block_c8lBs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lBs: // global
           _c8lBZ::P64 = R1 & 7;
           if (_c8lBZ::P64 != 3) goto u8lC7; else goto u8lCf;
       u8lC7: // global
           if (_c8lBZ::P64 != 4) goto u8lCh; else goto u8lCg;
       u8lCh: // global
           Sp = Sp + 8;
           call _c8lBT() args: 0, res: 0, upd: 0;
       u8lCg: // global
           Sp = Sp + 8;
           call _c8lBI() args: 0, res: 0, upd: 0;
       u8lCf: // global
           Sp = Sp + 8;
           call _c8lBX() args: 0, res: 0, upd: 0;
     }
 },
 _c8lBI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lBI: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lBL() //  [R1]
         { info_tbl: [(c8lBL,
                       label: block_c8lBL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lBL: // global
           if (R1 & 7 == 4) goto u8lCi; else goto u8lCj;
       u8lCi: // global
           Sp = Sp + 8;
           call _c8lBX() args: 0, res: 0, upd: 0;
       u8lCj: // global
           Sp = Sp + 8;
           call _c8lBT() args: 0, res: 0, upd: 0;
     }
 },
 _c8lBX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lBX: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lBT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lBT: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.486317812 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8lCM,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lCM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lCN; else goto c8lCO;
       c8lCN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lCO: // global
           I64[Sp - 16] = block_c8lCD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lEc; else goto c8lCE;
       u8lEc: // global
           call _c8lCD(R1) args: 0, res: 0, upd: 0;
       c8lCE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lCD() //  [R1]
         { info_tbl: [(c8lCD,
                       label: block_c8lCD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lCD: // global
           _s8jdI::P64 = P64[Sp + 8];
           _c8lCL::P64 = R1 & 7;
           if (_c8lCL::P64 < 3) goto u8lDW; else goto u8lDX;
       u8lDW: // global
           if (_c8lCL::P64 < 2) goto c8lCH; else goto c8lCI;
       c8lCH: // global
           I64[Sp + 8] = block_c8lCR_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lE8; else goto c8lCT;
       u8lE8: // global
           call _c8lCR(R1) args: 0, res: 0, upd: 0;
       c8lCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lCI: // global
           I64[Sp + 8] = block_c8lDe_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lE9; else goto c8lDg;
       u8lE9: // global
           call _c8lDe(R1) args: 0, res: 0, upd: 0;
       c8lDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lDX: // global
           if (_c8lCL::P64 < 4) goto c8lCJ; else goto c8lCK;
       c8lCJ: // global
           I64[Sp + 8] = block_c8lDx_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lEa; else goto c8lDz;
       u8lEa: // global
           call _c8lDx(R1) args: 0, res: 0, upd: 0;
       c8lDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lCK: // global
           I64[Sp + 8] = block_c8lDM_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lEb; else goto c8lDO;
       u8lEb: // global
           call _c8lDM() args: 0, res: 0, upd: 0;
       c8lDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lCR() //  [R1]
         { info_tbl: [(c8lCR,
                       label: block_c8lCR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lCR: // global
           _c8lDV::P64 = R1 & 7;
           if (_c8lDV::P64 < 2) goto u8lE0; else goto u8lDY;
       u8lE0: // global
           Sp = Sp + 8;
           call _c8lDF() args: 0, res: 0, upd: 0;
       u8lDY: // global
           if (_c8lDV::P64 != 3) goto u8lE2; else goto u8lE2;
       u8lE2: // global
           Sp = Sp + 8;
           call _c8lDJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8lDe() //  [R1]
         { info_tbl: [(c8lDe,
                       label: block_c8lDe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lDe: // global
           _c8lDU::P64 = R1 & 7;
           if (_c8lDU::P64 != 3) goto u8lDZ; else goto u8lE3;
       u8lDZ: // global
           if (_c8lDU::P64 != 4) goto u8lE5; else goto u8lE4;
       u8lE5: // global
           Sp = Sp + 8;
           call _c8lDF() args: 0, res: 0, upd: 0;
       u8lE4: // global
           Sp = Sp + 8;
           goto u8lEg;
       u8lE3: // global
           Sp = Sp + 8;
           goto u8lEg;
       u8lEg: // global
           call _c8lDJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8lDx() //  [R1]
         { info_tbl: [(c8lDx,
                       label: block_c8lDx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lDx: // global
           if (R1 & 7 == 4) goto u8lE6; else goto u8lE7;
       u8lE6: // global
           Sp = Sp + 8;
           call _c8lDJ() args: 0, res: 0, upd: 0;
       u8lE7: // global
           Sp = Sp + 8;
           call _c8lDF() args: 0, res: 0, upd: 0;
     }
 },
 _c8lDJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lDJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lDF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lDF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lDM() //  []
         { info_tbl: [(c8lDM,
                       label: block_c8lDM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lDM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.489234166 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8lEx,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lEx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lEy; else goto c8lEz;
       c8lEy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lEz: // global
           I64[Sp - 16] = block_c8lEo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lFX; else goto c8lEp;
       u8lFX: // global
           call _c8lEo(R1) args: 0, res: 0, upd: 0;
       c8lEp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lEo() //  [R1]
         { info_tbl: [(c8lEo,
                       label: block_c8lEo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lEo: // global
           _s8jdO::P64 = P64[Sp + 8];
           _c8lEw::P64 = R1 & 7;
           if (_c8lEw::P64 < 3) goto u8lFH; else goto u8lFI;
       u8lFH: // global
           if (_c8lEw::P64 < 2) goto c8lEs; else goto c8lEt;
       c8lEs: // global
           I64[Sp + 8] = block_c8lEC_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lFT; else goto c8lEE;
       u8lFT: // global
           call _c8lEC(R1) args: 0, res: 0, upd: 0;
       c8lEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lEt: // global
           I64[Sp + 8] = block_c8lEZ_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lFU; else goto c8lF1;
       u8lFU: // global
           call _c8lEZ(R1) args: 0, res: 0, upd: 0;
       c8lF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lFI: // global
           if (_c8lEw::P64 < 4) goto c8lEu; else goto c8lEv;
       c8lEu: // global
           I64[Sp + 8] = block_c8lFi_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lFV; else goto c8lFk;
       u8lFV: // global
           call _c8lFi(R1) args: 0, res: 0, upd: 0;
       c8lFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lEv: // global
           I64[Sp + 8] = block_c8lFx_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lFW; else goto c8lFz;
       u8lFW: // global
           call _c8lFx() args: 0, res: 0, upd: 0;
       c8lFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lEC() //  [R1]
         { info_tbl: [(c8lEC,
                       label: block_c8lEC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lEC: // global
           _c8lFG::P64 = R1 & 7;
           if (_c8lFG::P64 < 2) goto u8lFL; else goto u8lFJ;
       u8lFL: // global
           Sp = Sp + 8;
           call _c8lFq() args: 0, res: 0, upd: 0;
       u8lFJ: // global
           if (_c8lFG::P64 != 3) goto u8lFN; else goto u8lFN;
       u8lFN: // global
           Sp = Sp + 8;
           call _c8lFu() args: 0, res: 0, upd: 0;
     }
 },
 _c8lEZ() //  [R1]
         { info_tbl: [(c8lEZ,
                       label: block_c8lEZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lEZ: // global
           _c8lFF::P64 = R1 & 7;
           if (_c8lFF::P64 != 3) goto u8lFK; else goto u8lFO;
       u8lFK: // global
           if (_c8lFF::P64 != 4) goto u8lFQ; else goto u8lFP;
       u8lFQ: // global
           Sp = Sp + 8;
           call _c8lFq() args: 0, res: 0, upd: 0;
       u8lFP: // global
           Sp = Sp + 8;
           goto u8lG1;
       u8lFO: // global
           Sp = Sp + 8;
           goto u8lG1;
       u8lG1: // global
           call _c8lFu() args: 0, res: 0, upd: 0;
     }
 },
 _c8lFi() //  [R1]
         { info_tbl: [(c8lFi,
                       label: block_c8lFi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lFi: // global
           if (R1 & 7 == 4) goto u8lFR; else goto u8lFS;
       u8lFR: // global
           Sp = Sp + 8;
           call _c8lFu() args: 0, res: 0, upd: 0;
       u8lFS: // global
           Sp = Sp + 8;
           call _c8lFq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lFu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lFu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lFq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lFq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lFx() //  []
         { info_tbl: [(c8lFx,
                       label: block_c8lFx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lFx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.492177288 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmax_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmax_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8lGi,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lGj; else goto c8lGk;
       c8lGj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lGk: // global
           I64[Sp - 16] = block_c8lG9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lHh; else goto c8lGa;
       u8lHh: // global
           call _c8lG9(R1) args: 0, res: 0, upd: 0;
       c8lGa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lG9() //  [R1]
         { info_tbl: [(c8lG9,
                       label: block_c8lG9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lG9: // global
           _s8jdV::P64 = P64[Sp + 8];
           _c8lGh::P64 = R1 & 7;
           if (_c8lGh::P64 < 3) goto u8lH7; else goto u8lH8;
       u8lH7: // global
           if (_c8lGh::P64 < 2) goto c8lGd; else goto c8lGe;
       c8lGd: // global
           R1 = _s8jdV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lGe: // global
           I64[Sp + 8] = block_c8lGq_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lHe; else goto c8lGs;
       u8lHe: // global
           call _c8lGq(R1) args: 0, res: 0, upd: 0;
       c8lGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lH8: // global
           if (_c8lGh::P64 < 4) goto c8lGf; else goto c8lGg;
       c8lGf: // global
           I64[Sp + 8] = block_c8lGJ_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lHf; else goto c8lGL;
       u8lHf: // global
           call _c8lGJ(R1) args: 0, res: 0, upd: 0;
       c8lGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lGg: // global
           I64[Sp + 8] = block_c8lGY_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lHg; else goto c8lH0;
       u8lHg: // global
           call _c8lGY() args: 0, res: 0, upd: 0;
       c8lH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lGq() //  [R1]
         { info_tbl: [(c8lGq,
                       label: block_c8lGq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGq: // global
           _c8lH6::P64 = R1 & 7;
           if (_c8lH6::P64 != 3) goto u8lH9; else goto u8lHa;
       u8lH9: // global
           if (_c8lH6::P64 != 4) goto c8lGy; else goto u8lHb;
       c8lGy: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8lHb: // global
           Sp = Sp + 8;
           call _c8lGV() args: 0, res: 0, upd: 0;
       u8lHa: // global
           Sp = Sp + 8;
           call _c8lGR() args: 0, res: 0, upd: 0;
     }
 },
 _c8lGJ() //  [R1]
         { info_tbl: [(c8lGJ,
                       label: block_c8lGJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGJ: // global
           if (R1 & 7 == 4) goto u8lHc; else goto u8lHd;
       u8lHc: // global
           Sp = Sp + 8;
           call _c8lGV() args: 0, res: 0, upd: 0;
       u8lHd: // global
           Sp = Sp + 8;
           call _c8lGR() args: 0, res: 0, upd: 0;
     }
 },
 _c8lGV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGV: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lGR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGR: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lGY() //  []
         { info_tbl: [(c8lGY,
                       label: block_c8lGY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lGY: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.495049809 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8lHz,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lHz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lHA; else goto c8lHB;
       c8lHA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lHB: // global
           I64[Sp - 16] = block_c8lHq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lIZ; else goto c8lHr;
       u8lIZ: // global
           call _c8lHq(R1) args: 0, res: 0, upd: 0;
       c8lHr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lHq() //  [R1]
         { info_tbl: [(c8lHq,
                       label: block_c8lHq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lHq: // global
           _s8je2::P64 = P64[Sp + 8];
           _c8lHy::P64 = R1 & 7;
           if (_c8lHy::P64 < 3) goto u8lIJ; else goto u8lIK;
       u8lIJ: // global
           if (_c8lHy::P64 < 2) goto c8lHu; else goto c8lHv;
       c8lHu: // global
           I64[Sp + 8] = block_c8lHE_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lIV; else goto c8lHG;
       u8lIV: // global
           call _c8lHE(R1) args: 0, res: 0, upd: 0;
       c8lHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lHv: // global
           I64[Sp + 8] = block_c8lI1_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lIW; else goto c8lI3;
       u8lIW: // global
           call _c8lI1(R1) args: 0, res: 0, upd: 0;
       c8lI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lIK: // global
           if (_c8lHy::P64 < 4) goto c8lHw; else goto c8lHx;
       c8lHw: // global
           I64[Sp + 8] = block_c8lIk_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lIX; else goto c8lIm;
       u8lIX: // global
           call _c8lIk(R1) args: 0, res: 0, upd: 0;
       c8lIm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lHx: // global
           I64[Sp + 8] = block_c8lIz_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lIY; else goto c8lIB;
       u8lIY: // global
           call _c8lIz() args: 0, res: 0, upd: 0;
       c8lIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lHE() //  [R1]
         { info_tbl: [(c8lHE,
                       label: block_c8lHE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lHE: // global
           _c8lII::P64 = R1 & 7;
           if (_c8lII::P64 < 2) goto u8lIN; else goto u8lIL;
       u8lIN: // global
           Sp = Sp + 8;
           call _c8lIs() args: 0, res: 0, upd: 0;
       u8lIL: // global
           if (_c8lII::P64 != 3) goto u8lIP; else goto u8lIP;
       u8lIP: // global
           Sp = Sp + 8;
           call _c8lIw() args: 0, res: 0, upd: 0;
     }
 },
 _c8lI1() //  [R1]
         { info_tbl: [(c8lI1,
                       label: block_c8lI1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lI1: // global
           _c8lIH::P64 = R1 & 7;
           if (_c8lIH::P64 != 3) goto u8lIM; else goto u8lIQ;
       u8lIM: // global
           if (_c8lIH::P64 != 4) goto u8lIS; else goto u8lIR;
       u8lIS: // global
           Sp = Sp + 8;
           call _c8lIs() args: 0, res: 0, upd: 0;
       u8lIR: // global
           Sp = Sp + 8;
           goto u8lJ3;
       u8lIQ: // global
           Sp = Sp + 8;
           goto u8lJ3;
       u8lJ3: // global
           call _c8lIw() args: 0, res: 0, upd: 0;
     }
 },
 _c8lIk() //  [R1]
         { info_tbl: [(c8lIk,
                       label: block_c8lIk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lIk: // global
           if (R1 & 7 == 4) goto u8lIT; else goto u8lIU;
       u8lIT: // global
           Sp = Sp + 8;
           call _c8lIw() args: 0, res: 0, upd: 0;
       u8lIU: // global
           Sp = Sp + 8;
           call _c8lIs() args: 0, res: 0, upd: 0;
     }
 },
 _c8lIw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lIw: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lIs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lIs: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lIz() //  []
         { info_tbl: [(c8lIz,
                       label: block_c8lIz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lIz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.497420953 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8lJb,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJb: // global
           _s8je9::P64 = R3;
           R3 = R2;
           R2 = _s8je9::P64;
           call GHC.IO.Exception.$fOrdAsyncException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.498775015 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmin_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmin_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8lJr,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lJs; else goto c8lJt;
       c8lJs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lJt: // global
           I64[Sp - 16] = block_c8lJi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lKm; else goto c8lJj;
       u8lKm: // global
           call _c8lJi(R1) args: 0, res: 0, upd: 0;
       c8lJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lJi() //  [R1]
         { info_tbl: [(c8lJi,
                       label: block_c8lJi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJi: // global
           _s8jea::P64 = P64[Sp + 8];
           _c8lJq::P64 = R1 & 7;
           if (_c8lJq::P64 < 3) goto u8lKg; else goto u8lKh;
       u8lKg: // global
           if (_c8lJq::P64 < 2) goto c8lJm; else goto c8lJn;
       c8lJm: // global
           I64[Sp + 8] = block_c8lJw_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lKj; else goto c8lJy;
       u8lKj: // global
           call _c8lJw() args: 0, res: 0, upd: 0;
       c8lJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lJn: // global
           I64[Sp + 8] = block_c8lJF_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lKk; else goto c8lJH;
       u8lKk: // global
           call _c8lJF(R1) args: 0, res: 0, upd: 0;
       c8lJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8lKh: // global
           if (_c8lJq::P64 < 4) goto c8lJo; else goto c8lJp;
       c8lJo: // global
           I64[Sp + 8] = block_c8lJY_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lKl; else goto c8lK0;
       u8lKl: // global
           call _c8lJY(R1) args: 0, res: 0, upd: 0;
       c8lK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8lJp: // global
           R1 = _s8jea::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lJw() //  []
         { info_tbl: [(c8lJw,
                       label: block_c8lJw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJw: // global
           R1 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lJF() //  [R1]
         { info_tbl: [(c8lJF,
                       label: block_c8lJF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJF: // global
           _c8lKf::P64 = R1 & 7;
           if (_c8lKf::P64 == 3) goto c8lJV; else goto u8lKi;
       u8lKi: // global
           if (_c8lKf::P64 == 4) goto c8lJV; else goto c8lJN;
       c8lJV: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lJN: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lJY() //  [R1]
         { info_tbl: [(c8lJY,
                       label: block_c8lJY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lJY: // global
           if (R1 & 7 == 4) goto c8lKa; else goto c8lK6;
       c8lKa: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lK6: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.500650858 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_closure" {
     GHC.IO.Exception.$fOrdAsyncException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqAsyncException_closure+1;
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.501380395 UTC

[section ""cstring" . GHC.IO.Exception.$trModule4_bytes" {
     GHC.IO.Exception.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.501932512 UTC

[section ""data" . GHC.IO.Exception.$trModule3_closure" {
     GHC.IO.Exception.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.502465935 UTC

[section ""cstring" . GHC.IO.Exception.$trModule2_bytes" {
     GHC.IO.Exception.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.502978415 UTC

[section ""data" . GHC.IO.Exception.$trModule1_closure" {
     GHC.IO.Exception.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.503487044 UTC

[section ""data" . GHC.IO.Exception.$trModule_closure" {
     GHC.IO.Exception.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Exception.$trModule3_closure+1;
         const GHC.IO.Exception.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.504085393 UTC

[section ""data" . $krep_r8j3f_closure" {
     $krep_r8j3f_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.504657455 UTC

[section ""data" . $krep1_r8j3g_closure" {
     $krep1_r8j3g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.505222831 UTC

[section ""data" . $krep2_r8j3h_closure" {
     $krep2_r8j3h_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.505873492 UTC

[section ""data" . $krep3_r8j3i_closure" {
     $krep3_r8j3i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.506429464 UTC

[section ""data" . $krep4_r8j3j_closure" {
     $krep4_r8j3j_closure:
         const :_con_info;
         const $krep1_r8j3g_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.5069915 UTC

[section ""data" . $krep5_r8j3k_closure" {
     $krep5_r8j3k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.507534115 UTC

[section ""data" . $krep6_r8j3l_closure" {
     $krep6_r8j3l_closure:
         const :_con_info;
         const $krep3_r8j3i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.50813194 UTC

[section ""data" . $krep7_r8j3m_closure" {
     $krep7_r8j3m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8j3l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.508701482 UTC

[section ""data" . $krep8_r8j3n_closure" {
     $krep8_r8j3n_closure:
         const :_con_info;
         const $krep2_r8j3h_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.509232727 UTC

[section ""data" . $krep9_r8j3o_closure" {
     $krep9_r8j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8j3n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.509929738 UTC

[section ""data" . $krep10_r8j3p_closure" {
     $krep10_r8j3p_closure:
         const :_con_info;
         const $krep9_r8j3o_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.510527387 UTC

[section ""data" . $krep11_r8j3q_closure" {
     $krep11_r8j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep10_r8j3p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.511135179 UTC

[section ""data" . $krep12_r8j3r_closure" {
     $krep12_r8j3r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.511668172 UTC

[section ""data" . $krep13_r8j3s_closure" {
     $krep13_r8j3s_closure:
         const :_con_info;
         const $krep12_r8j3r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.512242088 UTC

[section ""data" . $krep14_r8j3t_closure" {
     $krep14_r8j3t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Exception.$tcException_closure;
         const $krep13_r8j3s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.512791545 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.513429682 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.514062156 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
         const GHC.Types.krep$*_closure;
         const 5532209509574600699;
         const 13011219155706606307;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.514680862 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.515264879 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.515829054 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.516377269 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure+1;
         const 6834741829236713234;
         const 5957659317954655195;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.517659101 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_entry() //  [R1]
         { info_tbl: [(c8lKy,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKy: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lKz; else goto c8lKA;
       c8lKz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lKA: // global
           (_c8lKq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lKq::I64 == 0) goto c8lKs; else goto c8lKr;
       c8lKs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lKr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lKq::I64;
           I64[Sp - 24] = block_c8lKt_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 13011219155706606307;
           R2 = 5532209509574600699;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lKt() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lKt,
                       label: block_c8lKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKt: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lKu() args: 0, res: 0, upd: 0;
     }
 },
 _c8lKu() //  []
         { info_tbl: [(c8lKu,
                       label: block_c8lKu_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lKD; else goto c8lKC;
       c8lKD: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lKu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lKC: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.519190701 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.519764511 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.520338898 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13946898568638194917;
         const 3504019511763148288;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.520951262 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.521603075 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.522154346 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.524460433 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure+1;
         const 13856829326869447687;
         const 12209020643191939554;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.525617037 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_entry() //  [R1]
         { info_tbl: [(c8lKR,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKR: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lKS; else goto c8lKT;
       c8lKS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lKT: // global
           (_c8lKJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lKJ::I64 == 0) goto c8lKL; else goto c8lKK;
       c8lKL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lKK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lKJ::I64;
           I64[Sp - 24] = block_c8lKM_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3504019511763148288;
           R2 = 13946898568638194917;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lKM() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lKM,
                       label: block_c8lKM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKM: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lKN() args: 0, res: 0, upd: 0;
     }
 },
 _c8lKN() //  []
         { info_tbl: [(c8lKN,
                       label: block_c8lKN_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lKN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lKW; else goto c8lKV;
       c8lKW: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lKN_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lKV: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.527066475 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock5_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock5_bytes:
         I8[] [68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.527608157 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock4_closure" {
     GHC.IO.Exception.$fExceptionDeadlock4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.528139767 UTC

[section ""data" . GHC.IO.Exception.$tcDeadlock_closure" {
     GHC.IO.Exception.$tcDeadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
         const GHC.Types.krep$*_closure;
         const 18363794241794644491;
         const 11186984538024031318;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.528739098 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock1_closure" {
     GHC.IO.Exception.$tc'Deadlock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcDeadlock_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.529383837 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Deadlock3_bytes" {
     GHC.IO.Exception.$tc'Deadlock3_bytes:
         I8[] [39,68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.529938692 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock2_closure" {
     GHC.IO.Exception.$tc'Deadlock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Deadlock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.530523878 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock_closure" {
     GHC.IO.Exception.$tc'Deadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Deadlock2_closure+1;
         const GHC.IO.Exception.$tc'Deadlock1_closure+1;
         const 8732553870978897242;
         const 16079179228471909431;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.531567209 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock3_closure" {
     GHC.IO.Exception.$fExceptionDeadlock3_closure:
         const GHC.IO.Exception.$fExceptionDeadlock3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock3_entry() //  [R1]
         { info_tbl: [(c8lLa,
                       label: GHC.IO.Exception.$fExceptionDeadlock3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLa: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lLb; else goto c8lLc;
       c8lLb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lLc: // global
           (_c8lL2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lL2::I64 == 0) goto c8lL4; else goto c8lL3;
       c8lL4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lL3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lL2::I64;
           I64[Sp - 24] = block_c8lL5_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lL5() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lL5,
                       label: block_c8lL5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lL5: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lL6() args: 0, res: 0, upd: 0;
     }
 },
 _c8lL6() //  []
         { info_tbl: [(c8lL6,
                       label: block_c8lL6_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lL6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lLf; else goto c8lLe;
       c8lLf: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lL6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lLe: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.533595209 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lLp,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lLt; else goto c8lLu;
       c8lLt: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lLu: // global
           I64[Sp - 8] = block_c8lLm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lLP; else goto c8lLn;
       u8lLP: // global
           call _c8lLm(R1) args: 0, res: 0, upd: 0;
       c8lLn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lLm() //  [R1]
         { info_tbl: [(c8lLm,
                       label: block_c8lLm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLm: // global
           I64[Sp - 8] = block_c8lLs_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lLs() //  [R1]
         { info_tbl: [(c8lLs,
                       label: block_c8lLs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLs: // global
           I64[Sp] = block_c8lLz_info;
           R3 = GHC.IO.Exception.$fExceptionDeadlock3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lLz() //  [R1]
         { info_tbl: [(c8lLz,
                       label: block_c8lLz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLz: // global
           if (R1 & 7 == 1) goto c8lLG; else goto c8lLK;
       c8lLG: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lLK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lLN; else goto c8lLM;
       c8lLN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lLM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.535142725 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fShowDeadlock_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lLV,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lLV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lLZ; else goto c8lLY;
       c8lLZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lLY: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionDeadlock_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.53606937 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes:
         I8[] [65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.53664924 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.537182555 UTC

[section ""data" . GHC.IO.Exception.$tcAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tcAllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13160607835047152551;
         const 6828489586181860176;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.537874349 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAllocationLimitExceeded_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.538433498 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes:
         I8[] [39,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.538973392 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.539547993 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure+1;
         const 14911686161474736107;
         const 16735957051754280572;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.540563431 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_entry() //  [R1]
         { info_tbl: [(c8lMb,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lMc; else goto c8lMd;
       c8lMc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lMd: // global
           (_c8lM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lM3::I64 == 0) goto c8lM5; else goto c8lM4;
       c8lM5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lM4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lM3::I64;
           I64[Sp - 24] = block_c8lM6_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6828489586181860176;
           R2 = 13160607835047152551;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lM6() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lM6,
                       label: block_c8lM6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lM6: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lM7() args: 0, res: 0, upd: 0;
     }
 },
 _c8lM7() //  []
         { info_tbl: [(c8lM7,
                       label: block_c8lM7_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lM7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lMg; else goto c8lMf;
       c8lMg: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lM7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lMf: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.542102567 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed4_bytes:
         I8[] [67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.542673253 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed3_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.543271597 UTC

[section ""data" . GHC.IO.Exception.$tcCompactionFailed_closure" {
     GHC.IO.Exception.$tcCompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7633933266579528523;
         const 6393060685738357435;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.543889885 UTC

[section ""data" . $krep15_r8j3u_closure" {
     $krep15_r8j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcCompactionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.5444146 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed1_closure" {
     GHC.IO.Exception.$tc'CompactionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep15_r8j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.544988742 UTC

[section ""cstring" . GHC.IO.Exception.$tc'CompactionFailed3_bytes" {
     GHC.IO.Exception.$tc'CompactionFailed3_bytes:
         I8[] [39,67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.545640513 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed2_closure" {
     GHC.IO.Exception.$tc'CompactionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'CompactionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.546213154 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed_closure" {
     GHC.IO.Exception.$tc'CompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed2_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed1_closure+4;
         const 5917738941224226344;
         const 8436844331187314000;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.547198864 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed2_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed2_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed2_entry() //  [R1]
         { info_tbl: [(c8lMu,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMu: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lMv; else goto c8lMw;
       c8lMv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lMw: // global
           (_c8lMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lMm::I64 == 0) goto c8lMo; else goto c8lMn;
       c8lMo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lMn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lMm::I64;
           I64[Sp - 24] = block_c8lMp_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6393060685738357435;
           R2 = 7633933266579528523;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lMp() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lMp,
                       label: block_c8lMp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMp: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lMq() args: 0, res: 0, upd: 0;
     }
 },
 _c8lMq() //  []
         { info_tbl: [(c8lMq,
                       label: block_c8lMq_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lMz; else goto c8lMy;
       c8lMz: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lMq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lMy: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.548649815 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAssertionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionAssertionFailed4_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.549207816 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed3_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.549903426 UTC

[section ""data" . GHC.IO.Exception.$tcAssertionFailed_closure" {
     GHC.IO.Exception.$tcAssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7013231185527166567;
         const 11481669896152761825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.55056043 UTC

[section ""data" . $krep16_r8j3v_closure" {
     $krep16_r8j3v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAssertionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.551139187 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed1_closure" {
     GHC.IO.Exception.$tc'AssertionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep16_r8j3v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.551732394 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AssertionFailed3_bytes" {
     GHC.IO.Exception.$tc'AssertionFailed3_bytes:
         I8[] [39,65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.552310612 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed2_closure" {
     GHC.IO.Exception.$tc'AssertionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AssertionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.552887583 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed_closure" {
     GHC.IO.Exception.$tc'AssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed2_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed1_closure+4;
         const 6421416346863765662;
         const 16131786633010342764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.554023348 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed2_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed2_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed2_entry() //  [R1]
         { info_tbl: [(c8lMN,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMN: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lMO; else goto c8lMP;
       c8lMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lMP: // global
           (_c8lMF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lMF::I64 == 0) goto c8lMH; else goto c8lMG;
       c8lMH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lMG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lMF::I64;
           I64[Sp - 24] = block_c8lMI_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11481669896152761825;
           R2 = 7013231185527166567;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lMI() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lMI,
                       label: block_c8lMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMI: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lMJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8lMJ() //  []
         { info_tbl: [(c8lMJ,
                       label: block_c8lMJ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lMS; else goto c8lMR;
       c8lMS: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lMJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lMR: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.555871752 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lN2,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lN2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lN6; else goto c8lN7;
       c8lN6: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lN7: // global
           I64[Sp - 8] = block_c8lMZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lNs; else goto c8lN0;
       u8lNs: // global
           call _c8lMZ(R1) args: 0, res: 0, upd: 0;
       c8lN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lMZ() //  [R1]
         { info_tbl: [(c8lMZ,
                       label: block_c8lMZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lMZ: // global
           I64[Sp - 8] = block_c8lN5_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lN5() //  [R1]
         { info_tbl: [(c8lN5,
                       label: block_c8lN5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lN5: // global
           I64[Sp] = block_c8lNc_info;
           R3 = GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lNc() //  [R1]
         { info_tbl: [(c8lNc,
                       label: block_c8lNc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lNc: // global
           if (R1 & 7 == 1) goto c8lNj; else goto c8lNn;
       c8lNj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lNn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lNq; else goto c8lNp;
       c8lNq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lNp: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.557498279 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fShowAssertionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lNy,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lNy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lNC; else goto c8lNB;
       c8lNC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lNB: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAssertionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.558441949 UTC

[section ""cstring" . lvl38_r8j3w_bytes" {
     lvl38_r8j3w_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,32,102,97,105,108,101,100,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.561223953 UTC

[section ""data" . GHC.IO.Exception.assertError1_closure" {
     GHC.IO.Exception.assertError1_closure:
         const GHC.IO.Exception.assertError1_info;
         const 0;
 },
 sat_s8jfa_entry() //  [R1]
         { info_tbl: [(c8lO9,
                       label: sat_s8jfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lO9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lOa; else goto c8lOb;
       c8lOa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lOb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8lO7_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8lO7() //  [R1]
         { info_tbl: [(c8lO7,
                       label: block_c8lO7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lO7: // global
           R3 = R1;
           R2 = GHC.Exception.errorCallWithCallStackException9_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 n_s8jf5_entry() //  [R1]
         { info_tbl: [(c8lOj,
                       label: n_s8jf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lOj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lOk; else goto c8lOl;
       c8lOk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lOl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8lNX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8lOs; else goto c8lNY;
       u8lOs: // global
           call _c8lNX(R1) args: 0, res: 0, upd: 0;
       c8lNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8lNX() //  [R1]
         { info_tbl: [(c8lNX,
                       label: block_c8lNX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lNX: // global
           if (R1 & 7 == 1) goto c8lOg; else goto c8lOh;
       c8lOg: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8lOh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lOr; else goto c8lOq;
       c8lOr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8lOq: // global
           I64[Hp - 40] = sat_s8jfa_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException11_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jff_entry() //  [R1]
         { info_tbl: [(c8lOH,
                       label: sat_s8jff_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lOH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lOI; else goto c8lOJ;
       c8lOI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lOJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfo_entry() //  [R1]
         { info_tbl: [(c8lP6,
                       label: sat_s8jfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lP6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lP7; else goto c8lP8;
       c8lP7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lP8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.errorCallWithCallStackException1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8jfj_entry() //  [R1, R2]
         { info_tbl: [(c8lPd,
                       label: go_s8jfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lPd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lPe; else goto c8lPf;
       c8lPe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lPf: // global
           I64[Sp - 24] = block_c8lOV_info;
           _s8jfj::P64 = R1;
           _s8jf5::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s8jf5::P64;
           P64[Sp - 8] = _s8jfj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8lPm; else goto c8lOW;
       u8lPm: // global
           call _c8lOV(R1) args: 0, res: 0, upd: 0;
       c8lOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lOV() //  [R1]
         { info_tbl: [(c8lOV,
                       label: block_c8lOV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lOV: // global
           if (R1 & 7 == 1) goto c8lPa; else goto c8lPb;
       c8lPa: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lPb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8lPl; else goto c8lPk;
       c8lPl: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lPk: // global
           _s8jfm::P64 = P64[R1 + 6];
           _s8jfn::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _s8jfn::P64;
           I64[Hp - 40] = sat_s8jfo_info;
           P64[Hp - 24] = _s8jfm::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jfr_entry() //  [R1]
         { info_tbl: [(c8lPp,
                       label: sat_s8jfr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lPp: // global
           _s8jfr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8lPq; else goto c8lPr;
       c8lPr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lPt; else goto c8lPs;
       c8lPt: // global
           HpAlloc = 16;
           goto c8lPq;
       c8lPq: // global
           R1 = _s8jfr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lPs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfr::P64;
           _s8jf5::P64 = P64[_s8jfr::P64 + 16];
           _s8jfb::P64 = P64[_s8jfr::P64 + 24];
           I64[Hp - 8] = go_s8jfj_info;
           P64[Hp] = _s8jf5::P64;
           I64[Sp - 24] = block_c8lPn_info;
           R2 = _s8jfb::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s8jfj_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8lPn() //  [R1]
         { info_tbl: [(c8lPn,
                       label: block_c8lPn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lPn: // global
           R3 = R1;
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp + 8;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jft_entry() //  [R1]
         { info_tbl: [(c8lPB,
                       label: sat_s8jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lPB: // global
           _s8jft::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8lPC; else goto c8lPD;
       c8lPD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lPF; else goto c8lPE;
       c8lPF: // global
           HpAlloc = 24;
           goto c8lPC;
       c8lPC: // global
           R1 = _s8jft::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lPE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jft::P64;
           _s8jf2::P64 = P64[_s8jft::P64 + 16];
           _s8jf3::P64 = P64[_s8jft::P64 + 24];
           I64[Hp - 16] = n_s8jf5_info;
           P64[Hp] = _s8jf3::P64;
           I64[Sp - 32] = block_c8lOt_info;
           R2 = _s8jf2::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Stack.Types.getCallStack_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8lOt() //  [R1]
         { info_tbl: [(c8lOt,
                       label: block_c8lOt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lOt: // global
           _c8lNT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8lPy; else goto c8lPz;
       c8lPy: // global
           I64[Sp + 8] = block_c8lOx_info;
           R1 = _c8lNT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8lPV; else goto c8lOy;
       u8lPV: // global
           call _c8lOx(R1) args: 0, res: 0, upd: 0;
       c8lOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       c8lPz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8lPT; else goto c8lPS;
       c8lPT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8lPS: // global
           I64[Hp - 48] = sat_s8jfr_info;
           P64[Hp - 32] = _c8lNT::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException6_closure;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _c8lOx() //  [R1]
         { info_tbl: [(c8lOx,
                       label: block_c8lOx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lOx: // global
           if (R1 & 7 == 1) goto c8lPK; else goto c8lPM;
       c8lPK: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8lPM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lPP; else goto c8lPO;
       c8lPP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8lPO: // global
           _s8jfd::P64 = P64[R1 + 6];
           _s8jfe::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_s8jff_info;
           P64[Hp - 24] = _s8jfe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8jfd::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfu_entry() //  [R1]
         { info_tbl: [(c8lPW,
                       label: sat_s8jfu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lPW: // global
           _s8jfu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8lPX; else goto c8lPY;
       c8lPY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8lQ0; else goto c8lPZ;
       c8lQ0: // global
           HpAlloc = 32;
           goto c8lPX;
       c8lPX: // global
           R1 = _s8jfu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfu::P64;
           _s8jf2::P64 = P64[_s8jfu::P64 + 16];
           _s8jf3::P64 = P64[_s8jfu::P64 + 24];
           I64[Hp - 24] = sat_s8jft_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R3 = Hp - 24;
           R2 = lvl38_r8j3w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfv_entry() //  [R1]
         { info_tbl: [(c8lQ1,
                       label: sat_s8jfv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQ1: // global
           _s8jfv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8lQ2; else goto c8lQ3;
       c8lQ3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8lQ5; else goto c8lQ4;
       c8lQ5: // global
           HpAlloc = 32;
           goto c8lQ2;
       c8lQ2: // global
           R1 = _s8jfv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lQ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfv::P64;
           _s8jf2::P64 = P64[_s8jfv::P64 + 16];
           _s8jf3::P64 = P64[_s8jfv::P64 + 24];
           I64[Hp - 24] = sat_s8jfu_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R2 = Hp - 24;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.assertError1_entry() //  [R2, R3]
         { info_tbl: [(c8lQ6,
                       label: GHC.IO.Exception.assertError1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQ6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8lQa; else goto c8lQ9;
       c8lQa: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lQ9: // global
           I64[Hp - 24] = sat_s8jfv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.566892725 UTC

[section ""data" . GHC.IO.Exception.assertError_closure" {
     GHC.IO.Exception.assertError_closure:
         const GHC.IO.Exception.assertError_info;
         const 0;
 },
 GHC.IO.Exception.assertError_entry() //  [R2, R3, R4]
         { info_tbl: [(c8lQm,
                       label: GHC.IO.Exception.assertError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lQn; else goto c8lQo;
       c8lQn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lQo: // global
           I64[Sp - 24] = block_c8lQf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8lQB; else goto c8lQg;
       u8lQB: // global
           call _c8lQf(R1) args: 0, res: 0, upd: 0;
       c8lQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lQf() //  [R1]
         { info_tbl: [(c8lQf,
                       label: block_c8lQf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQf: // global
           if (R1 & 7 == 1) goto c8lQj; else goto c8lQk;
       c8lQj: // global
           I64[Sp] = block_c8lQr_info;
           R1 = GHC.Stack.CCS.currentCallStack_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c8lQk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lQr() //  [R1]
         { info_tbl: [(c8lQr,
                       label: block_c8lQr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQr: // global
           I64[Sp + 16] = block_c8lQt_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Exception.assertError1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lQt() //  [R1]
         { info_tbl: [(c8lQt,
                       label: block_c8lQt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQt: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.569570656 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes:
         I8[] [83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.570158985 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.57083031 UTC

[section ""data" . GHC.IO.Exception.$tcSomeAsyncException_closure" {
     GHC.IO.Exception.$tcSomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
         const GHC.Types.krep$*_closure;
         const 7698277271892269964;
         const 12603180528693821542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.571457171 UTC

[section ""data" . $krep17_r8j3x_closure" {
     $krep17_r8j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcSomeAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.572029118 UTC

[section ""data" . $krep18_r8j3y_closure" {
     $krep18_r8j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r8j3r_closure+2;
         const $krep17_r8j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.572611892 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException1_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r8j3t_closure+1;
         const $krep18_r8j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.573148965 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SomeAsyncException3_bytes" {
     GHC.IO.Exception.$tc'SomeAsyncException3_bytes:
         I8[] [39,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.573750144 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException2_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SomeAsyncException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.574271754 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException2_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException1_closure+4;
         const 2590663161510005226;
         const 12089333203895315586;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.57533085 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_entry() //  [R1]
         { info_tbl: [(c8lQN,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQN: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lQO; else goto c8lQP;
       c8lQO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lQP: // global
           (_c8lQF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lQF::I64 == 0) goto c8lQH; else goto c8lQG;
       c8lQH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lQG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lQF::I64;
           I64[Sp - 24] = block_c8lQI_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12603180528693821542;
           R2 = 7698277271892269964;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lQI() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lQI,
                       label: block_c8lQI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQI: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lQJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8lQJ() //  []
         { info_tbl: [(c8lQJ,
                       label: block_c8lQJ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lQS; else goto c8lQR;
       c8lQS: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lQJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lQR: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.577178097 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lR2,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lR2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lR6; else goto c8lR7;
       c8lR6: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lR7: // global
           I64[Sp - 8] = block_c8lQZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lRs; else goto c8lR0;
       u8lRs: // global
           call _c8lQZ(R1) args: 0, res: 0, upd: 0;
       c8lR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lQZ() //  [R1]
         { info_tbl: [(c8lQZ,
                       label: block_c8lQZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lQZ: // global
           I64[Sp - 8] = block_c8lR5_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lR5() //  [R1]
         { info_tbl: [(c8lR5,
                       label: block_c8lR5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lR5: // global
           I64[Sp] = block_c8lRc_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lRc() //  [R1]
         { info_tbl: [(c8lRc,
                       label: block_c8lRc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRc: // global
           if (R1 & 7 == 1) goto c8lRj; else goto c8lRn;
       c8lRj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lRn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lRq; else goto c8lRp;
       c8lRq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lRp: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.578911325 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fShowSomeAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lRy,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lRC; else goto c8lRB;
       c8lRC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lRB: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionSomeAsyncException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.580482583 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionFromException_closure" {
     GHC.IO.Exception.asyncExceptionFromException_closure:
         const GHC.IO.Exception.asyncExceptionFromException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionFromException_entry() //  [R2, R3]
         { info_tbl: [(c8lRK,
                       label: GHC.IO.Exception.asyncExceptionFromException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8lRO; else goto c8lRP;
       c8lRO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionFromException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lRP: // global
           I64[Sp - 16] = block_c8lRH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8lSD; else goto c8lRI;
       u8lSD: // global
           call _c8lRH(R1) args: 0, res: 0, upd: 0;
       c8lRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lRH() //  [R1]
         { info_tbl: [(c8lRH,
                       label: block_c8lRH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRH: // global
           I64[Sp - 8] = block_c8lRN_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lRN() //  [R1]
         { info_tbl: [(c8lRN,
                       label: block_c8lRN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRN: // global
           I64[Sp] = block_c8lRU_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lRU() //  [R1]
         { info_tbl: [(c8lRU,
                       label: block_c8lRU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lRU: // global
           if (R1 & 7 == 1) goto u8lSB; else goto c8lSe;
       u8lSB: // global
           Sp = Sp + 24;
           call _c8lSr() args: 0, res: 0, upd: 0;
       c8lSe: // global
           _s8jfW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lS4_info;
           R1 = _s8jfW::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lS4() //  [R1]
         { info_tbl: [(c8lS4,
                       label: block_c8lS4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lS4: // global
           I64[Sp - 8] = block_c8lS8_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lS8() //  [R1]
         { info_tbl: [(c8lS8,
                       label: block_c8lS8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lS8: // global
           I64[Sp] = block_c8lSc_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lSc() //  [R1]
         { info_tbl: [(c8lSc,
                       label: block_c8lSc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSc: // global
           I64[Sp] = block_c8lSk_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lSk() //  [R1]
         { info_tbl: [(c8lSk,
                       label: block_c8lSk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSk: // global
           if (R1 & 7 == 1) goto u8lSC; else goto c8lSv;
       u8lSC: // global
           Sp = Sp + 24;
           call _c8lSr() args: 0, res: 0, upd: 0;
       c8lSv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lSy; else goto c8lSx;
       c8lSy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lSx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lSr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSr: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.58287691 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionToException_closure" {
     GHC.IO.Exception.asyncExceptionToException_closure:
         const GHC.IO.Exception.asyncExceptionToException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionToException_entry() //  [R2, R3]
         { info_tbl: [(c8lSL,
                       label: GHC.IO.Exception.asyncExceptionToException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lSP; else goto c8lSO;
       c8lSP: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionToException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lSO: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.583732298 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException11_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException11_bytes:
         I8[] [65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.58428182 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException10_closure" {
     GHC.IO.Exception.$fExceptionAsyncException10_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.584848879 UTC

[section ""data" . GHC.IO.Exception.$tcAsyncException_closure" {
     GHC.IO.Exception.$tcAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
         const GHC.Types.krep$*_closure;
         const 3223192752092240512;
         const 6151543105744102738;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.58586299 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow1_closure" {
     GHC.IO.Exception.$tc'HeapOverflow1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.586426364 UTC

[section ""cstring" . GHC.IO.Exception.$tc'StackOverflow2_bytes" {
     GHC.IO.Exception.$tc'StackOverflow2_bytes:
         I8[] [39,83,116,97,99,107,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.586979169 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow1_closure" {
     GHC.IO.Exception.$tc'StackOverflow1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'StackOverflow2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.587533848 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow_closure" {
     GHC.IO.Exception.$tc'StackOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'StackOverflow1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 7140728310745047686;
         const 9210977118047764825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.588130349 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HeapOverflow3_bytes" {
     GHC.IO.Exception.$tc'HeapOverflow3_bytes:
         I8[] [39,72,101,97,112,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.588684361 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow2_closure" {
     GHC.IO.Exception.$tc'HeapOverflow2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HeapOverflow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.589297595 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow_closure" {
     GHC.IO.Exception.$tc'HeapOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow2_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 6603650813243937168;
         const 2046005135570222520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.589884532 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ThreadKilled2_bytes" {
     GHC.IO.Exception.$tc'ThreadKilled2_bytes:
         I8[] [39,84,104,114,101,97,100,75,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.590422204 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled1_closure" {
     GHC.IO.Exception.$tc'ThreadKilled1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ThreadKilled2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.590982255 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled_closure" {
     GHC.IO.Exception.$tc'ThreadKilled_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ThreadKilled1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 13600447017231937444;
         const 101896852196063416;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.591550143 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserInterrupt2_bytes" {
     GHC.IO.Exception.$tc'UserInterrupt2_bytes:
         I8[] [39,85,115,101,114,73,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.592060439 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt1_closure" {
     GHC.IO.Exception.$tc'UserInterrupt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserInterrupt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.59265901 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt_closure" {
     GHC.IO.Exception.$tc'UserInterrupt_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserInterrupt1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 1214873852534998649;
         const 13851718192780849484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.593860168 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException9_closure" {
     GHC.IO.Exception.$fExceptionAsyncException9_closure:
         const GHC.IO.Exception.$fExceptionAsyncException9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException9_entry() //  [R1]
         { info_tbl: [(c8lT1,
                       label: GHC.IO.Exception.$fExceptionAsyncException9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lT1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lT2; else goto c8lT3;
       c8lT2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lT3: // global
           (_c8lST::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lST::I64 == 0) goto c8lSV; else goto c8lSU;
       c8lSV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lSU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lST::I64;
           I64[Sp - 24] = block_c8lSW_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6151543105744102738;
           R2 = 3223192752092240512;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lSW() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lSW,
                       label: block_c8lSW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSW: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lSX() args: 0, res: 0, upd: 0;
     }
 },
 _c8lSX() //  []
         { info_tbl: [(c8lSX,
                       label: block_c8lSX_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lSX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lT6; else goto c8lT5;
       c8lT6: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lSX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lT5: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.595332533 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException7_bytes" {
     GHC.IO.Exception.$fExceptionArrayException7_bytes:
         I8[] [65,114,114,97,121,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.595928454 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException6_closure" {
     GHC.IO.Exception.$fExceptionArrayException6_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionArrayException7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.596497896 UTC

[section ""data" . GHC.IO.Exception.$tcArrayException_closure" {
     GHC.IO.Exception.$tcArrayException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException6_closure+1;
         const GHC.Types.krep$*_closure;
         const 14361659568498315305;
         const 6805143727974531880;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.597088873 UTC

[section ""data" . $krep19_r8j3z_closure" {
     $krep19_r8j3z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcArrayException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.597717661 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds1_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep19_r8j3z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.598287731 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes" {
     GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes:
         I8[] [39,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.598812977 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds2_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.599393246 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds2_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 14241149568806879436;
         const 10551655754853710333;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.600000129 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UndefinedElement2_bytes" {
     GHC.IO.Exception.$tc'UndefinedElement2_bytes:
         I8[] [39,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.600473886 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement1_closure" {
     GHC.IO.Exception.$tc'UndefinedElement1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UndefinedElement2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.601045768 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement_closure" {
     GHC.IO.Exception.$tc'UndefinedElement_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UndefinedElement1_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 9439210122732754255;
         const 8562757414325900819;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.602129057 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException5_closure" {
     GHC.IO.Exception.$fExceptionArrayException5_closure:
         const GHC.IO.Exception.$fExceptionArrayException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException5_entry() //  [R1]
         { info_tbl: [(c8lTk,
                       label: GHC.IO.Exception.$fExceptionArrayException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTk: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lTl; else goto c8lTm;
       c8lTl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lTm: // global
           (_c8lTc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lTc::I64 == 0) goto c8lTe; else goto c8lTd;
       c8lTe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lTd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lTc::I64;
           I64[Sp - 24] = block_c8lTf_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionArrayException6_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6805143727974531880;
           R2 = 14361659568498315305;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lTf() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lTf,
                       label: block_c8lTf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTf: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lTg() args: 0, res: 0, upd: 0;
     }
 },
 _c8lTg() //  []
         { info_tbl: [(c8lTg,
                       label: block_c8lTg_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lTp; else goto c8lTo;
       c8lTp: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lTg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lTo: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.605174454 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lTz,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lTD; else goto c8lTE;
       c8lTD: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lTE: // global
           I64[Sp - 8] = block_c8lTw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lTZ; else goto c8lTx;
       u8lTZ: // global
           call _c8lTw(R1) args: 0, res: 0, upd: 0;
       c8lTx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lTw() //  [R1]
         { info_tbl: [(c8lTw,
                       label: block_c8lTw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTw: // global
           I64[Sp - 8] = block_c8lTC_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lTC() //  [R1]
         { info_tbl: [(c8lTC,
                       label: block_c8lTC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTC: // global
           I64[Sp] = block_c8lTJ_info;
           R3 = GHC.IO.Exception.$fExceptionArrayException5_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lTJ() //  [R1]
         { info_tbl: [(c8lTJ,
                       label: block_c8lTJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lTJ: // global
           if (R1 & 7 == 1) goto c8lTQ; else goto c8lTU;
       c8lTQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lTX; else goto c8lTW;
       c8lTX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lTW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.606810142 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fShowArrayException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lU5,
                       label: GHC.IO.Exception.$fExceptionArrayException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lU5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lU9; else goto c8lU8;
       c8lU9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lU8: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionArrayException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.607725672 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException5_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException5_bytes:
         I8[] [70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.608301146 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException4_closure" {
     GHC.IO.Exception.$fExceptionFixIOException4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.608877117 UTC

[section ""data" . GHC.IO.Exception.$tcFixIOException_closure" {
     GHC.IO.Exception.$tcFixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
         const GHC.Types.krep$*_closure;
         const 175794591112768165;
         const 12820711924146365796;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.609548911 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException1_closure" {
     GHC.IO.Exception.$tc'FixIOException1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcFixIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.610119851 UTC

[section ""cstring" . GHC.IO.Exception.$tc'FixIOException3_bytes" {
     GHC.IO.Exception.$tc'FixIOException3_bytes:
         I8[] [39,70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.610673927 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException2_closure" {
     GHC.IO.Exception.$tc'FixIOException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'FixIOException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.61126326 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException_closure" {
     GHC.IO.Exception.$tc'FixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'FixIOException2_closure+1;
         const GHC.IO.Exception.$tc'FixIOException1_closure+1;
         const 1253631570386628537;
         const 15724415228749653558;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.612290698 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException3_closure" {
     GHC.IO.Exception.$fExceptionFixIOException3_closure:
         const GHC.IO.Exception.$fExceptionFixIOException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException3_entry() //  [R1]
         { info_tbl: [(c8lUl,
                       label: GHC.IO.Exception.$fExceptionFixIOException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUl: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lUm; else goto c8lUn;
       c8lUm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lUn: // global
           (_c8lUd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lUd::I64 == 0) goto c8lUf; else goto c8lUe;
       c8lUf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lUe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lUd::I64;
           I64[Sp - 24] = block_c8lUg_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12820711924146365796;
           R2 = 175794591112768165;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lUg() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lUg,
                       label: block_c8lUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUg: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lUh() args: 0, res: 0, upd: 0;
     }
 },
 _c8lUh() //  []
         { info_tbl: [(c8lUh,
                       label: block_c8lUh_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lUq; else goto c8lUp;
       c8lUq: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lUh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lUp: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.614172434 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lUA,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lUE; else goto c8lUF;
       c8lUE: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lUF: // global
           I64[Sp - 8] = block_c8lUx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lV0; else goto c8lUy;
       u8lV0: // global
           call _c8lUx(R1) args: 0, res: 0, upd: 0;
       c8lUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lUx() //  [R1]
         { info_tbl: [(c8lUx,
                       label: block_c8lUx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUx: // global
           I64[Sp - 8] = block_c8lUD_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lUD() //  [R1]
         { info_tbl: [(c8lUD,
                       label: block_c8lUD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUD: // global
           I64[Sp] = block_c8lUK_info;
           R3 = GHC.IO.Exception.$fExceptionFixIOException3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lUK() //  [R1]
         { info_tbl: [(c8lUK,
                       label: block_c8lUK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lUK: // global
           if (R1 & 7 == 1) goto c8lUR; else goto c8lUV;
       c8lUR: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lUV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lUY; else goto c8lUX;
       c8lUY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lUX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.615764328 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fShowFixIOException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lV6,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lV6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lVa; else goto c8lV9;
       c8lVa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lV9: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionFixIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.616683582 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode6_bytes" {
     GHC.IO.Exception.$fExceptionExitCode6_bytes:
         I8[] [69,120,105,116,67,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.617292981 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode5_closure" {
     GHC.IO.Exception.$fExceptionExitCode5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionExitCode6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.617852118 UTC

[section ""data" . GHC.IO.Exception.$tcExitCode_closure" {
     GHC.IO.Exception.$tcExitCode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode5_closure+1;
         const GHC.Types.krep$*_closure;
         const 8177210543059932106;
         const 3694335570555580912;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.61850561 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess1_closure" {
     GHC.IO.Exception.$tc'ExitSuccess1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcExitCode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.619069181 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitSuccess3_bytes" {
     GHC.IO.Exception.$tc'ExitSuccess3_bytes:
         I8[] [39,69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.619628193 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess2_closure" {
     GHC.IO.Exception.$tc'ExitSuccess2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitSuccess3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.620209564 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess_closure" {
     GHC.IO.Exception.$tc'ExitSuccess_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess2_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 6011095708053053284;
         const 14896688531190285489;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.620834797 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure1_closure" {
     GHC.IO.Exception.$tc'ExitFailure1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r8j3f_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.622510029 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitFailure3_bytes" {
     GHC.IO.Exception.$tc'ExitFailure3_bytes:
         I8[] [39,69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.623064 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure2_closure" {
     GHC.IO.Exception.$tc'ExitFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.623583123 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure_closure" {
     GHC.IO.Exception.$tc'ExitFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure2_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure1_closure+4;
         const 13149331685465745995;
         const 10453046320643141131;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.624785709 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode4_closure" {
     GHC.IO.Exception.$fExceptionExitCode4_closure:
         const GHC.IO.Exception.$fExceptionExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode4_entry() //  [R1]
         { info_tbl: [(c8lVm,
                       label: GHC.IO.Exception.$fExceptionExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVm: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lVn; else goto c8lVo;
       c8lVn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lVo: // global
           (_c8lVe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lVe::I64 == 0) goto c8lVg; else goto c8lVf;
       c8lVg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lVf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lVe::I64;
           I64[Sp - 24] = block_c8lVh_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionExitCode5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3694335570555580912;
           R2 = 8177210543059932106;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lVh() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lVh,
                       label: block_c8lVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVh: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lVi() args: 0, res: 0, upd: 0;
     }
 },
 _c8lVi() //  []
         { info_tbl: [(c8lVi,
                       label: block_c8lVi_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lVr; else goto c8lVq;
       c8lVr: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lVi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lVq: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.626776561 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lVB,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lVF; else goto c8lVG;
       c8lVF: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lVG: // global
           I64[Sp - 8] = block_c8lVy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lW1; else goto c8lVz;
       u8lW1: // global
           call _c8lVy(R1) args: 0, res: 0, upd: 0;
       c8lVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lVy() //  [R1]
         { info_tbl: [(c8lVy,
                       label: block_c8lVy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVy: // global
           I64[Sp - 8] = block_c8lVE_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lVE() //  [R1]
         { info_tbl: [(c8lVE,
                       label: block_c8lVE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVE: // global
           I64[Sp] = block_c8lVL_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lVL() //  [R1]
         { info_tbl: [(c8lVL,
                       label: block_c8lVL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lVL: // global
           if (R1 & 7 == 1) goto c8lVS; else goto c8lVW;
       c8lVS: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lVW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lVZ; else goto c8lVY;
       c8lVZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lVY: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.628425464 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_closure" {
     GHC.IO.Exception.$fExceptionExitCode_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fShowExitCode_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lW7,
                       label: GHC.IO.Exception.$fExceptionExitCode_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lW7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lWb; else goto c8lWa;
       c8lWb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lWa: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionExitCode_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.629419896 UTC

[section ""cstring" . GHC.IO.Exception.$tcIOErrorType2_bytes" {
     GHC.IO.Exception.$tcIOErrorType2_bytes:
         I8[] [73,79,69,114,114,111,114,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.629965881 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType1_closure" {
     GHC.IO.Exception.$tcIOErrorType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tcIOErrorType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.630545808 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType_closure" {
     GHC.IO.Exception.$tcIOErrorType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tcIOErrorType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13260403802836574836;
         const 9962456285013293537;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.631143412 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists1_closure" {
     GHC.IO.Exception.$tc'AlreadyExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOErrorType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.631691516 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AlreadyExists3_bytes" {
     GHC.IO.Exception.$tc'AlreadyExists3_bytes:
         I8[] [39,65,108,114,101,97,100,121,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.632208919 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists2_closure" {
     GHC.IO.Exception.$tc'AlreadyExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.632787926 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists_closure" {
     GHC.IO.Exception.$tc'AlreadyExists_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists2_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 13383994725479033447;
         const 16077735236426702934;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.633480193 UTC

[section ""cstring" . GHC.IO.Exception.$tc'NoSuchThing2_bytes" {
     GHC.IO.Exception.$tc'NoSuchThing2_bytes:
         I8[] [39,78,111,83,117,99,104,84,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.634051396 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing1_closure" {
     GHC.IO.Exception.$tc'NoSuchThing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'NoSuchThing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.63463219 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing_closure" {
     GHC.IO.Exception.$tc'NoSuchThing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'NoSuchThing1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 1065788776620214811;
         const 7708272823769791518;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.63521802 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceBusy2_bytes" {
     GHC.IO.Exception.$tc'ResourceBusy2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,66,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.635791567 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy1_closure" {
     GHC.IO.Exception.$tc'ResourceBusy1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceBusy2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.63636657 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy_closure" {
     GHC.IO.Exception.$tc'ResourceBusy_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceBusy1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 81041156937828521;
         const 16732677038738772765;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.636909154 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceExhausted2_bytes" {
     GHC.IO.Exception.$tc'ResourceExhausted2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.637518497 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted1_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceExhausted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.638131176 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceExhausted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 661664682644939150;
         const 17978068149744050586;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.639762664 UTC

[section ""cstring" . GHC.IO.Exception.$tc'EOF2_bytes" {
     GHC.IO.Exception.$tc'EOF2_bytes:
         I8[] [39,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.640342101 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF1_closure" {
     GHC.IO.Exception.$tc'EOF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'EOF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.640936768 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF_closure" {
     GHC.IO.Exception.$tc'EOF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'EOF1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 15446447841260182649;
         const 9615135582901540009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.643922868 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IllegalOperation2_bytes" {
     GHC.IO.Exception.$tc'IllegalOperation2_bytes:
         I8[] [39,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.644631866 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation1_closure" {
     GHC.IO.Exception.$tc'IllegalOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IllegalOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.645354827 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation_closure" {
     GHC.IO.Exception.$tc'IllegalOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IllegalOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2997750042243464947;
         const 13732497530673208550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.645959004 UTC

[section ""cstring" . GHC.IO.Exception.$tc'PermissionDenied2_bytes" {
     GHC.IO.Exception.$tc'PermissionDenied2_bytes:
         I8[] [39,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.64661173 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied1_closure" {
     GHC.IO.Exception.$tc'PermissionDenied1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'PermissionDenied2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.647370307 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied_closure" {
     GHC.IO.Exception.$tc'PermissionDenied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'PermissionDenied1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17002959889944859215;
         const 11679101384562499698;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.648228238 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserError2_bytes" {
     GHC.IO.Exception.$tc'UserError2_bytes:
         I8[] [39,85,115,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.648918536 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError1_closure" {
     GHC.IO.Exception.$tc'UserError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.649527322 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError_closure" {
     GHC.IO.Exception.$tc'UserError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2110707588451626880;
         const 793010194601470118;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.650154438 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes:
         I8[] [39,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.650878948 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.651694044 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 7774786765253276509;
         const 11159080782866109022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.652555379 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SystemError2_bytes" {
     GHC.IO.Exception.$tc'SystemError2_bytes:
         I8[] [39,83,121,115,116,101,109,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.653304662 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError1_closure" {
     GHC.IO.Exception.$tc'SystemError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SystemError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.654056071 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError_closure" {
     GHC.IO.Exception.$tc'SystemError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SystemError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14723310935893761222;
         const 8619015840207109406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.654752316 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ProtocolError2_bytes" {
     GHC.IO.Exception.$tc'ProtocolError2_bytes:
         I8[] [39,80,114,111,116,111,99,111,108,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.655404001 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError1_closure" {
     GHC.IO.Exception.$tc'ProtocolError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ProtocolError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.656162205 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError_closure" {
     GHC.IO.Exception.$tc'ProtocolError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ProtocolError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2348878698518162749;
         const 1616623917153004368;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.656949764 UTC

[section ""cstring" . GHC.IO.Exception.$tc'OtherError2_bytes" {
     GHC.IO.Exception.$tc'OtherError2_bytes:
         I8[] [39,79,116,104,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.658561557 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError1_closure" {
     GHC.IO.Exception.$tc'OtherError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'OtherError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.659276103 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError_closure" {
     GHC.IO.Exception.$tc'OtherError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'OtherError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 11457353566076247204;
         const 7448318885269020484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.659987388 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InvalidArgument2_bytes" {
     GHC.IO.Exception.$tc'InvalidArgument2_bytes:
         I8[] [39,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.660805853 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument1_closure" {
     GHC.IO.Exception.$tc'InvalidArgument1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InvalidArgument2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.661562247 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument_closure" {
     GHC.IO.Exception.$tc'InvalidArgument_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InvalidArgument1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2877905627043716713;
         const 870624010466166536;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.662336204 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InappropriateType2_bytes" {
     GHC.IO.Exception.$tc'InappropriateType2_bytes:
         I8[] [39,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.663052002 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType1_closure" {
     GHC.IO.Exception.$tc'InappropriateType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InappropriateType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.663785659 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType_closure" {
     GHC.IO.Exception.$tc'InappropriateType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InappropriateType1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 12194312324817842633;
         const 15900888301186079347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.664692402 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HardwareFault2_bytes" {
     GHC.IO.Exception.$tc'HardwareFault2_bytes:
         I8[] [39,72,97,114,100,119,97,114,101,70,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.665454357 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault1_closure" {
     GHC.IO.Exception.$tc'HardwareFault1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HardwareFault2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.666370349 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault_closure" {
     GHC.IO.Exception.$tc'HardwareFault_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HardwareFault1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 56378797976289033;
         const 18431513512258190916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.667326367 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsupportedOperation2_bytes" {
     GHC.IO.Exception.$tc'UnsupportedOperation2_bytes:
         I8[] [39,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.668000896 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation1_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsupportedOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.668688056 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsupportedOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 8512525638220727204;
         const 8859286885870192330;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.669414231 UTC

[section ""cstring" . GHC.IO.Exception.$tc'TimeExpired2_bytes" {
     GHC.IO.Exception.$tc'TimeExpired2_bytes:
         I8[] [39,84,105,109,101,69,120,112,105,114,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.670115836 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired1_closure" {
     GHC.IO.Exception.$tc'TimeExpired1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'TimeExpired2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.670779876 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired_closure" {
     GHC.IO.Exception.$tc'TimeExpired_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'TimeExpired1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 10911629093425571025;
         const 350480745296812363;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.671491375 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceVanished2_bytes" {
     GHC.IO.Exception.$tc'ResourceVanished2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.672087444 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished1_closure" {
     GHC.IO.Exception.$tc'ResourceVanished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceVanished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.672744122 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished_closure" {
     GHC.IO.Exception.$tc'ResourceVanished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceVanished1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14859807110076739958;
         const 15612633629389469803;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.674254093 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Interrupted2_bytes" {
     GHC.IO.Exception.$tc'Interrupted2_bytes:
         I8[] [39,73,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.67575541 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted1_closure" {
     GHC.IO.Exception.$tc'Interrupted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Interrupted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.676513887 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted_closure" {
     GHC.IO.Exception.$tc'Interrupted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Interrupted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17492795632142579451;
         const 15910845476779721305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.677377606 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException6_bytes" {
     GHC.IO.Exception.$fExceptionIOException6_bytes:
         I8[] [73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.678043189 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException5_closure" {
     GHC.IO.Exception.$fExceptionIOException5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionIOException6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.678596985 UTC

[section ""data" . GHC.IO.Exception.$tcIOException_closure" {
     GHC.IO.Exception.$tcIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionIOException5_closure+1;
         const GHC.Types.krep$*_closure;
         const 10434000377887324342;
         const 16509375198449321302;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.679156649 UTC

[section ""data" . $krep20_r8j3A_closure" {
     $krep20_r8j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.679711871 UTC

[section ""data" . $krep21_r8j3B_closure" {
     $krep21_r8j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8j3q_closure+1;
         const $krep20_r8j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.680280099 UTC

[section ""data" . $krep22_r8j3C_closure" {
     $krep22_r8j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8j3k_closure+1;
         const $krep21_r8j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.68086911 UTC

[section ""data" . $krep23_r8j3D_closure" {
     $krep23_r8j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep22_r8j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.681508691 UTC

[section ""data" . $krep24_r8j3E_closure" {
     $krep24_r8j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep23_r8j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.682110456 UTC

[section ""data" . $krep25_r8j3F_closure" {
     $krep25_r8j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const $krep24_r8j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.682673375 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError1_closure" {
     GHC.IO.Exception.$tc'IOError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8j3m_closure+1;
         const $krep25_r8j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.683204581 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IOError3_bytes" {
     GHC.IO.Exception.$tc'IOError3_bytes:
         I8[] [39,73,79,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.683760754 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError2_closure" {
     GHC.IO.Exception.$tc'IOError2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IOError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.68428311 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError_closure" {
     GHC.IO.Exception.$tc'IOError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IOError2_closure+1;
         const GHC.IO.Exception.$tc'IOError1_closure+4;
         const 16489485703680136625;
         const 16514523686887444952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.685537311 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException4_closure" {
     GHC.IO.Exception.$fExceptionIOException4_closure:
         const GHC.IO.Exception.$fExceptionIOException4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException4_entry() //  [R1]
         { info_tbl: [(c8lWn,
                       label: GHC.IO.Exception.$fExceptionIOException4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWn: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8lWo; else goto c8lWp;
       c8lWo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lWp: // global
           (_c8lWf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lWf::I64 == 0) goto c8lWh; else goto c8lWg;
       c8lWh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lWg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lWf::I64;
           I64[Sp - 24] = block_c8lWi_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionIOException5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 16509375198449321302;
           R2 = 10434000377887324342;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8lWi() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8lWi,
                       label: block_c8lWi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWi: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8lWj() args: 0, res: 0, upd: 0;
     }
 },
 _c8lWj() //  []
         { info_tbl: [(c8lWj,
                       label: block_c8lWj_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8lWs; else goto c8lWr;
       c8lWs: // global
           HpAlloc = 48;
           I64[Sp] = block_c8lWj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8lWr: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.68749924 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lWC,
                       label: GHC.IO.Exception.$fExceptionIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lWG; else goto c8lWH;
       c8lWG: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lWH: // global
           I64[Sp - 8] = block_c8lWz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lX2; else goto c8lWA;
       u8lX2: // global
           call _c8lWz(R1) args: 0, res: 0, upd: 0;
       c8lWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lWz() //  [R1]
         { info_tbl: [(c8lWz,
                       label: block_c8lWz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWz: // global
           I64[Sp - 8] = block_c8lWF_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lWF() //  [R1]
         { info_tbl: [(c8lWF,
                       label: block_c8lWF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWF: // global
           I64[Sp] = block_c8lWM_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lWM() //  [R1]
         { info_tbl: [(c8lWM,
                       label: block_c8lWM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lWM: // global
           if (R1 & 7 == 1) goto c8lWT; else goto c8lWX;
       c8lWT: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lWX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lX0; else goto c8lWZ;
       c8lX0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lWZ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.689042045 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_closure" {
     GHC.IO.Exception.$fExceptionIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Exception.$fShowIOException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lX8,
                       label: GHC.IO.Exception.$fExceptionIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lX8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lXc; else goto c8lXb;
       c8lXc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lXb: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.69034369 UTC

[section ""data" . GHC.IO.Exception.ioError1_closure" {
     GHC.IO.Exception.ioError1_closure:
         const GHC.IO.Exception.ioError1_info;
         const 0;
 },
 sat_s8jh2_entry() //  [R1]
         { info_tbl: [(c8lXl,
                       label: sat_s8jh2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lXm; else goto c8lXn;
       c8lXm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lXn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.ioError1_entry() //  [R2]
         { info_tbl: [(c8lXo,
                       label: GHC.IO.Exception.ioError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lXs; else goto c8lXr;
       c8lXs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.ioError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lXr: // global
           I64[Hp - 16] = sat_s8jh2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.691491019 UTC

[section ""data" . GHC.IO.Exception.ioException_closure" {
     GHC.IO.Exception.ioException_closure:
         const GHC.IO.Exception.ioException_info;
         const 0;
 },
 GHC.IO.Exception.ioException_entry() //  [R2]
         { info_tbl: [(c8lXx,
                       label: GHC.IO.Exception.ioException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXx: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.692270507 UTC

[section ""data" . GHC.IO.Exception.ioError_closure" {
     GHC.IO.Exception.ioError_closure:
         const GHC.IO.Exception.ioError_info;
         const 0;
 },
 GHC.IO.Exception.ioError_entry() //  [R2]
         { info_tbl: [(c8lXE,
                       label: GHC.IO.Exception.ioError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXE: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.692963889 UTC

[section ""data" . GHC.IO.Exception.$fxExceptionIOException_closure" {
     GHC.IO.Exception.$fxExceptionIOException_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Exception.$fExceptionIOException_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.693991779 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lXO,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lXS; else goto c8lXT;
       c8lXS: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lXT: // global
           I64[Sp - 8] = block_c8lXL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lYe; else goto c8lXM;
       u8lYe: // global
           call _c8lXL(R1) args: 0, res: 0, upd: 0;
       c8lXM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lXL() //  [R1]
         { info_tbl: [(c8lXL,
                       label: block_c8lXL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXL: // global
           I64[Sp - 8] = block_c8lXR_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lXR() //  [R1]
         { info_tbl: [(c8lXR,
                       label: block_c8lXR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXR: // global
           I64[Sp] = block_c8lXY_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lXY() //  [R1]
         { info_tbl: [(c8lXY,
                       label: block_c8lXY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lXY: // global
           if (R1 & 7 == 1) goto c8lY5; else goto c8lY9;
       c8lY5: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lY9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lYc; else goto c8lYb;
       c8lYc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lYb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.695611714 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lYk,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lYo; else goto c8lYn;
       c8lYo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lYn: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.696739602 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnMVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnMVar_entry() //  [R1]
         { info_tbl: [(c8lYv,
                       label: GHC.IO.Exception.blockedIndefinitelyOnMVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lYw; else goto c8lYx;
       c8lYw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lYx: // global
           (_c8lYs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lYs::I64 == 0) goto c8lYu; else goto c8lYt;
       c8lYu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lYt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lYs::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.698100477 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lYF,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lYJ; else goto c8lYK;
       c8lYJ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lYK: // global
           I64[Sp - 8] = block_c8lYC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8lZ5; else goto c8lYD;
       u8lZ5: // global
           call _c8lYC(R1) args: 0, res: 0, upd: 0;
       c8lYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lYC() //  [R1]
         { info_tbl: [(c8lYC,
                       label: block_c8lYC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYC: // global
           I64[Sp - 8] = block_c8lYI_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lYI() //  [R1]
         { info_tbl: [(c8lYI,
                       label: block_c8lYI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYI: // global
           I64[Sp] = block_c8lYP_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lYP() //  [R1]
         { info_tbl: [(c8lYP,
                       label: block_c8lYP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lYP: // global
           if (R1 & 7 == 1) goto c8lYW; else goto c8lZ0;
       c8lYW: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lZ0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8lZ3; else goto c8lZ2;
       c8lZ3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lZ2: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.699687294 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry() //  [R2]
         { info_tbl: [(c8lZb,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lZf; else goto c8lZe;
       c8lZf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lZe: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.700773524 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnSTM_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnSTM_entry() //  [R1]
         { info_tbl: [(c8lZm,
                       label: GHC.IO.Exception.blockedIndefinitelyOnSTM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lZn; else goto c8lZo;
       c8lZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8lZo: // global
           (_c8lZj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8lZj::I64 == 0) goto c8lZl; else goto c8lZk;
       c8lZl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8lZk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8lZj::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.702574411 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8m0n_srtd" {
     u8m0n_srtd:
         const S8ji8_srt+688;
         const 35;
         const 25771900929;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_entry() //  [R2]
         { info_tbl: [(c8lZw,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8lZA; else goto c8lZB;
       c8lZA: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8lZB: // global
           I64[Sp - 8] = block_c8lZt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m0k; else goto c8lZu;
       u8m0k: // global
           call _c8lZt(R1) args: 0, res: 0, upd: 0;
       c8lZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8m0o_srtd" {
     u8m0o_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8lZt() //  [R1]
         { info_tbl: [(c8lZt,
                       label: block_c8lZt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZt: // global
           I64[Sp - 8] = block_c8lZz_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8m0p_srtd" {
     u8m0p_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8lZz() //  [R1]
         { info_tbl: [(c8lZz,
                       label: block_c8lZz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZz: // global
           I64[Sp] = block_c8lZG_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lZG() //  [R1]
         { info_tbl: [(c8lZG,
                       label: block_c8lZG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZG: // global
           if (R1 & 7 == 1) goto u8m0i; else goto c8lZW;
       u8m0i: // global
           Sp = Sp + 16;
           call _c8m08() args: 0, res: 0, upd: 0;
       c8lZW: // global
           _s8jhi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8lZQ_info;
           R1 = _s8jhi::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8lZQ() //  [R1]
         { info_tbl: [(c8lZQ,
                       label: block_c8lZQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZQ: // global
           I64[Sp - 8] = block_c8lZU_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8lZU() //  [R1]
         { info_tbl: [(c8lZU,
                       label: block_c8lZU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lZU: // global
           I64[Sp] = block_c8m01_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m01() //  [R1]
         { info_tbl: [(c8m01,
                       label: block_c8m01_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m01: // global
           if (R1 & 7 == 1) goto u8m0j; else goto c8m0c;
       u8m0j: // global
           Sp = Sp + 16;
           call _c8m08() args: 0, res: 0, upd: 0;
       c8m0c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m0f; else goto c8m0e;
       c8m0f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8m0e: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8m08() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m08: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.704844854 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry() //  [R2]
         { info_tbl: [(c8m0v,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m0v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8m0z; else goto c8m0y;
       c8m0z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m0y: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.705970136 UTC

[section ""data" . GHC.IO.Exception.allocationLimitExceeded_closure" {
     GHC.IO.Exception.allocationLimitExceeded_closure:
         const GHC.IO.Exception.allocationLimitExceeded_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.allocationLimitExceeded_entry() //  [R1]
         { info_tbl: [(c8m0G,
                       label: GHC.IO.Exception.allocationLimitExceeded_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m0G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m0H; else goto c8m0I;
       c8m0H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m0I: // global
           (_c8m0D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m0D::I64 == 0) goto c8m0F; else goto c8m0E;
       c8m0F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m0E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m0D::I64;
           R2 = GHC.IO.Exception.AllocationLimitExceeded_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.707423647 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8m0Q,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m0U; else goto c8m0V;
       c8m0U: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m0V: // global
           I64[Sp - 8] = block_c8m0N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m1g; else goto c8m0O;
       u8m1g: // global
           call _c8m0N(R1) args: 0, res: 0, upd: 0;
       c8m0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m0N() //  [R1]
         { info_tbl: [(c8m0N,
                       label: block_c8m0N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m0N: // global
           I64[Sp - 8] = block_c8m0T_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m0T() //  [R1]
         { info_tbl: [(c8m0T,
                       label: block_c8m0T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m0T: // global
           I64[Sp] = block_c8m10_info;
           R3 = GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m10() //  [R1]
         { info_tbl: [(c8m10,
                       label: block_c8m10_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m10: // global
           if (R1 & 7 == 1) goto c8m17; else goto c8m1b;
       c8m17: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8m1b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m1e; else goto c8m1d;
       c8m1e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8m1d: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.709427128 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fShowCompactionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8m1m,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m1m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8m1q; else goto c8m1p;
       c8m1q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m1p: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionCompactionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.710521208 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactMutable2_bytes" {
     GHC.IO.Exception.cannotCompactMutable2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,109,117,116,97,98,108,101,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.711328955 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable1_closure" {
     GHC.IO.Exception.cannotCompactMutable1_closure:
         const GHC.IO.Exception.cannotCompactMutable1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable1_entry() //  [R1]
         { info_tbl: [(c8m1x,
                       label: GHC.IO.Exception.cannotCompactMutable1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m1x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m1y; else goto c8m1z;
       c8m1y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m1z: // global
           (_c8m1u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m1u::I64 == 0) goto c8m1w; else goto c8m1v;
       c8m1w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m1v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m1u::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.712538997 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable_closure" {
     GHC.IO.Exception.cannotCompactMutable_closure:
         const GHC.IO.Exception.cannotCompactMutable_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable_entry() //  [R1]
         { info_tbl: [(c8m1G,
                       label: GHC.IO.Exception.cannotCompactMutable_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m1G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m1H; else goto c8m1I;
       c8m1H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m1I: // global
           (_c8m1D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m1D::I64 == 0) goto c8m1F; else goto c8m1E;
       c8m1F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m1E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m1D::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.713695174 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactPinned2_bytes" {
     GHC.IO.Exception.cannotCompactPinned2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,112,105,110,110,101,100,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.71449754 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned1_closure" {
     GHC.IO.Exception.cannotCompactPinned1_closure:
         const GHC.IO.Exception.cannotCompactPinned1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned1_entry() //  [R1]
         { info_tbl: [(c8m1P,
                       label: GHC.IO.Exception.cannotCompactPinned1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m1P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m1Q; else goto c8m1R;
       c8m1Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m1R: // global
           (_c8m1M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m1M::I64 == 0) goto c8m1O; else goto c8m1N;
       c8m1O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m1N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m1M::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.715622904 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned_closure" {
     GHC.IO.Exception.cannotCompactPinned_closure:
         const GHC.IO.Exception.cannotCompactPinned_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned_entry() //  [R1]
         { info_tbl: [(c8m1Y,
                       label: GHC.IO.Exception.cannotCompactPinned_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m1Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m1Z; else goto c8m20;
       c8m1Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m20: // global
           (_c8m1V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m1V::I64 == 0) goto c8m1X; else goto c8m1W;
       c8m1X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m1W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m1V::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.716693061 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactFunction2_bytes" {
     GHC.IO.Exception.cannotCompactFunction2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,102,117,110,99,116,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.717648835 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction1_closure" {
     GHC.IO.Exception.cannotCompactFunction1_closure:
         const GHC.IO.Exception.cannotCompactFunction1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction1_entry() //  [R1]
         { info_tbl: [(c8m27,
                       label: GHC.IO.Exception.cannotCompactFunction1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m27: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m28; else goto c8m29;
       c8m28: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m29: // global
           (_c8m24::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m24::I64 == 0) goto c8m26; else goto c8m25;
       c8m26: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m25: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m24::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.718787239 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction_closure" {
     GHC.IO.Exception.cannotCompactFunction_closure:
         const GHC.IO.Exception.cannotCompactFunction_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction_entry() //  [R1]
         { info_tbl: [(c8m2g,
                       label: GHC.IO.Exception.cannotCompactFunction_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m2h; else goto c8m2i;
       c8m2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m2i: // global
           (_c8m2d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m2d::I64 == 0) goto c8m2f; else goto c8m2e;
       c8m2f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m2e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m2d::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.720710373 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8m3h_srtd" {
     u8m3h_srtd:
         const S8ji8_srt+688;
         const 47;
         const 105553118363649;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8m2q,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m2u; else goto c8m2v;
       c8m2u: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m2v: // global
           I64[Sp - 8] = block_c8m2n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m3e; else goto c8m2o;
       u8m3e: // global
           call _c8m2n(R1) args: 0, res: 0, upd: 0;
       c8m2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8m3i_srtd" {
     u8m3i_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8m2n() //  [R1]
         { info_tbl: [(c8m2n,
                       label: block_c8m2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2n: // global
           I64[Sp - 8] = block_c8m2t_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8m3j_srtd" {
     u8m3j_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8m2t() //  [R1]
         { info_tbl: [(c8m2t,
                       label: block_c8m2t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2t: // global
           I64[Sp] = block_c8m2A_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m2A() //  [R1]
         { info_tbl: [(c8m2A,
                       label: block_c8m2A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2A: // global
           if (R1 & 7 == 1) goto u8m3c; else goto c8m2Q;
       u8m3c: // global
           Sp = Sp + 16;
           call _c8m32() args: 0, res: 0, upd: 0;
       c8m2Q: // global
           _s8jhB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8m2K_info;
           R1 = _s8jhB::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m2K() //  [R1]
         { info_tbl: [(c8m2K,
                       label: block_c8m2K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2K: // global
           I64[Sp - 8] = block_c8m2O_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m2O() //  [R1]
         { info_tbl: [(c8m2O,
                       label: block_c8m2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2O: // global
           I64[Sp] = block_c8m2V_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8m2V() //  [R1]
         { info_tbl: [(c8m2V,
                       label: block_c8m2V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m2V: // global
           if (R1 & 7 == 1) goto u8m3d; else goto c8m36;
       u8m3d: // global
           Sp = Sp + 16;
           call _c8m32() args: 0, res: 0, upd: 0;
       c8m36: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m39; else goto c8m38;
       c8m39: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8m38: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8m32() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m32: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.724475047 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fShowAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8m3p,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m3p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8m3t; else goto c8m3s;
       c8m3t: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m3s: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAsyncException_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.725660719 UTC

[section ""data" . GHC.IO.Exception.heapOverflow_closure" {
     GHC.IO.Exception.heapOverflow_closure:
         const GHC.IO.Exception.heapOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.heapOverflow_entry() //  [R1]
         { info_tbl: [(c8m3A,
                       label: GHC.IO.Exception.heapOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m3B; else goto c8m3C;
       c8m3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m3C: // global
           (_c8m3x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m3x::I64 == 0) goto c8m3z; else goto c8m3y;
       c8m3z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m3y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m3x::I64;
           R2 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.726704879 UTC

[section ""data" . GHC.IO.Exception.stackOverflow_closure" {
     GHC.IO.Exception.stackOverflow_closure:
         const GHC.IO.Exception.stackOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.stackOverflow_entry() //  [R1]
         { info_tbl: [(c8m3J,
                       label: GHC.IO.Exception.stackOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m3J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m3K; else goto c8m3L;
       c8m3K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m3L: // global
           (_c8m3G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m3G::I64 == 0) goto c8m3I; else goto c8m3H;
       c8m3I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m3H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m3G::I64;
           R2 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.727827675 UTC

[section ""data" . GHC.IO.Exception.IOError_closure" {
     GHC.IO.Exception.IOError_closure:
         const GHC.IO.Exception.IOError_info;
 },
 GHC.IO.Exception.IOError_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8m3R,
                       label: GHC.IO.Exception.IOError_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m3R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8m3V; else goto c8m3U;
       c8m3V: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.IOError_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8m3U: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.72871059 UTC

[section ""data" . GHC.IO.Exception.AlreadyExists_closure" {
     GHC.IO.Exception.AlreadyExists_closure:
         const GHC.IO.Exception.AlreadyExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.729348014 UTC

[section ""data" . GHC.IO.Exception.NoSuchThing_closure" {
     GHC.IO.Exception.NoSuchThing_closure:
         const GHC.IO.Exception.NoSuchThing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.729930362 UTC

[section ""data" . GHC.IO.Exception.ResourceBusy_closure" {
     GHC.IO.Exception.ResourceBusy_closure:
         const GHC.IO.Exception.ResourceBusy_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.730513452 UTC

[section ""data" . GHC.IO.Exception.ResourceExhausted_closure" {
     GHC.IO.Exception.ResourceExhausted_closure:
         const GHC.IO.Exception.ResourceExhausted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.731053813 UTC

[section ""data" . GHC.IO.Exception.EOF_closure" {
     GHC.IO.Exception.EOF_closure:
         const GHC.IO.Exception.EOF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.731638221 UTC

[section ""data" . GHC.IO.Exception.IllegalOperation_closure" {
     GHC.IO.Exception.IllegalOperation_closure:
         const GHC.IO.Exception.IllegalOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.732225705 UTC

[section ""data" . GHC.IO.Exception.PermissionDenied_closure" {
     GHC.IO.Exception.PermissionDenied_closure:
         const GHC.IO.Exception.PermissionDenied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.732758944 UTC

[section ""data" . GHC.IO.Exception.UserError_closure" {
     GHC.IO.Exception.UserError_closure:
         const GHC.IO.Exception.UserError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.734076338 UTC

[section ""data" . GHC.IO.Exception.UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.UnsatisfiedConstraints_closure:
         const GHC.IO.Exception.UnsatisfiedConstraints_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.734627672 UTC

[section ""data" . GHC.IO.Exception.SystemError_closure" {
     GHC.IO.Exception.SystemError_closure:
         const GHC.IO.Exception.SystemError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.735123851 UTC

[section ""data" . GHC.IO.Exception.ProtocolError_closure" {
     GHC.IO.Exception.ProtocolError_closure:
         const GHC.IO.Exception.ProtocolError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.735661413 UTC

[section ""data" . GHC.IO.Exception.OtherError_closure" {
     GHC.IO.Exception.OtherError_closure:
         const GHC.IO.Exception.OtherError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.736201073 UTC

[section ""data" . GHC.IO.Exception.InvalidArgument_closure" {
     GHC.IO.Exception.InvalidArgument_closure:
         const GHC.IO.Exception.InvalidArgument_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.736759771 UTC

[section ""data" . GHC.IO.Exception.InappropriateType_closure" {
     GHC.IO.Exception.InappropriateType_closure:
         const GHC.IO.Exception.InappropriateType_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.737392045 UTC

[section ""data" . GHC.IO.Exception.HardwareFault_closure" {
     GHC.IO.Exception.HardwareFault_closure:
         const GHC.IO.Exception.HardwareFault_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.737934053 UTC

[section ""data" . GHC.IO.Exception.UnsupportedOperation_closure" {
     GHC.IO.Exception.UnsupportedOperation_closure:
         const GHC.IO.Exception.UnsupportedOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.738457847 UTC

[section ""data" . GHC.IO.Exception.TimeExpired_closure" {
     GHC.IO.Exception.TimeExpired_closure:
         const GHC.IO.Exception.TimeExpired_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.738995572 UTC

[section ""data" . GHC.IO.Exception.ResourceVanished_closure" {
     GHC.IO.Exception.ResourceVanished_closure:
         const GHC.IO.Exception.ResourceVanished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.739537643 UTC

[section ""data" . GHC.IO.Exception.Interrupted_closure" {
     GHC.IO.Exception.Interrupted_closure:
         const GHC.IO.Exception.Interrupted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.740085955 UTC

[section ""data" . GHC.IO.Exception.ExitSuccess_closure" {
     GHC.IO.Exception.ExitSuccess_closure:
         const GHC.IO.Exception.ExitSuccess_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.740964426 UTC

[section ""data" . GHC.IO.Exception.ExitFailure_closure" {
     GHC.IO.Exception.ExitFailure_closure:
         const GHC.IO.Exception.ExitFailure_info;
 },
 GHC.IO.Exception.ExitFailure_entry() //  [R2]
         { info_tbl: [(c8m41,
                       label: GHC.IO.Exception.ExitFailure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m41: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m45; else goto c8m44;
       c8m45: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.ExitFailure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m44: // global
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.741989071 UTC

[section ""data" . GHC.IO.Exception.FixIOException_closure" {
     GHC.IO.Exception.FixIOException_closure:
         const GHC.IO.Exception.FixIOException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.742673884 UTC

[section ""data" . GHC.IO.Exception.IndexOutOfBounds_closure" {
     GHC.IO.Exception.IndexOutOfBounds_closure:
         const GHC.IO.Exception.IndexOutOfBounds_info;
 },
 GHC.IO.Exception.IndexOutOfBounds_entry() //  [R2]
         { info_tbl: [(c8m4b,
                       label: GHC.IO.Exception.IndexOutOfBounds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m4f; else goto c8m4e;
       c8m4f: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.IndexOutOfBounds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m4e: // global
           I64[Hp - 8] = GHC.IO.Exception.IndexOutOfBounds_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.743705832 UTC

[section ""data" . GHC.IO.Exception.UndefinedElement_closure" {
     GHC.IO.Exception.UndefinedElement_closure:
         const GHC.IO.Exception.UndefinedElement_info;
 },
 GHC.IO.Exception.UndefinedElement_entry() //  [R2]
         { info_tbl: [(c8m4l,
                       label: GHC.IO.Exception.UndefinedElement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8m4p; else goto c8m4o;
       c8m4p: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.UndefinedElement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m4o: // global
           I64[Hp - 8] = GHC.IO.Exception.UndefinedElement_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.744520238 UTC

[section ""data" . GHC.IO.Exception.StackOverflow_closure" {
     GHC.IO.Exception.StackOverflow_closure:
         const GHC.IO.Exception.StackOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.74507499 UTC

[section ""data" . GHC.IO.Exception.HeapOverflow_closure" {
     GHC.IO.Exception.HeapOverflow_closure:
         const GHC.IO.Exception.HeapOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.74569895 UTC

[section ""data" . GHC.IO.Exception.ThreadKilled_closure" {
     GHC.IO.Exception.ThreadKilled_closure:
         const GHC.IO.Exception.ThreadKilled_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.746247433 UTC

[section ""data" . GHC.IO.Exception.UserInterrupt_closure" {
     GHC.IO.Exception.UserInterrupt_closure:
         const GHC.IO.Exception.UserInterrupt_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.747002106 UTC

[section ""data" . GHC.IO.Exception.SomeAsyncException_closure" {
     GHC.IO.Exception.SomeAsyncException_closure:
         const GHC.IO.Exception.SomeAsyncException_info;
 },
 GHC.IO.Exception.SomeAsyncException_entry() //  [R2, R3]
         { info_tbl: [(c8m4v,
                       label: GHC.IO.Exception.SomeAsyncException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8m4z; else goto c8m4y;
       c8m4z: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.SomeAsyncException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m4y: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.747846165 UTC

[section ""data" . GHC.IO.Exception.AllocationLimitExceeded_closure" {
     GHC.IO.Exception.AllocationLimitExceeded_closure:
         const GHC.IO.Exception.AllocationLimitExceeded_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.748387051 UTC

[section ""data" . GHC.IO.Exception.Deadlock_closure" {
     GHC.IO.Exception.Deadlock_closure:
         const GHC.IO.Exception.Deadlock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.748919135 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.749509246 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.750081841 UTC

[GHC.IO.Exception.IOError_con_entry() //  [R1]
         { info_tbl: [(c8m4A,
                       label: GHC.IO.Exception.IOError_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,79,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4A: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.7507597 UTC

[section ""relreadonly" . GHC.IO.Exception.IOErrorType_closure_tbl" {
     GHC.IO.Exception.IOErrorType_closure_tbl:
         const GHC.IO.Exception.AlreadyExists_closure+1;
         const GHC.IO.Exception.NoSuchThing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.IO.Exception.PermissionDenied_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.IO.Exception.UnsatisfiedConstraints_closure+1;
         const GHC.IO.Exception.SystemError_closure+1;
         const GHC.IO.Exception.ProtocolError_closure+1;
         const GHC.IO.Exception.OtherError_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Exception.HardwareFault_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.IO.Exception.TimeExpired_closure+1;
         const GHC.IO.Exception.ResourceVanished_closure+1;
         const GHC.IO.Exception.Interrupted_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.751439695 UTC

[GHC.IO.Exception.AlreadyExists_con_entry() //  [R1]
         { info_tbl: [(c8m4C,
                       label: GHC.IO.Exception.AlreadyExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,114,101,97,100,121,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4C: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.752143763 UTC

[GHC.IO.Exception.NoSuchThing_con_entry() //  [R1]
         { info_tbl: [(c8m4E,
                       label: GHC.IO.Exception.NoSuchThing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,78,111,83,117,99,104,84,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4E: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.752824796 UTC

[GHC.IO.Exception.ResourceBusy_con_entry() //  [R1]
         { info_tbl: [(c8m4G,
                       label: GHC.IO.Exception.ResourceBusy_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,66,117,115,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4G: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.754644403 UTC

[GHC.IO.Exception.ResourceExhausted_con_entry() //  [R1]
         { info_tbl: [(c8m4I,
                       label: GHC.IO.Exception.ResourceExhausted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4I: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.755446787 UTC

[GHC.IO.Exception.EOF_con_entry() //  [R1]
         { info_tbl: [(c8m4K,
                       label: GHC.IO.Exception.EOF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,79,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4K: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.75618542 UTC

[GHC.IO.Exception.IllegalOperation_con_entry() //  [R1]
         { info_tbl: [(c8m4M,
                       label: GHC.IO.Exception.IllegalOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4M: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.756901735 UTC

[GHC.IO.Exception.PermissionDenied_con_entry() //  [R1]
         { info_tbl: [(c8m4O,
                       label: GHC.IO.Exception.PermissionDenied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 6
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4O: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.757635394 UTC

[GHC.IO.Exception.UserError_con_entry() //  [R1]
         { info_tbl: [(c8m4Q,
                       label: GHC.IO.Exception.UserError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 7
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4Q: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.758343645 UTC

[GHC.IO.Exception.UnsatisfiedConstraints_con_entry() //  [R1]
         { info_tbl: [(c8m4S,
                       label: GHC.IO.Exception.UnsatisfiedConstraints_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 8
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4S: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.759034779 UTC

[GHC.IO.Exception.SystemError_con_entry() //  [R1]
         { info_tbl: [(c8m4U,
                       label: GHC.IO.Exception.SystemError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 9
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,121,115,116,101,109,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4U: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.759723904 UTC

[GHC.IO.Exception.ProtocolError_con_entry() //  [R1]
         { info_tbl: [(c8m4W,
                       label: GHC.IO.Exception.ProtocolError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 10
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,114,111,116,111,99,111,108,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4W: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.760411624 UTC

[GHC.IO.Exception.OtherError_con_entry() //  [R1]
         { info_tbl: [(c8m4Y,
                       label: GHC.IO.Exception.OtherError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 11
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,79,116,104,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m4Y: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.761104268 UTC

[GHC.IO.Exception.InvalidArgument_con_entry() //  [R1]
         { info_tbl: [(c8m50,
                       label: GHC.IO.Exception.InvalidArgument_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 12
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m50: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.761876687 UTC

[GHC.IO.Exception.InappropriateType_con_entry() //  [R1]
         { info_tbl: [(c8m52,
                       label: GHC.IO.Exception.InappropriateType_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 13
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m52: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.76259222 UTC

[GHC.IO.Exception.HardwareFault_con_entry() //  [R1]
         { info_tbl: [(c8m54,
                       label: GHC.IO.Exception.HardwareFault_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 14
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,97,114,100,119,97,114,101,70,97,117,108,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m54: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.763262301 UTC

[GHC.IO.Exception.UnsupportedOperation_con_entry() //  [R1]
         { info_tbl: [(c8m56,
                       label: GHC.IO.Exception.UnsupportedOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 15
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m56: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.763979638 UTC

[GHC.IO.Exception.TimeExpired_con_entry() //  [R1]
         { info_tbl: [(c8m58,
                       label: GHC.IO.Exception.TimeExpired_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 16
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,105,109,101,69,120,112,105,114,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m58: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.764651517 UTC

[GHC.IO.Exception.ResourceVanished_con_entry() //  [R1]
         { info_tbl: [(c8m5a,
                       label: GHC.IO.Exception.ResourceVanished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 17
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5a: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.765392906 UTC

[GHC.IO.Exception.Interrupted_con_entry() //  [R1]
         { info_tbl: [(c8m5c,
                       label: GHC.IO.Exception.Interrupted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 18
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,116,101,114,114,117,112,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5c: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.76611621 UTC

[GHC.IO.Exception.ExitSuccess_con_entry() //  [R1]
         { info_tbl: [(c8m5e,
                       label: GHC.IO.Exception.ExitSuccess_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,83,117,99,99,101,115,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5e: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.766844333 UTC

[GHC.IO.Exception.ExitFailure_con_entry() //  [R1]
         { info_tbl: [(c8m5g,
                       label: GHC.IO.Exception.ExitFailure_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5g: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.767514262 UTC

[section ""relreadonly" . GHC.IO.Exception.FixIOException_closure_tbl" {
     GHC.IO.Exception.FixIOException_closure_tbl:
         const GHC.IO.Exception.FixIOException_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.768093823 UTC

[GHC.IO.Exception.FixIOException_con_entry() //  [R1]
         { info_tbl: [(c8m5i,
                       label: GHC.IO.Exception.FixIOException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,70,105,120,73,79,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5i: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.768784906 UTC

[GHC.IO.Exception.IndexOutOfBounds_con_entry() //  [R1]
         { info_tbl: [(c8m5k,
                       label: GHC.IO.Exception.IndexOutOfBounds_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5k: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.770102454 UTC

[GHC.IO.Exception.UndefinedElement_con_entry() //  [R1]
         { info_tbl: [(c8m5m,
                       label: GHC.IO.Exception.UndefinedElement_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5m: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.770776006 UTC

[section ""relreadonly" . GHC.IO.Exception.AsyncException_closure_tbl" {
     GHC.IO.Exception.AsyncException_closure_tbl:
         const GHC.IO.Exception.StackOverflow_closure+1;
         const GHC.IO.Exception.HeapOverflow_closure+2;
         const GHC.IO.Exception.ThreadKilled_closure+3;
         const GHC.IO.Exception.UserInterrupt_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.771376287 UTC

[GHC.IO.Exception.StackOverflow_con_entry() //  [R1]
         { info_tbl: [(c8m5o,
                       label: GHC.IO.Exception.StackOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,116,97,99,107,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5o: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.772072188 UTC

[GHC.IO.Exception.HeapOverflow_con_entry() //  [R1]
         { info_tbl: [(c8m5q,
                       label: GHC.IO.Exception.HeapOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,101,97,112,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5q: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.772791535 UTC

[GHC.IO.Exception.ThreadKilled_con_entry() //  [R1]
         { info_tbl: [(c8m5s,
                       label: GHC.IO.Exception.ThreadKilled_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,104,114,101,97,100,75,105,108,108,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5s: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.773530093 UTC

[GHC.IO.Exception.UserInterrupt_con_entry() //  [R1]
         { info_tbl: [(c8m5u,
                       label: GHC.IO.Exception.UserInterrupt_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,73,110,116,101,114,114,117,112,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5u: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.774224373 UTC

[GHC.IO.Exception.SomeAsyncException_con_entry() //  [R1]
         { info_tbl: [(c8m5w,
                       label: GHC.IO.Exception.SomeAsyncException_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5w: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.774890609 UTC

[section ""relreadonly" . GHC.IO.Exception.AllocationLimitExceeded_closure_tbl" {
     GHC.IO.Exception.AllocationLimitExceeded_closure_tbl:
         const GHC.IO.Exception.AllocationLimitExceeded_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.775472735 UTC

[GHC.IO.Exception.AllocationLimitExceeded_con_entry() //  [R1]
         { info_tbl: [(c8m5y,
                       label: GHC.IO.Exception.AllocationLimitExceeded_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5y: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.776139021 UTC

[section ""relreadonly" . GHC.IO.Exception.Deadlock_closure_tbl" {
     GHC.IO.Exception.Deadlock_closure_tbl:
         const GHC.IO.Exception.Deadlock_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.77675748 UTC

[GHC.IO.Exception.Deadlock_con_entry() //  [R1]
         { info_tbl: [(c8m5A,
                       label: GHC.IO.Exception.Deadlock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,68,101,97,100,108,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5A: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.777438237 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.778010577 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_entry() //  [R1]
         { info_tbl: [(c8m5C,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5C: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.778663953 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.779288192 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_entry() //  [R1]
         { info_tbl: [(c8m5E,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5E: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.779947978 UTC

[section ""relreadonly" . S8ji8_srt" {
     S8ji8_srt:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fExceptionDeadlock1_closure;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
         const GHC.IO.Exception.$fShowDeadlock1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException3_closure;
         const GHC.IO.Exception.$fExceptionAsyncException5_closure;
         const GHC.IO.Exception.$fExceptionAsyncException7_closure;
         const GHC.IO.Exception.$w$cshowsPrec1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
         const GHC.IO.Exception.$fExceptionFixIOException1_closure;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowFixIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec4_closure;
         const lvl1_r8j2E_closure;
         const lvl3_r8j2G_closure;
         const lvl5_r8j2I_closure;
         const lvl7_r8j2K_closure;
         const lvl9_r8j2M_closure;
         const lvl11_r8j2O_closure;
         const lvl13_r8j2Q_closure;
         const lvl15_r8j2S_closure;
         const lvl17_r8j2U_closure;
         const lvl19_r8j2W_closure;
         const lvl21_r8j2Y_closure;
         const lvl23_r8j30_closure;
         const lvl25_r8j32_closure;
         const lvl27_r8j34_closure;
         const lvl29_r8j36_closure;
         const lvl31_r8j38_closure;
         const lvl33_r8j3a_closure;
         const lvl35_r8j3c_closure;
         const lvl37_r8j3e_closure;
         const GHC.IO.Exception.$fExceptionIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowIOException1_closure;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
         const GHC.IO.Exception.$fShowExitCode1_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Exception.$fReadExitCode2_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme1_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Exception.$fReadExitCode1_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const GHC.IO.Exception.$fReadExitCode6_closure;
         const GHC.IO.Exception.untangle2_closure;
         const GHC.IO.Exception.untangle_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
         const GHC.Exception.errorCallWithCallStackException9_closure;
         const GHC.Exception.errorCallWithCallStackException11_closure;
         const GHC.Exception.errorCallWithCallStackException6_closure;
         const GHC.IO.Exception.assertError1_closure;
         const GHC.IO.Exception.assertError_closure;
         const GHC.Stack.CCS.currentCallStack_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.asyncExceptionFromException_closure;
         const GHC.IO.Exception.asyncExceptionToException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fExceptionArrayException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fExceptionExitCode_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Exception.ioError1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
         const GHC.IO.Exception.cannotCompactMutable1_closure;
         const GHC.IO.Exception.cannotCompactPinned1_closure;
         const GHC.IO.Exception.cannotCompactFunction1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.781709821 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:25.78283802 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,77,86,97,114,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.786802247 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_entry() //  [R1]
         { info_tbl: [(c8m5N,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m5N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m5O; else goto c8m5P;
       c8m5O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m5P: // global
           (_c8m5K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m5K::I64 == 0) goto c8m5M; else goto c8m5L;
       c8m5M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m5L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m5K::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.79134403 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(c8m64,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m64: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m65; else goto c8m66;
       c8m65: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m66: // global
           I64[Sp - 16] = block_c8m61_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8m6a; else goto c8m62;
       u8m6a: // global
           call _c8m61() args: 0, res: 0, upd: 0;
       c8m62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m61() //  []
         { info_tbl: [(c8m61,
                       label: block_c8m61_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m61: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.797436145 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_entry() //  [R2]
         { info_tbl: [(c8m6r,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m6r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8m6s; else goto c8m6t;
       c8m6s: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m6t: // global
           I64[Sp - 8] = block_c8m6o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m6x; else goto c8m6p;
       u8m6x: // global
           call _c8m6o() args: 0, res: 0, upd: 0;
       c8m6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m6o() //  []
         { info_tbl: [(c8m6o,
                       label: block_c8m6o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m6o: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.802885768 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8m6P,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m6P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m6Q; else goto c8m6R;
       c8m6Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m6R: // global
           I64[Sp - 16] = block_c8m6M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8m6V; else goto c8m6N;
       u8m6V: // global
           call _c8m6M() args: 0, res: 0, upd: 0;
       c8m6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m6M() //  []
         { info_tbl: [(c8m6M,
                       label: block_c8m6M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m6M: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.808575103 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(c8m79,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m79: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.811893202 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.813645365 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,83,84,77,32,116,114,97,110,115,97,99,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.815598561 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_entry() //  [R1]
         { info_tbl: [(c8m7o,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m7o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m7p; else goto c8m7q;
       c8m7p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m7q: // global
           (_c8m7l::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m7l::I64 == 0) goto c8m7n; else goto c8m7m;
       c8m7n: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m7m: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m7l::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.820248057 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_entry() //  [R2,
                                                                          R3, R4]
         { info_tbl: [(c8m7F,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m7F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m7G; else goto c8m7H;
       c8m7G: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m7H: // global
           I64[Sp - 16] = block_c8m7C_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8m7L; else goto c8m7D;
       u8m7L: // global
           call _c8m7C() args: 0, res: 0, upd: 0;
       c8m7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m7C() //  []
         { info_tbl: [(c8m7C,
                       label: block_c8m7C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m7C: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.826636016 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_entry() //  [R2]
         { info_tbl: [(c8m82,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m82: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8m83; else goto c8m84;
       c8m83: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m84: // global
           I64[Sp - 8] = block_c8m7Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m88; else goto c8m80;
       u8m88: // global
           call _c8m7Z() args: 0, res: 0, upd: 0;
       c8m80: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m7Z() //  []
         { info_tbl: [(c8m7Z,
                       label: block_c8m7Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m7Z: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.832209438 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8m8q,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m8q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m8r; else goto c8m8s;
       c8m8r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m8s: // global
           I64[Sp - 16] = block_c8m8n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8m8w; else goto c8m8o;
       u8m8w: // global
           call _c8m8n() args: 0, res: 0, upd: 0;
       c8m8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m8n() //  []
         { info_tbl: [(c8m8n,
                       label: block_c8m8n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m8n: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.837445287 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8m8K,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m8K: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.840819175 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.84282975 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock2_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock2_bytes:
         I8[] [60,60,100,101,97,100,108,111,99,107,62,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.844734398 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock1_closure" {
     GHC.IO.Exception.$fExceptionDeadlock1_closure:
         const GHC.IO.Exception.$fExceptionDeadlock1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock1_entry() //  [R1]
         { info_tbl: [(c8m8Z,
                       label: GHC.IO.Exception.$fExceptionDeadlock1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m8Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m90; else goto c8m91;
       c8m90: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8m91: // global
           (_c8m8W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8m8W::I64 == 0) goto c8m8Y; else goto c8m8X;
       c8m8Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8m8X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8m8W::I64;
           R2 = GHC.IO.Exception.$fExceptionDeadlock2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.849064942 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8m9g,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8m9h; else goto c8m9i;
       c8m9h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8m9i: // global
           I64[Sp - 16] = block_c8m9d_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8m9m; else goto c8m9e;
       u8m9m: // global
           call _c8m9d() args: 0, res: 0, upd: 0;
       c8m9e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m9d() //  []
         { info_tbl: [(c8m9d,
                       label: block_c8m9d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m9d: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.855798135 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cshow_entry() //  [R2]
         { info_tbl: [(c8m9D,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m9D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8m9E; else goto c8m9F;
       c8m9E: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8m9F: // global
           I64[Sp - 8] = block_c8m9A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8m9J; else goto c8m9B;
       u8m9J: // global
           call _c8m9A() args: 0, res: 0, upd: 0;
       c8m9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m9A() //  []
         { info_tbl: [(c8m9A,
                       label: block_c8m9A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m9A: // global
           R1 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.861625339 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock1_closure" {
     GHC.IO.Exception.$fShowDeadlock1_closure:
         const GHC.IO.Exception.$fShowDeadlock1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock1_entry() //  [R2, R3]
         { info_tbl: [(c8ma1,
                       label: GHC.IO.Exception.$fShowDeadlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ma1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ma2; else goto c8ma3;
       c8ma2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ma3: // global
           I64[Sp - 16] = block_c8m9Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ma7; else goto c8m9Z;
       u8ma7: // global
           call _c8m9Y() args: 0, res: 0, upd: 0;
       c8m9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8m9Y() //  []
         { info_tbl: [(c8m9Y,
                       label: block_c8m9Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8m9Y: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.867010364 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowList_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowList_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8mal,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mal: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowDeadlock1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.870456948 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_closure" {
     GHC.IO.Exception.$fShowDeadlock_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.872223325 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes:
         I8[] [97,108,108,111,99,97,116,105,111,110,32,108,105,109,105,116,32,101,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.874399352 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_entry() //  [R1]
         { info_tbl: [(c8maA,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8maA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8maB; else goto c8maC;
       c8maB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8maC: // global
           (_c8max::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8max::I64 == 0) goto c8maz; else goto c8may;
       c8maz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8may: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8max::I64;
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.878655237 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_entry() //  [R2,
                                                                         R3, R4]
         { info_tbl: [(c8maR,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8maR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8maS; else goto c8maT;
       c8maS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8maT: // global
           I64[Sp - 16] = block_c8maO_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8maX; else goto c8maP;
       u8maX: // global
           call _c8maO() args: 0, res: 0, upd: 0;
       c8maP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8maO() //  []
         { info_tbl: [(c8maO,
                       label: block_c8maO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8maO: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.884514075 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_entry() //  [R2]
         { info_tbl: [(c8mbe,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mbe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mbf; else goto c8mbg;
       c8mbf: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mbg: // global
           I64[Sp - 8] = block_c8mbb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mbk; else goto c8mbc;
       u8mbk: // global
           call _c8mbb() args: 0, res: 0, upd: 0;
       c8mbc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mbb() //  []
         { info_tbl: [(c8mbb,
                       label: block_c8mbb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mbb: // global
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.890989515 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8mbC,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mbD; else goto c8mbE;
       c8mbD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mbE: // global
           I64[Sp - 16] = block_c8mbz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mbI; else goto c8mbA;
       u8mbI: // global
           call _c8mbz() args: 0, res: 0, upd: 0;
       c8mbA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mbz() //  []
         { info_tbl: [(c8mbz,
                       label: block_c8mbz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mbz: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.896540366 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c8mbW,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mbW: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.899799217 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.901771069 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed1_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed1_bytes:
         I8[] [99,111,109,112,97,99,116,105,111,110,32,102,97,105,108,101,100,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.903856831 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec2_closure" {
     GHC.IO.Exception.$w$cshowsPrec2_closure:
         const GHC.IO.Exception.$w$cshowsPrec2_info;
 },
 sat_s8j4q_entry() //  [R1]
         { info_tbl: [(c8mcd,
                       label: sat_s8j4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mcd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mce; else goto c8mcf;
       c8mce: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mcf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec2_entry() //  [R2]
         { info_tbl: [(c8mcg,
                       label: GHC.IO.Exception.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mcg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mck; else goto c8mcj;
       c8mck: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mcj: // global
           I64[Hp - 16] = sat_s8j4q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.909694466 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(c8mcx,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mcx: // global
           R2 = R3;
           call GHC.IO.Exception.$w$cshowsPrec2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.912922291 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_entry() //  [R2]
         { info_tbl: [(c8mcI,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mcI: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.916343385 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(c8mcT,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mcT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec2_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.919669546 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure+2;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.922581815 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_entry() //  [R3,
                                                                 R4]
         { info_tbl: [(c8md5,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8md5: // global
           _s8j4x::P64 = R3;
           R3 = R4;
           R2 = _s8j4x::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.926064938 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed1_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed1_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed1_info;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed1_entry() //  [R2]
         { info_tbl: [(c8mdg,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mdg: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.92947519 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8mdt,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mdt: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.++_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.932742551 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.935131115 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8mdI,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mdI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mdM; else goto c8mdN;
       c8mdM: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mdN: // global
           I64[Sp - 8] = block_c8mdF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mdT; else goto c8mdG;
       u8mdT: // global
           call _c8mdF(R1) args: 0, res: 0, upd: 0;
       c8mdG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mdF() //  [R1]
         { info_tbl: [(c8mdF,
                       label: block_c8mdF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mdF: // global
           I64[Sp - 8] = block_c8mdL_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8mdL() //  [R1]
         { info_tbl: [(c8mdL,
                       label: block_c8mdL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mdL: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.942284659 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_entry() //  [R2,
                                                                    R3, R4]
         { info_tbl: [(c8mee,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mee: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mem; else goto c8men;
       c8mem: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8men: // global
           I64[Sp - 16] = block_c8meb_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8meu; else goto c8mec;
       u8meu: // global
           call _c8meb(R1) args: 0, res: 0, upd: 0;
       c8mec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8meb() //  [R1]
         { info_tbl: [(c8meb,
                       label: block_c8meb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meb: // global
           I64[Sp - 8] = block_c8meh_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8meh() //  [R1]
         { info_tbl: [(c8meh,
                       label: block_c8meh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meh: // global
           _s8j4L::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8mel_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4L::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8mel() //  [R1]
         { info_tbl: [(c8mel,
                       label: block_c8mel_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mel: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.951437461 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException1_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException1_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException1_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException1_entry() //  [R2, R3]
         { info_tbl: [(c8meS,
                       label: GHC.IO.Exception.$fShowSomeAsyncException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mf0; else goto c8mf1;
       c8mf0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mf1: // global
           I64[Sp - 16] = block_c8meP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mf8; else goto c8meQ;
       u8mf8: // global
           call _c8meP(R1) args: 0, res: 0, upd: 0;
       c8meQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8meP() //  [R1]
         { info_tbl: [(c8meP,
                       label: block_c8meP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meP: // global
           I64[Sp - 8] = block_c8meV_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8meV() //  [R1]
         { info_tbl: [(c8meV,
                       label: block_c8meV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meV: // global
           _s8j4S::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8meZ_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8j4S::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8meZ() //  [R1]
         { info_tbl: [(c8meZ,
                       label: block_c8meZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8meZ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.960431115 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c8mft,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mft: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowSomeAsyncException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.964192854 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.965993518 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException8_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException8_bytes:
         I8[] [115,116,97,99,107,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.967884809 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException7_closure" {
     GHC.IO.Exception.$fExceptionAsyncException7_closure:
         const GHC.IO.Exception.$fExceptionAsyncException7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException7_entry() //  [R1]
         { info_tbl: [(c8mfI,
                       label: GHC.IO.Exception.$fExceptionAsyncException7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mfI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mfJ; else goto c8mfK;
       c8mfJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mfK: // global
           (_c8mfF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mfF::I64 == 0) goto c8mfH; else goto c8mfG;
       c8mfH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mfG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mfF::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.971823999 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException6_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException6_bytes:
         I8[] [104,101,97,112,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.973935471 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException5_closure" {
     GHC.IO.Exception.$fExceptionAsyncException5_closure:
         const GHC.IO.Exception.$fExceptionAsyncException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException5_entry() //  [R1]
         { info_tbl: [(c8mfZ,
                       label: GHC.IO.Exception.$fExceptionAsyncException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mfZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mg0; else goto c8mg1;
       c8mg0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mg1: // global
           (_c8mfW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mfW::I64 == 0) goto c8mfY; else goto c8mfX;
       c8mfY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mfX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mfW::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.977774779 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException4_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException4_bytes:
         I8[] [116,104,114,101,97,100,32,107,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.979627546 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException3_closure" {
     GHC.IO.Exception.$fExceptionAsyncException3_closure:
         const GHC.IO.Exception.$fExceptionAsyncException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException3_entry() //  [R1]
         { info_tbl: [(c8mgg,
                       label: GHC.IO.Exception.$fExceptionAsyncException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mgg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mgh; else goto c8mgi;
       c8mgh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mgi: // global
           (_c8mgd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mgd::I64 == 0) goto c8mgf; else goto c8mge;
       c8mgf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mge: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mgd::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.98369875 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException2_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException2_bytes:
         I8[] [117,115,101,114,32,105,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.986049644 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException1_closure" {
     GHC.IO.Exception.$fExceptionAsyncException1_closure:
         const GHC.IO.Exception.$fExceptionAsyncException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException1_entry() //  [R1]
         { info_tbl: [(c8mgx,
                       label: GHC.IO.Exception.$fExceptionAsyncException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mgx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mgy; else goto c8mgz;
       c8mgy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mgz: // global
           (_c8mgu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mgu::I64 == 0) goto c8mgw; else goto c8mgv;
       c8mgw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mgv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mgu::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.990257575 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec1_closure" {
     GHC.IO.Exception.$w$cshowsPrec1_closure:
         const GHC.IO.Exception.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(c8mgU,
                       label: GHC.IO.Exception.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mgU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mgV; else goto c8mgW;
       c8mgV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mgW: // global
           I64[Sp - 16] = block_c8mgL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mhb; else goto c8mgM;
       u8mhb: // global
           call _c8mgL(R1) args: 0, res: 0, upd: 0;
       c8mgM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mgL() //  [R1]
         { info_tbl: [(c8mgL,
                       label: block_c8mgL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mgL: // global
           _s8j4Y::P64 = P64[Sp + 8];
           _c8mgT::P64 = R1 & 7;
           if (_c8mgT::P64 < 3) goto u8mh9; else goto u8mha;
       u8mh9: // global
           if (_c8mgT::P64 < 2) goto c8mgP; else goto c8mgQ;
       c8mgP: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mgQ: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8mha: // global
           if (_c8mgT::P64 < 4) goto c8mgR; else goto c8mgS;
       c8mgR: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mgS: // global
           R3 = _s8j4Y::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:25.996549579 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_entry() //  [R3,
                                                                R4]
         { info_tbl: [(c8mhq,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mhq: // global
           _s8j51::P64 = R3;
           R3 = R4;
           R2 = _s8j51::P64;
           call GHC.IO.Exception.$w$cshowsPrec1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.000075307 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8mhK,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mhK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mhL; else goto c8mhM;
       c8mhL: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mhM: // global
           I64[Sp - 8] = block_c8mhB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mi1; else goto c8mhC;
       u8mi1: // global
           call _c8mhB(R1) args: 0, res: 0, upd: 0;
       c8mhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mhB() //  [R1]
         { info_tbl: [(c8mhB,
                       label: block_c8mhB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mhB: // global
           _c8mhJ::P64 = R1 & 7;
           if (_c8mhJ::P64 < 3) goto u8mhZ; else goto u8mi0;
       u8mhZ: // global
           if (_c8mhJ::P64 < 2) goto c8mhF; else goto c8mhG;
       c8mhF: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8mhG: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8mi0: // global
           if (_c8mhJ::P64 < 4) goto c8mhH; else goto c8mhI;
       c8mhH: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8mhI: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.006105647 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8mik,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mik: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.009727207 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_closure" {
     GHC.IO.Exception.$fShowAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.011513403 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException4_bytes" {
     GHC.IO.Exception.$fExceptionArrayException4_bytes:
         I8[] [97,114,114,97,121,32,105,110,100,101,120,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.013181055 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException3_bytes" {
     GHC.IO.Exception.$fExceptionArrayException3_bytes:
         I8[] [58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.014908891 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException2_bytes" {
     GHC.IO.Exception.$fExceptionArrayException2_bytes:
         I8[] [117,110,100,101,102,105,110,101,100,32,97,114,114,97,121,32,101,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.018220785 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec_closure" {
     GHC.IO.Exception.$w$cshowsPrec_closure:
         const GHC.IO.Exception.$w$cshowsPrec_info;
 },
 sat_s8j5e_entry() //  [R1]
         { info_tbl: [(c8miS,
                       label: sat_s8j5e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8miS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8miT; else goto c8miU;
       c8miT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8miU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5f_entry() //  [R1]
         { info_tbl: [(c8miZ,
                       label: sat_s8j5f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8miZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mj0; else goto c8mj1;
       c8mj0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mj1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8miI_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mj7; else goto c8miJ;
       u8mj7: // global
           call _c8miI(R1) args: 0, res: 0, upd: 0;
       c8miJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8miI() //  [R1]
         { info_tbl: [(c8miI,
                       label: block_c8miI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8miI: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8miW; else goto c8miX;
       c8miW: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8miX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8mj6; else goto c8mj5;
       c8mj6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mj5: // global
           I64[Hp - 24] = sat_s8j5e_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5k_entry() //  [R1]
         { info_tbl: [(c8mjo,
                       label: sat_s8j5k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mjo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mjp; else goto c8mjq;
       c8mjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j5l_entry() //  [R1]
         { info_tbl: [(c8mjv,
                       label: sat_s8j5l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mjv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mjw; else goto c8mjx;
       c8mjw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mjx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8mje_info;
           _s8j58::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j58::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mjD; else goto c8mjf;
       u8mjD: // global
           call _c8mje(R1) args: 0, res: 0, upd: 0;
       c8mjf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mje() //  [R1]
         { info_tbl: [(c8mje,
                       label: block_c8mje_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mje: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mjs; else goto c8mjt;
       c8mjs: // global
           R1 = _s8j58::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8mjt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8mjC; else goto c8mjB;
       c8mjC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mjB: // global
           I64[Hp - 24] = sat_s8j5k_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8mjI,
                       label: GHC.IO.Exception.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mjI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mjJ; else goto c8mjK;
       c8mjJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mjK: // global
           I64[Sp - 16] = block_c8miz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mjR; else goto c8miA;
       u8mjR: // global
           call _c8miz(R1) args: 0, res: 0, upd: 0;
       c8miA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8miz() //  [R1]
         { info_tbl: [(c8miz,
                       label: block_c8miz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8miz: // global
           _s8j58::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mjF; else goto c8mjG;
       c8mjF: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8mjQ; else goto c8mjM;
       c8mjM: // global
           _s8j5a::P64 = P64[_s8j59::P64 + 7];
           I64[Hp - 24] = sat_s8j5f_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5a::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8mjG: // global
           Hp = Hp + 32;
           _s8j59::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8mjQ; else goto c8mjP;
       c8mjQ: // global
           HpAlloc = 32;
           R1 = _s8j59::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mjP: // global
           _s8j5g::P64 = P64[_s8j59::P64 + 6];
           I64[Hp - 24] = sat_s8j5l_info;
           P64[Hp - 8] = _s8j58::P64;
           P64[Hp] = _s8j5g::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException2_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.037313651 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_entry() //  [R3,
                                                                     R4]
         { info_tbl: [(c8mkD,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mkD: // global
           _s8j5n::P64 = R3;
           R3 = R4;
           R2 = _s8j5n::P64;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.040539015 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException1_closure" {
     GHC.IO.Exception.$fExceptionArrayException1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.042936552 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshow_entry() //  [R2]
         { info_tbl: [(c8mkP,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mkP: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.046379324 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_$cshowList_closure" {
     GHC.IO.Exception.$fShowArrayException_$cshowList_closure:
         const GHC.IO.Exception.$fShowArrayException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowArrayException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8ml0,
                       label: GHC.IO.Exception.$fShowArrayException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ml0: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.049988143 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_closure" {
     GHC.IO.Exception.$fShowArrayException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowArrayException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.051802248 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException2_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException2_bytes:
         I8[] [99,121,99,108,105,99,32,101,118,97,108,117,97,116,105,111,110,32,105,110,32,102,105,120,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.053680058 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException1_closure" {
     GHC.IO.Exception.$fExceptionFixIOException1_closure:
         const GHC.IO.Exception.$fExceptionFixIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException1_entry() //  [R1]
         { info_tbl: [(c8mlf,
                       label: GHC.IO.Exception.$fExceptionFixIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mlf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mlg; else goto c8mlh;
       c8mlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mlh: // global
           (_c8mlc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mlc::I64 == 0) goto c8mle; else goto c8mld;
       c8mle: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mld: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mlc::I64;
           R2 = GHC.IO.Exception.$fExceptionFixIOException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.05843562 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8mlw,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mlw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mlx; else goto c8mly;
       c8mlx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mly: // global
           I64[Sp - 16] = block_c8mlt_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mlC; else goto c8mlu;
       u8mlC: // global
           call _c8mlt() args: 0, res: 0, upd: 0;
       c8mlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mlt() //  []
         { info_tbl: [(c8mlt,
                       label: block_c8mlt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mlt: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.064205137 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8mlT,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mlT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mlU; else goto c8mlV;
       c8mlU: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mlV: // global
           I64[Sp - 8] = block_c8mlQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mlZ; else goto c8mlR;
       u8mlZ: // global
           call _c8mlQ() args: 0, res: 0, upd: 0;
       c8mlR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mlQ() //  []
         { info_tbl: [(c8mlQ,
                       label: block_c8mlQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mlQ: // global
           R1 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.069613574 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException1_closure" {
     GHC.IO.Exception.$fShowFixIOException1_closure:
         const GHC.IO.Exception.$fShowFixIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8mmh,
                       label: GHC.IO.Exception.$fShowFixIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mmh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mmi; else goto c8mmj;
       c8mmi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mmj: // global
           I64[Sp - 16] = block_c8mme_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mmn; else goto c8mmf;
       u8mmn: // global
           call _c8mme() args: 0, res: 0, upd: 0;
       c8mmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mme() //  []
         { info_tbl: [(c8mme,
                       label: block_c8mme_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mme: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.075166296 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8mmB,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mmB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowFixIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.078421583 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_closure" {
     GHC.IO.Exception.$fShowFixIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.080552162 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c==_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c==_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c==_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8mmR,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mmR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mmX; else goto c8mmY;
       c8mmX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mmY: // global
           I64[Sp - 16] = block_c8mmN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mni; else goto c8mmO;
       u8mni: // global
           call _c8mmN(R1) args: 0, res: 0, upd: 0;
       c8mmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mmN() //  [R1]
         { info_tbl: [(c8mmN,
                       label: block_c8mmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mmN: // global
           _s8j5G::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8mmW_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5G::I64;
           if (R1 & 7 != 0) goto u8mnh; else goto c8mn3;
       u8mnh: // global
           call _c8mmW(R1) args: 0, res: 0, upd: 0;
       c8mn3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mmW() //  [R1]
         { info_tbl: [(c8mmW,
                       label: block_c8mmW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mmW: // global
           R1 = I64[((%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.088770988 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c/=_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c/=_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8mnO,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mnO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mnU; else goto c8mnV;
       c8mnU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mnV: // global
           I64[Sp - 16] = block_c8mnK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8moj; else goto c8mnL;
       u8moj: // global
           call _c8mnK(R1) args: 0, res: 0, upd: 0;
       c8mnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mnK() //  [R1]
         { info_tbl: [(c8mnK,
                       label: block_c8mnK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mnK: // global
           _s8j5N::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8mnT_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j5N::I64;
           if (R1 & 7 != 0) goto u8moi; else goto c8mo0;
       u8moi: // global
           call _c8mnT(R1) args: 0, res: 0, upd: 0;
       c8mo0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mnT() //  [R1]
         { info_tbl: [(c8mnT,
                       label: block_c8mnT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mnT: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) goto c8mof; else goto c8moe;
       c8mof: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8moe: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.096014912 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_closure" {
     GHC.IO.Exception.$fEqIOErrorType_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOErrorType_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.098036023 UTC

[section ""cstring" . lvl_r8j2D_bytes" {
     lvl_r8j2D_bytes:
         I8[] [97,108,114,101,97,100,121,32,101,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.099891476 UTC

[section ""data" . lvl1_r8j2E_closure" {
     lvl1_r8j2E_closure:
         const lvl1_r8j2E_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8j2E_entry() //  [R1]
         { info_tbl: [(c8moO,
                       label: lvl1_r8j2E_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8moO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8moP; else goto c8moQ;
       c8moP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8moQ: // global
           (_c8moL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8moL::I64 == 0) goto c8moN; else goto c8moM;
       c8moN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8moM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8moL::I64;
           R2 = lvl_r8j2D_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.103716378 UTC

[section ""cstring" . lvl2_r8j2F_bytes" {
     lvl2_r8j2F_bytes:
         I8[] [100,111,101,115,32,110,111,116,32,101,120,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.105495618 UTC

[section ""data" . lvl3_r8j2G_closure" {
     lvl3_r8j2G_closure:
         const lvl3_r8j2G_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8j2G_entry() //  [R1]
         { info_tbl: [(c8mp5,
                       label: lvl3_r8j2G_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mp5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mp6; else goto c8mp7;
       c8mp6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mp7: // global
           (_c8mp2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mp2::I64 == 0) goto c8mp4; else goto c8mp3;
       c8mp4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mp3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mp2::I64;
           R2 = lvl2_r8j2F_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.109167884 UTC

[section ""cstring" . lvl4_r8j2H_bytes" {
     lvl4_r8j2H_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,98,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.111205578 UTC

[section ""data" . lvl5_r8j2I_closure" {
     lvl5_r8j2I_closure:
         const lvl5_r8j2I_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8j2I_entry() //  [R1]
         { info_tbl: [(c8mpm,
                       label: lvl5_r8j2I_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mpm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mpn; else goto c8mpo;
       c8mpn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mpo: // global
           (_c8mpj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mpj::I64 == 0) goto c8mpl; else goto c8mpk;
       c8mpl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mpk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mpj::I64;
           R2 = lvl4_r8j2H_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.114914777 UTC

[section ""cstring" . lvl6_r8j2J_bytes" {
     lvl6_r8j2J_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,101,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.116742317 UTC

[section ""data" . lvl7_r8j2K_closure" {
     lvl7_r8j2K_closure:
         const lvl7_r8j2K_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r8j2K_entry() //  [R1]
         { info_tbl: [(c8mpD,
                       label: lvl7_r8j2K_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mpD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mpE; else goto c8mpF;
       c8mpE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mpF: // global
           (_c8mpA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mpA::I64 == 0) goto c8mpC; else goto c8mpB;
       c8mpC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mpB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mpA::I64;
           R2 = lvl6_r8j2J_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.121110703 UTC

[section ""cstring" . lvl8_r8j2L_bytes" {
     lvl8_r8j2L_bytes:
         I8[] [101,110,100,32,111,102,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.123575552 UTC

[section ""data" . lvl9_r8j2M_closure" {
     lvl9_r8j2M_closure:
         const lvl9_r8j2M_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r8j2M_entry() //  [R1]
         { info_tbl: [(c8mpU,
                       label: lvl9_r8j2M_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mpU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mpV; else goto c8mpW;
       c8mpV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mpW: // global
           (_c8mpR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mpR::I64 == 0) goto c8mpT; else goto c8mpS;
       c8mpT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mpS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mpR::I64;
           R2 = lvl8_r8j2L_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.127293108 UTC

[section ""cstring" . lvl10_r8j2N_bytes" {
     lvl10_r8j2N_bytes:
         I8[] [105,108,108,101,103,97,108,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.129220667 UTC

[section ""data" . lvl11_r8j2O_closure" {
     lvl11_r8j2O_closure:
         const lvl11_r8j2O_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8j2O_entry() //  [R1]
         { info_tbl: [(c8mqb,
                       label: lvl11_r8j2O_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mqc; else goto c8mqd;
       c8mqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mqd: // global
           (_c8mq8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mq8::I64 == 0) goto c8mqa; else goto c8mq9;
       c8mqa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mq9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mq8::I64;
           R2 = lvl10_r8j2N_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.133144562 UTC

[section ""cstring" . lvl12_r8j2P_bytes" {
     lvl12_r8j2P_bytes:
         I8[] [112,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.135036523 UTC

[section ""data" . lvl13_r8j2Q_closure" {
     lvl13_r8j2Q_closure:
         const lvl13_r8j2Q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r8j2Q_entry() //  [R1]
         { info_tbl: [(c8mqs,
                       label: lvl13_r8j2Q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mqs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mqt; else goto c8mqu;
       c8mqt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mqu: // global
           (_c8mqp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mqp::I64 == 0) goto c8mqr; else goto c8mqq;
       c8mqr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mqq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mqp::I64;
           R2 = lvl12_r8j2P_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.139071511 UTC

[section ""cstring" . lvl14_r8j2R_bytes" {
     lvl14_r8j2R_bytes:
         I8[] [117,115,101,114,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.140942589 UTC

[section ""data" . lvl15_r8j2S_closure" {
     lvl15_r8j2S_closure:
         const lvl15_r8j2S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_r8j2S_entry() //  [R1]
         { info_tbl: [(c8mqJ,
                       label: lvl15_r8j2S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mqJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mqK; else goto c8mqL;
       c8mqK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mqL: // global
           (_c8mqG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mqG::I64 == 0) goto c8mqI; else goto c8mqH;
       c8mqI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mqH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mqG::I64;
           R2 = lvl14_r8j2R_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.144857706 UTC

[section ""cstring" . lvl16_r8j2T_bytes" {
     lvl16_r8j2T_bytes:
         I8[] [117,110,115,97,116,105,115,102,105,101,100,32,99,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.146849234 UTC

[section ""data" . lvl17_r8j2U_closure" {
     lvl17_r8j2U_closure:
         const lvl17_r8j2U_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_r8j2U_entry() //  [R1]
         { info_tbl: [(c8mr0,
                       label: lvl17_r8j2U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mr0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mr1; else goto c8mr2;
       c8mr1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mr2: // global
           (_c8mqX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mqX::I64 == 0) goto c8mqZ; else goto c8mqY;
       c8mqZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mqY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mqX::I64;
           R2 = lvl16_r8j2T_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.150889263 UTC

[section ""cstring" . lvl18_r8j2V_bytes" {
     lvl18_r8j2V_bytes:
         I8[] [115,121,115,116,101,109,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.15337568 UTC

[section ""data" . lvl19_r8j2W_closure" {
     lvl19_r8j2W_closure:
         const lvl19_r8j2W_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r8j2W_entry() //  [R1]
         { info_tbl: [(c8mrh,
                       label: lvl19_r8j2W_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mrh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mri; else goto c8mrj;
       c8mri: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mrj: // global
           (_c8mre::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mre::I64 == 0) goto c8mrg; else goto c8mrf;
       c8mrg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mrf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mre::I64;
           R2 = lvl18_r8j2V_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.157011617 UTC

[section ""cstring" . lvl20_r8j2X_bytes" {
     lvl20_r8j2X_bytes:
         I8[] [112,114,111,116,111,99,111,108,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.158839243 UTC

[section ""data" . lvl21_r8j2Y_closure" {
     lvl21_r8j2Y_closure:
         const lvl21_r8j2Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_r8j2Y_entry() //  [R1]
         { info_tbl: [(c8mry,
                       label: lvl21_r8j2Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mry: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mrz; else goto c8mrA;
       c8mrz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mrA: // global
           (_c8mrv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mrv::I64 == 0) goto c8mrx; else goto c8mrw;
       c8mrx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mrw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mrv::I64;
           R2 = lvl20_r8j2X_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.162527972 UTC

[section ""cstring" . lvl22_r8j2Z_bytes" {
     lvl22_r8j2Z_bytes:
         I8[] [102,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.16430909 UTC

[section ""data" . lvl23_r8j30_closure" {
     lvl23_r8j30_closure:
         const lvl23_r8j30_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_r8j30_entry() //  [R1]
         { info_tbl: [(c8mrP,
                       label: lvl23_r8j30_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mrP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mrQ; else goto c8mrR;
       c8mrQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mrR: // global
           (_c8mrM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mrM::I64 == 0) goto c8mrO; else goto c8mrN;
       c8mrO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mrN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mrM::I64;
           R2 = lvl22_r8j2Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.168174297 UTC

[section ""cstring" . lvl24_r8j31_bytes" {
     lvl24_r8j31_bytes:
         I8[] [105,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.170075036 UTC

[section ""data" . lvl25_r8j32_closure" {
     lvl25_r8j32_closure:
         const lvl25_r8j32_info;
         const 0;
         const 0;
         const 0;
 },
 lvl25_r8j32_entry() //  [R1]
         { info_tbl: [(c8ms6,
                       label: lvl25_r8j32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ms6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ms7; else goto c8ms8;
       c8ms7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ms8: // global
           (_c8ms3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ms3::I64 == 0) goto c8ms5; else goto c8ms4;
       c8ms5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ms4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ms3::I64;
           R2 = lvl24_r8j31_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.174397421 UTC

[section ""cstring" . lvl26_r8j33_bytes" {
     lvl26_r8j33_bytes:
         I8[] [105,110,97,112,112,114,111,112,114,105,97,116,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.176236547 UTC

[section ""data" . lvl27_r8j34_closure" {
     lvl27_r8j34_closure:
         const lvl27_r8j34_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_r8j34_entry() //  [R1]
         { info_tbl: [(c8msn,
                       label: lvl27_r8j34_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8msn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mso; else goto c8msp;
       c8mso: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8msp: // global
           (_c8msk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8msk::I64 == 0) goto c8msm; else goto c8msl;
       c8msm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8msl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8msk::I64;
           R2 = lvl26_r8j33_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.180163457 UTC

[section ""cstring" . lvl28_r8j35_bytes" {
     lvl28_r8j35_bytes:
         I8[] [104,97,114,100,119,97,114,101,32,102,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.182045774 UTC

[section ""data" . lvl29_r8j36_closure" {
     lvl29_r8j36_closure:
         const lvl29_r8j36_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_r8j36_entry() //  [R1]
         { info_tbl: [(c8msE,
                       label: lvl29_r8j36_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8msE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8msF; else goto c8msG;
       c8msF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8msG: // global
           (_c8msB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8msB::I64 == 0) goto c8msD; else goto c8msC;
       c8msD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8msC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8msB::I64;
           R2 = lvl28_r8j35_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.186800057 UTC

[section ""cstring" . lvl30_r8j37_bytes" {
     lvl30_r8j37_bytes:
         I8[] [117,110,115,117,112,112,111,114,116,101,100,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.188606925 UTC

[section ""data" . lvl31_r8j38_closure" {
     lvl31_r8j38_closure:
         const lvl31_r8j38_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_r8j38_entry() //  [R1]
         { info_tbl: [(c8msV,
                       label: lvl31_r8j38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8msV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8msW; else goto c8msX;
       c8msW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8msX: // global
           (_c8msS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8msS::I64 == 0) goto c8msU; else goto c8msT;
       c8msU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8msT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8msS::I64;
           R2 = lvl30_r8j37_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.192438349 UTC

[section ""cstring" . lvl32_r8j39_bytes" {
     lvl32_r8j39_bytes:
         I8[] [116,105,109,101,111,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.194830129 UTC

[section ""data" . lvl33_r8j3a_closure" {
     lvl33_r8j3a_closure:
         const lvl33_r8j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_r8j3a_entry() //  [R1]
         { info_tbl: [(c8mtc,
                       label: lvl33_r8j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mtc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mtd; else goto c8mte;
       c8mtd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mte: // global
           (_c8mt9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mt9::I64 == 0) goto c8mtb; else goto c8mta;
       c8mtb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mta: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mt9::I64;
           R2 = lvl32_r8j39_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.198593592 UTC

[section ""cstring" . lvl34_r8j3b_bytes" {
     lvl34_r8j3b_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,118,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.20030286 UTC

[section ""data" . lvl35_r8j3c_closure" {
     lvl35_r8j3c_closure:
         const lvl35_r8j3c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_r8j3c_entry() //  [R1]
         { info_tbl: [(c8mtt,
                       label: lvl35_r8j3c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mtt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mtu; else goto c8mtv;
       c8mtu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mtv: // global
           (_c8mtq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mtq::I64 == 0) goto c8mts; else goto c8mtr;
       c8mts: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mtr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mtq::I64;
           R2 = lvl34_r8j3b_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.204064637 UTC

[section ""cstring" . lvl36_r8j3d_bytes" {
     lvl36_r8j3d_bytes:
         I8[] [105,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.206208436 UTC

[section ""data" . lvl37_r8j3e_closure" {
     lvl37_r8j3e_closure:
         const lvl37_r8j3e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_r8j3e_entry() //  [R1]
         { info_tbl: [(c8mtK,
                       label: lvl37_r8j3e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mtK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mtL; else goto c8mtM;
       c8mtL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mtM: // global
           (_c8mtH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mtH::I64 == 0) goto c8mtJ; else goto c8mtI;
       c8mtJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mtI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mtH::I64;
           R2 = lvl36_r8j3d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.211924087 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec4_closure" {
     GHC.IO.Exception.$w$cshowsPrec4_closure:
         const GHC.IO.Exception.$w$cshowsPrec4_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec4_entry() //  [R2, R3]
         { info_tbl: [(c8mum,
                       label: GHC.IO.Exception.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mum: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mun; else goto c8muo;
       c8mun: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8muo: // global
           I64[Sp - 16] = block_c8mtY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mvk; else goto c8mtZ;
       u8mvk: // global
           call _c8mtY(R1) args: 0, res: 0, upd: 0;
       c8mtZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mtY() //  [R1]
         { info_tbl: [(c8mtY,
                       label: block_c8mtY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mtY: // global
           _s8j5S::P64 = P64[Sp + 8];
           switch [0 .. 18] (%MO_UU_Conv_W32_W64(I32[I64[R1 - 1] + 20])) {
               case 0 : goto c8mu2;
               case 1 : goto c8mu3;
               case 2 : goto c8mu4;
               case 3 : goto c8mu5;
               case 4 : goto c8mu6;
               case 5 : goto c8mu7;
               case 6 : goto c8mu8;
               case 7 : goto c8mu9;
               case 8 : goto c8mua;
               case 9 : goto c8mub;
               case 10 : goto c8muc;
               case 11 : goto c8mud;
               case 12 : goto c8mue;
               case 13 : goto c8muf;
               case 14 : goto c8mug;
               case 15 : goto c8muh;
               case 16 : goto c8mui;
               case 17 : goto c8muj;
               case 18 : goto c8muk;
           }
       c8muk: // global
           R3 = _s8j5S::P64;
           R2 = lvl37_r8j3e_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8muj: // global
           R3 = _s8j5S::P64;
           R2 = lvl35_r8j3c_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mui: // global
           R3 = _s8j5S::P64;
           R2 = lvl33_r8j3a_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8muh: // global
           R3 = _s8j5S::P64;
           R2 = lvl31_r8j38_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mug: // global
           R3 = _s8j5S::P64;
           R2 = lvl29_r8j36_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8muf: // global
           R3 = _s8j5S::P64;
           R2 = lvl27_r8j34_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mue: // global
           R3 = _s8j5S::P64;
           R2 = lvl25_r8j32_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mud: // global
           R3 = _s8j5S::P64;
           R2 = lvl23_r8j30_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8muc: // global
           R3 = _s8j5S::P64;
           R2 = lvl21_r8j2Y_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mub: // global
           R3 = _s8j5S::P64;
           R2 = lvl19_r8j2W_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mua: // global
           R3 = _s8j5S::P64;
           R2 = lvl17_r8j2U_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu9: // global
           R3 = _s8j5S::P64;
           R2 = lvl15_r8j2S_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu8: // global
           R3 = _s8j5S::P64;
           R2 = lvl13_r8j2Q_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu7: // global
           R3 = _s8j5S::P64;
           R2 = lvl11_r8j2O_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu6: // global
           R3 = _s8j5S::P64;
           R2 = lvl9_r8j2M_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu5: // global
           R3 = _s8j5S::P64;
           R2 = lvl7_r8j2K_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu4: // global
           R3 = _s8j5S::P64;
           R2 = lvl5_r8j2I_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu3: // global
           R3 = _s8j5S::P64;
           R2 = lvl3_r8j2G_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mu2: // global
           R3 = _s8j5S::P64;
           R2 = lvl1_r8j2E_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.222847359 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c8mvB,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mvB: // global
           _s8j5V::P64 = R3;
           R3 = R4;
           R2 = _s8j5V::P64;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.226634708 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshow_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshow_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshow_entry() //  [R2]
         { info_tbl: [(c8mvM,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mvM: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.230483823 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8mvX,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mvX: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.234149073 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_closure" {
     GHC.IO.Exception.$fShowIOErrorType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.239972828 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c==_closure" {
     GHC.IO.Exception.$fEqIOException_$c==_closure:
         const GHC.IO.Exception.$fEqIOException_$c==_info;
 },
 GHC.IO.Exception.$fEqIOException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8mwc,
                       label: GHC.IO.Exception.$fEqIOException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mwc: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c8mwt; else goto c8mwu;
       c8mwt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mwu: // global
           I64[Sp - 16] = block_c8mw9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mB6; else goto c8mwa;
       u8mB6: // global
           call _c8mw9(R1) args: 0, res: 0, upd: 0;
       c8mwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mw9() //  [R1]
         { info_tbl: [(c8mw9,
                       label: block_c8mw9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mw9: // global
           I64[Sp - 40] = block_c8mwf_info;
           _s8j63::P64 = P64[R1 + 7];
           _s8j64::P64 = P64[R1 + 15];
           _s8j65::P64 = P64[R1 + 23];
           _s8j66::P64 = P64[R1 + 31];
           _s8j67::P64 = P64[R1 + 39];
           _s8j68::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8j65::P64;
           P64[Sp - 24] = _s8j66::P64;
           P64[Sp - 16] = _s8j67::P64;
           P64[Sp - 8] = _s8j68::P64;
           P64[Sp] = _s8j64::P64;
           P64[Sp + 8] = _s8j63::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8mB5; else goto c8mwg;
       u8mB5: // global
           call _c8mwf(R1) args: 0, res: 0, upd: 0;
       c8mwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mwf() //  [R1]
         { info_tbl: [(c8mwf,
                       label: block_c8mwf_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mwf: // global
           I64[Sp - 40] = block_c8mwk_info;
           _s8j6a::P64 = P64[R1 + 7];
           _s8j6c::P64 = P64[R1 + 23];
           _s8j6d::P64 = P64[R1 + 31];
           _s8j6e::P64 = P64[R1 + 39];
           _s8j6f::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _s8j6c::P64;
           P64[Sp - 24] = _s8j6d::P64;
           P64[Sp - 16] = _s8j6e::P64;
           P64[Sp - 8] = _s8j6f::P64;
           P64[Sp] = _s8j6a::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8mB7; else goto c8mwl;
       u8mB7: // global
           call _c8mwk(R1) args: 0, res: 0, upd: 0;
       c8mwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mwk() //  [R1]
         { info_tbl: [(c8mwk,
                       label: block_c8mwk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mwk: // global
           _s8j6h::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8mws_info;
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _s8j6h::I64;
           if (R1 & 7 != 0) goto u8mB8; else goto c8mwB;
       u8mB8: // global
           call _c8mws(R1) args: 0, res: 0, upd: 0;
       c8mwB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mws() //  [R1]
         { info_tbl: [(c8mws,
                       label: block_c8mws_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mws: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 80]) goto c8mwT; else goto u8mAM;
       c8mwT: // global
           I64[Sp] = block_c8mwS_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8mAM: // global
           Sp = Sp + 96;
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _c8mwS() //  [R1]
         { info_tbl: [(c8mwS,
                       label: block_c8mwS_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mwS: // global
           if (R1 & 7 == 1) goto u8mAN; else goto c8myS;
       u8mAN: // global
           Sp = Sp + 96;
           call _c8mAl() args: 0, res: 0, upd: 0;
       c8myS: // global
           I64[Sp] = block_c8mx4_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto u8mBa; else goto c8myT;
       u8mBa: // global
           call _c8mx4(R1) args: 0, res: 0, upd: 0;
       c8myT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mx4() //  [R1]
         { info_tbl: [(c8mx4,
                       label: block_c8mx4_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mx4: // global
           _s8j6a::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8mz0; else goto c8mzg;
       c8mz0: // global
           I64[Sp] = block_c8myX_info;
           R1 = _s8j6a::P64;
           if (R1 & 7 != 0) goto u8mBc; else goto c8mz1;
       u8mBc: // global
           call _c8myX(R1) args: 0, res: 0, upd: 0;
       c8mz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mzg: // global
           I64[Sp] = block_c8mze_info;
           _s8j6J::P64 = P64[R1 + 6];
           R1 = _s8j6a::P64;
           P64[Sp + 88] = _s8j6J::P64;
           if (R1 & 7 != 0) goto u8mBd; else goto c8mzh;
       u8mBd: // global
           call _c8mze(R1) args: 0, res: 0, upd: 0;
       c8mzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8myX() //  [R1]
         { info_tbl: [(c8myX,
                       label: block_c8myX_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8myX: // global
           if (R1 & 7 == 1) goto u8mAV; else goto u8mAW;
       u8mAV: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8mAW: // global
           Sp = Sp + 96;
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _c8mze() //  [R1]
         { info_tbl: [(c8mze,
                       label: block_c8mze_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mze: // global
           if (R1 & 7 == 1) goto u8mAO; else goto c8mzs;
       u8mAO: // global
           Sp = Sp + 96;
           call _c8mAl() args: 0, res: 0, upd: 0;
       c8mzs: // global
           I64[Sp] = block_c8mzq_info;
           _s8j6L::P64 = P64[R1 + 6];
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _s8j6L::P64;
           if (R1 & 7 != 0) goto u8mBv; else goto c8mzt;
       u8mBv: // global
           call _c8mzq(R1) args: 0, res: 0, upd: 0;
       c8mzt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mzq() //  [R1]
         { info_tbl: [(c8mzq,
                       label: block_c8mzq_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mzq: // global
           _s8j6L::P64 = P64[Sp + 88];
           if (R1 & 7 == 1) goto c8mzA; else goto c8mA5;
       c8mzA: // global
           I64[Sp] = block_c8mzx_info;
           _s8j6O::P64 = P64[R1 + 15];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6O::P64;
           if (R1 & 7 != 0) goto u8mBx; else goto c8mzB;
       u8mBx: // global
           call _c8mzx(R1) args: 0, res: 0, upd: 0;
       c8mzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mA5: // global
           I64[Sp] = block_c8mA3_info;
           _s8j6X::P64 = P64[R1 + 14];
           R1 = _s8j6L::P64;
           P64[Sp + 88] = _s8j6X::P64;
           if (R1 & 7 != 0) goto u8mBy; else goto c8mA6;
       u8mBy: // global
           call _c8mA3(R1) args: 0, res: 0, upd: 0;
       c8mA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mzx() //  [R1]
         { info_tbl: [(c8mzx,
                       label: block_c8mzx_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mzx: // global
           if (R1 & 7 == 1) goto c8mzW; else goto u8mAS;
       c8mzW: // global
           if (P64[Sp + 88] == P64[R1 + 15]) goto u8mAT; else goto u8mAU;
       u8mAT: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8mAU: // global
           Sp = Sp + 96;
           goto u8mBB;
       u8mAS: // global
           Sp = Sp + 96;
           goto u8mBB;
       u8mBB: // global
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _c8mA3() //  [R1]
         { info_tbl: [(c8mA3,
                       label: block_c8mA3_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mA3: // global
           if (R1 & 7 == 1) goto u8mAP; else goto c8mAv;
       u8mAP: // global
           Sp = Sp + 96;
           goto u8mBE;
       c8mAv: // global
           if (P64[Sp + 88] == P64[R1 + 14]) goto u8mAQ; else goto u8mAR;
       u8mAQ: // global
           Sp = Sp + 8;
           call _s8j6m() args: 0, res: 0, upd: 0;
       u8mAR: // global
           Sp = Sp + 96;
           goto u8mBE;
       u8mBE: // global
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6m: // global
           I64[Sp + 8] = block_c8mx9_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8mx9() //  [R1]
         { info_tbl: [(c8mx9,
                       label: block_c8mx9_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mx9: // global
           if (R1 & 7 == 1) goto u8mAX; else goto c8my1;
       u8mAX: // global
           Sp = Sp + 80;
           call _c8mAl() args: 0, res: 0, upd: 0;
       c8my1: // global
           I64[Sp] = block_c8mxl_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto u8mBe; else goto c8my2;
       u8mBe: // global
           call _c8mxl(R1) args: 0, res: 0, upd: 0;
       c8my2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mxl() //  [R1]
         { info_tbl: [(c8mxl,
                       label: block_c8mxl_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mxl: // global
           _s8j6e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8my9; else goto c8myp;
       c8my9: // global
           I64[Sp + 8] = block_c8my6_info;
           R1 = _s8j6e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mBg; else goto c8mya;
       u8mBg: // global
           call _c8my6(R1) args: 0, res: 0, upd: 0;
       c8mya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8myp: // global
           I64[Sp + 8] = block_c8myn_info;
           _s8j6y::P64 = P64[R1 + 6];
           R1 = _s8j6e::P64;
           P64[Sp + 72] = _s8j6y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mBh; else goto c8myq;
       u8mBh: // global
           call _c8myn(R1) args: 0, res: 0, upd: 0;
       c8myq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8my6() //  [R1]
         { info_tbl: [(c8my6,
                       label: block_c8my6_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8my6: // global
           if (R1 & 7 == 1) goto u8mB1; else goto u8mB2;
       u8mB1: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8mB2: // global
           Sp = Sp + 72;
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _c8myn() //  [R1]
         { info_tbl: [(c8myn,
                       label: block_c8myn_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8myn: // global
           if (R1 & 7 == 1) goto u8mAY; else goto c8myG;
       u8mAY: // global
           Sp = Sp + 72;
           call _c8mAl() args: 0, res: 0, upd: 0;
       c8myG: // global
           I64[Sp] = block_c8myz_info;
           _s8j6A::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8j6A::P64;
           if (R1 & 7 != 0) goto u8mBo; else goto c8myA;
       u8mBo: // global
           call _c8myz(R1) args: 0, res: 0, upd: 0;
       c8myA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8myz() //  [R1]
         { info_tbl: [(c8myz,
                       label: block_c8myz_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8myz: // global
           I64[Sp] = block_c8myE_info;
           _s8j6C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 64];
           I64[Sp + 64] = _s8j6C::I64;
           if (R1 & 7 != 0) goto u8mBq; else goto c8myI;
       u8mBq: // global
           call _c8myE(R1) args: 0, res: 0, upd: 0;
       c8myI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8myE() //  [R1]
         { info_tbl: [(c8myE,
                       label: block_c8myE_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8myE: // global
           if (I64[Sp + 64] == I64[R1 + 7]) goto u8mAZ; else goto u8mB0;
       u8mAZ: // global
           Sp = Sp + 8;
           call _s8j6o() args: 0, res: 0, upd: 0;
       u8mB0: // global
           Sp = Sp + 72;
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _s8j6o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8j6o: // global
           I64[Sp - 8] = block_c8mxq_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mBF; else goto c8mxs;
       u8mBF: // global
           call _c8mxq(R1) args: 0, res: 0, upd: 0;
       c8mxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mxq() //  [R1]
         { info_tbl: [(c8mxq,
                       label: block_c8mxq_info
                       rep:StackRep [False, True, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mxq: // global
           _s8j6f::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mxz; else goto c8mxP;
       c8mxz: // global
           I64[Sp + 64] = block_c8mxw_info;
           R1 = _s8j6f::P64;
           Sp = Sp + 64;
           if (R1 & 7 != 0) goto u8mBi; else goto c8mxA;
       u8mBi: // global
           call _c8mxw(R1) args: 0, res: 0, upd: 0;
       c8mxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mxP: // global
           I64[Sp + 56] = block_c8mxN_info;
           _s8j6s::P64 = P64[R1 + 6];
           R1 = _s8j6f::P64;
           P64[Sp + 64] = _s8j6s::P64;
           Sp = Sp + 56;
           if (R1 & 7 != 0) goto u8mBj; else goto c8mxQ;
       u8mBj: // global
           call _c8mxN(R1) args: 0, res: 0, upd: 0;
       c8mxQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mxw() //  [R1]
         { info_tbl: [(c8mxw,
                       label: block_c8mxw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mxw: // global
           if (R1 & 7 == 1) goto c8mxG; else goto u8mB4;
       c8mxG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8mB4: // global
           Sp = Sp + 8;
           call _c8mAl() args: 0, res: 0, upd: 0;
     }
 },
 _c8mxN() //  [R1]
         { info_tbl: [(c8mxN,
                       label: block_c8mxN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mxN: // global
           if (R1 & 7 == 1) goto u8mB3; else goto c8my0;
       u8mB3: // global
           Sp = Sp + 16;
           call _c8mAl() args: 0, res: 0, upd: 0;
       c8my0: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8mAl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mAl: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.287686782 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c/=_closure" {
     GHC.IO.Exception.$fEqIOException_$c/=_closure:
         const GHC.IO.Exception.$fEqIOException_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8mDV,
                       label: GHC.IO.Exception.$fEqIOException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mDV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mDW; else goto c8mDX;
       c8mDW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mDX: // global
           I64[Sp - 8] = block_c8mDP_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Exception.$fEqIOException_$c==_entry(R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8mDP() //  [R1]
         { info_tbl: [(c8mDP,
                       label: block_c8mDP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mDP: // global
           if (R1 & 7 == 1) goto c8mDS; else goto c8mDT;
       c8mDS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mDT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.292944314 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_closure" {
     GHC.IO.Exception.$fEqIOException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOException_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.294947142 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException1_closure" {
     GHC.IO.Exception.$fExceptionIOException1_closure:
         const GHC.IO.Exception.$fExceptionIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException1_entry() //  [R1]
         { info_tbl: [(c8mEn,
                       label: GHC.IO.Exception.$fExceptionIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mEn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mEo; else goto c8mEp;
       c8mEo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mEp: // global
           (_c8mEk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mEk::I64 == 0) goto c8mEm; else goto c8mEl;
       c8mEm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mEl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mEk::I64;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.299237477 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException3_bytes" {
     GHC.IO.Exception.$fExceptionIOException3_bytes:
         I8[] [32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.300907845 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException2_bytes" {
     GHC.IO.Exception.$fExceptionIOException2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.306209821 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec3_closure" {
     GHC.IO.Exception.$w$cshowsPrec3_closure:
         const GHC.IO.Exception.$w$cshowsPrec3_info;
         const 0;
 },
 sat_s8j7k_entry() //  [R1]
         { info_tbl: [(c8mF3,
                       label: sat_s8j7k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mF3: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7l_entry() //  [R1]
         { info_tbl: [(c8mF6,
                       label: sat_s8j7l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mF6: // global
           _s8j7l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mF7; else goto c8mF8;
       c8mF8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mFa; else goto c8mF9;
       c8mFa: // global
           HpAlloc = 24;
           goto c8mF7;
       c8mF7: // global
           R1 = _s8j7l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7l::P64;
           _s8j7e::P64 = P64[_s8j7l::P64 + 16];
           _s8j7h::P64 = P64[_s8j7l::P64 + 24];
           I64[Hp - 16] = sat_s8j7k_info;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 16;
           R2 = _s8j7h::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7m_entry() //  [R1]
         { info_tbl: [(c8mFf,
                       label: sat_s8j7m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mFg; else goto c8mFh;
       c8mFg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mFh: // global
           I64[Sp - 16] = block_c8mEP_info;
           _s8j7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s8j7e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mFn; else goto c8mEQ;
       u8mFn: // global
           call _c8mEP(R1) args: 0, res: 0, upd: 0;
       c8mEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mEP() //  [R1]
         { info_tbl: [(c8mEP,
                       label: block_c8mEP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mEP: // global
           _s8j7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mFc; else goto c8mFd;
       c8mFc: // global
           R1 = _s8j7e::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8mFd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8mFm; else goto c8mFl;
       c8mFm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mFl: // global
           I64[Hp - 24] = sat_s8j7l_info;
           P64[Hp - 8] = _s8j7e::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionIOException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8j7g_entry() //  [R1]
         { info_tbl: [(c8mFo,
                       label: karg_s8j7g_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFo: // global
           _s8j7g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mFp; else goto c8mFq;
       c8mFq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8mFs; else goto c8mFr;
       c8mFs: // global
           HpAlloc = 32;
           goto c8mFp;
       c8mFp: // global
           R1 = _s8j7g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mFr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7g::P64;
           _s8j7a::P64 = P64[_s8j7g::P64 + 16];
           _s8j7c::P64 = P64[_s8j7g::P64 + 24];
           _s8j7e::P64 = P64[_s8j7g::P64 + 32];
           I64[Hp - 24] = sat_s8j7m_info;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           R3 = Hp - 24;
           R2 = _s8j7a::P64;
           Sp = Sp - 16;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7q_entry() //  [R1]
         { info_tbl: [(c8mFD,
                       label: sat_s8j7q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFD: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_s8j7f_entry() //  [R1]
         { info_tbl: [(c8mFK,
                       label: eta_s8j7f_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFK: // global
           _s8j7f::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8mFL; else goto c8mFM;
       c8mFM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8mFO; else goto c8mFN;
       c8mFO: // global
           HpAlloc = 40;
           goto c8mFL;
       c8mFL: // global
           R1 = _s8j7f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7f::P64;
           _s8j7a::P64 = P64[_s8j7f::P64 + 16];
           _s8j7b::P64 = P64[_s8j7f::P64 + 24];
           _s8j7c::P64 = P64[_s8j7f::P64 + 32];
           _s8j7e::P64 = P64[_s8j7f::P64 + 40];
           I64[Hp - 32] = karg_s8j7g_info;
           P64[Hp - 16] = _s8j7a::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = _s8j7e::P64;
           I64[Sp - 32] = block_c8mFt_info;
           R1 = _s8j7b::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mFU; else goto c8mFu;
       u8mFU: // global
           call _c8mFt(R1) args: 0, res: 0, upd: 0;
       c8mFu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mFt() //  [R1]
         { info_tbl: [(c8mFt,
                       label: block_c8mFt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFt: // global
           _c8mEH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mFH; else goto c8mFI;
       c8mFH: // global
           R1 = _c8mEH::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8mFI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mFT; else goto c8mFS;
       c8mFT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mFS: // global
           I64[Hp - 16] = sat_s8j7q_info;
           P64[Hp] = _c8mEH::P64;
           R3 = Hp - 16;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7x_entry() //  [R1]
         { info_tbl: [(c8mGn,
                       label: sat_s8j7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mGo; else goto c8mGp;
       c8mGo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7y_entry() //  [R1]
         { info_tbl: [(c8mGq,
                       label: sat_s8j7y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mGu; else goto c8mGt;
       c8mGu: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGt: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7x_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7z_entry() //  [R1]
         { info_tbl: [(c8mGv,
                       label: sat_s8j7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGv: // global
           _s8j7z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mGw; else goto c8mGx;
       c8mGx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mGz; else goto c8mGy;
       c8mGz: // global
           HpAlloc = 24;
           goto c8mGw;
       c8mGw: // global
           R1 = _s8j7z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7z::P64;
           _s8j7f::P64 = P64[_s8j7z::P64 + 16];
           _s8j7v::P64 = P64[_s8j7z::P64 + 24];
           I64[Hp - 16] = sat_s8j7y_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7v::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7D_entry() //  [R1]
         { info_tbl: [(c8mGO,
                       label: sat_s8j7D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mGP; else goto c8mGQ;
       c8mGP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7E_entry() //  [R1]
         { info_tbl: [(c8mGR,
                       label: sat_s8j7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mGV; else goto c8mGU;
       c8mGV: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGU: // global
           _s8j7f::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8j7D_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j7F_entry() //  [R1]
         { info_tbl: [(c8mGW,
                       label: sat_s8j7F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mGW: // global
           _s8j7F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mGX; else goto c8mGY;
       c8mGY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mH0; else goto c8mGZ;
       c8mH0: // global
           HpAlloc = 24;
           goto c8mGX;
       c8mGX: // global
           R1 = _s8j7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mGZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j7F::P64;
           _s8j7f::P64 = P64[_s8j7F::P64 + 16];
           _s8j7A::P64 = P64[_s8j7F::P64 + 24];
           I64[Hp - 16] = sat_s8j7E_info;
           P64[Hp] = _s8j7f::P64;
           R3 = Hp - 16;
           R2 = _s8j7A::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j7H_entry() //  [R1]
         { info_tbl: [(c8mH7,
                       label: sat_s8j7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mH7: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8mHe,
                       label: GHC.IO.Exception.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mHe: // global
           _s8j7d::P64 = R6;
           _s8j7c::P64 = R5;
           _s8j7b::P64 = R4;
           _s8j7a::P64 = R3;
           _s8j79::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mHf; else goto c8mHg;
       c8mHg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8mHi; else goto c8mHh;
       c8mHi: // global
           HpAlloc = 48;
           goto c8mHf;
       c8mHf: // global
           R6 = _s8j7d::P64;
           R5 = _s8j7c::P64;
           R4 = _s8j7b::P64;
           R3 = _s8j7a::P64;
           R2 = _s8j79::P64;
           R1 = GHC.IO.Exception.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8mHh: // global
           I64[Hp - 40] = eta_s8j7f_info;
           P64[Hp - 24] = _s8j7a::P64;
           P64[Hp - 16] = _s8j7b::P64;
           P64[Hp - 8] = _s8j7c::P64;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_c8mFV_info;
           R1 = _s8j7d::P64;
           P64[Sp - 8] = _s8j79::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mHG; else goto c8mFW;
       u8mHG: // global
           call _c8mFV(R1) args: 0, res: 0, upd: 0;
       c8mFW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mFV() //  [R1]
         { info_tbl: [(c8mFV,
                       label: block_c8mFV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mFV: // global
           if (R1 & 7 == 1) goto c8mHb; else goto c8mHc;
       c8mHb: // global
           _s8j79::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8mG0_info;
           R1 = _s8j79::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mHE; else goto c8mG1;
       u8mHE: // global
           call _c8mG0(R1) args: 0, res: 0, upd: 0;
       c8mG1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mHc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mHB; else goto c8mHA;
       c8mHB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mHA: // global
           _s8j7G::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j7H_info;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = _s8j7G::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8mG0() //  [R1]
         { info_tbl: [(c8mG0,
                       label: block_c8mG0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mG0: // global
           if (R1 & 7 == 1) goto c8mHn; else goto c8mHp;
       c8mHn: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8mHp: // global
           I64[Sp] = block_c8mG6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u8mHF; else goto c8mG7;
       u8mHF: // global
           call _c8mG6(R1) args: 0, res: 0, upd: 0;
       c8mG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mG6() //  [R1]
         { info_tbl: [(c8mG6,
                       label: block_c8mG6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mG6: // global
           _c8mED::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mHr; else goto c8mHv;
       c8mHr: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8mHy; else goto c8mHt;
       c8mHt: // global
           _s8j7v::P64 = P64[_s8j7u::P64 + 7];
           I64[Hp - 24] = sat_s8j7z_info;
           P64[Hp - 8] = _c8mED::P64;
           P64[Hp] = _s8j7v::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8mHv: // global
           Hp = Hp + 32;
           _s8j7u::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8mHy; else goto c8mHx;
       c8mHy: // global
           HpAlloc = 32;
           R1 = _s8j7u::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mHx: // global
           _s8j7A::P64 = P64[_s8j7u::P64 + 6];
           I64[Hp - 24] = sat_s8j7F_info;
           P64[Hp - 8] = _c8mED::P64;
           P64[Hp] = _s8j7A::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.347965306 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_entry() //  [R2,
                                                                  R3, R4]
         { info_tbl: [(c8mJi,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mJi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mJj; else goto c8mJk;
       c8mJj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mJk: // global
           I64[Sp - 16] = block_c8mJf_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mJo; else goto c8mJg;
       u8mJo: // global
           call _c8mJf(R1) args: 0, res: 0, upd: 0;
       c8mJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mJf() //  [R1]
         { info_tbl: [(c8mJf,
                       label: block_c8mJf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mJf: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.353885482 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8mJF,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mJF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mJG; else goto c8mJH;
       c8mJG: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mJH: // global
           I64[Sp - 8] = block_c8mJC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mJL; else goto c8mJD;
       u8mJL: // global
           call _c8mJC(R1) args: 0, res: 0, upd: 0;
       c8mJD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mJC() //  [R1]
         { info_tbl: [(c8mJC,
                       label: block_c8mJC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mJC: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = GHC.Types.[]_closure+1;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.360171471 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException1_closure" {
     GHC.IO.Exception.$fShowIOException1_closure:
         const GHC.IO.Exception.$fShowIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8mK2,
                       label: GHC.IO.Exception.$fShowIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mK2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mK3; else goto c8mK4;
       c8mK3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mK4: // global
           I64[Sp - 16] = block_c8mJZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mK8; else goto c8mK0;
       u8mK8: // global
           call _c8mJZ(R1) args: 0, res: 0, upd: 0;
       c8mK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mJZ() //  [R1]
         { info_tbl: [(c8mJZ,
                       label: block_c8mJZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mJZ: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.367888109 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8mKm,
                       label: GHC.IO.Exception.$fShowIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mKm: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.372700699 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_closure" {
     GHC.IO.Exception.$fShowIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.375930839 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_$cto_closure" {
     GHC.IO.Exception.$fGenericExitCode_$cto_closure:
         const GHC.IO.Exception.$fGenericExitCode_$cto_info;
 },
 GHC.IO.Exception.$fGenericExitCode_$cto_entry() //  [R2]
         { info_tbl: [(c8mKE,
                       label: GHC.IO.Exception.$fGenericExitCode_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mKE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mKF; else goto c8mKG;
       c8mKF: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mKG: // global
           I64[Sp - 8] = block_c8mKy_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mKy() //  [R1]
         { info_tbl: [(c8mKy,
                       label: block_c8mKy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mKy: // global
           if (R1 & 7 == 1) goto c8mKB; else goto c8mKC;
       c8mKB: // global
           I64[Sp] = block_c8mKJ_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8mKW; else goto c8mKL;
       u8mKW: // global
           call _c8mKJ() args: 0, res: 0, upd: 0;
       c8mKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mKC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mKV; else goto c8mKU;
       c8mKV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mKU: // global
           _s8j8f::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = _s8j8f::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8mKJ() //  []
         { info_tbl: [(c8mKJ,
                       label: block_c8mKJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mKJ: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.383695838 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode2_closure" {
     GHC.IO.Exception.$fGenericExitCode2_closure:
         const GHC.Generics.L1_con_info;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.386440433 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode1_closure" {
     GHC.IO.Exception.$fGenericExitCode1_closure:
         const GHC.IO.Exception.$fGenericExitCode1_info;
 },
 GHC.IO.Exception.$fGenericExitCode1_entry() //  [R2]
         { info_tbl: [(c8mLp,
                       label: GHC.IO.Exception.$fGenericExitCode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mLp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mLq; else goto c8mLr;
       c8mLq: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mLr: // global
           I64[Sp - 8] = block_c8mLi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mLB; else goto c8mLj;
       u8mLB: // global
           call _c8mLi(R1) args: 0, res: 0, upd: 0;
       c8mLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mLi() //  [R1]
         { info_tbl: [(c8mLi,
                       label: block_c8mLi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mLi: // global
           if (R1 & 7 == 1) goto c8mLm; else goto c8mLn;
       c8mLm: // global
           R1 = GHC.IO.Exception.$fGenericExitCode2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mLn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mLA; else goto c8mLz;
       c8mLA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mLz: // global
           _s8j8i::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _s8j8i::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.392863545 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_closure" {
     GHC.IO.Exception.$fGenericExitCode_closure:
         const GHC.Generics.C:Generic_con_info;
         const GHC.IO.Exception.$fGenericExitCode1_closure+1;
         const GHC.IO.Exception.$fGenericExitCode_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.394711819 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode3_bytes" {
     GHC.IO.Exception.$fExceptionExitCode3_bytes:
         I8[] [69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.396617663 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode2_closure" {
     GHC.IO.Exception.$fExceptionExitCode2_closure:
         const GHC.IO.Exception.$fExceptionExitCode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode2_entry() //  [R1]
         { info_tbl: [(c8mLX,
                       label: GHC.IO.Exception.$fExceptionExitCode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mLX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mLY; else goto c8mLZ;
       c8mLY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mLZ: // global
           (_c8mLU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mLU::I64 == 0) goto c8mLW; else goto c8mLV;
       c8mLW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mLV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mLU::I64;
           R2 = GHC.IO.Exception.$fExceptionExitCode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.400583311 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode1_bytes" {
     GHC.IO.Exception.$fExceptionExitCode1_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.403926249 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info;
         const 0;
 },
 sat_s8j8w_entry() //  [R1]
         { info_tbl: [(c8mMx,
                       label: sat_s8j8w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mMD; else goto c8mME;
       c8mMD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mME: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8mMu_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mMJ; else goto c8mMv;
       u8mMJ: // global
           call _c8mMu(R1) args: 0, res: 0, upd: 0;
       c8mMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mMu() //  [R1]
         { info_tbl: [(c8mMu,
                       label: block_c8mMu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMu: // global
           _s8j8l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8mMA_info;
           R4 = _s8j8l::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8mMA() //  [R1, R2]
         { info_tbl: [(c8mMA,
                       label: block_c8mMA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mMI; else goto c8mMH;
       c8mMI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8mMH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8D_entry() //  [R1]
         { info_tbl: [(c8mMW,
                       label: sat_s8j8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mN3; else goto c8mN4;
       c8mN3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mN4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8mMT_info;
           _s8j8l::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8j8l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mNb; else goto c8mMU;
       u8mNb: // global
           call _c8mMT(R1) args: 0, res: 0, upd: 0;
       c8mMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mMT() //  [R1]
         { info_tbl: [(c8mMT,
                       label: block_c8mMT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mN7; else goto c8mN6;
       c8mN7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mN6: // global
           _s8j8y::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8mN0_info;
           R4 = Hp - 14;
           R3 = _s8j8y::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8mN0() //  [R1, R2]
         { info_tbl: [(c8mN0,
                       label: block_c8mN0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mN0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mNa; else goto c8mN9;
       c8mNa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8mN9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j8E_entry() //  [R1]
         { info_tbl: [(c8mNc,
                       label: sat_s8j8E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mNc: // global
           _s8j8E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8mNd; else goto c8mNe;
       c8mNe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8mNg; else goto c8mNf;
       c8mNg: // global
           HpAlloc = 32;
           goto c8mNd;
       c8mNd: // global
           R1 = _s8j8E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8j8E::P64;
           _s8j8l::P64 = P64[_s8j8E::P64 + 16];
           _s8j8n::P64 = P64[_s8j8E::P64 + 24];
           I64[Hp - 24] = sat_s8j8D_info;
           P64[Hp - 8] = _s8j8l::P64;
           P64[Hp] = _s8j8n::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8mNl,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mNl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8mNm; else goto c8mNn;
       c8mNm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mNn: // global
           I64[Sp - 24] = block_c8mMc_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8mNz; else goto c8mMd;
       u8mNz: // global
           call _c8mMc(R1) args: 0, res: 0, upd: 0;
       c8mMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mMc() //  [R1]
         { info_tbl: [(c8mMc,
                       label: block_c8mMc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMc: // global
           if (R1 & 7 == 1) goto c8mNi; else goto c8mNj;
       c8mNi: // global
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8mNj: // global
           I64[Sp] = block_c8mMi_info;
           _s8j8n::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j8n::P64;
           if (R1 & 7 != 0) goto u8mNy; else goto c8mMj;
       u8mNy: // global
           call _c8mMi(R1) args: 0, res: 0, upd: 0;
       c8mMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mMi() //  [R1]
         { info_tbl: [(c8mMi,
                       label: block_c8mMi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mMi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8mNt; else goto c8mNs;
       c8mNt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mNs: // global
           _s8j8l::P64 = P64[Sp + 16];
           _s8j8n::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c8mNv; else goto c8mNx;
       c8mNv: // global
           I64[Hp - 48] = sat_s8j8w_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           _c8mMq::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c8mMq::P64;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8mNx: // global
           I64[Hp - 48] = sat_s8j8E_info;
           P64[Hp - 32] = _s8j8l::P64;
           P64[Hp - 24] = _s8j8n::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.427100144 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cshow_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cshow_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_info;
         const 0;
 },
 sat_s8j8N_entry() //  [R1]
         { info_tbl: [(c8mOB,
                       label: sat_s8j8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mOB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8mOH; else goto c8mOI;
       c8mOH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mOI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8mOy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8mON; else goto c8mOz;
       u8mON: // global
           call _c8mOy(R1) args: 0, res: 0, upd: 0;
       c8mOz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mOy() //  [R1]
         { info_tbl: [(c8mOy,
                       label: block_c8mOy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mOy: // global
           I64[Sp] = block_c8mOE_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8mOE() //  [R1, R2]
         { info_tbl: [(c8mOE,
                       label: block_c8mOE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mOE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mOM; else goto c8mOL;
       c8mOM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8mOL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fExceptionExitCode_$cshow_entry() //  [R2]
         { info_tbl: [(c8mOS,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mOS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8mOT; else goto c8mOU;
       c8mOT: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mOU: // global
           I64[Sp - 8] = block_c8mOo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8mP0; else goto c8mOp;
       u8mP0: // global
           call _c8mOo(R1) args: 0, res: 0, upd: 0;
       c8mOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mOo() //  [R1]
         { info_tbl: [(c8mOo,
                       label: block_c8mOo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mOo: // global
           if (R1 & 7 == 1) goto c8mOP; else goto c8mOQ;
       c8mOP: // global
           R1 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8mOQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mOZ; else goto c8mOY;
       c8mOZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mOY: // global
           _s8j8H::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8j8N_info;
           P64[Hp] = _s8j8H::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.44189702 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode1_closure" {
     GHC.IO.Exception.$fShowExitCode1_closure:
         const GHC.IO.Exception.$fShowExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8mPt,
                       label: GHC.IO.Exception.$fShowExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mPt: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionArrayException1_closure+1;
           call GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.447248541 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowList_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowList_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8mPE,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mPE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowExitCode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.451055764 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_closure" {
     GHC.IO.Exception.$fShowExitCode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const GHC.IO.Exception.$fShowExitCode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.452865707 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme1_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.4547676 UTC

[section ""cstring" . GHC.IO.Exception.$fReadExitCode5_bytes" {
     GHC.IO.Exception.$fReadExitCode5_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.456611198 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode4_closure" {
     GHC.IO.Exception.$fReadExitCode4_closure:
         const GHC.IO.Exception.$fReadExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode4_entry() //  [R1]
         { info_tbl: [(c8mPU,
                       label: GHC.IO.Exception.$fReadExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mPV; else goto c8mPW;
       c8mPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mPW: // global
           (_c8mPR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mPR::I64 == 0) goto c8mPT; else goto c8mPS;
       c8mPT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mPS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mPR::I64;
           R2 = GHC.IO.Exception.$fReadExitCode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.460581742 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fReadExitCode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.462309236 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode3_closure" {
     GHC.IO.Exception.$fReadExitCode3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.46656321 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode2_closure" {
     GHC.IO.Exception.$fReadExitCode2_closure:
         const GHC.IO.Exception.$fReadExitCode2_info;
         const 0;
 },
 sat_s8j8T_entry() //  [R1]
         { info_tbl: [(c8mQf,
                       label: sat_s8j8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQf: // global
           R2 = GHC.IO.Exception.ExitSuccess_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j93_entry() //  [R1, R2]
         { info_tbl: [(c8mQI,
                       label: sat_s8j93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mQM; else goto c8mQL;
       c8mQM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mQL: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _s8j8R::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j94_entry() //  [R1, R2]
         { info_tbl: [(c8mQN,
                       label: sat_s8j94_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mQR; else goto c8mQQ;
       c8mQR: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mQQ: // global
           _s8j8R::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8j93_info;
           P64[Hp] = _s8j8R::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Exception.$fReadExitCode3_closure+1;
           R2 = GHC.Read.$fReadInt2_closure+1;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8j97_entry() //  [R1]
         { info_tbl: [(c8mQS,
                       label: sat_s8j97_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8mQT; else goto c8mQU;
       c8mQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8mQo_info;
           _s8j8R::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8j8R::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8mR7; else goto c8mQp;
       u8mR7: // global
           call _c8mQo(R1) args: 0, res: 0, upd: 0;
       c8mQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8mQo() //  [R1]
         { info_tbl: [(c8mQo,
                       label: block_c8mQo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mQX; else goto c8mQW;
       c8mQX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mQW: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8mQZ; else goto c8mR3;
       c8mQZ: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8mR3: // global
           I64[Hp - 8] = sat_s8j94_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8mR0_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8mR0() //  [R1]
         { info_tbl: [(c8mR0,
                       label: block_c8mR0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mR0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mR6; else goto c8mR5;
       c8mR6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8mR5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode2_entry() //  [R2, R3]
         { info_tbl: [(c8mR9,
                       label: GHC.IO.Exception.$fReadExitCode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mR9: // global
           _s8j8R::P64 = R3;
           _s8j8Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8mRa; else goto c8mRb;
       c8mRb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mRd; else goto c8mRc;
       c8mRd: // global
           HpAlloc = 16;
           goto c8mRa;
       c8mRa: // global
           R3 = _s8j8R::P64;
           R2 = _s8j8Q::P64;
           R1 = GHC.IO.Exception.$fReadExitCode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mRc: // global
           I64[Hp - 8] = sat_s8j8T_info;
           P64[Hp] = _s8j8R::P64;
           I64[Sp - 24] = block_c8mQi_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme1_closure+4;
           P64[Sp - 16] = _s8j8Q::P64;
           P64[Sp - 8] = _s8j8R::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8mQi() //  [R1]
         { info_tbl: [(c8mQi,
                       label: block_c8mQi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mQi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8mRg; else goto c8mRf;
       c8mRg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mRf: // global
           I64[Hp - 40] = sat_s8j97_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.484211873 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode1_closure" {
     GHC.IO.Exception.$fReadExitCode1_closure:
         const GHC.IO.Exception.$fReadExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8mRS,
                       label: GHC.IO.Exception.$fReadExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mRS: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.488015579 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_info;
         const 0;
 },
 sat_s8j99_entry() //  [R1]
         { info_tbl: [(c8mS7,
                       label: sat_s8j99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mS7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mS8; else goto c8mS9;
       c8mS8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mS9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8mSa,
                       label: GHC.IO.Exception.$fReadExitCode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mSa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8mSe; else goto c8mSd;
       c8mSe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8mSd: // global
           I64[Hp - 16] = sat_s8j99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.493949911 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8mSt,
                       label: GHC.IO.Exception.$fReadExitCode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mSt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mSu; else goto c8mSv;
       c8mSu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mSv: // global
           (_c8mSq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mSq::I64 == 0) goto c8mSs; else goto c8mSr;
       c8mSs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mSr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mSq::I64;
           R2 = GHC.IO.Exception.$fReadExitCode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.498113784 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode6_closure" {
     GHC.IO.Exception.$fReadExitCode6_closure:
         const GHC.IO.Exception.$fReadExitCode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode6_entry() //  [R1]
         { info_tbl: [(c8mSJ,
                       label: GHC.IO.Exception.$fReadExitCode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mSK; else goto c8mSL;
       c8mSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8mSL: // global
           (_c8mSG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8mSG::I64 == 0) goto c8mSI; else goto c8mSH;
       c8mSI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8mSH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8mSG::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.502542174 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadList_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadList_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadList_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadList_entry() //  [R2]
         { info_tbl: [(c8mSX,
                       label: GHC.IO.Exception.$fReadExitCode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mSX: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode6_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.506516767 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_closure" {
     GHC.IO.Exception.$fReadExitCode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure+1;
         const GHC.IO.Exception.$fReadExitCode_$creadList_closure+1;
         const GHC.IO.Exception.$fReadExitCode1_closure+2;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.508962037 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8mTg,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mTh; else goto c8mTi;
       c8mTh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mTi: // global
           I64[Sp - 16] = block_c8mT9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mTT; else goto c8mTa;
       u8mTT: // global
           call _c8mT9(R1) args: 0, res: 0, upd: 0;
       c8mTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mT9() //  [R1]
         { info_tbl: [(c8mT9,
                       label: block_c8mT9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mT9: // global
           _s8j9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mTd; else goto c8mTe;
       c8mTd: // global
           I64[Sp + 8] = block_c8mTl_info;
           R1 = _s8j9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mTR; else goto c8mTn;
       u8mTR: // global
           call _c8mTl(R1) args: 0, res: 0, upd: 0;
       c8mTn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mTe: // global
           I64[Sp] = block_c8mTA_info;
           _s8j9f::P64 = P64[R1 + 6];
           R1 = _s8j9b::P64;
           P64[Sp + 8] = _s8j9f::P64;
           if (R1 & 7 != 0) goto u8mTS; else goto c8mTC;
       u8mTS: // global
           call _c8mTA(R1) args: 0, res: 0, upd: 0;
       c8mTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mTl() //  [R1]
         { info_tbl: [(c8mTl,
                       label: block_c8mTl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mTl: // global
           if (R1 & 7 == 1) goto u8mTQ; else goto c8mTx;
       u8mTQ: // global
           Sp = Sp + 8;
           call _c8mTI() args: 0, res: 0, upd: 0;
       c8mTx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8mTA() //  [R1]
         { info_tbl: [(c8mTA,
                       label: block_c8mTA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mTA: // global
           if (R1 & 7 == 1) goto u8mTP; else goto c8mTM;
       u8mTP: // global
           Sp = Sp + 16;
           call _c8mTI() args: 0, res: 0, upd: 0;
       c8mTM: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8mTI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mTI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.519836509 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$ccompare_closure" {
     GHC.IO.Exception.$fOrdExitCode_$ccompare_closure:
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8mUy,
                       label: GHC.IO.Exception.$fOrdExitCode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mUy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mUz; else goto c8mUA;
       c8mUz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mUA: // global
           I64[Sp - 16] = block_c8mUr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mV9; else goto c8mUs;
       u8mV9: // global
           call _c8mUr(R1) args: 0, res: 0, upd: 0;
       c8mUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mUr() //  [R1]
         { info_tbl: [(c8mUr,
                       label: block_c8mUr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mUr: // global
           _s8j9j::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mUv; else goto c8mUw;
       c8mUv: // global
           I64[Sp + 8] = block_c8mUD_info;
           R1 = _s8j9j::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mV7; else goto c8mUF;
       u8mV7: // global
           call _c8mUD(R1) args: 0, res: 0, upd: 0;
       c8mUF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mUw: // global
           I64[Sp] = block_c8mUS_info;
           _s8j9n::P64 = P64[R1 + 6];
           R1 = _s8j9j::P64;
           P64[Sp + 8] = _s8j9n::P64;
           if (R1 & 7 != 0) goto u8mV8; else goto c8mUU;
       u8mV8: // global
           call _c8mUS(R1) args: 0, res: 0, upd: 0;
       c8mUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mUD() //  [R1]
         { info_tbl: [(c8mUD,
                       label: block_c8mUD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mUD: // global
           if (R1 & 7 == 1) goto c8mUL; else goto c8mUP;
       c8mUL: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mUP: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8mUS() //  [R1]
         { info_tbl: [(c8mUS,
                       label: block_c8mUS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mUS: // global
           if (R1 & 7 == 1) goto c8mV0; else goto c8mV4;
       c8mV0: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mV4: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.530104443 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c==_closure" {
     GHC.IO.Exception.$fEqExitCode_$c==_closure:
         const GHC.IO.Exception.$fEqExitCode_$c==_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8mVL,
                       label: GHC.IO.Exception.$fEqExitCode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mVL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mVM; else goto c8mVN;
       c8mVM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mVN: // global
           I64[Sp - 16] = block_c8mVE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mWo; else goto c8mVF;
       u8mWo: // global
           call _c8mVE(R1) args: 0, res: 0, upd: 0;
       c8mVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mVE() //  [R1]
         { info_tbl: [(c8mVE,
                       label: block_c8mVE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mVE: // global
           _s8j9r::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mVI; else goto c8mVJ;
       c8mVI: // global
           I64[Sp + 8] = block_c8mVQ_info;
           R1 = _s8j9r::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mWm; else goto c8mVS;
       u8mWm: // global
           call _c8mVQ(R1) args: 0, res: 0, upd: 0;
       c8mVS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mVJ: // global
           I64[Sp] = block_c8mW5_info;
           _s8j9v::P64 = P64[R1 + 6];
           R1 = _s8j9r::P64;
           P64[Sp + 8] = _s8j9v::P64;
           if (R1 & 7 != 0) goto u8mWn; else goto c8mW7;
       u8mWn: // global
           call _c8mW5(R1) args: 0, res: 0, upd: 0;
       c8mW7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mVQ() //  [R1]
         { info_tbl: [(c8mVQ,
                       label: block_c8mVQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mVQ: // global
           if (R1 & 7 == 1) goto c8mVY; else goto u8mWl;
       c8mVY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8mWl: // global
           Sp = Sp + 8;
           call _c8mWd() args: 0, res: 0, upd: 0;
     }
 },
 _c8mW5() //  [R1]
         { info_tbl: [(c8mW5,
                       label: block_c8mW5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mW5: // global
           if (R1 & 7 == 1) goto u8mWk; else goto c8mWh;
       u8mWk: // global
           Sp = Sp + 16;
           call _c8mWd() args: 0, res: 0, upd: 0;
       c8mWh: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8mWd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mWd: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.540887097 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c/=_closure" {
     GHC.IO.Exception.$fEqExitCode_$c/=_closure:
         const GHC.IO.Exception.$fEqExitCode_$c/=_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8mX3,
                       label: GHC.IO.Exception.$fEqExitCode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mX4; else goto c8mX5;
       c8mX4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mX5: // global
           I64[Sp - 16] = block_c8mWW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mY0; else goto c8mWX;
       u8mY0: // global
           call _c8mWW(R1) args: 0, res: 0, upd: 0;
       c8mWX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mWW() //  [R1]
         { info_tbl: [(c8mWW,
                       label: block_c8mWW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mWW: // global
           _s8j9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mX0; else goto c8mX1;
       c8mX0: // global
           I64[Sp + 8] = block_c8mX8_info;
           R1 = _s8j9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mXY; else goto c8mXa;
       u8mXY: // global
           call _c8mX8(R1) args: 0, res: 0, upd: 0;
       c8mXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mX1: // global
           I64[Sp] = block_c8mXn_info;
           _s8j9D::P64 = P64[R1 + 6];
           R1 = _s8j9z::P64;
           P64[Sp + 8] = _s8j9D::P64;
           if (R1 & 7 != 0) goto u8mXZ; else goto c8mXp;
       u8mXZ: // global
           call _c8mXn(R1) args: 0, res: 0, upd: 0;
       c8mXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mX8() //  [R1]
         { info_tbl: [(c8mX8,
                       label: block_c8mX8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mX8: // global
           if (R1 & 7 == 1) goto u8mXW; else goto u8mXX;
       u8mXW: // global
           Sp = Sp + 8;
           call _c8mXQ() args: 0, res: 0, upd: 0;
       u8mXX: // global
           Sp = Sp + 8;
           call _c8mXP() args: 0, res: 0, upd: 0;
     }
 },
 _c8mXn() //  [R1]
         { info_tbl: [(c8mXn,
                       label: block_c8mXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mXn: // global
           if (R1 & 7 == 1) goto u8mXT; else goto c8mXF;
       u8mXT: // global
           Sp = Sp + 16;
           call _c8mXP() args: 0, res: 0, upd: 0;
       c8mXF: // global
           I64[Sp] = block_c8mXy_info;
           _s8j9F::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9F::P64;
           if (R1 & 7 != 0) goto u8mY3; else goto c8mXz;
       u8mY3: // global
           call _c8mXy(R1) args: 0, res: 0, upd: 0;
       c8mXz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mXy() //  [R1]
         { info_tbl: [(c8mXy,
                       label: block_c8mXy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mXy: // global
           I64[Sp] = block_c8mXD_info;
           _s8j9H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9H::I64;
           if (R1 & 7 != 0) goto u8mY5; else goto c8mXH;
       u8mY5: // global
           call _c8mXD(R1) args: 0, res: 0, upd: 0;
       c8mXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mXD() //  [R1]
         { info_tbl: [(c8mXD,
                       label: block_c8mXD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mXD: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8mXU; else goto u8mXV;
       u8mXU: // global
           Sp = Sp + 16;
           call _c8mXQ() args: 0, res: 0, upd: 0;
       u8mXV: // global
           Sp = Sp + 16;
           call _c8mXP() args: 0, res: 0, upd: 0;
     }
 },
 _c8mXQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mXQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8mXP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mXP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.556276158 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_closure" {
     GHC.IO.Exception.$fEqExitCode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqExitCode_$c==_closure+2;
         const GHC.IO.Exception.$fEqExitCode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.558971241 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8mYW,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mYW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mYX; else goto c8mYY;
       c8mYX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mYY: // global
           I64[Sp - 16] = block_c8mYP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8mZT; else goto c8mYQ;
       u8mZT: // global
           call _c8mYP(R1) args: 0, res: 0, upd: 0;
       c8mYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mYP() //  [R1]
         { info_tbl: [(c8mYP,
                       label: block_c8mYP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mYP: // global
           _s8j9L::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8mYT; else goto c8mYU;
       c8mYT: // global
           I64[Sp + 8] = block_c8mZ1_info;
           R1 = _s8j9L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8mZR; else goto c8mZ3;
       u8mZR: // global
           call _c8mZ1(R1) args: 0, res: 0, upd: 0;
       c8mZ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8mYU: // global
           I64[Sp] = block_c8mZg_info;
           _s8j9Q::P64 = P64[R1 + 6];
           R1 = _s8j9L::P64;
           P64[Sp + 8] = _s8j9Q::P64;
           if (R1 & 7 != 0) goto u8mZS; else goto c8mZi;
       u8mZS: // global
           call _c8mZg(R1) args: 0, res: 0, upd: 0;
       c8mZi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mZ1() //  [R1]
         { info_tbl: [(c8mZ1,
                       label: block_c8mZ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZ1: // global
           if (R1 & 7 == 1) goto u8mZP; else goto u8mZQ;
       u8mZP: // global
           Sp = Sp + 8;
           call _c8mZI() args: 0, res: 0, upd: 0;
       u8mZQ: // global
           Sp = Sp + 8;
           call _c8mZJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8mZg() //  [R1]
         { info_tbl: [(c8mZg,
                       label: block_c8mZg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZg: // global
           if (R1 & 7 == 1) goto u8mZM; else goto c8mZy;
       u8mZM: // global
           Sp = Sp + 16;
           call _c8mZI() args: 0, res: 0, upd: 0;
       c8mZy: // global
           I64[Sp] = block_c8mZr_info;
           _s8j9S::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8j9S::P64;
           if (R1 & 7 != 0) goto u8mZW; else goto c8mZs;
       u8mZW: // global
           call _c8mZr(R1) args: 0, res: 0, upd: 0;
       c8mZs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mZr() //  [R1]
         { info_tbl: [(c8mZr,
                       label: block_c8mZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZr: // global
           I64[Sp] = block_c8mZw_info;
           _s8j9U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8j9U::I64;
           if (R1 & 7 != 0) goto u8mZY; else goto c8mZA;
       u8mZY: // global
           call _c8mZw(R1) args: 0, res: 0, upd: 0;
       c8mZA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mZw() //  [R1]
         { info_tbl: [(c8mZw,
                       label: block_c8mZw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZw: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8mZO; else goto u8mZN;
       u8mZO: // global
           Sp = Sp + 16;
           call _c8mZI() args: 0, res: 0, upd: 0;
       u8mZN: // global
           Sp = Sp + 16;
           call _c8mZJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8mZI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZI: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8mZJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mZJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.574130636 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmax_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmax_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmax_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8n0O,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n0O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8n0P; else goto c8n0Q;
       c8n0P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n0Q: // global
           I64[Sp - 16] = block_c8n0H_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n1u; else goto c8n0I;
       u8n1u: // global
           call _c8n0H(R1) args: 0, res: 0, upd: 0;
       c8n0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n0H() //  [R1]
         { info_tbl: [(c8n0H,
                       label: block_c8n0H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n0H: // global
           _s8j9Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n0L; else goto c8n0M;
       c8n0L: // global
           R1 = _s8j9Y::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8n0M: // global
           I64[Sp - 8] = block_c8n0W_info;
           _s8ja0::P64 = R1;
           _s8ja1::P64 = P64[R1 + 6];
           R1 = _s8j9Y::P64;
           P64[Sp] = _s8ja1::P64;
           P64[Sp + 8] = _s8ja0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8n1t; else goto c8n0Y;
       u8n1t: // global
           call _c8n0W(R1) args: 0, res: 0, upd: 0;
       c8n0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n0W() //  [R1]
         { info_tbl: [(c8n0W,
                       label: block_c8n0W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n0W: // global
           if (R1 & 7 == 1) goto u8n1r; else goto c8n1e;
       u8n1r: // global
           Sp = Sp + 16;
           call _c8n1o() args: 0, res: 0, upd: 0;
       c8n1e: // global
           I64[Sp - 8] = block_c8n17_info;
           _s8ja2::P64 = R1;
           _s8ja3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ja3::P64;
           P64[Sp + 8] = _s8ja2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8n1v; else goto c8n18;
       u8n1v: // global
           call _c8n17(R1) args: 0, res: 0, upd: 0;
       c8n18: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n17() //  [R1]
         { info_tbl: [(c8n17,
                       label: block_c8n17_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n17: // global
           I64[Sp] = block_c8n1c_info;
           _s8ja5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ja5::I64;
           if (R1 & 7 != 0) goto u8n1x; else goto c8n1g;
       u8n1x: // global
           call _c8n1c(R1) args: 0, res: 0, upd: 0;
       c8n1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n1c() //  [R1]
         { info_tbl: [(c8n1c,
                       label: block_c8n1c_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n1c: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8n1s; else goto c8n1p;
       u8n1s: // global
           Sp = Sp + 24;
           call _c8n1o() args: 0, res: 0, upd: 0;
       c8n1p: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8n1o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n1o: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.588058711 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8n2i,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8n2j; else goto c8n2k;
       c8n2j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n2k: // global
           I64[Sp - 16] = block_c8n2b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n3f; else goto c8n2c;
       u8n3f: // global
           call _c8n2b(R1) args: 0, res: 0, upd: 0;
       c8n2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n2b() //  [R1]
         { info_tbl: [(c8n2b,
                       label: block_c8n2b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2b: // global
           _s8jaa::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n2f; else goto c8n2g;
       c8n2f: // global
           I64[Sp + 8] = block_c8n2n_info;
           R1 = _s8jaa::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8n3d; else goto c8n2p;
       u8n3d: // global
           call _c8n2n(R1) args: 0, res: 0, upd: 0;
       c8n2p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n2g: // global
           I64[Sp] = block_c8n2C_info;
           _s8jae::P64 = P64[R1 + 6];
           R1 = _s8jaa::P64;
           P64[Sp + 8] = _s8jae::P64;
           if (R1 & 7 != 0) goto u8n3e; else goto c8n2E;
       u8n3e: // global
           call _c8n2C(R1) args: 0, res: 0, upd: 0;
       c8n2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n2n() //  [R1]
         { info_tbl: [(c8n2n,
                       label: block_c8n2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2n: // global
           if (R1 & 7 == 1) goto u8n3b; else goto u8n3c;
       u8n3b: // global
           Sp = Sp + 8;
           call _c8n34() args: 0, res: 0, upd: 0;
       u8n3c: // global
           Sp = Sp + 8;
           call _c8n35() args: 0, res: 0, upd: 0;
     }
 },
 _c8n2C() //  [R1]
         { info_tbl: [(c8n2C,
                       label: block_c8n2C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2C: // global
           if (R1 & 7 == 1) goto u8n38; else goto c8n2U;
       u8n38: // global
           Sp = Sp + 16;
           call _c8n34() args: 0, res: 0, upd: 0;
       c8n2U: // global
           I64[Sp] = block_c8n2N_info;
           _s8jag::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8jag::P64;
           if (R1 & 7 != 0) goto u8n3i; else goto c8n2O;
       u8n3i: // global
           call _c8n2N(R1) args: 0, res: 0, upd: 0;
       c8n2O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n2N() //  [R1]
         { info_tbl: [(c8n2N,
                       label: block_c8n2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2N: // global
           I64[Sp] = block_c8n2S_info;
           _s8jai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jai::I64;
           if (R1 & 7 != 0) goto u8n3k; else goto c8n2W;
       u8n3k: // global
           call _c8n2S(R1) args: 0, res: 0, upd: 0;
       c8n2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n2S() //  [R1]
         { info_tbl: [(c8n2S,
                       label: block_c8n2S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n2S: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8n3a; else goto u8n39;
       u8n3a: // global
           Sp = Sp + 16;
           call _c8n34() args: 0, res: 0, upd: 0;
       u8n39: // global
           Sp = Sp + 16;
           call _c8n35() args: 0, res: 0, upd: 0;
     }
 },
 _c8n34() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n34: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8n35() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n35: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.602891632 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8n43,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n43: // global
           _s8jan::P64 = R3;
           R3 = R2;
           R2 = _s8jan::P64;
           call GHC.IO.Exception.$fOrdExitCode_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.607020151 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmin_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmin_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmin_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8n4l,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8n4m; else goto c8n4n;
       c8n4m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n4n: // global
           I64[Sp - 16] = block_c8n4e_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n56; else goto c8n4f;
       u8n56: // global
           call _c8n4e(R1) args: 0, res: 0, upd: 0;
       c8n4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n4e() //  [R1]
         { info_tbl: [(c8n4e,
                       label: block_c8n4e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4e: // global
           _s8jao::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n4i; else goto c8n4j;
       c8n4i: // global
           I64[Sp + 8] = block_c8n4q_info;
           R1 = _s8jao::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8n54; else goto c8n4s;
       u8n54: // global
           call _c8n4q() args: 0, res: 0, upd: 0;
       c8n4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n4j: // global
           I64[Sp - 8] = block_c8n4z_info;
           _s8jaq::P64 = R1;
           _s8jas::P64 = P64[R1 + 6];
           R1 = _s8jao::P64;
           P64[Sp] = _s8jas::P64;
           P64[Sp + 8] = _s8jaq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8n55; else goto c8n4B;
       u8n55: // global
           call _c8n4z(R1) args: 0, res: 0, upd: 0;
       c8n4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n4q() //  []
         { info_tbl: [(c8n4q,
                       label: block_c8n4q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4q: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8n4z() //  [R1]
         { info_tbl: [(c8n4z,
                       label: block_c8n4z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4z: // global
           if (R1 & 7 == 1) goto c8n4H; else goto c8n4R;
       c8n4H: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8n4R: // global
           I64[Sp - 8] = block_c8n4K_info;
           _s8jat::P64 = R1;
           _s8jau::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8jau::P64;
           P64[Sp + 8] = _s8jat::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8n57; else goto c8n4L;
       u8n57: // global
           call _c8n4K(R1) args: 0, res: 0, upd: 0;
       c8n4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n4K() //  [R1]
         { info_tbl: [(c8n4K,
                       label: block_c8n4K_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4K: // global
           I64[Sp] = block_c8n4P_info;
           _s8jaw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8jaw::I64;
           if (R1 & 7 != 0) goto u8n58; else goto c8n4T;
       u8n58: // global
           call _c8n4P(R1) args: 0, res: 0, upd: 0;
       c8n4T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n4P() //  [R1]
         { info_tbl: [(c8n4P,
                       label: block_c8n4P_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n4P: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c8n51; else goto c8n52;
       c8n51: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8n52: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.620894016 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_closure" {
     GHC.IO.Exception.$fOrdExitCode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqExitCode_closure+1;
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.623516878 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8n5V,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n5V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8n5W; else goto c8n5X;
       c8n5W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n5X: // global
           I64[Sp - 16] = block_c8n5O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n6w; else goto c8n5P;
       u8n6w: // global
           call _c8n5O(R1) args: 0, res: 0, upd: 0;
       c8n5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n5O() //  [R1]
         { info_tbl: [(c8n5O,
                       label: block_c8n5O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n5O: // global
           _s8jaB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n5S; else goto c8n5T;
       c8n5S: // global
           I64[Sp] = block_c8n60_info;
           _s8jaD::P64 = P64[R1 + 7];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaD::P64;
           if (R1 & 7 != 0) goto u8n6u; else goto c8n62;
       u8n6u: // global
           call _c8n60(R1) args: 0, res: 0, upd: 0;
       c8n62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n5T: // global
           I64[Sp] = block_c8n6f_info;
           _s8jaH::P64 = P64[R1 + 6];
           R1 = _s8jaB::P64;
           P64[Sp + 8] = _s8jaH::P64;
           if (R1 & 7 != 0) goto u8n6v; else goto c8n6h;
       u8n6v: // global
           call _c8n6f(R1) args: 0, res: 0, upd: 0;
       c8n6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n60() //  [R1]
         { info_tbl: [(c8n60,
                       label: block_c8n60_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n60: // global
           if (R1 & 7 == 1) goto c8n68; else goto c8n6c;
       c8n68: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c8n6c: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8n6f() //  [R1]
         { info_tbl: [(c8n6f,
                       label: block_c8n6f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n6f: // global
           if (R1 & 7 == 1) goto c8n6n; else goto c8n6r;
       c8n6n: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8n6r: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.633611209 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdArrayException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8n77,
                       label: GHC.IO.Exception.$fOrdArrayException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8n78; else goto c8n79;
       c8n78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n79: // global
           I64[Sp - 16] = block_c8n70_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n7I; else goto c8n71;
       u8n7I: // global
           call _c8n70(R1) args: 0, res: 0, upd: 0;
       c8n71: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n70() //  [R1]
         { info_tbl: [(c8n70,
                       label: block_c8n70_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n70: // global
           _s8jaM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n74; else goto c8n75;
       c8n74: // global
           I64[Sp] = block_c8n7c_info;
           _s8jaO::P64 = P64[R1 + 7];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaO::P64;
           if (R1 & 7 != 0) goto u8n7G; else goto c8n7e;
       u8n7G: // global
           call _c8n7c(R1) args: 0, res: 0, upd: 0;
       c8n7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n75: // global
           I64[Sp] = block_c8n7r_info;
           _s8jaS::P64 = P64[R1 + 6];
           R1 = _s8jaM::P64;
           P64[Sp + 8] = _s8jaS::P64;
           if (R1 & 7 != 0) goto u8n7H; else goto c8n7t;
       u8n7H: // global
           call _c8n7r(R1) args: 0, res: 0, upd: 0;
       c8n7t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n7c() //  [R1]
         { info_tbl: [(c8n7c,
                       label: block_c8n7c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n7c: // global
           if (R1 & 7 == 1) goto c8n7k; else goto c8n7o;
       c8n7k: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8n7o: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8n7r() //  [R1]
         { info_tbl: [(c8n7r,
                       label: block_c8n7r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n7r: // global
           if (R1 & 7 == 1) goto c8n7z; else goto c8n7D;
       c8n7z: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8n7D: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.643803083 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c==_closure" {
     GHC.IO.Exception.$fEqArrayException_$c==_closure:
         const GHC.IO.Exception.$fEqArrayException_$c==_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8n8j,
                       label: GHC.IO.Exception.$fEqArrayException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n8j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8n8k; else goto c8n8l;
       c8n8k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n8l: // global
           I64[Sp - 16] = block_c8n8c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8n8W; else goto c8n8d;
       u8n8W: // global
           call _c8n8c(R1) args: 0, res: 0, upd: 0;
       c8n8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n8c() //  [R1]
         { info_tbl: [(c8n8c,
                       label: block_c8n8c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n8c: // global
           _s8jaX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n8g; else goto c8n8h;
       c8n8g: // global
           I64[Sp] = block_c8n8o_info;
           _s8jaZ::P64 = P64[R1 + 7];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jaZ::P64;
           if (R1 & 7 != 0) goto u8n8U; else goto c8n8q;
       u8n8U: // global
           call _c8n8o(R1) args: 0, res: 0, upd: 0;
       c8n8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n8h: // global
           I64[Sp] = block_c8n8D_info;
           _s8jb3::P64 = P64[R1 + 6];
           R1 = _s8jaX::P64;
           P64[Sp + 8] = _s8jb3::P64;
           if (R1 & 7 != 0) goto u8n8V; else goto c8n8F;
       u8n8V: // global
           call _c8n8D(R1) args: 0, res: 0, upd: 0;
       c8n8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n8o() //  [R1]
         { info_tbl: [(c8n8o,
                       label: block_c8n8o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n8o: // global
           if (R1 & 7 == 1) goto c8n8w; else goto u8n8T;
       c8n8w: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8n8T: // global
           Sp = Sp + 16;
           call _c8n8L() args: 0, res: 0, upd: 0;
     }
 },
 _c8n8D() //  [R1]
         { info_tbl: [(c8n8D,
                       label: block_c8n8D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n8D: // global
           if (R1 & 7 == 1) goto u8n8S; else goto c8n8P;
       u8n8S: // global
           Sp = Sp + 16;
           call _c8n8L() args: 0, res: 0, upd: 0;
       c8n8P: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8n8L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n8L: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.654744331 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c/=_closure" {
     GHC.IO.Exception.$fEqArrayException_$c/=_closure:
         const GHC.IO.Exception.$fEqArrayException_$c/=_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8n9A,
                       label: GHC.IO.Exception.$fEqArrayException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n9A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8n9B; else goto c8n9C;
       c8n9B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8n9C: // global
           I64[Sp - 16] = block_c8n9t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8naF; else goto c8n9u;
       u8naF: // global
           call _c8n9t(R1) args: 0, res: 0, upd: 0;
       c8n9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n9t() //  [R1]
         { info_tbl: [(c8n9t,
                       label: block_c8n9t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n9t: // global
           _s8jb8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8n9x; else goto c8n9y;
       c8n9x: // global
           I64[Sp] = block_c8n9F_info;
           _s8jba::P64 = P64[R1 + 7];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jba::P64;
           if (R1 & 7 != 0) goto u8naD; else goto c8n9H;
       u8naD: // global
           call _c8n9F(R1) args: 0, res: 0, upd: 0;
       c8n9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8n9y: // global
           I64[Sp] = block_c8na5_info;
           _s8jbf::P64 = P64[R1 + 6];
           R1 = _s8jb8::P64;
           P64[Sp + 8] = _s8jbf::P64;
           if (R1 & 7 != 0) goto u8naE; else goto c8na7;
       u8naE: // global
           call _c8na5(R1) args: 0, res: 0, upd: 0;
       c8na7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8n9F() //  [R1]
         { info_tbl: [(c8n9F,
                       label: block_c8n9F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n9F: // global
           if (R1 & 7 == 1) goto c8n9O; else goto u8naA;
       c8n9O: // global
           _s8jba::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8n9L_info;
           R3 = P64[R1 + 7];
           R2 = _s8jba::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8naA: // global
           Sp = Sp + 16;
           call _c8nao() args: 0, res: 0, upd: 0;
     }
 },
 _c8n9L() //  [R1]
         { info_tbl: [(c8n9L,
                       label: block_c8n9L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8n9L: // global
           if (R1 & 7 == 1) goto u8naB; else goto u8naC;
       u8naB: // global
           Sp = Sp + 8;
           call _c8nao() args: 0, res: 0, upd: 0;
       u8naC: // global
           Sp = Sp + 8;
           call _c8nas() args: 0, res: 0, upd: 0;
     }
 },
 _c8na5() //  [R1]
         { info_tbl: [(c8na5,
                       label: block_c8na5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8na5: // global
           if (R1 & 7 == 1) goto u8nax; else goto c8nai;
       u8nax: // global
           Sp = Sp + 16;
           call _c8nao() args: 0, res: 0, upd: 0;
       c8nai: // global
           _s8jbf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8nag_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbf::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nag() //  [R1]
         { info_tbl: [(c8nag,
                       label: block_c8nag_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nag: // global
           if (R1 & 7 == 1) goto u8nay; else goto u8naz;
       u8nay: // global
           Sp = Sp + 8;
           call _c8nao() args: 0, res: 0, upd: 0;
       u8naz: // global
           Sp = Sp + 8;
           call _c8nas() args: 0, res: 0, upd: 0;
     }
 },
 _c8nao() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nao: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nas() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nas: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.669364868 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_closure" {
     GHC.IO.Exception.$fEqArrayException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqArrayException_$c==_closure+2;
         const GHC.IO.Exception.$fEqArrayException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.671920366 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8nbB,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nbB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nbC; else goto c8nbD;
       c8nbC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nbD: // global
           I64[Sp - 16] = block_c8nbu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ncG; else goto c8nbv;
       u8ncG: // global
           call _c8nbu(R1) args: 0, res: 0, upd: 0;
       c8nbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nbu() //  [R1]
         { info_tbl: [(c8nbu,
                       label: block_c8nbu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nbu: // global
           _s8jbk::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8nby; else goto c8nbz;
       c8nby: // global
           I64[Sp] = block_c8nbG_info;
           _s8jbn::P64 = P64[R1 + 7];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbn::P64;
           if (R1 & 7 != 0) goto u8ncE; else goto c8nbI;
       u8ncE: // global
           call _c8nbG(R1) args: 0, res: 0, upd: 0;
       c8nbI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nbz: // global
           I64[Sp] = block_c8nc6_info;
           _s8jbs::P64 = P64[R1 + 6];
           R1 = _s8jbk::P64;
           P64[Sp + 8] = _s8jbs::P64;
           if (R1 & 7 != 0) goto u8ncF; else goto c8nc8;
       u8ncF: // global
           call _c8nc6(R1) args: 0, res: 0, upd: 0;
       c8nc8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nbG() //  [R1]
         { info_tbl: [(c8nbG,
                       label: block_c8nbG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nbG: // global
           if (R1 & 7 == 1) goto c8nbP; else goto u8ncB;
       c8nbP: // global
           _s8jbn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8nbM_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbn::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8ncB: // global
           Sp = Sp + 16;
           call _c8nct() args: 0, res: 0, upd: 0;
     }
 },
 _c8nbM() //  [R1]
         { info_tbl: [(c8nbM,
                       label: block_c8nbM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nbM: // global
           if (R1 & 7 == 1) goto u8ncC; else goto u8ncD;
       u8ncC: // global
           Sp = Sp + 8;
           call _c8nct() args: 0, res: 0, upd: 0;
       u8ncD: // global
           Sp = Sp + 8;
           call _c8ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c8nc6() //  [R1]
         { info_tbl: [(c8nc6,
                       label: block_c8nc6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nc6: // global
           if (R1 & 7 == 1) goto u8ncy; else goto c8ncj;
       u8ncy: // global
           Sp = Sp + 16;
           call _c8ncp() args: 0, res: 0, upd: 0;
       c8ncj: // global
           _s8jbs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8nch_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nch() //  [R1]
         { info_tbl: [(c8nch,
                       label: block_c8nch_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nch: // global
           if (R1 & 7 == 1) goto u8ncz; else goto u8ncA;
       u8ncz: // global
           Sp = Sp + 8;
           call _c8nct() args: 0, res: 0, upd: 0;
       u8ncA: // global
           Sp = Sp + 8;
           call _c8ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c8nct() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nct: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ncp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ncp: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.686901704 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmax_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmax_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8ndB,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ndB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ndC; else goto c8ndD;
       c8ndC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ndD: // global
           I64[Sp - 16] = block_c8ndu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8neF; else goto c8ndv;
       u8neF: // global
           call _c8ndu(R1) args: 0, res: 0, upd: 0;
       c8ndv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ndu() //  [R1]
         { info_tbl: [(c8ndu,
                       label: block_c8ndu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ndu: // global
           _s8jbx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ndy; else goto c8ndz;
       c8ndy: // global
           I64[Sp - 8] = block_c8ndG_info;
           _s8jbz::P64 = R1;
           _s8jbA::P64 = P64[R1 + 7];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbA::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8neD; else goto c8ndI;
       u8neD: // global
           call _c8ndG(R1) args: 0, res: 0, upd: 0;
       c8ndI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ndz: // global
           I64[Sp - 8] = block_c8ne6_info;
           _s8jbz::P64 = R1;
           _s8jbF::P64 = P64[R1 + 6];
           R1 = _s8jbx::P64;
           P64[Sp] = _s8jbF::P64;
           P64[Sp + 8] = _s8jbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8neE; else goto c8ne8;
       u8neE: // global
           call _c8ne6(R1) args: 0, res: 0, upd: 0;
       c8ne8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ndG() //  [R1]
         { info_tbl: [(c8ndG,
                       label: block_c8ndG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ndG: // global
           if (R1 & 7 == 1) goto c8ndP; else goto u8neA;
       c8ndP: // global
           I64[Sp] = block_c8ndM_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8neA: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8ne3() args: 0, res: 0, upd: 0;
     }
 },
 _c8ndM() //  [R1]
         { info_tbl: [(c8ndM,
                       label: block_c8ndM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ndM: // global
           if (R1 & 7 == 1) goto u8neB; else goto u8neC;
       u8neB: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8ne3() args: 0, res: 0, upd: 0;
       u8neC: // global
           Sp = Sp + 16;
           call _c8nep() args: 0, res: 0, upd: 0;
     }
 },
 _c8ne3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ne3: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ne6() //  [R1]
         { info_tbl: [(c8ne6,
                       label: block_c8ne6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ne6: // global
           if (R1 & 7 == 1) goto u8ney; else goto c8nej;
       u8ney: // global
           Sp = Sp + 16;
           call _c8nep() args: 0, res: 0, upd: 0;
       c8nej: // global
           I64[Sp] = block_c8neh_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8neh() //  [R1]
         { info_tbl: [(c8neh,
                       label: block_c8neh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8neh: // global
           if (R1 & 7 == 1) goto c8net; else goto u8nez;
       c8net: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8nez: // global
           Sp = Sp + 16;
           call _c8nep() args: 0, res: 0, upd: 0;
     }
 },
 _c8nep() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nep: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.703290718 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8nfE,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nfF; else goto c8nfG;
       c8nfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nfG: // global
           I64[Sp - 16] = block_c8nfx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ngJ; else goto c8nfy;
       u8ngJ: // global
           call _c8nfx(R1) args: 0, res: 0, upd: 0;
       c8nfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nfx() //  [R1]
         { info_tbl: [(c8nfx,
                       label: block_c8nfx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nfx: // global
           _s8jbL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8nfB; else goto c8nfC;
       c8nfB: // global
           I64[Sp] = block_c8nfJ_info;
           _s8jbN::P64 = P64[R1 + 7];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbN::P64;
           if (R1 & 7 != 0) goto u8ngH; else goto c8nfL;
       u8ngH: // global
           call _c8nfJ(R1) args: 0, res: 0, upd: 0;
       c8nfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nfC: // global
           I64[Sp] = block_c8ng9_info;
           _s8jbS::P64 = P64[R1 + 6];
           R1 = _s8jbL::P64;
           P64[Sp + 8] = _s8jbS::P64;
           if (R1 & 7 != 0) goto u8ngI; else goto c8ngb;
       u8ngI: // global
           call _c8ng9(R1) args: 0, res: 0, upd: 0;
       c8ngb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nfJ() //  [R1]
         { info_tbl: [(c8nfJ,
                       label: block_c8nfJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nfJ: // global
           if (R1 & 7 == 1) goto c8nfS; else goto u8ngE;
       c8nfS: // global
           _s8jbN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8nfP_info;
           R3 = P64[R1 + 7];
           R2 = _s8jbN::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8ngE: // global
           Sp = Sp + 16;
           call _c8ngw() args: 0, res: 0, upd: 0;
     }
 },
 _c8nfP() //  [R1]
         { info_tbl: [(c8nfP,
                       label: block_c8nfP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nfP: // global
           if (R1 & 7 == 1) goto u8ngF; else goto u8ngG;
       u8ngF: // global
           Sp = Sp + 8;
           call _c8ngw() args: 0, res: 0, upd: 0;
       u8ngG: // global
           Sp = Sp + 8;
           call _c8ngs() args: 0, res: 0, upd: 0;
     }
 },
 _c8ng9() //  [R1]
         { info_tbl: [(c8ng9,
                       label: block_c8ng9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ng9: // global
           if (R1 & 7 == 1) goto u8ngB; else goto c8ngm;
       u8ngB: // global
           Sp = Sp + 16;
           call _c8ngs() args: 0, res: 0, upd: 0;
       c8ngm: // global
           _s8jbS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ngk_info;
           R3 = P64[R1 + 6];
           R2 = _s8jbS::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ngk() //  [R1]
         { info_tbl: [(c8ngk,
                       label: block_c8ngk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ngk: // global
           if (R1 & 7 == 1) goto u8ngC; else goto u8ngD;
       u8ngC: // global
           Sp = Sp + 8;
           call _c8ngw() args: 0, res: 0, upd: 0;
       u8ngD: // global
           Sp = Sp + 8;
           call _c8ngs() args: 0, res: 0, upd: 0;
     }
 },
 _c8ngw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ngw: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ngs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ngs: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.717766809 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8nhx,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nhx: // global
           _s8jbY::P64 = R3;
           R3 = R2;
           R2 = _s8jbY::P64;
           call GHC.IO.Exception.$fOrdArrayException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.721891238 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmin_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmin_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8nhP,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nhP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nhQ; else goto c8nhR;
       c8nhQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nhR: // global
           I64[Sp - 16] = block_c8nhI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8niT; else goto c8nhJ;
       u8niT: // global
           call _c8nhI(R1) args: 0, res: 0, upd: 0;
       c8nhJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nhI() //  [R1]
         { info_tbl: [(c8nhI,
                       label: block_c8nhI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nhI: // global
           _s8jbZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8nhM; else goto c8nhN;
       c8nhM: // global
           I64[Sp - 8] = block_c8nhU_info;
           _s8jc1::P64 = R1;
           _s8jc2::P64 = P64[R1 + 7];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc2::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8niR; else goto c8nhW;
       u8niR: // global
           call _c8nhU(R1) args: 0, res: 0, upd: 0;
       c8nhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nhN: // global
           I64[Sp - 8] = block_c8nik_info;
           _s8jc1::P64 = R1;
           _s8jc7::P64 = P64[R1 + 6];
           R1 = _s8jbZ::P64;
           P64[Sp] = _s8jc7::P64;
           P64[Sp + 8] = _s8jc1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8niS; else goto c8nim;
       u8niS: // global
           call _c8nik(R1) args: 0, res: 0, upd: 0;
       c8nim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nhU() //  [R1]
         { info_tbl: [(c8nhU,
                       label: block_c8nhU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nhU: // global
           if (R1 & 7 == 1) goto c8ni3; else goto u8niP;
       c8ni3: // global
           I64[Sp] = block_c8ni0_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8niP: // global
           Sp = Sp + 16;
           call _c8niH() args: 0, res: 0, upd: 0;
     }
 },
 _c8ni0() //  [R1]
         { info_tbl: [(c8ni0,
                       label: block_c8ni0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ni0: // global
           if (R1 & 7 == 1) goto u8niQ; else goto c8ni9;
       u8niQ: // global
           Sp = Sp + 16;
           call _c8niH() args: 0, res: 0, upd: 0;
       c8ni9: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nik() //  [R1]
         { info_tbl: [(c8nik,
                       label: block_c8nik_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nik: // global
           if (R1 & 7 == 1) goto u8niM; else goto c8nix;
       u8niM: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8niD() args: 0, res: 0, upd: 0;
       c8nix: // global
           I64[Sp] = block_c8niv_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8niv() //  [R1]
         { info_tbl: [(c8niv,
                       label: block_c8niv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8niv: // global
           if (R1 & 7 == 1) goto u8niN; else goto u8niO;
       u8niN: // global
           Sp = Sp + 16;
           call _c8niH() args: 0, res: 0, upd: 0;
       u8niO: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8niD() args: 0, res: 0, upd: 0;
     }
 },
 _c8niH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8niH: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8niD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8niD: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.737209565 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_closure" {
     GHC.IO.Exception.$fOrdArrayException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqArrayException_closure+1;
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.74004204 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c==_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c==_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c==_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8njV,
                       label: GHC.IO.Exception.$fEqAsyncException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8njV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8njW; else goto c8njX;
       c8njW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8njX: // global
           I64[Sp - 16] = block_c8njM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nle; else goto c8njN;
       u8nle: // global
           call _c8njM(R1) args: 0, res: 0, upd: 0;
       c8njN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8njM() //  [R1]
         { info_tbl: [(c8njM,
                       label: block_c8njM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8njM: // global
           _s8jcd::P64 = P64[Sp + 8];
           _c8njU::P64 = R1 & 7;
           if (_c8njU::P64 < 3) goto u8nl0; else goto u8nl1;
       u8nl0: // global
           if (_c8njU::P64 < 2) goto c8njQ; else goto c8njR;
       c8njQ: // global
           I64[Sp + 8] = block_c8nk0_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nla; else goto c8nk2;
       u8nla: // global
           call _c8nk0(R1) args: 0, res: 0, upd: 0;
       c8nk2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8njR: // global
           I64[Sp + 8] = block_c8nkf_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nlb; else goto c8nkh;
       u8nlb: // global
           call _c8nkf(R1) args: 0, res: 0, upd: 0;
       c8nkh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nl1: // global
           if (_c8njU::P64 < 4) goto c8njS; else goto c8njT;
       c8njS: // global
           I64[Sp + 8] = block_c8nku_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nlc; else goto c8nkw;
       u8nlc: // global
           call _c8nku(R1) args: 0, res: 0, upd: 0;
       c8nkw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8njT: // global
           I64[Sp + 8] = block_c8nkJ_info;
           R1 = _s8jcd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nld; else goto c8nkL;
       u8nld: // global
           call _c8nkJ(R1) args: 0, res: 0, upd: 0;
       c8nkL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nk0() //  [R1]
         { info_tbl: [(c8nk0,
                       label: block_c8nk0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nk0: // global
           if (R1 & 7 == 1) goto u8nl2; else goto u8nl3;
       u8nl2: // global
           Sp = Sp + 8;
           call _c8nkV() args: 0, res: 0, upd: 0;
       u8nl3: // global
           Sp = Sp + 8;
           call _c8nkR() args: 0, res: 0, upd: 0;
     }
 },
 _c8nkf() //  [R1]
         { info_tbl: [(c8nkf,
                       label: block_c8nkf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nkf: // global
           if (R1 & 7 == 2) goto u8nl4; else goto u8nl5;
       u8nl4: // global
           Sp = Sp + 8;
           call _c8nkV() args: 0, res: 0, upd: 0;
       u8nl5: // global
           Sp = Sp + 8;
           call _c8nkR() args: 0, res: 0, upd: 0;
     }
 },
 _c8nku() //  [R1]
         { info_tbl: [(c8nku,
                       label: block_c8nku_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nku: // global
           if (R1 & 7 == 3) goto u8nl6; else goto u8nl7;
       u8nl6: // global
           Sp = Sp + 8;
           call _c8nkV() args: 0, res: 0, upd: 0;
       u8nl7: // global
           Sp = Sp + 8;
           call _c8nkR() args: 0, res: 0, upd: 0;
     }
 },
 _c8nkJ() //  [R1]
         { info_tbl: [(c8nkJ,
                       label: block_c8nkJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nkJ: // global
           if (R1 & 7 == 4) goto u8nl8; else goto u8nl9;
       u8nl8: // global
           Sp = Sp + 8;
           call _c8nkV() args: 0, res: 0, upd: 0;
       u8nl9: // global
           Sp = Sp + 8;
           call _c8nkR() args: 0, res: 0, upd: 0;
     }
 },
 _c8nkV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nkV: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nkR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nkR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.75555775 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c/=_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c/=_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c/=_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8nme,
                       label: GHC.IO.Exception.$fEqAsyncException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nme: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nmf; else goto c8nmg;
       c8nmf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nmg: // global
           I64[Sp - 16] = block_c8nm5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nnx; else goto c8nm6;
       u8nnx: // global
           call _c8nm5(R1) args: 0, res: 0, upd: 0;
       c8nm6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nm5() //  [R1]
         { info_tbl: [(c8nm5,
                       label: block_c8nm5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nm5: // global
           _s8jck::P64 = P64[Sp + 8];
           _c8nmd::P64 = R1 & 7;
           if (_c8nmd::P64 < 3) goto u8nnj; else goto u8nnk;
       u8nnj: // global
           if (_c8nmd::P64 < 2) goto c8nm9; else goto c8nma;
       c8nm9: // global
           I64[Sp + 8] = block_c8nmj_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nnt; else goto c8nml;
       u8nnt: // global
           call _c8nmj(R1) args: 0, res: 0, upd: 0;
       c8nml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nma: // global
           I64[Sp + 8] = block_c8nmy_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nnu; else goto c8nmA;
       u8nnu: // global
           call _c8nmy(R1) args: 0, res: 0, upd: 0;
       c8nmA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nnk: // global
           if (_c8nmd::P64 < 4) goto c8nmb; else goto c8nmc;
       c8nmb: // global
           I64[Sp + 8] = block_c8nmN_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nnv; else goto c8nmP;
       u8nnv: // global
           call _c8nmN(R1) args: 0, res: 0, upd: 0;
       c8nmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nmc: // global
           I64[Sp + 8] = block_c8nn2_info;
           R1 = _s8jck::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nnw; else goto c8nn4;
       u8nnw: // global
           call _c8nn2(R1) args: 0, res: 0, upd: 0;
       c8nn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nmj() //  [R1]
         { info_tbl: [(c8nmj,
                       label: block_c8nmj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nmj: // global
           if (R1 & 7 == 1) goto u8nnl; else goto u8nnm;
       u8nnl: // global
           Sp = Sp + 8;
           call _c8nne() args: 0, res: 0, upd: 0;
       u8nnm: // global
           Sp = Sp + 8;
           call _c8nna() args: 0, res: 0, upd: 0;
     }
 },
 _c8nmy() //  [R1]
         { info_tbl: [(c8nmy,
                       label: block_c8nmy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nmy: // global
           if (R1 & 7 == 2) goto u8nnn; else goto u8nno;
       u8nnn: // global
           Sp = Sp + 8;
           call _c8nne() args: 0, res: 0, upd: 0;
       u8nno: // global
           Sp = Sp + 8;
           call _c8nna() args: 0, res: 0, upd: 0;
     }
 },
 _c8nmN() //  [R1]
         { info_tbl: [(c8nmN,
                       label: block_c8nmN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nmN: // global
           if (R1 & 7 == 3) goto u8nnp; else goto u8nnq;
       u8nnp: // global
           Sp = Sp + 8;
           call _c8nne() args: 0, res: 0, upd: 0;
       u8nnq: // global
           Sp = Sp + 8;
           call _c8nna() args: 0, res: 0, upd: 0;
     }
 },
 _c8nn2() //  [R1]
         { info_tbl: [(c8nn2,
                       label: block_c8nn2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nn2: // global
           if (R1 & 7 == 4) goto u8nnr; else goto u8nns;
       u8nnr: // global
           Sp = Sp + 8;
           call _c8nne() args: 0, res: 0, upd: 0;
       u8nns: // global
           Sp = Sp + 8;
           call _c8nna() args: 0, res: 0, upd: 0;
     }
 },
 _c8nne() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nne: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nna() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nna: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.770106605 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_closure" {
     GHC.IO.Exception.$fEqAsyncException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqAsyncException_$c==_closure+2;
         const GHC.IO.Exception.$fEqAsyncException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.772766417 UTC

[section ""data" . GHC.IO.Exception.ioe_filename_closure" {
     GHC.IO.Exception.ioe_filename_closure:
         const GHC.IO.Exception.ioe_filename_info;
 },
 GHC.IO.Exception.ioe_filename_entry() //  [R2]
         { info_tbl: [(c8nos,
                       label: GHC.IO.Exception.ioe_filename_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nos: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8not; else goto c8nou;
       c8not: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_filename_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nou: // global
           I64[Sp - 8] = block_c8nop_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8noy; else goto c8noq;
       u8noy: // global
           call _c8nop(R1) args: 0, res: 0, upd: 0;
       c8noq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nop() //  [R1]
         { info_tbl: [(c8nop,
                       label: block_c8nop_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nop: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.778147179 UTC

[section ""data" . GHC.IO.Exception.ioe_errno_closure" {
     GHC.IO.Exception.ioe_errno_closure:
         const GHC.IO.Exception.ioe_errno_info;
 },
 GHC.IO.Exception.ioe_errno_entry() //  [R2]
         { info_tbl: [(c8noR,
                       label: GHC.IO.Exception.ioe_errno_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8noR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8noS; else goto c8noT;
       c8noS: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_errno_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8noT: // global
           I64[Sp - 8] = block_c8noO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8noX; else goto c8noP;
       u8noX: // global
           call _c8noO(R1) args: 0, res: 0, upd: 0;
       c8noP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8noO() //  [R1]
         { info_tbl: [(c8noO,
                       label: block_c8noO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8noO: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.785370641 UTC

[section ""data" . GHC.IO.Exception.ioe_description_closure" {
     GHC.IO.Exception.ioe_description_closure:
         const GHC.IO.Exception.ioe_description_info;
 },
 GHC.IO.Exception.ioe_description_entry() //  [R2]
         { info_tbl: [(c8npg,
                       label: GHC.IO.Exception.ioe_description_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8npg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8nph; else goto c8npi;
       c8nph: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_description_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8npi: // global
           I64[Sp - 8] = block_c8npd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8npm; else goto c8npe;
       u8npm: // global
           call _c8npd(R1) args: 0, res: 0, upd: 0;
       c8npe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8npd() //  [R1]
         { info_tbl: [(c8npd,
                       label: block_c8npd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8npd: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.79087283 UTC

[section ""data" . GHC.IO.Exception.ioe_location_closure" {
     GHC.IO.Exception.ioe_location_closure:
         const GHC.IO.Exception.ioe_location_info;
 },
 GHC.IO.Exception.ioe_location_entry() //  [R2]
         { info_tbl: [(c8npF,
                       label: GHC.IO.Exception.ioe_location_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8npF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8npG; else goto c8npH;
       c8npG: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_location_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8npH: // global
           I64[Sp - 8] = block_c8npC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8npL; else goto c8npD;
       u8npL: // global
           call _c8npC(R1) args: 0, res: 0, upd: 0;
       c8npD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8npC() //  [R1]
         { info_tbl: [(c8npC,
                       label: block_c8npC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8npC: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.796229316 UTC

[section ""data" . GHC.IO.Exception.ioe_type_closure" {
     GHC.IO.Exception.ioe_type_closure:
         const GHC.IO.Exception.ioe_type_info;
 },
 GHC.IO.Exception.ioe_type_entry() //  [R2]
         { info_tbl: [(c8nq4,
                       label: GHC.IO.Exception.ioe_type_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nq4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8nq5; else goto c8nq6;
       c8nq5: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_type_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nq6: // global
           I64[Sp - 8] = block_c8nq1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nqa; else goto c8nq2;
       u8nqa: // global
           call _c8nq1(R1) args: 0, res: 0, upd: 0;
       c8nq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nq1() //  [R1]
         { info_tbl: [(c8nq1,
                       label: block_c8nq1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nq1: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.801475723 UTC

[section ""data" . GHC.IO.Exception.ioe_handle_closure" {
     GHC.IO.Exception.ioe_handle_closure:
         const GHC.IO.Exception.ioe_handle_info;
 },
 GHC.IO.Exception.ioe_handle_entry() //  [R2]
         { info_tbl: [(c8nqt,
                       label: GHC.IO.Exception.ioe_handle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nqt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8nqu; else goto c8nqv;
       c8nqu: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_handle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nqv: // global
           I64[Sp - 8] = block_c8nqq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nqz; else goto c8nqr;
       u8nqz: // global
           call _c8nqq(R1) args: 0, res: 0, upd: 0;
       c8nqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nqq() //  [R1]
         { info_tbl: [(c8nqq,
                       label: block_c8nqq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nqq: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.807584343 UTC

[section ""data" . GHC.IO.Exception.userError_closure" {
     GHC.IO.Exception.userError_closure:
         const GHC.IO.Exception.userError_info;
 },
 GHC.IO.Exception.userError_entry() //  [R2]
         { info_tbl: [(c8nqQ,
                       label: GHC.IO.Exception.userError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nqQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8nqU; else goto c8nqT;
       c8nqU: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.IO.Exception.userError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nqT: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.811391569 UTC

[section ""cstring" . GHC.IO.Exception.unsupportedOperation2_bytes" {
     GHC.IO.Exception.unsupportedOperation2_bytes:
         I8[] [79,112,101,114,97,116,105,111,110,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.813316664 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation1_closure" {
     GHC.IO.Exception.unsupportedOperation1_closure:
         const GHC.IO.Exception.unsupportedOperation1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.unsupportedOperation1_entry() //  [R1]
         { info_tbl: [(c8nr7,
                       label: GHC.IO.Exception.unsupportedOperation1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nr7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nr8; else goto c8nr9;
       c8nr8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nr9: // global
           (_c8nr4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nr4::I64 == 0) goto c8nr6; else goto c8nr5;
       c8nr6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nr5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nr4::I64;
           R2 = GHC.IO.Exception.unsupportedOperation2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.817157865 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation_closure" {
     GHC.IO.Exception.unsupportedOperation_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Exception.unsupportedOperation1_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.819041417 UTC

[section ""data" . GHC.IO.Exception.untangle1_closure" {
     GHC.IO.Exception.untangle1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.821041072 UTC

[section ""data" . GHC.IO.Exception.untangle4_closure" {
     GHC.IO.Exception.untangle4_closure:
         const GHC.IO.Exception.untangle4_info;
 },
 GHC.IO.Exception.untangle4_entry() //  [R2]
         { info_tbl: [(c8nrq,
                       label: GHC.IO.Exception.untangle4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nrq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8nrr; else goto c8nrs;
       c8nrr: // global
           R2 = R2;
           R1 = GHC.IO.Exception.untangle4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nrs: // global
           I64[Sp - 8] = block_c8nrn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nrA; else goto c8nro;
       u8nrA: // global
           call _c8nrn(R1) args: 0, res: 0, upd: 0;
       c8nro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nrn() //  [R1]
         { info_tbl: [(c8nrn,
                       label: block_c8nrn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nrn: // global
           if (I64[R1 + 7] == 124) goto c8nrz; else goto c8nry;
       c8nrz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nry: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.826757975 UTC

[section ""cstring" . GHC.IO.Exception.untangle3_bytes" {
     GHC.IO.Exception.untangle3_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.828630685 UTC

[section ""data" . GHC.IO.Exception.untangle2_closure" {
     GHC.IO.Exception.untangle2_closure:
         const GHC.IO.Exception.untangle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.untangle2_entry() //  [R1]
         { info_tbl: [(c8nrT,
                       label: GHC.IO.Exception.untangle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nrT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nrU; else goto c8nrV;
       c8nrU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nrV: // global
           (_c8nrQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nrQ::I64 == 0) goto c8nrS; else goto c8nrR;
       c8nrS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nrR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nrQ::I64;
           R2 = GHC.IO.Exception.untangle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.833739327 UTC

[section ""data" . GHC.IO.Exception.untangle_closure" {
     GHC.IO.Exception.untangle_closure:
         const GHC.IO.Exception.untangle_info;
         const 0;
 },
 sat_s8jdq_entry() //  [R1]
         { info_tbl: [(c8nsJ,
                       label: sat_s8jdq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsJ: // global
           R3 = GHC.IO.Exception.untangle2_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jdr_entry() //  [R1]
         { info_tbl: [(c8nsM,
                       label: sat_s8jdr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsM: // global
           _s8jdr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8nsN; else goto c8nsO;
       c8nsO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nsQ; else goto c8nsP;
       c8nsQ: // global
           HpAlloc = 24;
           goto c8nsN;
       c8nsN: // global
           R1 = _s8jdr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nsP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jdr::P64;
           _s8jdi::P64 = P64[_s8jdr::P64 + 16];
           _s8jdp::P64 = P64[_s8jdr::P64 + 24];
           I64[Hp - 16] = sat_s8jdq_info;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 16;
           R2 = _s8jdi::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jds_entry() //  [R1]
         { info_tbl: [(c8nsR,
                       label: sat_s8jds_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8nsV; else goto c8nsU;
       c8nsV: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nsU: // global
           _s8jdi::P64 = P64[R1 + 16];
           _s8jdp::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8jdr_info;
           P64[Hp - 8] = _s8jdi::P64;
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.untangle_entry() //  [R2, R3]
         { info_tbl: [(c8nsW,
                       label: GHC.IO.Exception.untangle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8nsX; else goto c8nsY;
       c8nsX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.untangle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nsY: // global
           I64[Sp - 16] = block_c8ns7_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.CString.unpackCStringUtf8#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ns7() //  [R1]
         { info_tbl: [(c8ns7,
                       label: block_c8ns7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ns7: // global
           I64[Sp] = block_c8nsb_info;
           R3 = R1;
           R2 = GHC.IO.Exception.untangle4_closure+1;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nsb() //  [R1, R2]
         { info_tbl: [(c8nsb,
                       label: block_c8nsb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsb: // global
           I64[Sp - 8] = block_c8nsf_info;
           _s8jdl::P64 = R1;
           R1 = R2;
           P64[Sp] = _s8jdl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ntl; else goto c8nsg;
       u8ntl: // global
           call _c8nsf(R1) args: 0, res: 0, upd: 0;
       c8nsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nsf() //  [R1]
         { info_tbl: [(c8nsf,
                       label: block_c8nsf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsf: // global
           if (R1 & 7 == 1) goto c8nt7; else goto c8nt9;
       c8nt7: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp] = GHC.Types.[]_closure+1;
           call _c8nsv() args: 0, res: 0, upd: 0;
       c8nt9: // global
           I64[Sp - 8] = block_c8nsl_info;
           _s8jdv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jdv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ntm; else goto c8nsm;
       u8ntm: // global
           call _c8nsl(R1) args: 0, res: 0, upd: 0;
       c8nsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nsl() //  [R1]
         { info_tbl: [(c8nsl,
                       label: block_c8nsl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ntc; else goto c8ntb;
       c8ntc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ntb: // global
           _s8jdl::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 124) goto c8ntf; else goto c8nte;
       c8ntf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.IO.Exception.untangle1_closure+1;
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 16] = _s8jdl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           goto u8ntp;
       c8nte: // global
           Hp = Hp - 24;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           P64[Sp + 16] = _s8jdl::P64;
           Sp = Sp + 8;
           goto u8ntp;
       u8ntp: // global
           call _c8nsv() args: 0, res: 0, upd: 0;
     }
 },
 _c8nsv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsv: // global
           Hp = Hp + 32;
           _s8jdo::P64 = P64[Sp + 8];
           _s8jdp::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto c8nt3; else goto c8nt2;
       c8nt3: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c8nsu_info;
           R2 = _s8jdp::P64;
           R1 = _s8jdo::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8nt2: // global
           I64[Hp - 24] = sat_s8jds_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8jdp::P64;
           R3 = Hp - 24;
           R2 = _s8jdo::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8nsu() //  [R1, R2]
         { info_tbl: [(c8nsu,
                       label: block_c8nsu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nsu: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c8nsv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.855487015 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8nui,
                       label: GHC.IO.Exception.$fOrdAsyncException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nuj; else goto c8nuk;
       c8nuj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nuk: // global
           I64[Sp - 16] = block_c8nu9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nw3; else goto c8nua;
       u8nw3: // global
           call _c8nu9(R1) args: 0, res: 0, upd: 0;
       c8nua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nu9() //  [R1]
         { info_tbl: [(c8nu9,
                       label: block_c8nu9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nu9: // global
           _s8jdB::P64 = P64[Sp + 8];
           _c8nuh::P64 = R1 & 7;
           if (_c8nuh::P64 < 3) goto u8nvH; else goto u8nvI;
       u8nvH: // global
           if (_c8nuh::P64 < 2) goto c8nud; else goto c8nue;
       c8nud: // global
           I64[Sp + 8] = block_c8nun_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nvZ; else goto c8nup;
       u8nvZ: // global
           call _c8nun(R1) args: 0, res: 0, upd: 0;
       c8nup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nue: // global
           I64[Sp + 8] = block_c8nuK_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nw0; else goto c8nuM;
       u8nw0: // global
           call _c8nuK(R1) args: 0, res: 0, upd: 0;
       c8nuM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nvI: // global
           if (_c8nuh::P64 < 4) goto c8nuf; else goto c8nug;
       c8nuf: // global
           I64[Sp + 8] = block_c8nv7_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nw1; else goto c8nv9;
       u8nw1: // global
           call _c8nv7(R1) args: 0, res: 0, upd: 0;
       c8nv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nug: // global
           I64[Sp + 8] = block_c8nvq_info;
           R1 = _s8jdB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nw2; else goto c8nvs;
       u8nw2: // global
           call _c8nvq(R1) args: 0, res: 0, upd: 0;
       c8nvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nun() //  [R1]
         { info_tbl: [(c8nun,
                       label: block_c8nun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nun: // global
           _c8nvG::P64 = R1 & 7;
           if (_c8nvG::P64 < 2) goto u8nvN; else goto u8nvJ;
       u8nvN: // global
           Sp = Sp + 8;
           call _c8nvC() args: 0, res: 0, upd: 0;
       u8nvJ: // global
           if (_c8nvG::P64 != 3) goto u8nvP; else goto u8nvP;
       u8nvP: // global
           Sp = Sp + 8;
           call _c8nvn() args: 0, res: 0, upd: 0;
     }
 },
 _c8nuK() //  [R1]
         { info_tbl: [(c8nuK,
                       label: block_c8nuK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nuK: // global
           _c8nvF::P64 = R1 & 7;
           if (_c8nvF::P64 < 3) goto u8nvK; else goto u8nvL;
       u8nvK: // global
           if (_c8nvF::P64 < 2) goto u8nvR; else goto u8nvQ;
       u8nvR: // global
           Sp = Sp + 8;
           call _c8nvy() args: 0, res: 0, upd: 0;
       u8nvQ: // global
           Sp = Sp + 8;
           call _c8nvC() args: 0, res: 0, upd: 0;
       u8nvL: // global
           if (_c8nvF::P64 < 4) goto u8nvT; else goto u8nvT;
       u8nvT: // global
           Sp = Sp + 8;
           call _c8nvn() args: 0, res: 0, upd: 0;
     }
 },
 _c8nv7() //  [R1]
         { info_tbl: [(c8nv7,
                       label: block_c8nv7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nv7: // global
           _c8nvE::P64 = R1 & 7;
           if (_c8nvE::P64 != 3) goto u8nvM; else goto u8nvU;
       u8nvM: // global
           if (_c8nvE::P64 != 4) goto u8nvW; else goto u8nvV;
       u8nvW: // global
           Sp = Sp + 8;
           call _c8nvy() args: 0, res: 0, upd: 0;
       u8nvV: // global
           Sp = Sp + 8;
           call _c8nvn() args: 0, res: 0, upd: 0;
       u8nvU: // global
           Sp = Sp + 8;
           call _c8nvC() args: 0, res: 0, upd: 0;
     }
 },
 _c8nvn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nvn: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nvq() //  [R1]
         { info_tbl: [(c8nvq,
                       label: block_c8nvq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nvq: // global
           if (R1 & 7 == 4) goto u8nvX; else goto u8nvY;
       u8nvX: // global
           Sp = Sp + 8;
           call _c8nvC() args: 0, res: 0, upd: 0;
       u8nvY: // global
           Sp = Sp + 8;
           call _c8nvy() args: 0, res: 0, upd: 0;
     }
 },
 _c8nvC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nvC: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nvy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nvy: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.872047482 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8nx5,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nx5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nx6; else goto c8nx7;
       c8nx6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nx7: // global
           I64[Sp - 16] = block_c8nwW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nyv; else goto c8nwX;
       u8nyv: // global
           call _c8nwW(R1) args: 0, res: 0, upd: 0;
       c8nwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nwW() //  [R1]
         { info_tbl: [(c8nwW,
                       label: block_c8nwW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nwW: // global
           _s8jdI::P64 = P64[Sp + 8];
           _c8nx4::P64 = R1 & 7;
           if (_c8nx4::P64 < 3) goto u8nyf; else goto u8nyg;
       u8nyf: // global
           if (_c8nx4::P64 < 2) goto c8nx0; else goto c8nx1;
       c8nx0: // global
           I64[Sp + 8] = block_c8nxa_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nyr; else goto c8nxc;
       u8nyr: // global
           call _c8nxa(R1) args: 0, res: 0, upd: 0;
       c8nxc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nx1: // global
           I64[Sp + 8] = block_c8nxx_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nys; else goto c8nxz;
       u8nys: // global
           call _c8nxx(R1) args: 0, res: 0, upd: 0;
       c8nxz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nyg: // global
           if (_c8nx4::P64 < 4) goto c8nx2; else goto c8nx3;
       c8nx2: // global
           I64[Sp + 8] = block_c8nxQ_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nyt; else goto c8nxS;
       u8nyt: // global
           call _c8nxQ(R1) args: 0, res: 0, upd: 0;
       c8nxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nx3: // global
           I64[Sp + 8] = block_c8ny5_info;
           R1 = _s8jdI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nyu; else goto c8ny7;
       u8nyu: // global
           call _c8ny5() args: 0, res: 0, upd: 0;
       c8ny7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nxa() //  [R1]
         { info_tbl: [(c8nxa,
                       label: block_c8nxa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nxa: // global
           _c8nye::P64 = R1 & 7;
           if (_c8nye::P64 < 2) goto u8nyj; else goto u8nyh;
       u8nyj: // global
           Sp = Sp + 8;
           call _c8nxY() args: 0, res: 0, upd: 0;
       u8nyh: // global
           if (_c8nye::P64 != 3) goto u8nyl; else goto u8nyl;
       u8nyl: // global
           Sp = Sp + 8;
           call _c8ny2() args: 0, res: 0, upd: 0;
     }
 },
 _c8nxx() //  [R1]
         { info_tbl: [(c8nxx,
                       label: block_c8nxx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nxx: // global
           _c8nyd::P64 = R1 & 7;
           if (_c8nyd::P64 != 3) goto u8nyi; else goto u8nym;
       u8nyi: // global
           if (_c8nyd::P64 != 4) goto u8nyo; else goto u8nyn;
       u8nyo: // global
           Sp = Sp + 8;
           call _c8nxY() args: 0, res: 0, upd: 0;
       u8nyn: // global
           Sp = Sp + 8;
           goto u8nyz;
       u8nym: // global
           Sp = Sp + 8;
           goto u8nyz;
       u8nyz: // global
           call _c8ny2() args: 0, res: 0, upd: 0;
     }
 },
 _c8nxQ() //  [R1]
         { info_tbl: [(c8nxQ,
                       label: block_c8nxQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nxQ: // global
           if (R1 & 7 == 4) goto u8nyp; else goto u8nyq;
       u8nyp: // global
           Sp = Sp + 8;
           call _c8ny2() args: 0, res: 0, upd: 0;
       u8nyq: // global
           Sp = Sp + 8;
           call _c8nxY() args: 0, res: 0, upd: 0;
     }
 },
 _c8ny2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ny2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nxY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nxY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ny5() //  []
         { info_tbl: [(c8ny5,
                       label: block_c8ny5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ny5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.888021408 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8nzr,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nzr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nzs; else goto c8nzt;
       c8nzs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nzt: // global
           I64[Sp - 16] = block_c8nzi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nAR; else goto c8nzj;
       u8nAR: // global
           call _c8nzi(R1) args: 0, res: 0, upd: 0;
       c8nzj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nzi() //  [R1]
         { info_tbl: [(c8nzi,
                       label: block_c8nzi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nzi: // global
           _s8jdO::P64 = P64[Sp + 8];
           _c8nzq::P64 = R1 & 7;
           if (_c8nzq::P64 < 3) goto u8nAB; else goto u8nAC;
       u8nAB: // global
           if (_c8nzq::P64 < 2) goto c8nzm; else goto c8nzn;
       c8nzm: // global
           I64[Sp + 8] = block_c8nzw_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nAN; else goto c8nzy;
       u8nAN: // global
           call _c8nzw(R1) args: 0, res: 0, upd: 0;
       c8nzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nzn: // global
           I64[Sp + 8] = block_c8nzT_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nAO; else goto c8nzV;
       u8nAO: // global
           call _c8nzT(R1) args: 0, res: 0, upd: 0;
       c8nzV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nAC: // global
           if (_c8nzq::P64 < 4) goto c8nzo; else goto c8nzp;
       c8nzo: // global
           I64[Sp + 8] = block_c8nAc_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nAP; else goto c8nAe;
       u8nAP: // global
           call _c8nAc(R1) args: 0, res: 0, upd: 0;
       c8nAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nzp: // global
           I64[Sp + 8] = block_c8nAr_info;
           R1 = _s8jdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nAQ; else goto c8nAt;
       u8nAQ: // global
           call _c8nAr() args: 0, res: 0, upd: 0;
       c8nAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nzw() //  [R1]
         { info_tbl: [(c8nzw,
                       label: block_c8nzw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nzw: // global
           _c8nAA::P64 = R1 & 7;
           if (_c8nAA::P64 < 2) goto u8nAF; else goto u8nAD;
       u8nAF: // global
           Sp = Sp + 8;
           call _c8nAk() args: 0, res: 0, upd: 0;
       u8nAD: // global
           if (_c8nAA::P64 != 3) goto u8nAH; else goto u8nAH;
       u8nAH: // global
           Sp = Sp + 8;
           call _c8nAo() args: 0, res: 0, upd: 0;
     }
 },
 _c8nzT() //  [R1]
         { info_tbl: [(c8nzT,
                       label: block_c8nzT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nzT: // global
           _c8nAz::P64 = R1 & 7;
           if (_c8nAz::P64 != 3) goto u8nAE; else goto u8nAI;
       u8nAE: // global
           if (_c8nAz::P64 != 4) goto u8nAK; else goto u8nAJ;
       u8nAK: // global
           Sp = Sp + 8;
           call _c8nAk() args: 0, res: 0, upd: 0;
       u8nAJ: // global
           Sp = Sp + 8;
           goto u8nAV;
       u8nAI: // global
           Sp = Sp + 8;
           goto u8nAV;
       u8nAV: // global
           call _c8nAo() args: 0, res: 0, upd: 0;
     }
 },
 _c8nAc() //  [R1]
         { info_tbl: [(c8nAc,
                       label: block_c8nAc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nAc: // global
           if (R1 & 7 == 4) goto u8nAL; else goto u8nAM;
       u8nAL: // global
           Sp = Sp + 8;
           call _c8nAo() args: 0, res: 0, upd: 0;
       u8nAM: // global
           Sp = Sp + 8;
           call _c8nAk() args: 0, res: 0, upd: 0;
     }
 },
 _c8nAo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nAo: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nAk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nAk: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nAr() //  []
         { info_tbl: [(c8nAr,
                       label: block_c8nAr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nAr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.903228011 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmax_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmax_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8nBN,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nBN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nBO; else goto c8nBP;
       c8nBO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nBP: // global
           I64[Sp - 16] = block_c8nBE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nCM; else goto c8nBF;
       u8nCM: // global
           call _c8nBE(R1) args: 0, res: 0, upd: 0;
       c8nBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nBE() //  [R1]
         { info_tbl: [(c8nBE,
                       label: block_c8nBE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nBE: // global
           _s8jdV::P64 = P64[Sp + 8];
           _c8nBM::P64 = R1 & 7;
           if (_c8nBM::P64 < 3) goto u8nCC; else goto u8nCD;
       u8nCC: // global
           if (_c8nBM::P64 < 2) goto c8nBI; else goto c8nBJ;
       c8nBI: // global
           R1 = _s8jdV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8nBJ: // global
           I64[Sp + 8] = block_c8nBV_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nCJ; else goto c8nBX;
       u8nCJ: // global
           call _c8nBV(R1) args: 0, res: 0, upd: 0;
       c8nBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nCD: // global
           if (_c8nBM::P64 < 4) goto c8nBK; else goto c8nBL;
       c8nBK: // global
           I64[Sp + 8] = block_c8nCe_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nCK; else goto c8nCg;
       u8nCK: // global
           call _c8nCe(R1) args: 0, res: 0, upd: 0;
       c8nCg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nBL: // global
           I64[Sp + 8] = block_c8nCt_info;
           R1 = _s8jdV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nCL; else goto c8nCv;
       u8nCL: // global
           call _c8nCt() args: 0, res: 0, upd: 0;
       c8nCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nBV() //  [R1]
         { info_tbl: [(c8nBV,
                       label: block_c8nBV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nBV: // global
           _c8nCB::P64 = R1 & 7;
           if (_c8nCB::P64 != 3) goto u8nCE; else goto u8nCF;
       u8nCE: // global
           if (_c8nCB::P64 != 4) goto c8nC3; else goto u8nCG;
       c8nC3: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8nCG: // global
           Sp = Sp + 8;
           call _c8nCq() args: 0, res: 0, upd: 0;
       u8nCF: // global
           Sp = Sp + 8;
           call _c8nCm() args: 0, res: 0, upd: 0;
     }
 },
 _c8nCe() //  [R1]
         { info_tbl: [(c8nCe,
                       label: block_c8nCe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nCe: // global
           if (R1 & 7 == 4) goto u8nCH; else goto u8nCI;
       u8nCH: // global
           Sp = Sp + 8;
           call _c8nCq() args: 0, res: 0, upd: 0;
       u8nCI: // global
           Sp = Sp + 8;
           call _c8nCm() args: 0, res: 0, upd: 0;
     }
 },
 _c8nCq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nCq: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nCm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nCm: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nCt() //  []
         { info_tbl: [(c8nCt,
                       label: block_c8nCt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nCt: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.917366235 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8nDD,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nDD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nDE; else goto c8nDF;
       c8nDE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nDF: // global
           I64[Sp - 16] = block_c8nDu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nF3; else goto c8nDv;
       u8nF3: // global
           call _c8nDu(R1) args: 0, res: 0, upd: 0;
       c8nDv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nDu() //  [R1]
         { info_tbl: [(c8nDu,
                       label: block_c8nDu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nDu: // global
           _s8je2::P64 = P64[Sp + 8];
           _c8nDC::P64 = R1 & 7;
           if (_c8nDC::P64 < 3) goto u8nEN; else goto u8nEO;
       u8nEN: // global
           if (_c8nDC::P64 < 2) goto c8nDy; else goto c8nDz;
       c8nDy: // global
           I64[Sp + 8] = block_c8nDI_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nEZ; else goto c8nDK;
       u8nEZ: // global
           call _c8nDI(R1) args: 0, res: 0, upd: 0;
       c8nDK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nDz: // global
           I64[Sp + 8] = block_c8nE5_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nF0; else goto c8nE7;
       u8nF0: // global
           call _c8nE5(R1) args: 0, res: 0, upd: 0;
       c8nE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nEO: // global
           if (_c8nDC::P64 < 4) goto c8nDA; else goto c8nDB;
       c8nDA: // global
           I64[Sp + 8] = block_c8nEo_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nF1; else goto c8nEq;
       u8nF1: // global
           call _c8nEo(R1) args: 0, res: 0, upd: 0;
       c8nEq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nDB: // global
           I64[Sp + 8] = block_c8nED_info;
           R1 = _s8je2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nF2; else goto c8nEF;
       u8nF2: // global
           call _c8nED() args: 0, res: 0, upd: 0;
       c8nEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nDI() //  [R1]
         { info_tbl: [(c8nDI,
                       label: block_c8nDI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nDI: // global
           _c8nEM::P64 = R1 & 7;
           if (_c8nEM::P64 < 2) goto u8nER; else goto u8nEP;
       u8nER: // global
           Sp = Sp + 8;
           call _c8nEw() args: 0, res: 0, upd: 0;
       u8nEP: // global
           if (_c8nEM::P64 != 3) goto u8nET; else goto u8nET;
       u8nET: // global
           Sp = Sp + 8;
           call _c8nEA() args: 0, res: 0, upd: 0;
     }
 },
 _c8nE5() //  [R1]
         { info_tbl: [(c8nE5,
                       label: block_c8nE5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nE5: // global
           _c8nEL::P64 = R1 & 7;
           if (_c8nEL::P64 != 3) goto u8nEQ; else goto u8nEU;
       u8nEQ: // global
           if (_c8nEL::P64 != 4) goto u8nEW; else goto u8nEV;
       u8nEW: // global
           Sp = Sp + 8;
           call _c8nEw() args: 0, res: 0, upd: 0;
       u8nEV: // global
           Sp = Sp + 8;
           goto u8nF7;
       u8nEU: // global
           Sp = Sp + 8;
           goto u8nF7;
       u8nF7: // global
           call _c8nEA() args: 0, res: 0, upd: 0;
     }
 },
 _c8nEo() //  [R1]
         { info_tbl: [(c8nEo,
                       label: block_c8nEo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nEo: // global
           if (R1 & 7 == 4) goto u8nEX; else goto u8nEY;
       u8nEX: // global
           Sp = Sp + 8;
           call _c8nEA() args: 0, res: 0, upd: 0;
       u8nEY: // global
           Sp = Sp + 8;
           call _c8nEw() args: 0, res: 0, upd: 0;
     }
 },
 _c8nEA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nEA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nEw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nEw: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nED() //  []
         { info_tbl: [(c8nED,
                       label: block_c8nED_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nED: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.933155936 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8nFQ,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nFQ: // global
           _s8je9::P64 = R3;
           R3 = R2;
           R2 = _s8je9::P64;
           call GHC.IO.Exception.$fOrdAsyncException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.937111176 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmin_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmin_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8nGa,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nGa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nGb; else goto c8nGc;
       c8nGb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nGc: // global
           I64[Sp - 16] = block_c8nG1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nH5; else goto c8nG2;
       u8nH5: // global
           call _c8nG1(R1) args: 0, res: 0, upd: 0;
       c8nG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nG1() //  [R1]
         { info_tbl: [(c8nG1,
                       label: block_c8nG1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nG1: // global
           _s8jea::P64 = P64[Sp + 8];
           _c8nG9::P64 = R1 & 7;
           if (_c8nG9::P64 < 3) goto u8nGZ; else goto u8nH0;
       u8nGZ: // global
           if (_c8nG9::P64 < 2) goto c8nG5; else goto c8nG6;
       c8nG5: // global
           I64[Sp + 8] = block_c8nGf_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nH2; else goto c8nGh;
       u8nH2: // global
           call _c8nGf() args: 0, res: 0, upd: 0;
       c8nGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nG6: // global
           I64[Sp + 8] = block_c8nGo_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nH3; else goto c8nGq;
       u8nH3: // global
           call _c8nGo(R1) args: 0, res: 0, upd: 0;
       c8nGq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nH0: // global
           if (_c8nG9::P64 < 4) goto c8nG7; else goto c8nG8;
       c8nG7: // global
           I64[Sp + 8] = block_c8nGH_info;
           R1 = _s8jea::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nH4; else goto c8nGJ;
       u8nH4: // global
           call _c8nGH(R1) args: 0, res: 0, upd: 0;
       c8nGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8nG8: // global
           R1 = _s8jea::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nGf() //  []
         { info_tbl: [(c8nGf,
                       label: block_c8nGf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nGf: // global
           R1 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nGo() //  [R1]
         { info_tbl: [(c8nGo,
                       label: block_c8nGo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nGo: // global
           _c8nGY::P64 = R1 & 7;
           if (_c8nGY::P64 == 3) goto c8nGE; else goto u8nH1;
       u8nH1: // global
           if (_c8nGY::P64 == 4) goto c8nGE; else goto c8nGw;
       c8nGE: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nGw: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nGH() //  [R1]
         { info_tbl: [(c8nGH,
                       label: block_c8nGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nGH: // global
           if (R1 & 7 == 4) goto c8nGT; else goto c8nGP;
       c8nGT: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nGP: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.948512398 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_closure" {
     GHC.IO.Exception.$fOrdAsyncException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqAsyncException_closure+1;
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.950747109 UTC

[section ""cstring" . GHC.IO.Exception.$trModule4_bytes" {
     GHC.IO.Exception.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.952432331 UTC

[section ""data" . GHC.IO.Exception.$trModule3_closure" {
     GHC.IO.Exception.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.95417467 UTC

[section ""cstring" . GHC.IO.Exception.$trModule2_bytes" {
     GHC.IO.Exception.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.955844655 UTC

[section ""data" . GHC.IO.Exception.$trModule1_closure" {
     GHC.IO.Exception.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.958085435 UTC

[section ""data" . GHC.IO.Exception.$trModule_closure" {
     GHC.IO.Exception.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Exception.$trModule3_closure+1;
         const GHC.IO.Exception.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.959802138 UTC

[section ""data" . $krep_r8j3f_closure" {
     $krep_r8j3f_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.961860062 UTC

[section ""data" . $krep1_r8j3g_closure" {
     $krep1_r8j3g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.96363429 UTC

[section ""data" . $krep2_r8j3h_closure" {
     $krep2_r8j3h_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.965307095 UTC

[section ""data" . $krep3_r8j3i_closure" {
     $krep3_r8j3i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.967037502 UTC

[section ""data" . $krep4_r8j3j_closure" {
     $krep4_r8j3j_closure:
         const :_con_info;
         const $krep1_r8j3g_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.968751455 UTC

[section ""data" . $krep5_r8j3k_closure" {
     $krep5_r8j3k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.970410163 UTC

[section ""data" . $krep6_r8j3l_closure" {
     $krep6_r8j3l_closure:
         const :_con_info;
         const $krep3_r8j3i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.972148346 UTC

[section ""data" . $krep7_r8j3m_closure" {
     $krep7_r8j3m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8j3l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.973924544 UTC

[section ""data" . $krep8_r8j3n_closure" {
     $krep8_r8j3n_closure:
         const :_con_info;
         const $krep2_r8j3h_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.975634484 UTC

[section ""data" . $krep9_r8j3o_closure" {
     $krep9_r8j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8j3n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.977234827 UTC

[section ""data" . $krep10_r8j3p_closure" {
     $krep10_r8j3p_closure:
         const :_con_info;
         const $krep9_r8j3o_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.979234986 UTC

[section ""data" . $krep11_r8j3q_closure" {
     $krep11_r8j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep10_r8j3p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.98090995 UTC

[section ""data" . $krep12_r8j3r_closure" {
     $krep12_r8j3r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.983134061 UTC

[section ""data" . $krep13_r8j3s_closure" {
     $krep13_r8j3s_closure:
         const :_con_info;
         const $krep12_r8j3r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.984826134 UTC

[section ""data" . $krep14_r8j3t_closure" {
     $krep14_r8j3t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Exception.$tcException_closure;
         const $krep13_r8j3s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.986532915 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.98823322 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.990426435 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
         const GHC.Types.krep$*_closure;
         const 5532209509574600699;
         const 13011219155706606307;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.992188185 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.993815911 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.995454664 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.997101661 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure+1;
         const 6834741829236713234;
         const 5957659317954655195;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:26.99949433 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_entry() //  [R1]
         { info_tbl: [(c8nIh,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nIh: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nIi; else goto c8nIj;
       c8nIi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nIj: // global
           (_c8nI9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nI9::I64 == 0) goto c8nIb; else goto c8nIa;
       c8nIb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nIa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nI9::I64;
           I64[Sp - 24] = block_c8nIc_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 13011219155706606307;
           R2 = 5532209509574600699;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nIc() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nIc,
                       label: block_c8nIc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nIc: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nId() args: 0, res: 0, upd: 0;
     }
 },
 _c8nId() //  []
         { info_tbl: [(c8nId,
                       label: block_c8nId_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nId: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nIm; else goto c8nIl;
       c8nIm: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nId_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nIl: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.007540107 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.00914977 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.011433337 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13946898568638194917;
         const 3504019511763148288;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.013300308 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.01496279 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.016498764 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.018149694 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure+1;
         const 13856829326869447687;
         const 12209020643191939554;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.02058076 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_entry() //  [R1]
         { info_tbl: [(c8nJ0,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nJ0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nJ1; else goto c8nJ2;
       c8nJ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nJ2: // global
           (_c8nIS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nIS::I64 == 0) goto c8nIU; else goto c8nIT;
       c8nIU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nIT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nIS::I64;
           I64[Sp - 24] = block_c8nIV_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3504019511763148288;
           R2 = 13946898568638194917;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nIV() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nIV,
                       label: block_c8nIV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nIV: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nIW() args: 0, res: 0, upd: 0;
     }
 },
 _c8nIW() //  []
         { info_tbl: [(c8nIW,
                       label: block_c8nIW_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nIW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nJ5; else goto c8nJ4;
       c8nJ5: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nIW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nJ4: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.028717477 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock5_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock5_bytes:
         I8[] [68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.030468697 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock4_closure" {
     GHC.IO.Exception.$fExceptionDeadlock4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.03216949 UTC

[section ""data" . GHC.IO.Exception.$tcDeadlock_closure" {
     GHC.IO.Exception.$tcDeadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
         const GHC.Types.krep$*_closure;
         const 18363794241794644491;
         const 11186984538024031318;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.034004304 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock1_closure" {
     GHC.IO.Exception.$tc'Deadlock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcDeadlock_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.035717002 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Deadlock3_bytes" {
     GHC.IO.Exception.$tc'Deadlock3_bytes:
         I8[] [39,68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.037412215 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock2_closure" {
     GHC.IO.Exception.$tc'Deadlock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Deadlock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.039691553 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock_closure" {
     GHC.IO.Exception.$tc'Deadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Deadlock2_closure+1;
         const GHC.IO.Exception.$tc'Deadlock1_closure+1;
         const 8732553870978897242;
         const 16079179228471909431;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.042621782 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock3_closure" {
     GHC.IO.Exception.$fExceptionDeadlock3_closure:
         const GHC.IO.Exception.$fExceptionDeadlock3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock3_entry() //  [R1]
         { info_tbl: [(c8nJJ,
                       label: GHC.IO.Exception.$fExceptionDeadlock3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nJJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nJK; else goto c8nJL;
       c8nJK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nJL: // global
           (_c8nJB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nJB::I64 == 0) goto c8nJD; else goto c8nJC;
       c8nJD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nJC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nJB::I64;
           I64[Sp - 24] = block_c8nJE_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nJE() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nJE,
                       label: block_c8nJE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nJE: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nJF() args: 0, res: 0, upd: 0;
     }
 },
 _c8nJF() //  []
         { info_tbl: [(c8nJF,
                       label: block_c8nJF_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nJF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nJO; else goto c8nJN;
       c8nJO: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nJF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nJN: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.051071736 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cfromException_entry() //  [R2]
         { info_tbl: [(c8nKh,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nKh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nKl; else goto c8nKm;
       c8nKl: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nKm: // global
           I64[Sp - 8] = block_c8nKe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nKH; else goto c8nKf;
       u8nKH: // global
           call _c8nKe(R1) args: 0, res: 0, upd: 0;
       c8nKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nKe() //  [R1]
         { info_tbl: [(c8nKe,
                       label: block_c8nKe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nKe: // global
           I64[Sp - 8] = block_c8nKk_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nKk() //  [R1]
         { info_tbl: [(c8nKk,
                       label: block_c8nKk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nKk: // global
           I64[Sp] = block_c8nKr_info;
           R3 = GHC.IO.Exception.$fExceptionDeadlock3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nKr() //  [R1]
         { info_tbl: [(c8nKr,
                       label: block_c8nKr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nKr: // global
           if (R1 & 7 == 1) goto c8nKy; else goto c8nKC;
       c8nKy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nKC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nKF; else goto c8nKE;
       c8nKF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nKE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.060675047 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fShowDeadlock_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$ctoException_entry() //  [R2]
         { info_tbl: [(c8nL8,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nL8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nLc; else goto c8nLb;
       c8nLc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nLb: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionDeadlock_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.065334088 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes:
         I8[] [65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.067084538 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.068761 UTC

[section ""data" . GHC.IO.Exception.$tcAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tcAllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13160607835047152551;
         const 6828489586181860176;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.071012647 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAllocationLimitExceeded_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.072737082 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes:
         I8[] [39,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.07501151 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.076708797 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure+1;
         const 14911686161474736107;
         const 16735957051754280572;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.079341784 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_entry() //  [R1]
         { info_tbl: [(c8nLB,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nLB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nLC; else goto c8nLD;
       c8nLC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nLD: // global
           (_c8nLt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nLt::I64 == 0) goto c8nLv; else goto c8nLu;
       c8nLv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nLu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nLt::I64;
           I64[Sp - 24] = block_c8nLw_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6828489586181860176;
           R2 = 13160607835047152551;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nLw() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nLw,
                       label: block_c8nLw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nLw: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nLx() args: 0, res: 0, upd: 0;
     }
 },
 _c8nLx() //  []
         { info_tbl: [(c8nLx,
                       label: block_c8nLx_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nLx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nLG; else goto c8nLF;
       c8nLG: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nLx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nLF: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.087215671 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed4_bytes:
         I8[] [67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.088929759 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed3_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.090625462 UTC

[section ""data" . GHC.IO.Exception.$tcCompactionFailed_closure" {
     GHC.IO.Exception.$tcCompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7633933266579528523;
         const 6393060685738357435;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.092448046 UTC

[section ""data" . $krep15_r8j3u_closure" {
     $krep15_r8j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcCompactionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.094546 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed1_closure" {
     GHC.IO.Exception.$tc'CompactionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep15_r8j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.096184994 UTC

[section ""cstring" . GHC.IO.Exception.$tc'CompactionFailed3_bytes" {
     GHC.IO.Exception.$tc'CompactionFailed3_bytes:
         I8[] [39,67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.097878658 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed2_closure" {
     GHC.IO.Exception.$tc'CompactionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'CompactionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.099589542 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed_closure" {
     GHC.IO.Exception.$tc'CompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed2_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed1_closure+4;
         const 5917738941224226344;
         const 8436844331187314000;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.101989882 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed2_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed2_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed2_entry() //  [R1]
         { info_tbl: [(c8nMl,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nMl: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nMm; else goto c8nMn;
       c8nMm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nMn: // global
           (_c8nMd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nMd::I64 == 0) goto c8nMf; else goto c8nMe;
       c8nMf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nMe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nMd::I64;
           I64[Sp - 24] = block_c8nMg_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6393060685738357435;
           R2 = 7633933266579528523;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nMg() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nMg,
                       label: block_c8nMg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nMg: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nMh() args: 0, res: 0, upd: 0;
     }
 },
 _c8nMh() //  []
         { info_tbl: [(c8nMh,
                       label: block_c8nMh_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nMh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nMq; else goto c8nMp;
       c8nMq: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nMh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nMp: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.110780186 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAssertionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionAssertionFailed4_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.112508776 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed3_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.114256445 UTC

[section ""data" . GHC.IO.Exception.$tcAssertionFailed_closure" {
     GHC.IO.Exception.$tcAssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7013231185527166567;
         const 11481669896152761825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.116139967 UTC

[section ""data" . $krep16_r8j3v_closure" {
     $krep16_r8j3v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAssertionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.117861258 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed1_closure" {
     GHC.IO.Exception.$tc'AssertionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep16_r8j3v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.119502289 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AssertionFailed3_bytes" {
     GHC.IO.Exception.$tc'AssertionFailed3_bytes:
         I8[] [39,65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.121167238 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed2_closure" {
     GHC.IO.Exception.$tc'AssertionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AssertionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.123198022 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed_closure" {
     GHC.IO.Exception.$tc'AssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed2_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed1_closure+4;
         const 6421416346863765662;
         const 16131786633010342764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.125719116 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed2_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed2_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed2_entry() //  [R1]
         { info_tbl: [(c8nN5,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nN5: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nN6; else goto c8nN7;
       c8nN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nN7: // global
           (_c8nMX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nMX::I64 == 0) goto c8nMZ; else goto c8nMY;
       c8nMZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nMY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nMX::I64;
           I64[Sp - 24] = block_c8nN0_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11481669896152761825;
           R2 = 7013231185527166567;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nN0() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nN0,
                       label: block_c8nN0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nN0: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nN1() args: 0, res: 0, upd: 0;
     }
 },
 _c8nN1() //  []
         { info_tbl: [(c8nN1,
                       label: block_c8nN1_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nN1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nNa; else goto c8nN9;
       c8nNa: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nN1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nN9: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.134684255 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8nND,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nNH; else goto c8nNI;
       c8nNH: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nNI: // global
           I64[Sp - 8] = block_c8nNA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nO3; else goto c8nNB;
       u8nO3: // global
           call _c8nNA(R1) args: 0, res: 0, upd: 0;
       c8nNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nNA() //  [R1]
         { info_tbl: [(c8nNA,
                       label: block_c8nNA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nNA: // global
           I64[Sp - 8] = block_c8nNG_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nNG() //  [R1]
         { info_tbl: [(c8nNG,
                       label: block_c8nNG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nNG: // global
           I64[Sp] = block_c8nNN_info;
           R3 = GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nNN() //  [R1]
         { info_tbl: [(c8nNN,
                       label: block_c8nNN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nNN: // global
           if (R1 & 7 == 1) goto c8nNU; else goto c8nNY;
       c8nNU: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nNY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nO1; else goto c8nO0;
       c8nO1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nO0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.144535019 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fShowAssertionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8nOu,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nOu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nOy; else goto c8nOx;
       c8nOy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nOx: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAssertionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.149514213 UTC

[section ""cstring" . lvl38_r8j3w_bytes" {
     lvl38_r8j3w_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,32,102,97,105,108,101,100,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.153808818 UTC

[section ""data" . GHC.IO.Exception.assertError1_closure" {
     GHC.IO.Exception.assertError1_closure:
         const GHC.IO.Exception.assertError1_info;
         const 0;
 },
 sat_s8jfa_entry() //  [R1]
         { info_tbl: [(c8nPc,
                       label: sat_s8jfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nPd; else goto c8nPe;
       c8nPd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nPe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8nPa_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8nPa() //  [R1]
         { info_tbl: [(c8nPa,
                       label: block_c8nPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPa: // global
           R3 = R1;
           R2 = GHC.Exception.errorCallWithCallStackException9_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 n_s8jf5_entry() //  [R1]
         { info_tbl: [(c8nPm,
                       label: n_s8jf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nPn; else goto c8nPo;
       c8nPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8nP0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8nPv; else goto c8nP1;
       u8nPv: // global
           call _c8nP0(R1) args: 0, res: 0, upd: 0;
       c8nP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8nP0() //  [R1]
         { info_tbl: [(c8nP0,
                       label: block_c8nP0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nP0: // global
           if (R1 & 7 == 1) goto c8nPj; else goto c8nPk;
       c8nPj: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8nPk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nPu; else goto c8nPt;
       c8nPu: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8nPt: // global
           I64[Hp - 40] = sat_s8jfa_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException11_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jff_entry() //  [R1]
         { info_tbl: [(c8nPK,
                       label: sat_s8jff_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nPL; else goto c8nPM;
       c8nPL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nPM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfo_entry() //  [R1]
         { info_tbl: [(c8nQ9,
                       label: sat_s8jfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nQa; else goto c8nQb;
       c8nQa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nQb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.errorCallWithCallStackException1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8jfj_entry() //  [R1, R2]
         { info_tbl: [(c8nQg,
                       label: go_s8jfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nQh; else goto c8nQi;
       c8nQh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nQi: // global
           I64[Sp - 24] = block_c8nPY_info;
           _s8jfj::P64 = R1;
           _s8jf5::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s8jf5::P64;
           P64[Sp - 8] = _s8jfj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8nQp; else goto c8nPZ;
       u8nQp: // global
           call _c8nPY(R1) args: 0, res: 0, upd: 0;
       c8nPZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nPY() //  [R1]
         { info_tbl: [(c8nPY,
                       label: block_c8nPY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPY: // global
           if (R1 & 7 == 1) goto c8nQd; else goto c8nQe;
       c8nQd: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8nQe: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8nQo; else goto c8nQn;
       c8nQo: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nQn: // global
           _s8jfm::P64 = P64[R1 + 6];
           _s8jfn::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _s8jfn::P64;
           I64[Hp - 40] = sat_s8jfo_info;
           P64[Hp - 24] = _s8jfm::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8jfr_entry() //  [R1]
         { info_tbl: [(c8nQs,
                       label: sat_s8jfr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQs: // global
           _s8jfr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8nQt; else goto c8nQu;
       c8nQu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nQw; else goto c8nQv;
       c8nQw: // global
           HpAlloc = 16;
           goto c8nQt;
       c8nQt: // global
           R1 = _s8jfr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfr::P64;
           _s8jf5::P64 = P64[_s8jfr::P64 + 16];
           _s8jfb::P64 = P64[_s8jfr::P64 + 24];
           I64[Hp - 8] = go_s8jfj_info;
           P64[Hp] = _s8jf5::P64;
           I64[Sp - 24] = block_c8nQq_info;
           R2 = _s8jfb::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s8jfj_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8nQq() //  [R1]
         { info_tbl: [(c8nQq,
                       label: block_c8nQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQq: // global
           R3 = R1;
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp + 8;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jft_entry() //  [R1]
         { info_tbl: [(c8nQE,
                       label: sat_s8jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQE: // global
           _s8jft::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8nQF; else goto c8nQG;
       c8nQG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nQI; else goto c8nQH;
       c8nQI: // global
           HpAlloc = 24;
           goto c8nQF;
       c8nQF: // global
           R1 = _s8jft::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nQH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jft::P64;
           _s8jf2::P64 = P64[_s8jft::P64 + 16];
           _s8jf3::P64 = P64[_s8jft::P64 + 24];
           I64[Hp - 16] = n_s8jf5_info;
           P64[Hp] = _s8jf3::P64;
           I64[Sp - 32] = block_c8nPw_info;
           R2 = _s8jf2::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Stack.Types.getCallStack_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8nPw() //  [R1]
         { info_tbl: [(c8nPw,
                       label: block_c8nPw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPw: // global
           _c8nOW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8nQB; else goto c8nQC;
       c8nQB: // global
           I64[Sp + 8] = block_c8nPA_info;
           R1 = _c8nOW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8nQY; else goto c8nPB;
       u8nQY: // global
           call _c8nPA(R1) args: 0, res: 0, upd: 0;
       c8nPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       c8nQC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8nQW; else goto c8nQV;
       c8nQW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8nQV: // global
           I64[Hp - 48] = sat_s8jfr_info;
           P64[Hp - 32] = _c8nOW::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException6_closure;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _c8nPA() //  [R1]
         { info_tbl: [(c8nPA,
                       label: block_c8nPA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nPA: // global
           if (R1 & 7 == 1) goto c8nQN; else goto c8nQP;
       c8nQN: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8nQP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nQS; else goto c8nQR;
       c8nQS: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8nQR: // global
           _s8jfd::P64 = P64[R1 + 6];
           _s8jfe::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_s8jff_info;
           P64[Hp - 24] = _s8jfe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8jfd::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfu_entry() //  [R1]
         { info_tbl: [(c8nQZ,
                       label: sat_s8jfu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nQZ: // global
           _s8jfu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8nR0; else goto c8nR1;
       c8nR1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8nR3; else goto c8nR2;
       c8nR3: // global
           HpAlloc = 32;
           goto c8nR0;
       c8nR0: // global
           R1 = _s8jfu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nR2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfu::P64;
           _s8jf2::P64 = P64[_s8jfu::P64 + 16];
           _s8jf3::P64 = P64[_s8jfu::P64 + 24];
           I64[Hp - 24] = sat_s8jft_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R3 = Hp - 24;
           R2 = lvl38_r8j3w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8jfv_entry() //  [R1]
         { info_tbl: [(c8nR4,
                       label: sat_s8jfv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nR4: // global
           _s8jfv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8nR5; else goto c8nR6;
       c8nR6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8nR8; else goto c8nR7;
       c8nR8: // global
           HpAlloc = 32;
           goto c8nR5;
       c8nR5: // global
           R1 = _s8jfv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nR7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8jfv::P64;
           _s8jf2::P64 = P64[_s8jfv::P64 + 16];
           _s8jf3::P64 = P64[_s8jfv::P64 + 24];
           I64[Hp - 24] = sat_s8jfu_info;
           P64[Hp - 8] = _s8jf2::P64;
           P64[Hp] = _s8jf3::P64;
           R2 = Hp - 24;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.assertError1_entry() //  [R2, R3]
         { info_tbl: [(c8nR9,
                       label: GHC.IO.Exception.assertError1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nR9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8nRd; else goto c8nRc;
       c8nRd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nRc: // global
           I64[Hp - 24] = sat_s8jfv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.189396834 UTC

[section ""data" . GHC.IO.Exception.assertError_closure" {
     GHC.IO.Exception.assertError_closure:
         const GHC.IO.Exception.assertError_info;
         const 0;
 },
 GHC.IO.Exception.assertError_entry() //  [R2, R3, R4]
         { info_tbl: [(c8nSJ,
                       label: GHC.IO.Exception.assertError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nSJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nSK; else goto c8nSL;
       c8nSK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nSL: // global
           I64[Sp - 24] = block_c8nSC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8nSY; else goto c8nSD;
       u8nSY: // global
           call _c8nSC(R1) args: 0, res: 0, upd: 0;
       c8nSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nSC() //  [R1]
         { info_tbl: [(c8nSC,
                       label: block_c8nSC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nSC: // global
           if (R1 & 7 == 1) goto c8nSG; else goto c8nSH;
       c8nSG: // global
           I64[Sp] = block_c8nSO_info;
           R1 = GHC.Stack.CCS.currentCallStack_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c8nSH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nSO() //  [R1]
         { info_tbl: [(c8nSO,
                       label: block_c8nSO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nSO: // global
           I64[Sp + 16] = block_c8nSQ_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Exception.assertError1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nSQ() //  [R1]
         { info_tbl: [(c8nSQ,
                       label: block_c8nSQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nSQ: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.197991996 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes:
         I8[] [83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.199706025 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.201346535 UTC

[section ""data" . GHC.IO.Exception.$tcSomeAsyncException_closure" {
     GHC.IO.Exception.$tcSomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
         const GHC.Types.krep$*_closure;
         const 7698277271892269964;
         const 12603180528693821542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.203224009 UTC

[section ""data" . $krep17_r8j3x_closure" {
     $krep17_r8j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcSomeAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.204988017 UTC

[section ""data" . $krep18_r8j3y_closure" {
     $krep18_r8j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r8j3r_closure+2;
         const $krep17_r8j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.20676101 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException1_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r8j3t_closure+1;
         const $krep18_r8j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.208451445 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SomeAsyncException3_bytes" {
     GHC.IO.Exception.$tc'SomeAsyncException3_bytes:
         I8[] [39,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.210532077 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException2_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SomeAsyncException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.212809936 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException2_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException1_closure+4;
         const 2590663161510005226;
         const 12089333203895315586;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.215292409 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_entry() //  [R1]
         { info_tbl: [(c8nTA,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nTA: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nTB; else goto c8nTC;
       c8nTB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nTC: // global
           (_c8nTs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nTs::I64 == 0) goto c8nTu; else goto c8nTt;
       c8nTu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nTt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nTs::I64;
           I64[Sp - 24] = block_c8nTv_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12603180528693821542;
           R2 = 7698277271892269964;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nTv() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nTv,
                       label: block_c8nTv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nTv: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nTw() args: 0, res: 0, upd: 0;
     }
 },
 _c8nTw() //  []
         { info_tbl: [(c8nTw,
                       label: block_c8nTw_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nTw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nTF; else goto c8nTE;
       c8nTF: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nTw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nTE: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.224074486 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8nU8,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nU8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nUc; else goto c8nUd;
       c8nUc: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nUd: // global
           I64[Sp - 8] = block_c8nU5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nUy; else goto c8nU6;
       u8nUy: // global
           call _c8nU5(R1) args: 0, res: 0, upd: 0;
       c8nU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nU5() //  [R1]
         { info_tbl: [(c8nU5,
                       label: block_c8nU5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nU5: // global
           I64[Sp - 8] = block_c8nUb_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nUb() //  [R1]
         { info_tbl: [(c8nUb,
                       label: block_c8nUb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nUb: // global
           I64[Sp] = block_c8nUi_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nUi() //  [R1]
         { info_tbl: [(c8nUi,
                       label: block_c8nUi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nUi: // global
           if (R1 & 7 == 1) goto c8nUp; else goto c8nUt;
       c8nUp: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nUt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nUw; else goto c8nUv;
       c8nUw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nUv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.233232564 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fShowSomeAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8nUZ,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nUZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nV3; else goto c8nV2;
       c8nV3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nV2: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionSomeAsyncException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.238640166 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionFromException_closure" {
     GHC.IO.Exception.asyncExceptionFromException_closure:
         const GHC.IO.Exception.asyncExceptionFromException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionFromException_entry() //  [R2, R3]
         { info_tbl: [(c8nVh,
                       label: GHC.IO.Exception.asyncExceptionFromException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8nVl; else goto c8nVm;
       c8nVl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionFromException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nVm: // global
           I64[Sp - 16] = block_c8nVe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8nWa; else goto c8nVf;
       u8nWa: // global
           call _c8nVe(R1) args: 0, res: 0, upd: 0;
       c8nVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVe() //  [R1]
         { info_tbl: [(c8nVe,
                       label: block_c8nVe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVe: // global
           I64[Sp - 8] = block_c8nVk_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVk() //  [R1]
         { info_tbl: [(c8nVk,
                       label: block_c8nVk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVk: // global
           I64[Sp] = block_c8nVr_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVr() //  [R1]
         { info_tbl: [(c8nVr,
                       label: block_c8nVr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVr: // global
           if (R1 & 7 == 1) goto u8nW8; else goto c8nVL;
       u8nW8: // global
           Sp = Sp + 24;
           call _c8nVY() args: 0, res: 0, upd: 0;
       c8nVL: // global
           _s8jfW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8nVB_info;
           R1 = _s8jfW::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVB() //  [R1]
         { info_tbl: [(c8nVB,
                       label: block_c8nVB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVB: // global
           I64[Sp - 8] = block_c8nVF_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVF() //  [R1]
         { info_tbl: [(c8nVF,
                       label: block_c8nVF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVF: // global
           I64[Sp] = block_c8nVJ_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVJ() //  [R1]
         { info_tbl: [(c8nVJ,
                       label: block_c8nVJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVJ: // global
           I64[Sp] = block_c8nVR_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nVR() //  [R1]
         { info_tbl: [(c8nVR,
                       label: block_c8nVR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVR: // global
           if (R1 & 7 == 1) goto u8nW9; else goto c8nW2;
       u8nW9: // global
           Sp = Sp + 24;
           call _c8nVY() args: 0, res: 0, upd: 0;
       c8nW2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nW5; else goto c8nW4;
       c8nW5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nW4: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8nVY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nVY: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.255660184 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionToException_closure" {
     GHC.IO.Exception.asyncExceptionToException_closure:
         const GHC.IO.Exception.asyncExceptionToException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionToException_entry() //  [R2, R3]
         { info_tbl: [(c8nWV,
                       label: GHC.IO.Exception.asyncExceptionToException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nWV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nWZ; else goto c8nWY;
       c8nWZ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionToException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8nWY: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.259191514 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException11_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException11_bytes:
         I8[] [65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.260835733 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException10_closure" {
     GHC.IO.Exception.$fExceptionAsyncException10_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.262798958 UTC

[section ""data" . GHC.IO.Exception.$tcAsyncException_closure" {
     GHC.IO.Exception.$tcAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
         const GHC.Types.krep$*_closure;
         const 3223192752092240512;
         const 6151543105744102738;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.264616894 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow1_closure" {
     GHC.IO.Exception.$tc'HeapOverflow1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.266368193 UTC

[section ""cstring" . GHC.IO.Exception.$tc'StackOverflow2_bytes" {
     GHC.IO.Exception.$tc'StackOverflow2_bytes:
         I8[] [39,83,116,97,99,107,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.268059435 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow1_closure" {
     GHC.IO.Exception.$tc'StackOverflow1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'StackOverflow2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.269957113 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow_closure" {
     GHC.IO.Exception.$tc'StackOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'StackOverflow1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 7140728310745047686;
         const 9210977118047764825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.271705088 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HeapOverflow3_bytes" {
     GHC.IO.Exception.$tc'HeapOverflow3_bytes:
         I8[] [39,72,101,97,112,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.273300706 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow2_closure" {
     GHC.IO.Exception.$tc'HeapOverflow2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HeapOverflow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.275032329 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow_closure" {
     GHC.IO.Exception.$tc'HeapOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow2_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 6603650813243937168;
         const 2046005135570222520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.27765251 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ThreadKilled2_bytes" {
     GHC.IO.Exception.$tc'ThreadKilled2_bytes:
         I8[] [39,84,104,114,101,97,100,75,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.279214642 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled1_closure" {
     GHC.IO.Exception.$tc'ThreadKilled1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ThreadKilled2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.280930234 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled_closure" {
     GHC.IO.Exception.$tc'ThreadKilled_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ThreadKilled1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 13600447017231937444;
         const 101896852196063416;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.282689374 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserInterrupt2_bytes" {
     GHC.IO.Exception.$tc'UserInterrupt2_bytes:
         I8[] [39,85,115,101,114,73,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.284297819 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt1_closure" {
     GHC.IO.Exception.$tc'UserInterrupt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserInterrupt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.286295231 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt_closure" {
     GHC.IO.Exception.$tc'UserInterrupt_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserInterrupt1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 1214873852534998649;
         const 13851718192780849484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.288735375 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException9_closure" {
     GHC.IO.Exception.$fExceptionAsyncException9_closure:
         const GHC.IO.Exception.$fExceptionAsyncException9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException9_entry() //  [R1]
         { info_tbl: [(c8nXv,
                       label: GHC.IO.Exception.$fExceptionAsyncException9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nXv: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nXw; else goto c8nXx;
       c8nXw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nXx: // global
           (_c8nXn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nXn::I64 == 0) goto c8nXp; else goto c8nXo;
       c8nXp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nXo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nXn::I64;
           I64[Sp - 24] = block_c8nXq_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6151543105744102738;
           R2 = 3223192752092240512;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nXq() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nXq,
                       label: block_c8nXq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nXq: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nXr() args: 0, res: 0, upd: 0;
     }
 },
 _c8nXr() //  []
         { info_tbl: [(c8nXr,
                       label: block_c8nXr_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nXr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nXA; else goto c8nXz;
       c8nXA: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nXr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nXz: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.296766043 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException7_bytes" {
     GHC.IO.Exception.$fExceptionArrayException7_bytes:
         I8[] [65,114,114,97,121,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.298548334 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException6_closure" {
     GHC.IO.Exception.$fExceptionArrayException6_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionArrayException7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.300212545 UTC

[section ""data" . GHC.IO.Exception.$tcArrayException_closure" {
     GHC.IO.Exception.$tcArrayException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException6_closure+1;
         const GHC.Types.krep$*_closure;
         const 14361659568498315305;
         const 6805143727974531880;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.302097509 UTC

[section ""data" . $krep19_r8j3z_closure" {
     $krep19_r8j3z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcArrayException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.30374239 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds1_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep19_r8j3z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.305954104 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes" {
     GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes:
         I8[] [39,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.307682711 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds2_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.309650278 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds2_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 14241149568806879436;
         const 10551655754853710333;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.311448049 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UndefinedElement2_bytes" {
     GHC.IO.Exception.$tc'UndefinedElement2_bytes:
         I8[] [39,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.313078489 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement1_closure" {
     GHC.IO.Exception.$tc'UndefinedElement1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UndefinedElement2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.314785571 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement_closure" {
     GHC.IO.Exception.$tc'UndefinedElement_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UndefinedElement1_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 9439210122732754255;
         const 8562757414325900819;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.31719007 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException5_closure" {
     GHC.IO.Exception.$fExceptionArrayException5_closure:
         const GHC.IO.Exception.$fExceptionArrayException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException5_entry() //  [R1]
         { info_tbl: [(c8nYi,
                       label: GHC.IO.Exception.$fExceptionArrayException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8nYj; else goto c8nYk;
       c8nYj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8nYk: // global
           (_c8nYa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8nYa::I64 == 0) goto c8nYc; else goto c8nYb;
       c8nYc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8nYb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8nYa::I64;
           I64[Sp - 24] = block_c8nYd_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionArrayException6_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6805143727974531880;
           R2 = 14361659568498315305;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8nYd() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8nYd,
                       label: block_c8nYd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYd: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8nYe() args: 0, res: 0, upd: 0;
     }
 },
 _c8nYe() //  []
         { info_tbl: [(c8nYe,
                       label: block_c8nYe_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8nYn; else goto c8nYm;
       c8nYn: // global
           HpAlloc = 48;
           I64[Sp] = block_c8nYe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8nYm: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.325480697 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8nYQ,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8nYU; else goto c8nYV;
       c8nYU: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nYV: // global
           I64[Sp - 8] = block_c8nYN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8nZg; else goto c8nYO;
       u8nZg: // global
           call _c8nYN(R1) args: 0, res: 0, upd: 0;
       c8nYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8nYN() //  [R1]
         { info_tbl: [(c8nYN,
                       label: block_c8nYN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYN: // global
           I64[Sp - 8] = block_c8nYT_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nYT() //  [R1]
         { info_tbl: [(c8nYT,
                       label: block_c8nYT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nYT: // global
           I64[Sp] = block_c8nZ0_info;
           R3 = GHC.IO.Exception.$fExceptionArrayException5_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8nZ0() //  [R1]
         { info_tbl: [(c8nZ0,
                       label: block_c8nZ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nZ0: // global
           if (R1 & 7 == 1) goto c8nZ7; else goto c8nZb;
       c8nZ7: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8nZb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8nZe; else goto c8nZd;
       c8nZe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8nZd: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.334667205 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fShowArrayException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8nZH,
                       label: GHC.IO.Exception.$fExceptionArrayException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nZH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8nZL; else goto c8nZK;
       c8nZL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8nZK: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionArrayException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.339647096 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException5_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException5_bytes:
         I8[] [70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.341898079 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException4_closure" {
     GHC.IO.Exception.$fExceptionFixIOException4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.343575391 UTC

[section ""data" . GHC.IO.Exception.$tcFixIOException_closure" {
     GHC.IO.Exception.$tcFixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
         const GHC.Types.krep$*_closure;
         const 175794591112768165;
         const 12820711924146365796;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.345436034 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException1_closure" {
     GHC.IO.Exception.$tc'FixIOException1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcFixIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.347130726 UTC

[section ""cstring" . GHC.IO.Exception.$tc'FixIOException3_bytes" {
     GHC.IO.Exception.$tc'FixIOException3_bytes:
         I8[] [39,70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.348797995 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException2_closure" {
     GHC.IO.Exception.$tc'FixIOException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'FixIOException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.350449892 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException_closure" {
     GHC.IO.Exception.$tc'FixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'FixIOException2_closure+1;
         const GHC.IO.Exception.$tc'FixIOException1_closure+1;
         const 1253631570386628537;
         const 15724415228749653558;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.352822765 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException3_closure" {
     GHC.IO.Exception.$fExceptionFixIOException3_closure:
         const GHC.IO.Exception.$fExceptionFixIOException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException3_entry() //  [R1]
         { info_tbl: [(c8o0a,
                       label: GHC.IO.Exception.$fExceptionFixIOException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o0a: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8o0b; else goto c8o0c;
       c8o0b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8o0c: // global
           (_c8o02::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8o02::I64 == 0) goto c8o04; else goto c8o03;
       c8o04: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8o03: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8o02::I64;
           I64[Sp - 24] = block_c8o05_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12820711924146365796;
           R2 = 175794591112768165;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8o05() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8o05,
                       label: block_c8o05_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o05: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8o06() args: 0, res: 0, upd: 0;
     }
 },
 _c8o06() //  []
         { info_tbl: [(c8o06,
                       label: block_c8o06_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o06: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8o0f; else goto c8o0e;
       c8o0f: // global
           HpAlloc = 48;
           I64[Sp] = block_c8o06_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8o0e: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.3623641 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8o0I,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o0I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o0M; else goto c8o0N;
       c8o0M: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o0N: // global
           I64[Sp - 8] = block_c8o0F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8o18; else goto c8o0G;
       u8o18: // global
           call _c8o0F(R1) args: 0, res: 0, upd: 0;
       c8o0G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o0F() //  [R1]
         { info_tbl: [(c8o0F,
                       label: block_c8o0F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o0F: // global
           I64[Sp - 8] = block_c8o0L_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o0L() //  [R1]
         { info_tbl: [(c8o0L,
                       label: block_c8o0L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o0L: // global
           I64[Sp] = block_c8o0S_info;
           R3 = GHC.IO.Exception.$fExceptionFixIOException3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o0S() //  [R1]
         { info_tbl: [(c8o0S,
                       label: block_c8o0S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o0S: // global
           if (R1 & 7 == 1) goto c8o0Z; else goto c8o13;
       c8o0Z: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8o13: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8o16; else goto c8o15;
       c8o16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8o15: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.37241643 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fShowFixIOException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8o1z,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o1z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o1D; else goto c8o1C;
       c8o1D: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o1C: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionFixIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.377377109 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode6_bytes" {
     GHC.IO.Exception.$fExceptionExitCode6_bytes:
         I8[] [69,120,105,116,67,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.379132348 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode5_closure" {
     GHC.IO.Exception.$fExceptionExitCode5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionExitCode6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.380928148 UTC

[section ""data" . GHC.IO.Exception.$tcExitCode_closure" {
     GHC.IO.Exception.$tcExitCode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode5_closure+1;
         const GHC.Types.krep$*_closure;
         const 8177210543059932106;
         const 3694335570555580912;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.38302029 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess1_closure" {
     GHC.IO.Exception.$tc'ExitSuccess1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcExitCode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.38466708 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitSuccess3_bytes" {
     GHC.IO.Exception.$tc'ExitSuccess3_bytes:
         I8[] [39,69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.386365839 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess2_closure" {
     GHC.IO.Exception.$tc'ExitSuccess2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitSuccess3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.388041448 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess_closure" {
     GHC.IO.Exception.$tc'ExitSuccess_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess2_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 6011095708053053284;
         const 14896688531190285489;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.390036874 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure1_closure" {
     GHC.IO.Exception.$tc'ExitFailure1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r8j3f_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.391770925 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitFailure3_bytes" {
     GHC.IO.Exception.$tc'ExitFailure3_bytes:
         I8[] [39,69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.393434945 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure2_closure" {
     GHC.IO.Exception.$tc'ExitFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.395187719 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure_closure" {
     GHC.IO.Exception.$tc'ExitFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure2_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure1_closure+4;
         const 13149331685465745995;
         const 10453046320643141131;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.397699972 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode4_closure" {
     GHC.IO.Exception.$fExceptionExitCode4_closure:
         const GHC.IO.Exception.$fExceptionExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode4_entry() //  [R1]
         { info_tbl: [(c8o26,
                       label: GHC.IO.Exception.$fExceptionExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o26: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8o27; else goto c8o28;
       c8o27: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8o28: // global
           (_c8o1Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8o1Y::I64 == 0) goto c8o20; else goto c8o1Z;
       c8o20: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8o1Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8o1Y::I64;
           I64[Sp - 24] = block_c8o21_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionExitCode5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3694335570555580912;
           R2 = 8177210543059932106;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8o21() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8o21,
                       label: block_c8o21_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o21: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8o22() args: 0, res: 0, upd: 0;
     }
 },
 _c8o22() //  []
         { info_tbl: [(c8o22,
                       label: block_c8o22_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o22: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8o2b; else goto c8o2a;
       c8o2b: // global
           HpAlloc = 48;
           I64[Sp] = block_c8o22_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8o2a: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.407325444 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$cfromException_entry() //  [R2]
         { info_tbl: [(c8o2E,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o2E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o2I; else goto c8o2J;
       c8o2I: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o2J: // global
           I64[Sp - 8] = block_c8o2B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8o34; else goto c8o2C;
       u8o34: // global
           call _c8o2B(R1) args: 0, res: 0, upd: 0;
       c8o2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o2B() //  [R1]
         { info_tbl: [(c8o2B,
                       label: block_c8o2B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o2B: // global
           I64[Sp - 8] = block_c8o2H_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o2H() //  [R1]
         { info_tbl: [(c8o2H,
                       label: block_c8o2H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o2H: // global
           I64[Sp] = block_c8o2O_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o2O() //  [R1]
         { info_tbl: [(c8o2O,
                       label: block_c8o2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o2O: // global
           if (R1 & 7 == 1) goto c8o2V; else goto c8o2Z;
       c8o2V: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8o2Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8o32; else goto c8o31;
       c8o32: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8o31: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.416572795 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_closure" {
     GHC.IO.Exception.$fExceptionExitCode_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fShowExitCode_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$ctoException_entry() //  [R2]
         { info_tbl: [(c8o3v,
                       label: GHC.IO.Exception.$fExceptionExitCode_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o3v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o3z; else goto c8o3y;
       c8o3z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o3y: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionExitCode_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.421646952 UTC

[section ""cstring" . GHC.IO.Exception.$tcIOErrorType2_bytes" {
     GHC.IO.Exception.$tcIOErrorType2_bytes:
         I8[] [73,79,69,114,114,111,114,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.423362382 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType1_closure" {
     GHC.IO.Exception.$tcIOErrorType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tcIOErrorType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.425088168 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType_closure" {
     GHC.IO.Exception.$tcIOErrorType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tcIOErrorType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13260403802836574836;
         const 9962456285013293537;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.426945617 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists1_closure" {
     GHC.IO.Exception.$tc'AlreadyExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOErrorType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.428672159 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AlreadyExists3_bytes" {
     GHC.IO.Exception.$tc'AlreadyExists3_bytes:
         I8[] [39,65,108,114,101,97,100,121,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.430571582 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists2_closure" {
     GHC.IO.Exception.$tc'AlreadyExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.432229958 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists_closure" {
     GHC.IO.Exception.$tc'AlreadyExists_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists2_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 13383994725479033447;
         const 16077735236426702934;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.434634563 UTC

[section ""cstring" . GHC.IO.Exception.$tc'NoSuchThing2_bytes" {
     GHC.IO.Exception.$tc'NoSuchThing2_bytes:
         I8[] [39,78,111,83,117,99,104,84,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.436410834 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing1_closure" {
     GHC.IO.Exception.$tc'NoSuchThing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'NoSuchThing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.438110498 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing_closure" {
     GHC.IO.Exception.$tc'NoSuchThing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'NoSuchThing1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 1065788776620214811;
         const 7708272823769791518;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.439993068 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceBusy2_bytes" {
     GHC.IO.Exception.$tc'ResourceBusy2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,66,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.442009173 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy1_closure" {
     GHC.IO.Exception.$tc'ResourceBusy1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceBusy2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.443803078 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy_closure" {
     GHC.IO.Exception.$tc'ResourceBusy_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceBusy1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 81041156937828521;
         const 16732677038738772765;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.44567425 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceExhausted2_bytes" {
     GHC.IO.Exception.$tc'ResourceExhausted2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.447288729 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted1_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceExhausted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.448951999 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceExhausted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 661664682644939150;
         const 17978068149744050586;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.450815396 UTC

[section ""cstring" . GHC.IO.Exception.$tc'EOF2_bytes" {
     GHC.IO.Exception.$tc'EOF2_bytes:
         I8[] [39,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.452456323 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF1_closure" {
     GHC.IO.Exception.$tc'EOF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'EOF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.454564559 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF_closure" {
     GHC.IO.Exception.$tc'EOF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'EOF1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 15446447841260182649;
         const 9615135582901540009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.456339707 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IllegalOperation2_bytes" {
     GHC.IO.Exception.$tc'IllegalOperation2_bytes:
         I8[] [39,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.45808739 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation1_closure" {
     GHC.IO.Exception.$tc'IllegalOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IllegalOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.46032181 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation_closure" {
     GHC.IO.Exception.$tc'IllegalOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IllegalOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2997750042243464947;
         const 13732497530673208550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.462302405 UTC

[section ""cstring" . GHC.IO.Exception.$tc'PermissionDenied2_bytes" {
     GHC.IO.Exception.$tc'PermissionDenied2_bytes:
         I8[] [39,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.46396697 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied1_closure" {
     GHC.IO.Exception.$tc'PermissionDenied1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'PermissionDenied2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.465712577 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied_closure" {
     GHC.IO.Exception.$tc'PermissionDenied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'PermissionDenied1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17002959889944859215;
         const 11679101384562499698;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.46756491 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserError2_bytes" {
     GHC.IO.Exception.$tc'UserError2_bytes:
         I8[] [39,85,115,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.469669832 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError1_closure" {
     GHC.IO.Exception.$tc'UserError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.471275124 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError_closure" {
     GHC.IO.Exception.$tc'UserError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2110707588451626880;
         const 793010194601470118;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.473067099 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes:
         I8[] [39,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.474707532 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.476388218 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 7774786765253276509;
         const 11159080782866109022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.478211075 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SystemError2_bytes" {
     GHC.IO.Exception.$tc'SystemError2_bytes:
         I8[] [39,83,121,115,116,101,109,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.479896388 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError1_closure" {
     GHC.IO.Exception.$tc'SystemError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SystemError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.482204884 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError_closure" {
     GHC.IO.Exception.$tc'SystemError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SystemError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14723310935893761222;
         const 8619015840207109406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.484156413 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ProtocolError2_bytes" {
     GHC.IO.Exception.$tc'ProtocolError2_bytes:
         I8[] [39,80,114,111,116,111,99,111,108,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.485876485 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError1_closure" {
     GHC.IO.Exception.$tc'ProtocolError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ProtocolError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.488148454 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError_closure" {
     GHC.IO.Exception.$tc'ProtocolError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ProtocolError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2348878698518162749;
         const 1616623917153004368;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.4900297 UTC

[section ""cstring" . GHC.IO.Exception.$tc'OtherError2_bytes" {
     GHC.IO.Exception.$tc'OtherError2_bytes:
         I8[] [39,79,116,104,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.491682482 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError1_closure" {
     GHC.IO.Exception.$tc'OtherError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'OtherError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.493473739 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError_closure" {
     GHC.IO.Exception.$tc'OtherError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'OtherError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 11457353566076247204;
         const 7448318885269020484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.495248208 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InvalidArgument2_bytes" {
     GHC.IO.Exception.$tc'InvalidArgument2_bytes:
         I8[] [39,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.496765209 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument1_closure" {
     GHC.IO.Exception.$tc'InvalidArgument1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InvalidArgument2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.498766005 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument_closure" {
     GHC.IO.Exception.$tc'InvalidArgument_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InvalidArgument1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2877905627043716713;
         const 870624010466166536;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.500450732 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InappropriateType2_bytes" {
     GHC.IO.Exception.$tc'InappropriateType2_bytes:
         I8[] [39,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.502173472 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType1_closure" {
     GHC.IO.Exception.$tc'InappropriateType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InappropriateType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.503827444 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType_closure" {
     GHC.IO.Exception.$tc'InappropriateType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InappropriateType1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 12194312324817842633;
         const 15900888301186079347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.505597178 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HardwareFault2_bytes" {
     GHC.IO.Exception.$tc'HardwareFault2_bytes:
         I8[] [39,72,97,114,100,119,97,114,101,70,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.507211302 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault1_closure" {
     GHC.IO.Exception.$tc'HardwareFault1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HardwareFault2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.508886178 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault_closure" {
     GHC.IO.Exception.$tc'HardwareFault_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HardwareFault1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 56378797976289033;
         const 18431513512258190916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.511208836 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsupportedOperation2_bytes" {
     GHC.IO.Exception.$tc'UnsupportedOperation2_bytes:
         I8[] [39,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.513443232 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation1_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsupportedOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.515145281 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsupportedOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 8512525638220727204;
         const 8859286885870192330;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.516971072 UTC

[section ""cstring" . GHC.IO.Exception.$tc'TimeExpired2_bytes" {
     GHC.IO.Exception.$tc'TimeExpired2_bytes:
         I8[] [39,84,105,109,101,69,120,112,105,114,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.518653281 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired1_closure" {
     GHC.IO.Exception.$tc'TimeExpired1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'TimeExpired2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.520347872 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired_closure" {
     GHC.IO.Exception.$tc'TimeExpired_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'TimeExpired1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 10911629093425571025;
         const 350480745296812363;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.522593313 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceVanished2_bytes" {
     GHC.IO.Exception.$tc'ResourceVanished2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.524216823 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished1_closure" {
     GHC.IO.Exception.$tc'ResourceVanished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceVanished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.525957236 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished_closure" {
     GHC.IO.Exception.$tc'ResourceVanished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceVanished1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14859807110076739958;
         const 15612633629389469803;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.527856948 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Interrupted2_bytes" {
     GHC.IO.Exception.$tc'Interrupted2_bytes:
         I8[] [39,73,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.529531381 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted1_closure" {
     GHC.IO.Exception.$tc'Interrupted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Interrupted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.531303296 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted_closure" {
     GHC.IO.Exception.$tc'Interrupted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Interrupted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17492795632142579451;
         const 15910845476779721305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.533107464 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException6_bytes" {
     GHC.IO.Exception.$fExceptionIOException6_bytes:
         I8[] [73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.535173298 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException5_closure" {
     GHC.IO.Exception.$fExceptionIOException5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionIOException6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.536975511 UTC

[section ""data" . GHC.IO.Exception.$tcIOException_closure" {
     GHC.IO.Exception.$tcIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionIOException5_closure+1;
         const GHC.Types.krep$*_closure;
         const 10434000377887324342;
         const 16509375198449321302;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.539485771 UTC

[section ""data" . $krep20_r8j3A_closure" {
     $krep20_r8j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.541327387 UTC

[section ""data" . $krep21_r8j3B_closure" {
     $krep21_r8j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8j3q_closure+1;
         const $krep20_r8j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.542994184 UTC

[section ""data" . $krep22_r8j3C_closure" {
     $krep22_r8j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8j3k_closure+1;
         const $krep21_r8j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.54475981 UTC

[section ""data" . $krep23_r8j3D_closure" {
     $krep23_r8j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep22_r8j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.546547006 UTC

[section ""data" . $krep24_r8j3E_closure" {
     $krep24_r8j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep23_r8j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.548303212 UTC

[section ""data" . $krep25_r8j3F_closure" {
     $krep25_r8j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const $krep24_r8j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.550434251 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError1_closure" {
     GHC.IO.Exception.$tc'IOError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8j3m_closure+1;
         const $krep25_r8j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.552219783 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IOError3_bytes" {
     GHC.IO.Exception.$tc'IOError3_bytes:
         I8[] [39,73,79,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.553915405 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError2_closure" {
     GHC.IO.Exception.$tc'IOError2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IOError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.555647742 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError_closure" {
     GHC.IO.Exception.$tc'IOError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IOError2_closure+1;
         const GHC.IO.Exception.$tc'IOError1_closure+4;
         const 16489485703680136625;
         const 16514523686887444952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.558070519 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException4_closure" {
     GHC.IO.Exception.$fExceptionIOException4_closure:
         const GHC.IO.Exception.$fExceptionIOException4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException4_entry() //  [R1]
         { info_tbl: [(c8o53,
                       label: GHC.IO.Exception.$fExceptionIOException4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o53: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8o54; else goto c8o55;
       c8o54: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8o55: // global
           (_c8o4V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8o4V::I64 == 0) goto c8o4X; else goto c8o4W;
       c8o4X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8o4W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8o4V::I64;
           I64[Sp - 24] = block_c8o4Y_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionIOException5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 16509375198449321302;
           R2 = 10434000377887324342;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8o4Y() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8o4Y,
                       label: block_c8o4Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o4Y: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8o4Z() args: 0, res: 0, upd: 0;
     }
 },
 _c8o4Z() //  []
         { info_tbl: [(c8o4Z,
                       label: block_c8o4Z_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o4Z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8o58; else goto c8o57;
       c8o58: // global
           HpAlloc = 48;
           I64[Sp] = block_c8o4Z_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8o57: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.567076066 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8o5B,
                       label: GHC.IO.Exception.$fExceptionIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o5B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o5F; else goto c8o5G;
       c8o5F: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o5G: // global
           I64[Sp - 8] = block_c8o5y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8o61; else goto c8o5z;
       u8o61: // global
           call _c8o5y(R1) args: 0, res: 0, upd: 0;
       c8o5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o5y() //  [R1]
         { info_tbl: [(c8o5y,
                       label: block_c8o5y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o5y: // global
           I64[Sp - 8] = block_c8o5E_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o5E() //  [R1]
         { info_tbl: [(c8o5E,
                       label: block_c8o5E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o5E: // global
           I64[Sp] = block_c8o5L_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o5L() //  [R1]
         { info_tbl: [(c8o5L,
                       label: block_c8o5L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o5L: // global
           if (R1 & 7 == 1) goto c8o5S; else goto c8o5W;
       c8o5S: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8o5W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8o5Z; else goto c8o5Y;
       c8o5Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8o5Y: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.577012549 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_closure" {
     GHC.IO.Exception.$fExceptionIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Exception.$fShowIOException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8o6s,
                       label: GHC.IO.Exception.$fExceptionIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o6s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o6w; else goto c8o6v;
       c8o6w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o6v: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.582296027 UTC

[section ""data" . GHC.IO.Exception.ioError1_closure" {
     GHC.IO.Exception.ioError1_closure:
         const GHC.IO.Exception.ioError1_info;
         const 0;
 },
 sat_s8jh2_entry() //  [R1]
         { info_tbl: [(c8o6L,
                       label: sat_s8jh2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o6L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o6M; else goto c8o6N;
       c8o6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8o6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.ioError1_entry() //  [R2]
         { info_tbl: [(c8o6O,
                       label: GHC.IO.Exception.ioError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o6O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o6S; else goto c8o6R;
       c8o6S: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.ioError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o6R: // global
           I64[Hp - 16] = sat_s8jh2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.587986066 UTC

[section ""data" . GHC.IO.Exception.ioException_closure" {
     GHC.IO.Exception.ioException_closure:
         const GHC.IO.Exception.ioException_info;
         const 0;
 },
 GHC.IO.Exception.ioException_entry() //  [R2]
         { info_tbl: [(c8o75,
                       label: GHC.IO.Exception.ioException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o75: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.591480705 UTC

[section ""data" . GHC.IO.Exception.ioError_closure" {
     GHC.IO.Exception.ioError_closure:
         const GHC.IO.Exception.ioError_info;
         const 0;
 },
 GHC.IO.Exception.ioError_entry() //  [R2]
         { info_tbl: [(c8o7g,
                       label: GHC.IO.Exception.ioError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o7g: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.59471737 UTC

[section ""data" . GHC.IO.Exception.$fxExceptionIOException_closure" {
     GHC.IO.Exception.$fxExceptionIOException_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Exception.$fExceptionIOException_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.597046925 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_entry() //  [R2]
         { info_tbl: [(c8o7v,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o7v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o7z; else goto c8o7A;
       c8o7z: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o7A: // global
           I64[Sp - 8] = block_c8o7s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8o7V; else goto c8o7t;
       u8o7V: // global
           call _c8o7s(R1) args: 0, res: 0, upd: 0;
       c8o7t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o7s() //  [R1]
         { info_tbl: [(c8o7s,
                       label: block_c8o7s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o7s: // global
           I64[Sp - 8] = block_c8o7y_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o7y() //  [R1]
         { info_tbl: [(c8o7y,
                       label: block_c8o7y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o7y: // global
           I64[Sp] = block_c8o7F_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o7F() //  [R1]
         { info_tbl: [(c8o7F,
                       label: block_c8o7F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o7F: // global
           if (R1 & 7 == 1) goto c8o7M; else goto c8o7Q;
       c8o7M: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8o7Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8o7T; else goto c8o7S;
       c8o7T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8o7S: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.607381482 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry() //  [R2]
         { info_tbl: [(c8o8m,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o8q; else goto c8o8p;
       c8o8q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o8p: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.612241886 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnMVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnMVar_entry() //  [R1]
         { info_tbl: [(c8o8D,
                       label: GHC.IO.Exception.blockedIndefinitelyOnMVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o8E; else goto c8o8F;
       c8o8E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8o8F: // global
           (_c8o8A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8o8A::I64 == 0) goto c8o8C; else goto c8o8B;
       c8o8C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8o8B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8o8A::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.617433219 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_entry() //  [R2]
         { info_tbl: [(c8o8U,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o8Y; else goto c8o8Z;
       c8o8Y: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o8Z: // global
           I64[Sp - 8] = block_c8o8R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8o9k; else goto c8o8S;
       u8o9k: // global
           call _c8o8R(R1) args: 0, res: 0, upd: 0;
       c8o8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o8R() //  [R1]
         { info_tbl: [(c8o8R,
                       label: block_c8o8R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8R: // global
           I64[Sp - 8] = block_c8o8X_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o8X() //  [R1]
         { info_tbl: [(c8o8X,
                       label: block_c8o8X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8X: // global
           I64[Sp] = block_c8o94_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8o94() //  [R1]
         { info_tbl: [(c8o94,
                       label: block_c8o94_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o94: // global
           if (R1 & 7 == 1) goto c8o9b; else goto c8o9f;
       c8o9b: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8o9f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8o9i; else goto c8o9h;
       c8o9i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8o9h: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.62652528 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry() //  [R2]
         { info_tbl: [(c8o9L,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o9L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8o9P; else goto c8o9O;
       c8o9P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8o9O: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.631879352 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnSTM_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnSTM_entry() //  [R1]
         { info_tbl: [(c8oa2,
                       label: GHC.IO.Exception.blockedIndefinitelyOnSTM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oa2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oa3; else goto c8oa4;
       c8oa3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oa4: // global
           (_c8o9Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8o9Z::I64 == 0) goto c8oa1; else goto c8oa0;
       c8oa1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oa0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8o9Z::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.636810215 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8oba_srtd" {
     u8oba_srtd:
         const S8ji8_srt+688;
         const 35;
         const 25771900929;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_entry() //  [R2]
         { info_tbl: [(c8oaj,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oaj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oan; else goto c8oao;
       c8oan: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oao: // global
           I64[Sp - 8] = block_c8oag_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ob7; else goto c8oah;
       u8ob7: // global
           call _c8oag(R1) args: 0, res: 0, upd: 0;
       c8oah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8obb_srtd" {
     u8obb_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8oag() //  [R1]
         { info_tbl: [(c8oag,
                       label: block_c8oag_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oag: // global
           I64[Sp - 8] = block_c8oam_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8obc_srtd" {
     u8obc_srtd:
         const S8ji8_srt+688;
         const 35;
         const 17181966337;
 },
 _c8oam() //  [R1]
         { info_tbl: [(c8oam,
                       label: block_c8oam_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oam: // global
           I64[Sp] = block_c8oat_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oat() //  [R1]
         { info_tbl: [(c8oat,
                       label: block_c8oat_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oat: // global
           if (R1 & 7 == 1) goto u8ob5; else goto c8oaJ;
       u8ob5: // global
           Sp = Sp + 16;
           call _c8oaV() args: 0, res: 0, upd: 0;
       c8oaJ: // global
           _s8jhi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8oaD_info;
           R1 = _s8jhi::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oaD() //  [R1]
         { info_tbl: [(c8oaD,
                       label: block_c8oaD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oaD: // global
           I64[Sp - 8] = block_c8oaH_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oaH() //  [R1]
         { info_tbl: [(c8oaH,
                       label: block_c8oaH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oaH: // global
           I64[Sp] = block_c8oaO_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oaO() //  [R1]
         { info_tbl: [(c8oaO,
                       label: block_c8oaO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oaO: // global
           if (R1 & 7 == 1) goto u8ob6; else goto c8oaZ;
       u8ob6: // global
           Sp = Sp + 16;
           call _c8oaV() args: 0, res: 0, upd: 0;
       c8oaZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ob2; else goto c8ob1;
       c8ob2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ob1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8oaV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oaV: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.654326822 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry() //  [R2]
         { info_tbl: [(c8obU,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8obU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8obY; else goto c8obX;
       c8obY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8obX: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.659035 UTC

[section ""data" . GHC.IO.Exception.allocationLimitExceeded_closure" {
     GHC.IO.Exception.allocationLimitExceeded_closure:
         const GHC.IO.Exception.allocationLimitExceeded_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.allocationLimitExceeded_entry() //  [R1]
         { info_tbl: [(c8oca,
                       label: GHC.IO.Exception.allocationLimitExceeded_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ocb; else goto c8occ;
       c8ocb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8occ: // global
           (_c8oc7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oc7::I64 == 0) goto c8oc9; else goto c8oc8;
       c8oc9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oc8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oc7::I64;
           R2 = GHC.IO.Exception.AllocationLimitExceeded_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.663806743 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8ocr,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ocr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ocv; else goto c8ocw;
       c8ocv: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ocw: // global
           I64[Sp - 8] = block_c8oco_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ocR; else goto c8ocp;
       u8ocR: // global
           call _c8oco(R1) args: 0, res: 0, upd: 0;
       c8ocp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oco() //  [R1]
         { info_tbl: [(c8oco,
                       label: block_c8oco_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oco: // global
           I64[Sp - 8] = block_c8ocu_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ocu() //  [R1]
         { info_tbl: [(c8ocu,
                       label: block_c8ocu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ocu: // global
           I64[Sp] = block_c8ocB_info;
           R3 = GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ocB() //  [R1]
         { info_tbl: [(c8ocB,
                       label: block_c8ocB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ocB: // global
           if (R1 & 7 == 1) goto c8ocI; else goto c8ocM;
       c8ocI: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ocM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ocP; else goto c8ocO;
       c8ocP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ocO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.672777094 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fShowCompactionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8odi,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8odi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8odm; else goto c8odl;
       c8odm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8odl: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionCompactionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.677199118 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactMutable2_bytes" {
     GHC.IO.Exception.cannotCompactMutable2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,109,117,116,97,98,108,101,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.680008305 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable1_closure" {
     GHC.IO.Exception.cannotCompactMutable1_closure:
         const GHC.IO.Exception.cannotCompactMutable1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable1_entry() //  [R1]
         { info_tbl: [(c8odA,
                       label: GHC.IO.Exception.cannotCompactMutable1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8odA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8odB; else goto c8odC;
       c8odB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8odC: // global
           (_c8odx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8odx::I64 == 0) goto c8odz; else goto c8ody;
       c8odz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ody: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8odx::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.683984106 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable_closure" {
     GHC.IO.Exception.cannotCompactMutable_closure:
         const GHC.IO.Exception.cannotCompactMutable_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable_entry() //  [R1]
         { info_tbl: [(c8odQ,
                       label: GHC.IO.Exception.cannotCompactMutable_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8odQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8odR; else goto c8odS;
       c8odR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8odS: // global
           (_c8odN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8odN::I64 == 0) goto c8odP; else goto c8odO;
       c8odP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8odO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8odN::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.687839928 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactPinned2_bytes" {
     GHC.IO.Exception.cannotCompactPinned2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,112,105,110,110,101,100,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.690086733 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned1_closure" {
     GHC.IO.Exception.cannotCompactPinned1_closure:
         const GHC.IO.Exception.cannotCompactPinned1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned1_entry() //  [R1]
         { info_tbl: [(c8oe7,
                       label: GHC.IO.Exception.cannotCompactPinned1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oe7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oe8; else goto c8oe9;
       c8oe8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oe9: // global
           (_c8oe4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oe4::I64 == 0) goto c8oe6; else goto c8oe5;
       c8oe6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oe5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oe4::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.6939744 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned_closure" {
     GHC.IO.Exception.cannotCompactPinned_closure:
         const GHC.IO.Exception.cannotCompactPinned_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned_entry() //  [R1]
         { info_tbl: [(c8oen,
                       label: GHC.IO.Exception.cannotCompactPinned_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oen: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oeo; else goto c8oep;
       c8oeo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oep: // global
           (_c8oek::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oek::I64 == 0) goto c8oem; else goto c8oel;
       c8oem: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oel: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oek::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.69775267 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactFunction2_bytes" {
     GHC.IO.Exception.cannotCompactFunction2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,102,117,110,99,116,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.699559255 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction1_closure" {
     GHC.IO.Exception.cannotCompactFunction1_closure:
         const GHC.IO.Exception.cannotCompactFunction1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction1_entry() //  [R1]
         { info_tbl: [(c8oeE,
                       label: GHC.IO.Exception.cannotCompactFunction1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oeE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oeF; else goto c8oeG;
       c8oeF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oeG: // global
           (_c8oeB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oeB::I64 == 0) goto c8oeD; else goto c8oeC;
       c8oeD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oeC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oeB::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.703820586 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction_closure" {
     GHC.IO.Exception.cannotCompactFunction_closure:
         const GHC.IO.Exception.cannotCompactFunction_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction_entry() //  [R1]
         { info_tbl: [(c8oeU,
                       label: GHC.IO.Exception.cannotCompactFunction_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oeU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oeV; else goto c8oeW;
       c8oeV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oeW: // global
           (_c8oeR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oeR::I64 == 0) goto c8oeT; else goto c8oeS;
       c8oeT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oeS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oeR::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.708384615 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8og2_srtd" {
     u8og2_srtd:
         const S8ji8_srt+688;
         const 47;
         const 105553118363649;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8ofb,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8off; else goto c8ofg;
       c8off: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ofg: // global
           I64[Sp - 8] = block_c8of8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ofZ; else goto c8of9;
       u8ofZ: // global
           call _c8of8(R1) args: 0, res: 0, upd: 0;
       c8of9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8og3_srtd" {
     u8og3_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8of8() //  [R1]
         { info_tbl: [(c8of8,
                       label: block_c8of8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8of8: // global
           I64[Sp - 8] = block_c8ofe_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8og4_srtd" {
     u8og4_srtd:
         const S8ji8_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8ofe() //  [R1]
         { info_tbl: [(c8ofe,
                       label: block_c8ofe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofe: // global
           I64[Sp] = block_c8ofl_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ofl() //  [R1]
         { info_tbl: [(c8ofl,
                       label: block_c8ofl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofl: // global
           if (R1 & 7 == 1) goto u8ofX; else goto c8ofB;
       u8ofX: // global
           Sp = Sp + 16;
           call _c8ofN() args: 0, res: 0, upd: 0;
       c8ofB: // global
           _s8jhB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ofv_info;
           R1 = _s8jhB::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ofv() //  [R1]
         { info_tbl: [(c8ofv,
                       label: block_c8ofv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofv: // global
           I64[Sp - 8] = block_c8ofz_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ofz() //  [R1]
         { info_tbl: [(c8ofz,
                       label: block_c8ofz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofz: // global
           I64[Sp] = block_c8ofG_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ofG() //  [R1]
         { info_tbl: [(c8ofG,
                       label: block_c8ofG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofG: // global
           if (R1 & 7 == 1) goto u8ofY; else goto c8ofR;
       u8ofY: // global
           Sp = Sp + 16;
           call _c8ofN() args: 0, res: 0, upd: 0;
       c8ofR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ofU; else goto c8ofT;
       c8ofU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ofT: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ofN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ofN: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.725808309 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fShowAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8ogM,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ogM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ogQ; else goto c8ogP;
       c8ogQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ogP: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAsyncException_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.730453144 UTC

[section ""data" . GHC.IO.Exception.heapOverflow_closure" {
     GHC.IO.Exception.heapOverflow_closure:
         const GHC.IO.Exception.heapOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.heapOverflow_entry() //  [R1]
         { info_tbl: [(c8oh2,
                       label: GHC.IO.Exception.heapOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oh2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oh3; else goto c8oh4;
       c8oh3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oh4: // global
           (_c8ogZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ogZ::I64 == 0) goto c8oh1; else goto c8oh0;
       c8oh1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oh0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ogZ::I64;
           R2 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.734399482 UTC

[section ""data" . GHC.IO.Exception.stackOverflow_closure" {
     GHC.IO.Exception.stackOverflow_closure:
         const GHC.IO.Exception.stackOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.stackOverflow_entry() //  [R1]
         { info_tbl: [(c8ohi,
                       label: GHC.IO.Exception.stackOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ohi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ohj; else goto c8ohk;
       c8ohj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ohk: // global
           (_c8ohf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ohf::I64 == 0) goto c8ohh; else goto c8ohg;
       c8ohh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ohg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ohf::I64;
           R2 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.739013134 UTC

[section ""data" . GHC.IO.Exception.IOError_closure" {
     GHC.IO.Exception.IOError_closure:
         const GHC.IO.Exception.IOError_info;
 },
 GHC.IO.Exception.IOError_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8ohx,
                       label: GHC.IO.Exception.IOError_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ohx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ohB; else goto c8ohA;
       c8ohB: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.IOError_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8ohA: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.742809245 UTC

[section ""data" . GHC.IO.Exception.AlreadyExists_closure" {
     GHC.IO.Exception.AlreadyExists_closure:
         const GHC.IO.Exception.AlreadyExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.744401824 UTC

[section ""data" . GHC.IO.Exception.NoSuchThing_closure" {
     GHC.IO.Exception.NoSuchThing_closure:
         const GHC.IO.Exception.NoSuchThing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.746663242 UTC

[section ""data" . GHC.IO.Exception.ResourceBusy_closure" {
     GHC.IO.Exception.ResourceBusy_closure:
         const GHC.IO.Exception.ResourceBusy_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.748305058 UTC

[section ""data" . GHC.IO.Exception.ResourceExhausted_closure" {
     GHC.IO.Exception.ResourceExhausted_closure:
         const GHC.IO.Exception.ResourceExhausted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.750208714 UTC

[section ""data" . GHC.IO.Exception.EOF_closure" {
     GHC.IO.Exception.EOF_closure:
         const GHC.IO.Exception.EOF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.751849892 UTC

[section ""data" . GHC.IO.Exception.IllegalOperation_closure" {
     GHC.IO.Exception.IllegalOperation_closure:
         const GHC.IO.Exception.IllegalOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.753455026 UTC

[section ""data" . GHC.IO.Exception.PermissionDenied_closure" {
     GHC.IO.Exception.PermissionDenied_closure:
         const GHC.IO.Exception.PermissionDenied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.755075877 UTC

[section ""data" . GHC.IO.Exception.UserError_closure" {
     GHC.IO.Exception.UserError_closure:
         const GHC.IO.Exception.UserError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.756737665 UTC

[section ""data" . GHC.IO.Exception.UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.UnsatisfiedConstraints_closure:
         const GHC.IO.Exception.UnsatisfiedConstraints_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.758440932 UTC

[section ""data" . GHC.IO.Exception.SystemError_closure" {
     GHC.IO.Exception.SystemError_closure:
         const GHC.IO.Exception.SystemError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.760075801 UTC

[section ""data" . GHC.IO.Exception.ProtocolError_closure" {
     GHC.IO.Exception.ProtocolError_closure:
         const GHC.IO.Exception.ProtocolError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.762110838 UTC

[section ""data" . GHC.IO.Exception.OtherError_closure" {
     GHC.IO.Exception.OtherError_closure:
         const GHC.IO.Exception.OtherError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.763737348 UTC

[section ""data" . GHC.IO.Exception.InvalidArgument_closure" {
     GHC.IO.Exception.InvalidArgument_closure:
         const GHC.IO.Exception.InvalidArgument_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.765391538 UTC

[section ""data" . GHC.IO.Exception.InappropriateType_closure" {
     GHC.IO.Exception.InappropriateType_closure:
         const GHC.IO.Exception.InappropriateType_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.767044709 UTC

[section ""data" . GHC.IO.Exception.HardwareFault_closure" {
     GHC.IO.Exception.HardwareFault_closure:
         const GHC.IO.Exception.HardwareFault_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.768683812 UTC

[section ""data" . GHC.IO.Exception.UnsupportedOperation_closure" {
     GHC.IO.Exception.UnsupportedOperation_closure:
         const GHC.IO.Exception.UnsupportedOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.770768376 UTC

[section ""data" . GHC.IO.Exception.TimeExpired_closure" {
     GHC.IO.Exception.TimeExpired_closure:
         const GHC.IO.Exception.TimeExpired_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.772536974 UTC

[section ""data" . GHC.IO.Exception.ResourceVanished_closure" {
     GHC.IO.Exception.ResourceVanished_closure:
         const GHC.IO.Exception.ResourceVanished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.774601401 UTC

[section ""data" . GHC.IO.Exception.Interrupted_closure" {
     GHC.IO.Exception.Interrupted_closure:
         const GHC.IO.Exception.Interrupted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.776305997 UTC

[section ""data" . GHC.IO.Exception.ExitSuccess_closure" {
     GHC.IO.Exception.ExitSuccess_closure:
         const GHC.IO.Exception.ExitSuccess_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.778275859 UTC

[section ""data" . GHC.IO.Exception.ExitFailure_closure" {
     GHC.IO.Exception.ExitFailure_closure:
         const GHC.IO.Exception.ExitFailure_info;
 },
 GHC.IO.Exception.ExitFailure_entry() //  [R2]
         { info_tbl: [(c8oi7,
                       label: GHC.IO.Exception.ExitFailure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oi7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8oib; else goto c8oia;
       c8oib: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.ExitFailure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oia: // global
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.781992613 UTC

[section ""data" . GHC.IO.Exception.FixIOException_closure" {
     GHC.IO.Exception.FixIOException_closure:
         const GHC.IO.Exception.FixIOException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.783810454 UTC

[section ""data" . GHC.IO.Exception.IndexOutOfBounds_closure" {
     GHC.IO.Exception.IndexOutOfBounds_closure:
         const GHC.IO.Exception.IndexOutOfBounds_info;
 },
 GHC.IO.Exception.IndexOutOfBounds_entry() //  [R2]
         { info_tbl: [(c8oin,
                       label: GHC.IO.Exception.IndexOutOfBounds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oin: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8oir; else goto c8oiq;
       c8oir: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.IndexOutOfBounds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oiq: // global
           I64[Hp - 8] = GHC.IO.Exception.IndexOutOfBounds_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.78786644 UTC

[section ""data" . GHC.IO.Exception.UndefinedElement_closure" {
     GHC.IO.Exception.UndefinedElement_closure:
         const GHC.IO.Exception.UndefinedElement_info;
 },
 GHC.IO.Exception.UndefinedElement_entry() //  [R2]
         { info_tbl: [(c8oiC,
                       label: GHC.IO.Exception.UndefinedElement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oiC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8oiG; else goto c8oiF;
       c8oiG: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.UndefinedElement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oiF: // global
           I64[Hp - 8] = GHC.IO.Exception.UndefinedElement_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.791319248 UTC

[section ""data" . GHC.IO.Exception.StackOverflow_closure" {
     GHC.IO.Exception.StackOverflow_closure:
         const GHC.IO.Exception.StackOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.792954305 UTC

[section ""data" . GHC.IO.Exception.HeapOverflow_closure" {
     GHC.IO.Exception.HeapOverflow_closure:
         const GHC.IO.Exception.HeapOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.794606234 UTC

[section ""data" . GHC.IO.Exception.ThreadKilled_closure" {
     GHC.IO.Exception.ThreadKilled_closure:
         const GHC.IO.Exception.ThreadKilled_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.796245801 UTC

[section ""data" . GHC.IO.Exception.UserInterrupt_closure" {
     GHC.IO.Exception.UserInterrupt_closure:
         const GHC.IO.Exception.UserInterrupt_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.798171251 UTC

[section ""data" . GHC.IO.Exception.SomeAsyncException_closure" {
     GHC.IO.Exception.SomeAsyncException_closure:
         const GHC.IO.Exception.SomeAsyncException_info;
 },
 GHC.IO.Exception.SomeAsyncException_entry() //  [R2, R3]
         { info_tbl: [(c8oiV,
                       label: GHC.IO.Exception.SomeAsyncException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oiV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8oiZ; else goto c8oiY;
       c8oiZ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.SomeAsyncException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oiY: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.802683316 UTC

[section ""data" . GHC.IO.Exception.AllocationLimitExceeded_closure" {
     GHC.IO.Exception.AllocationLimitExceeded_closure:
         const GHC.IO.Exception.AllocationLimitExceeded_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.804262874 UTC

[section ""data" . GHC.IO.Exception.Deadlock_closure" {
     GHC.IO.Exception.Deadlock_closure:
         const GHC.IO.Exception.Deadlock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.805842291 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.807517147 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.809219472 UTC

[GHC.IO.Exception.IOError_con_entry() //  [R1]
         { info_tbl: [(c8oj9,
                       label: GHC.IO.Exception.IOError_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,79,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oj9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.812429447 UTC

[section ""relreadonly" . GHC.IO.Exception.IOErrorType_closure_tbl" {
     GHC.IO.Exception.IOErrorType_closure_tbl:
         const GHC.IO.Exception.AlreadyExists_closure+1;
         const GHC.IO.Exception.NoSuchThing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.IO.Exception.PermissionDenied_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.IO.Exception.UnsatisfiedConstraints_closure+1;
         const GHC.IO.Exception.SystemError_closure+1;
         const GHC.IO.Exception.ProtocolError_closure+1;
         const GHC.IO.Exception.OtherError_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Exception.HardwareFault_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.IO.Exception.TimeExpired_closure+1;
         const GHC.IO.Exception.ResourceVanished_closure+1;
         const GHC.IO.Exception.Interrupted_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.814549055 UTC

[GHC.IO.Exception.AlreadyExists_con_entry() //  [R1]
         { info_tbl: [(c8ojg,
                       label: GHC.IO.Exception.AlreadyExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,114,101,97,100,121,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.818172994 UTC

[GHC.IO.Exception.NoSuchThing_con_entry() //  [R1]
         { info_tbl: [(c8ojm,
                       label: GHC.IO.Exception.NoSuchThing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,78,111,83,117,99,104,84,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.821351308 UTC

[GHC.IO.Exception.ResourceBusy_con_entry() //  [R1]
         { info_tbl: [(c8ojs,
                       label: GHC.IO.Exception.ResourceBusy_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,66,117,115,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojs: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.824536753 UTC

[GHC.IO.Exception.ResourceExhausted_con_entry() //  [R1]
         { info_tbl: [(c8ojy,
                       label: GHC.IO.Exception.ResourceExhausted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.828289083 UTC

[GHC.IO.Exception.EOF_con_entry() //  [R1]
         { info_tbl: [(c8ojE,
                       label: GHC.IO.Exception.EOF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,79,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojE: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.831842255 UTC

[GHC.IO.Exception.IllegalOperation_con_entry() //  [R1]
         { info_tbl: [(c8ojK,
                       label: GHC.IO.Exception.IllegalOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.834938234 UTC

[GHC.IO.Exception.PermissionDenied_con_entry() //  [R1]
         { info_tbl: [(c8ojQ,
                       label: GHC.IO.Exception.PermissionDenied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 6
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.838054699 UTC

[GHC.IO.Exception.UserError_con_entry() //  [R1]
         { info_tbl: [(c8ojW,
                       label: GHC.IO.Exception.UserError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 7
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ojW: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.841107457 UTC

[GHC.IO.Exception.UnsatisfiedConstraints_con_entry() //  [R1]
         { info_tbl: [(c8ok2,
                       label: GHC.IO.Exception.UnsatisfiedConstraints_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 8
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ok2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.844256516 UTC

[GHC.IO.Exception.SystemError_con_entry() //  [R1]
         { info_tbl: [(c8ok8,
                       label: GHC.IO.Exception.SystemError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 9
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,121,115,116,101,109,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ok8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.847447222 UTC

[GHC.IO.Exception.ProtocolError_con_entry() //  [R1]
         { info_tbl: [(c8oke,
                       label: GHC.IO.Exception.ProtocolError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 10
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,114,111,116,111,99,111,108,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oke: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.850889062 UTC

[GHC.IO.Exception.OtherError_con_entry() //  [R1]
         { info_tbl: [(c8okk,
                       label: GHC.IO.Exception.OtherError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 11
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,79,116,104,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.854042006 UTC

[GHC.IO.Exception.InvalidArgument_con_entry() //  [R1]
         { info_tbl: [(c8okq,
                       label: GHC.IO.Exception.InvalidArgument_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 12
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okq: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.857709269 UTC

[GHC.IO.Exception.InappropriateType_con_entry() //  [R1]
         { info_tbl: [(c8okw,
                       label: GHC.IO.Exception.InappropriateType_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 13
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.860842161 UTC

[GHC.IO.Exception.HardwareFault_con_entry() //  [R1]
         { info_tbl: [(c8okC,
                       label: GHC.IO.Exception.HardwareFault_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 14
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,97,114,100,119,97,114,101,70,97,117,108,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.86398594 UTC

[GHC.IO.Exception.UnsupportedOperation_con_entry() //  [R1]
         { info_tbl: [(c8okI,
                       label: GHC.IO.Exception.UnsupportedOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 15
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okI: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.867150608 UTC

[GHC.IO.Exception.TimeExpired_con_entry() //  [R1]
         { info_tbl: [(c8okO,
                       label: GHC.IO.Exception.TimeExpired_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 16
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,105,109,101,69,120,112,105,114,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.8708941 UTC

[GHC.IO.Exception.ResourceVanished_con_entry() //  [R1]
         { info_tbl: [(c8okU,
                       label: GHC.IO.Exception.ResourceVanished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 17
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8okU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.874029728 UTC

[GHC.IO.Exception.Interrupted_con_entry() //  [R1]
         { info_tbl: [(c8ol0,
                       label: GHC.IO.Exception.Interrupted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 18
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,116,101,114,114,117,112,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ol0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.877168607 UTC

[GHC.IO.Exception.ExitSuccess_con_entry() //  [R1]
         { info_tbl: [(c8ol6,
                       label: GHC.IO.Exception.ExitSuccess_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,83,117,99,99,101,115,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ol6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.880263224 UTC

[GHC.IO.Exception.ExitFailure_con_entry() //  [R1]
         { info_tbl: [(c8olc,
                       label: GHC.IO.Exception.ExitFailure_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olc: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.884653374 UTC

[section ""relreadonly" . GHC.IO.Exception.FixIOException_closure_tbl" {
     GHC.IO.Exception.FixIOException_closure_tbl:
         const GHC.IO.Exception.FixIOException_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.886326293 UTC

[GHC.IO.Exception.FixIOException_con_entry() //  [R1]
         { info_tbl: [(c8olj,
                       label: GHC.IO.Exception.FixIOException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,70,105,120,73,79,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.889494793 UTC

[GHC.IO.Exception.IndexOutOfBounds_con_entry() //  [R1]
         { info_tbl: [(c8olp,
                       label: GHC.IO.Exception.IndexOutOfBounds_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.892696319 UTC

[GHC.IO.Exception.UndefinedElement_con_entry() //  [R1]
         { info_tbl: [(c8olv,
                       label: GHC.IO.Exception.UndefinedElement_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olv: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.896265634 UTC

[section ""relreadonly" . GHC.IO.Exception.AsyncException_closure_tbl" {
     GHC.IO.Exception.AsyncException_closure_tbl:
         const GHC.IO.Exception.StackOverflow_closure+1;
         const GHC.IO.Exception.HeapOverflow_closure+2;
         const GHC.IO.Exception.ThreadKilled_closure+3;
         const GHC.IO.Exception.UserInterrupt_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.898088385 UTC

[GHC.IO.Exception.StackOverflow_con_entry() //  [R1]
         { info_tbl: [(c8olC,
                       label: GHC.IO.Exception.StackOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,116,97,99,107,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.901179715 UTC

[GHC.IO.Exception.HeapOverflow_con_entry() //  [R1]
         { info_tbl: [(c8olI,
                       label: GHC.IO.Exception.HeapOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,101,97,112,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olI: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.90432174 UTC

[GHC.IO.Exception.ThreadKilled_con_entry() //  [R1]
         { info_tbl: [(c8olO,
                       label: GHC.IO.Exception.ThreadKilled_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,104,114,101,97,100,75,105,108,108,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olO: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.907823757 UTC

[GHC.IO.Exception.UserInterrupt_con_entry() //  [R1]
         { info_tbl: [(c8olU,
                       label: GHC.IO.Exception.UserInterrupt_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,73,110,116,101,114,114,117,112,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8olU: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.911429286 UTC

[GHC.IO.Exception.SomeAsyncException_con_entry() //  [R1]
         { info_tbl: [(c8om0,
                       label: GHC.IO.Exception.SomeAsyncException_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8om0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.914684281 UTC

[section ""relreadonly" . GHC.IO.Exception.AllocationLimitExceeded_closure_tbl" {
     GHC.IO.Exception.AllocationLimitExceeded_closure_tbl:
         const GHC.IO.Exception.AllocationLimitExceeded_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.916386686 UTC

[GHC.IO.Exception.AllocationLimitExceeded_con_entry() //  [R1]
         { info_tbl: [(c8om7,
                       label: GHC.IO.Exception.AllocationLimitExceeded_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8om7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.919835897 UTC

[section ""relreadonly" . GHC.IO.Exception.Deadlock_closure_tbl" {
     GHC.IO.Exception.Deadlock_closure_tbl:
         const GHC.IO.Exception.Deadlock_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.922125438 UTC

[GHC.IO.Exception.Deadlock_con_entry() //  [R1]
         { info_tbl: [(c8ome,
                       label: GHC.IO.Exception.Deadlock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,68,101,97,100,108,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ome: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.925193948 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.92694521 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_entry() //  [R1]
         { info_tbl: [(c8oml,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oml: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.930043647 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.931670497 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_entry() //  [R1]
         { info_tbl: [(c8oms,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oms: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:27.935104761 UTC

[section ""relreadonly" . S8ji8_srt" {
     S8ji8_srt:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fExceptionDeadlock1_closure;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
         const GHC.IO.Exception.$fShowDeadlock1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException3_closure;
         const GHC.IO.Exception.$fExceptionAsyncException5_closure;
         const GHC.IO.Exception.$fExceptionAsyncException7_closure;
         const GHC.IO.Exception.$w$cshowsPrec1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
         const GHC.IO.Exception.$fExceptionFixIOException1_closure;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowFixIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec4_closure;
         const lvl1_r8j2E_closure;
         const lvl3_r8j2G_closure;
         const lvl5_r8j2I_closure;
         const lvl7_r8j2K_closure;
         const lvl9_r8j2M_closure;
         const lvl11_r8j2O_closure;
         const lvl13_r8j2Q_closure;
         const lvl15_r8j2S_closure;
         const lvl17_r8j2U_closure;
         const lvl19_r8j2W_closure;
         const lvl21_r8j2Y_closure;
         const lvl23_r8j30_closure;
         const lvl25_r8j32_closure;
         const lvl27_r8j34_closure;
         const lvl29_r8j36_closure;
         const lvl31_r8j38_closure;
         const lvl33_r8j3a_closure;
         const lvl35_r8j3c_closure;
         const lvl37_r8j3e_closure;
         const GHC.IO.Exception.$fExceptionIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowIOException1_closure;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
         const GHC.IO.Exception.$fShowExitCode1_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Exception.$fReadExitCode2_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme1_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Exception.$fReadExitCode1_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const GHC.IO.Exception.$fReadExitCode6_closure;
         const GHC.IO.Exception.untangle2_closure;
         const GHC.IO.Exception.untangle_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
         const GHC.Exception.errorCallWithCallStackException9_closure;
         const GHC.Exception.errorCallWithCallStackException11_closure;
         const GHC.Exception.errorCallWithCallStackException6_closure;
         const GHC.IO.Exception.assertError1_closure;
         const GHC.IO.Exception.assertError_closure;
         const GHC.Stack.CCS.currentCallStack_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.asyncExceptionFromException_closure;
         const GHC.IO.Exception.asyncExceptionToException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fExceptionArrayException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fExceptionExitCode_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Exception.ioError1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
         const GHC.IO.Exception.cannotCompactMutable1_closure;
         const GHC.IO.Exception.cannotCompactPinned1_closure;
         const GHC.IO.Exception.cannotCompactFunction1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.552063042 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:32.553129771 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,77,86,97,114,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.555123067 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_entry() //  [R1]
         { info_tbl: [(c8oAK,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oAK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oAL; else goto c8oAM;
       c8oAL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oAM: // global
           (_c8oAH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oAH::I64 == 0) goto c8oAJ; else goto c8oAI;
       c8oAJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oAI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oAH::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.559389609 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(c8oB2,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oB2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oB3; else goto c8oB4;
       c8oB3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oB4: // global
           I64[Sp - 16] = block_c8oAZ_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oB8; else goto c8oB0;
       u8oB8: // global
           call _c8oAZ() args: 0, res: 0, upd: 0;
       c8oB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oAZ() //  []
         { info_tbl: [(c8oAZ,
                       label: block_c8oAZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oAZ: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.564963208 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_entry() //  [R2]
         { info_tbl: [(c8oBr,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oBr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oBs; else goto c8oBt;
       c8oBs: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oBt: // global
           I64[Sp - 8] = block_c8oBo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oBx; else goto c8oBp;
       u8oBx: // global
           call _c8oBo() args: 0, res: 0, upd: 0;
       c8oBp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oBo() //  []
         { info_tbl: [(c8oBo,
                       label: block_c8oBo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oBo: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.570537991 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8oBQ,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oBQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oBR; else goto c8oBS;
       c8oBR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oBS: // global
           I64[Sp - 16] = block_c8oBN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oBW; else goto c8oBO;
       u8oBW: // global
           call _c8oBN() args: 0, res: 0, upd: 0;
       c8oBO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oBN() //  []
         { info_tbl: [(c8oBN,
                       label: block_c8oBN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oBN: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.575979731 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(c8oCb,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oCb: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.579780726 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.581662421 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes:
         I8[] [116,104,114,101,97,100,32,98,108,111,99,107,101,100,32,105,110,100,101,102,105,110,105,116,101,108,121,32,105,110,32,97,110,32,83,84,77,32,116,114,97,110,115,97,99,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.585078834 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_entry() //  [R1]
         { info_tbl: [(c8oCq,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oCq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oCr; else goto c8oCs;
       c8oCr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oCs: // global
           (_c8oCn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oCn::I64 == 0) goto c8oCp; else goto c8oCo;
       c8oCp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oCo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oCn::I64;
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.589568616 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_entry() //  [R2,
                                                                          R3, R4]
         { info_tbl: [(c8oCI,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oCI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oCJ; else goto c8oCK;
       c8oCJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oCK: // global
           I64[Sp - 16] = block_c8oCF_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oCO; else goto c8oCG;
       u8oCO: // global
           call _c8oCF() args: 0, res: 0, upd: 0;
       c8oCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oCF() //  []
         { info_tbl: [(c8oCF,
                       label: block_c8oCF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oCF: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.595056329 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_entry() //  [R2]
         { info_tbl: [(c8oD6,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oD6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oD7; else goto c8oD8;
       c8oD7: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oD8: // global
           I64[Sp - 8] = block_c8oD3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oDc; else goto c8oD4;
       u8oDc: // global
           call _c8oD3() args: 0, res: 0, upd: 0;
       c8oD4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oD3() //  []
         { info_tbl: [(c8oD3,
                       label: block_c8oD3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oD3: // global
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.600441328 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8oDv,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oDw; else goto c8oDx;
       c8oDw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oDx: // global
           I64[Sp - 16] = block_c8oDs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oDB; else goto c8oDt;
       u8oDB: // global
           call _c8oDs() args: 0, res: 0, upd: 0;
       c8oDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oDs() //  []
         { info_tbl: [(c8oDs,
                       label: block_c8oDs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oDs: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.606160105 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure:
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_entry() //  [R2,
                                                                         R3]
         { info_tbl: [(c8oDQ,
                       label: GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oDQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.609501128 UTC

[section ""data" . GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.612045264 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock2_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock2_bytes:
         I8[] [60,60,100,101,97,100,108,111,99,107,62,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.61479076 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock1_closure" {
     GHC.IO.Exception.$fExceptionDeadlock1_closure:
         const GHC.IO.Exception.$fExceptionDeadlock1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock1_entry() //  [R1]
         { info_tbl: [(c8oE5,
                       label: GHC.IO.Exception.$fExceptionDeadlock1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oE5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oE6; else goto c8oE7;
       c8oE6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oE7: // global
           (_c8oE2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oE2::I64 == 0) goto c8oE4; else goto c8oE3;
       c8oE4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oE3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oE2::I64;
           R2 = GHC.IO.Exception.$fExceptionDeadlock2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.622190544 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8oEn,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oEn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oEo; else goto c8oEp;
       c8oEo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oEp: // global
           I64[Sp - 16] = block_c8oEk_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oEt; else goto c8oEl;
       u8oEt: // global
           call _c8oEk() args: 0, res: 0, upd: 0;
       c8oEl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oEk() //  []
         { info_tbl: [(c8oEk,
                       label: block_c8oEk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oEk: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.629633787 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cshow_entry() //  [R2]
         { info_tbl: [(c8oEL,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oEL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oEM; else goto c8oEN;
       c8oEM: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oEN: // global
           I64[Sp - 8] = block_c8oEI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oER; else goto c8oEJ;
       u8oER: // global
           call _c8oEI() args: 0, res: 0, upd: 0;
       c8oEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oEI() //  []
         { info_tbl: [(c8oEI,
                       label: block_c8oEI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oEI: // global
           R1 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.636921973 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock1_closure" {
     GHC.IO.Exception.$fShowDeadlock1_closure:
         const GHC.IO.Exception.$fShowDeadlock1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock1_entry() //  [R2, R3]
         { info_tbl: [(c8oFa,
                       label: GHC.IO.Exception.$fShowDeadlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oFb; else goto c8oFc;
       c8oFb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowDeadlock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oFc: // global
           I64[Sp - 16] = block_c8oF7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oFg; else goto c8oF8;
       u8oFg: // global
           call _c8oF7() args: 0, res: 0, upd: 0;
       c8oF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oF7() //  []
         { info_tbl: [(c8oF7,
                       label: block_c8oF7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oF7: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionDeadlock1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.64482501 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_$cshowList_closure" {
     GHC.IO.Exception.$fShowDeadlock_$cshowList_closure:
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowDeadlock_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8oFv,
                       label: GHC.IO.Exception.$fShowDeadlock_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oFv: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowDeadlock1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.649413077 UTC

[section ""data" . GHC.IO.Exception.$fShowDeadlock_closure" {
     GHC.IO.Exception.$fShowDeadlock_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const GHC.IO.Exception.$fShowDeadlock_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.651808355 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes:
         I8[] [97,108,108,111,99,97,116,105,111,110,32,108,105,109,105,116,32,101,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.654951859 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_entry() //  [R1]
         { info_tbl: [(c8oFK,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oFL; else goto c8oFM;
       c8oFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oFM: // global
           (_c8oFH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oFH::I64 == 0) goto c8oFJ; else goto c8oFI;
       c8oFJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oFI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oFH::I64;
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.660465372 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_entry() //  [R2,
                                                                         R3, R4]
         { info_tbl: [(c8oG2,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oG3; else goto c8oG4;
       c8oG3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oG4: // global
           I64[Sp - 16] = block_c8oFZ_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oG8; else goto c8oG0;
       u8oG8: // global
           call _c8oFZ() args: 0, res: 0, upd: 0;
       c8oG0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oFZ() //  []
         { info_tbl: [(c8oFZ,
                       label: block_c8oFZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oFZ: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.666767525 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_entry() //  [R2]
         { info_tbl: [(c8oGq,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oGq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oGr; else goto c8oGs;
       c8oGr: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oGs: // global
           I64[Sp - 8] = block_c8oGn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oGw; else goto c8oGo;
       u8oGw: // global
           call _c8oGn() args: 0, res: 0, upd: 0;
       c8oGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oGn() //  []
         { info_tbl: [(c8oGn,
                       label: block_c8oGn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oGn: // global
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.672113364 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8oGP,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oGP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oGQ; else goto c8oGR;
       c8oGQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oGR: // global
           I64[Sp - 16] = block_c8oGM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oGV; else goto c8oGN;
       u8oGV: // global
           call _c8oGM() args: 0, res: 0, upd: 0;
       c8oGN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oGM() //  []
         { info_tbl: [(c8oGM,
                       label: block_c8oGM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oGM: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.677467772 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure:
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c8oHa,
                       label: GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oHa: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.680854475 UTC

[section ""data" . GHC.IO.Exception.$fShowAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fShowAllocationLimitExceeded_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.68334213 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed1_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed1_bytes:
         I8[] [99,111,109,112,97,99,116,105,111,110,32,102,97,105,108,101,100,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.685430423 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec2_closure" {
     GHC.IO.Exception.$w$cshowsPrec2_closure:
         const GHC.IO.Exception.$w$cshowsPrec2_info;
 },
 sat_s8oni_entry() //  [R1]
         { info_tbl: [(c8oHr,
                       label: sat_s8oni_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oHs; else goto c8oHt;
       c8oHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec2_entry() //  [R2]
         { info_tbl: [(c8oHu,
                       label: GHC.IO.Exception.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oHu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8oHy; else goto c8oHx;
       c8oHy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oHx: // global
           I64[Hp - 16] = sat_s8oni_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.691055915 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(c8oHO,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oHO: // global
           R2 = R3;
           call GHC.IO.Exception.$w$cshowsPrec2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.694366205 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_entry() //  [R2]
         { info_tbl: [(c8oHZ,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oHZ: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionCompactionFailed1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.698279383 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowCompactionFailed_$cshowList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(c8oIa,
                       label: GHC.IO.Exception.$fShowCompactionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oIa: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec2_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.701599713 UTC

[section ""data" . GHC.IO.Exception.$fShowCompactionFailed_closure" {
     GHC.IO.Exception.$fShowCompactionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec_closure+2;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const GHC.IO.Exception.$fShowCompactionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.703550642 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_entry() //  [R3,
                                                                 R4]
         { info_tbl: [(c8oIm,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oIm: // global
           _s8onp::P64 = R3;
           R3 = R4;
           R2 = _s8onp::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.707435454 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed1_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed1_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed1_info;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed1_entry() //  [R2]
         { info_tbl: [(c8oIx,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oIx: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.710776656 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure:
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info;
 },
 GHC.IO.Exception.$fShowAssertionFailed_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c8oIK,
                       label: GHC.IO.Exception.$fShowAssertionFailed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oIK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.++_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.71467329 UTC

[section ""data" . GHC.IO.Exception.$fShowAssertionFailed_closure" {
     GHC.IO.Exception.$fShowAssertionFailed_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const GHC.IO.Exception.$fShowAssertionFailed_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.716715568 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8oJ0,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oJ4; else goto c8oJ5;
       c8oJ4: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oJ5: // global
           I64[Sp - 8] = block_c8oIX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oJb; else goto c8oIY;
       u8oJb: // global
           call _c8oIX(R1) args: 0, res: 0, upd: 0;
       c8oIY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oIX() //  [R1]
         { info_tbl: [(c8oIX,
                       label: block_c8oIX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oIX: // global
           I64[Sp - 8] = block_c8oJ3_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oJ3() //  [R1]
         { info_tbl: [(c8oJ3,
                       label: block_c8oJ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJ3: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.723985219 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_entry() //  [R2,
                                                                    R3, R4]
         { info_tbl: [(c8oJz,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8oJH; else goto c8oJI;
       c8oJH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oJI: // global
           I64[Sp - 16] = block_c8oJw_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oJP; else goto c8oJx;
       u8oJP: // global
           call _c8oJw(R1) args: 0, res: 0, upd: 0;
       c8oJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oJw() //  [R1]
         { info_tbl: [(c8oJw,
                       label: block_c8oJw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJw: // global
           I64[Sp - 8] = block_c8oJC_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oJC() //  [R1]
         { info_tbl: [(c8oJC,
                       label: block_c8oJC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJC: // global
           _s8onD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8oJG_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8onD::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8oJG() //  [R1]
         { info_tbl: [(c8oJG,
                       label: block_c8oJG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oJG: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.733447996 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException1_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException1_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException1_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException1_entry() //  [R2, R3]
         { info_tbl: [(c8oKh,
                       label: GHC.IO.Exception.$fShowSomeAsyncException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oKh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8oKp; else goto c8oKq;
       c8oKp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowSomeAsyncException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oKq: // global
           I64[Sp - 16] = block_c8oKe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oKx; else goto c8oKf;
       u8oKx: // global
           call _c8oKe(R1) args: 0, res: 0, upd: 0;
       c8oKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oKe() //  [R1]
         { info_tbl: [(c8oKe,
                       label: block_c8oKe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oKe: // global
           I64[Sp - 8] = block_c8oKk_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8oKk() //  [R1]
         { info_tbl: [(c8oKk,
                       label: block_c8oKk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oKk: // global
           _s8onK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8oKo_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s8onK::P64;
           Sp = Sp - 8;
           call GHC.Show.show_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8oKo() //  [R1]
         { info_tbl: [(c8oKo,
                       label: block_c8oKo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oKo: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.742162313 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c8oKW,
                       label: GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oKW: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowSomeAsyncException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.745752594 UTC

[section ""data" . GHC.IO.Exception.$fShowSomeAsyncException_closure" {
     GHC.IO.Exception.$fShowSomeAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowSomeAsyncException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.747397754 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException8_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException8_bytes:
         I8[] [115,116,97,99,107,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.749339537 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException7_closure" {
     GHC.IO.Exception.$fExceptionAsyncException7_closure:
         const GHC.IO.Exception.$fExceptionAsyncException7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException7_entry() //  [R1]
         { info_tbl: [(c8oLb,
                       label: GHC.IO.Exception.$fExceptionAsyncException7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oLb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oLc; else goto c8oLd;
       c8oLc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oLd: // global
           (_c8oL8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oL8::I64 == 0) goto c8oLa; else goto c8oL9;
       c8oLa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oL9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oL8::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.753177364 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException6_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException6_bytes:
         I8[] [104,101,97,112,32,111,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.755022068 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException5_closure" {
     GHC.IO.Exception.$fExceptionAsyncException5_closure:
         const GHC.IO.Exception.$fExceptionAsyncException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException5_entry() //  [R1]
         { info_tbl: [(c8oLt,
                       label: GHC.IO.Exception.$fExceptionAsyncException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oLt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oLu; else goto c8oLv;
       c8oLu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oLv: // global
           (_c8oLq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oLq::I64 == 0) goto c8oLs; else goto c8oLr;
       c8oLs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oLr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oLq::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.759119492 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException4_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException4_bytes:
         I8[] [116,104,114,101,97,100,32,107,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.760957875 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException3_closure" {
     GHC.IO.Exception.$fExceptionAsyncException3_closure:
         const GHC.IO.Exception.$fExceptionAsyncException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException3_entry() //  [R1]
         { info_tbl: [(c8oLL,
                       label: GHC.IO.Exception.$fExceptionAsyncException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oLL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oLM; else goto c8oLN;
       c8oLM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oLN: // global
           (_c8oLI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oLI::I64 == 0) goto c8oLK; else goto c8oLJ;
       c8oLK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oLJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oLI::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.765396463 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException2_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException2_bytes:
         I8[] [117,115,101,114,32,105,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.767281075 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException1_closure" {
     GHC.IO.Exception.$fExceptionAsyncException1_closure:
         const GHC.IO.Exception.$fExceptionAsyncException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException1_entry() //  [R1]
         { info_tbl: [(c8oM3,
                       label: GHC.IO.Exception.$fExceptionAsyncException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oM3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oM4; else goto c8oM5;
       c8oM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oM5: // global
           (_c8oM0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oM0::I64 == 0) goto c8oM2; else goto c8oM1;
       c8oM2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oM1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oM0::I64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.772203449 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec1_closure" {
     GHC.IO.Exception.$w$cshowsPrec1_closure:
         const GHC.IO.Exception.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(c8oMr,
                       label: GHC.IO.Exception.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oMr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oMs; else goto c8oMt;
       c8oMs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oMt: // global
           I64[Sp - 16] = block_c8oMi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oMI; else goto c8oMj;
       u8oMI: // global
           call _c8oMi(R1) args: 0, res: 0, upd: 0;
       c8oMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oMi() //  [R1]
         { info_tbl: [(c8oMi,
                       label: block_c8oMi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oMi: // global
           _s8onQ::P64 = P64[Sp + 8];
           _c8oMq::P64 = R1 & 7;
           if (_c8oMq::P64 < 3) goto u8oMG; else goto u8oMH;
       u8oMG: // global
           if (_c8oMq::P64 < 2) goto c8oMm; else goto c8oMn;
       c8oMm: // global
           R3 = _s8onQ::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8oMn: // global
           R3 = _s8onQ::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8oMH: // global
           if (_c8oMq::P64 < 4) goto c8oMo; else goto c8oMp;
       c8oMo: // global
           R3 = _s8onQ::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8oMp: // global
           R3 = _s8onQ::P64;
           R2 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.779037282 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_entry() //  [R3,
                                                                R4]
         { info_tbl: [(c8oMY,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oMY: // global
           _s8onT::P64 = R3;
           R3 = R4;
           R2 = _s8onT::P64;
           call GHC.IO.Exception.$w$cshowsPrec1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.783145466 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cshow_entry() //  [R2]
         { info_tbl: [(c8oNi,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oNi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oNj; else goto c8oNk;
       c8oNj: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oNk: // global
           I64[Sp - 8] = block_c8oN9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oNz; else goto c8oNa;
       u8oNz: // global
           call _c8oN9(R1) args: 0, res: 0, upd: 0;
       c8oNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oN9() //  [R1]
         { info_tbl: [(c8oN9,
                       label: block_c8oN9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oN9: // global
           _c8oNh::P64 = R1 & 7;
           if (_c8oNh::P64 < 3) goto u8oNx; else goto u8oNy;
       u8oNx: // global
           if (_c8oNh::P64 < 2) goto c8oNd; else goto c8oNe;
       c8oNd: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8oNe: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8oNy: // global
           if (_c8oNh::P64 < 4) goto c8oNf; else goto c8oNg;
       c8oNf: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8oNg: // global
           R1 = GHC.IO.Exception.$fExceptionAsyncException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.789644234 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_$cshowList_closure" {
     GHC.IO.Exception.$fShowAsyncException_$cshowList_closure:
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowAsyncException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8oNT,
                       label: GHC.IO.Exception.$fShowAsyncException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oNT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.793568535 UTC

[section ""data" . GHC.IO.Exception.$fShowAsyncException_closure" {
     GHC.IO.Exception.$fShowAsyncException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowAsyncException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowAsyncException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.795479575 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException4_bytes" {
     GHC.IO.Exception.$fExceptionArrayException4_bytes:
         I8[] [97,114,114,97,121,32,105,110,100,101,120,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.797182622 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException3_bytes" {
     GHC.IO.Exception.$fExceptionArrayException3_bytes:
         I8[] [58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.799699319 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException2_bytes" {
     GHC.IO.Exception.$fExceptionArrayException2_bytes:
         I8[] [117,110,100,101,102,105,110,101,100,32,97,114,114,97,121,32,101,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.803042398 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec_closure" {
     GHC.IO.Exception.$w$cshowsPrec_closure:
         const GHC.IO.Exception.$w$cshowsPrec_info;
 },
 sat_s8oo6_entry() //  [R1]
         { info_tbl: [(c8oOr,
                       label: sat_s8oo6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oOr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oOs; else goto c8oOt;
       c8oOs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oOt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oo7_entry() //  [R1]
         { info_tbl: [(c8oOy,
                       label: sat_s8oo7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oOy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8oOz; else goto c8oOA;
       c8oOz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oOA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8oOh_info;
           _s8oo0::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8oo0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8oOG; else goto c8oOi;
       u8oOG: // global
           call _c8oOh(R1) args: 0, res: 0, upd: 0;
       c8oOi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8oOh() //  [R1]
         { info_tbl: [(c8oOh,
                       label: block_c8oOh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oOh: // global
           _s8oo0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8oOv; else goto c8oOw;
       c8oOv: // global
           R1 = _s8oo0::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8oOw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8oOF; else goto c8oOE;
       c8oOF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8oOE: // global
           I64[Hp - 24] = sat_s8oo6_info;
           P64[Hp - 8] = _s8oo0::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ooc_entry() //  [R1]
         { info_tbl: [(c8oOX,
                       label: sat_s8ooc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oOY; else goto c8oOZ;
       c8oOY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ood_entry() //  [R1]
         { info_tbl: [(c8oP4,
                       label: sat_s8ood_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oP4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8oP5; else goto c8oP6;
       c8oP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8oON_info;
           _s8oo0::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8oo0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8oPc; else goto c8oOO;
       u8oPc: // global
           call _c8oON(R1) args: 0, res: 0, upd: 0;
       c8oOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8oON() //  [R1]
         { info_tbl: [(c8oON,
                       label: block_c8oON_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oON: // global
           _s8oo0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8oP1; else goto c8oP2;
       c8oP1: // global
           R1 = _s8oo0::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8oP2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8oPb; else goto c8oPa;
       c8oPb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8oPa: // global
           I64[Hp - 24] = sat_s8ooc_info;
           P64[Hp - 8] = _s8oo0::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8oPh,
                       label: GHC.IO.Exception.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oPh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oPi; else goto c8oPj;
       c8oPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oPj: // global
           I64[Sp - 16] = block_c8oO8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oPq; else goto c8oO9;
       u8oPq: // global
           call _c8oO8(R1) args: 0, res: 0, upd: 0;
       c8oO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oO8() //  [R1]
         { info_tbl: [(c8oO8,
                       label: block_c8oO8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oO8: // global
           _s8oo0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8oPe; else goto c8oPf;
       c8oPe: // global
           Hp = Hp + 32;
           _s8oo1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8oPp; else goto c8oPl;
       c8oPl: // global
           _s8oo2::P64 = P64[_s8oo1::P64 + 7];
           I64[Hp - 24] = sat_s8oo7_info;
           P64[Hp - 8] = _s8oo0::P64;
           P64[Hp] = _s8oo2::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8oPf: // global
           Hp = Hp + 32;
           _s8oo1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8oPp; else goto c8oPo;
       c8oPp: // global
           HpAlloc = 32;
           R1 = _s8oo1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8oPo: // global
           _s8oo8::P64 = P64[_s8oo1::P64 + 6];
           I64[Hp - 24] = sat_s8ood_info;
           P64[Hp - 8] = _s8oo0::P64;
           P64[Hp] = _s8oo8::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException2_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.823588982 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_entry() //  [R3,
                                                                     R4]
         { info_tbl: [(c8oQn,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oQn: // global
           _s8oof::P64 = R3;
           R3 = R4;
           R2 = _s8oof::P64;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.827255929 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException1_closure" {
     GHC.IO.Exception.$fExceptionArrayException1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.829214309 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_info;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cshow_entry() //  [R2]
         { info_tbl: [(c8oQz,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oQz: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.833060575 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_$cshowList_closure" {
     GHC.IO.Exception.$fShowArrayException_$cshowList_closure:
         const GHC.IO.Exception.$fShowArrayException_$cshowList_info;
 },
 GHC.IO.Exception.$fShowArrayException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8oQL,
                       label: GHC.IO.Exception.$fShowArrayException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oQL: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.837121726 UTC

[section ""data" . GHC.IO.Exception.$fShowArrayException_closure" {
     GHC.IO.Exception.$fShowArrayException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowArrayException_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.839331571 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException2_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException2_bytes:
         I8[] [99,121,99,108,105,99,32,101,118,97,108,117,97,116,105,111,110,32,105,110,32,102,105,120,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.841441982 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException1_closure" {
     GHC.IO.Exception.$fExceptionFixIOException1_closure:
         const GHC.IO.Exception.$fExceptionFixIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException1_entry() //  [R1]
         { info_tbl: [(c8oR0,
                       label: GHC.IO.Exception.$fExceptionFixIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oR0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oR1; else goto c8oR2;
       c8oR1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oR2: // global
           (_c8oQX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oQX::I64 == 0) goto c8oQZ; else goto c8oQY;
       c8oQZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oQY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oQX::I64;
           R2 = GHC.IO.Exception.$fExceptionFixIOException2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.845929441 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8oRi,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oRj; else goto c8oRk;
       c8oRj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oRk: // global
           I64[Sp - 16] = block_c8oRf_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oRo; else goto c8oRg;
       u8oRo: // global
           call _c8oRf() args: 0, res: 0, upd: 0;
       c8oRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oRf() //  []
         { info_tbl: [(c8oRf,
                       label: block_c8oRf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oRf: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.85164676 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8oRG,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oRG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8oRH; else goto c8oRI;
       c8oRH: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8oRI: // global
           I64[Sp - 8] = block_c8oRD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8oRM; else goto c8oRE;
       u8oRM: // global
           call _c8oRD() args: 0, res: 0, upd: 0;
       c8oRE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oRD() //  []
         { info_tbl: [(c8oRD,
                       label: block_c8oRD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oRD: // global
           R1 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.857181293 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException1_closure" {
     GHC.IO.Exception.$fShowFixIOException1_closure:
         const GHC.IO.Exception.$fShowFixIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8oS5,
                       label: GHC.IO.Exception.$fShowFixIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oS5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oS6; else goto c8oS7;
       c8oS6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowFixIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oS7: // global
           I64[Sp - 16] = block_c8oS2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oSb; else goto c8oS3;
       u8oSb: // global
           call _c8oS2() args: 0, res: 0, upd: 0;
       c8oS3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oS2() //  []
         { info_tbl: [(c8oS2,
                       label: block_c8oS2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oS2: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Exception.$fExceptionFixIOException1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.862834096 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowFixIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowFixIOException_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8oSq,
                       label: GHC.IO.Exception.$fShowFixIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oSq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowFixIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.866599431 UTC

[section ""data" . GHC.IO.Exception.$fShowFixIOException_closure" {
     GHC.IO.Exception.$fShowFixIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowFixIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.868879594 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c==_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c==_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c==_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8oSG,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oSG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oSM; else goto c8oSN;
       c8oSM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oSN: // global
           I64[Sp - 16] = block_c8oSC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oT7; else goto c8oSD;
       u8oT7: // global
           call _c8oSC(R1) args: 0, res: 0, upd: 0;
       c8oSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oSC() //  [R1]
         { info_tbl: [(c8oSC,
                       label: block_c8oSC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oSC: // global
           _s8ooy::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8oSL_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ooy::I64;
           if (R1 & 7 != 0) goto u8oT6; else goto c8oSS;
       u8oT6: // global
           call _c8oSL(R1) args: 0, res: 0, upd: 0;
       c8oSS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oSL() //  [R1]
         { info_tbl: [(c8oSL,
                       label: block_c8oSL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oSL: // global
           R1 = I64[((%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.877384699 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_$c/=_closure" {
     GHC.IO.Exception.$fEqIOErrorType_$c/=_closure:
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOErrorType_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8oTG,
                       label: GHC.IO.Exception.$fEqIOErrorType_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oTG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oTM; else goto c8oTN;
       c8oTM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOErrorType_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oTN: // global
           I64[Sp - 16] = block_c8oTC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8oUb; else goto c8oTD;
       u8oUb: // global
           call _c8oTC(R1) args: 0, res: 0, upd: 0;
       c8oTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oTC() //  [R1]
         { info_tbl: [(c8oTC,
                       label: block_c8oTC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oTC: // global
           _s8ooF::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8oTL_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ooF::I64;
           if (R1 & 7 != 0) goto u8oUa; else goto c8oTS;
       u8oUa: // global
           call _c8oTL(R1) args: 0, res: 0, upd: 0;
       c8oTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oTL() //  [R1]
         { info_tbl: [(c8oTL,
                       label: block_c8oTL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oTL: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 8]) goto c8oU7; else goto c8oU6;
       c8oU7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8oU6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.885002983 UTC

[section ""data" . GHC.IO.Exception.$fEqIOErrorType_closure" {
     GHC.IO.Exception.$fEqIOErrorType_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOErrorType_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOErrorType_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.886877271 UTC

[section ""cstring" . lvl_r8j2D_bytes" {
     lvl_r8j2D_bytes:
         I8[] [97,108,114,101,97,100,121,32,101,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.888958468 UTC

[section ""data" . lvl1_r8j2E_closure" {
     lvl1_r8j2E_closure:
         const lvl1_r8j2E_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8j2E_entry() //  [R1]
         { info_tbl: [(c8oUK,
                       label: lvl1_r8j2E_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oUL; else goto c8oUM;
       c8oUL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oUM: // global
           (_c8oUH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oUH::I64 == 0) goto c8oUJ; else goto c8oUI;
       c8oUJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oUI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oUH::I64;
           R2 = lvl_r8j2D_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.893044102 UTC

[section ""cstring" . lvl2_r8j2F_bytes" {
     lvl2_r8j2F_bytes:
         I8[] [100,111,101,115,32,110,111,116,32,101,120,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.89498909 UTC

[section ""data" . lvl3_r8j2G_closure" {
     lvl3_r8j2G_closure:
         const lvl3_r8j2G_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8j2G_entry() //  [R1]
         { info_tbl: [(c8oV2,
                       label: lvl3_r8j2G_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oV2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oV3; else goto c8oV4;
       c8oV3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oV4: // global
           (_c8oUZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oUZ::I64 == 0) goto c8oV1; else goto c8oV0;
       c8oV1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oV0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oUZ::I64;
           R2 = lvl2_r8j2F_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.899047671 UTC

[section ""cstring" . lvl4_r8j2H_bytes" {
     lvl4_r8j2H_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,98,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.900923677 UTC

[section ""data" . lvl5_r8j2I_closure" {
     lvl5_r8j2I_closure:
         const lvl5_r8j2I_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8j2I_entry() //  [R1]
         { info_tbl: [(c8oVk,
                       label: lvl5_r8j2I_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oVk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oVl; else goto c8oVm;
       c8oVl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oVm: // global
           (_c8oVh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oVh::I64 == 0) goto c8oVj; else goto c8oVi;
       c8oVj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oVi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oVh::I64;
           R2 = lvl4_r8j2H_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.90509826 UTC

[section ""cstring" . lvl6_r8j2J_bytes" {
     lvl6_r8j2J_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,101,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.908206263 UTC

[section ""data" . lvl7_r8j2K_closure" {
     lvl7_r8j2K_closure:
         const lvl7_r8j2K_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r8j2K_entry() //  [R1]
         { info_tbl: [(c8oVC,
                       label: lvl7_r8j2K_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oVC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oVD; else goto c8oVE;
       c8oVD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oVE: // global
           (_c8oVz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oVz::I64 == 0) goto c8oVB; else goto c8oVA;
       c8oVB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oVA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oVz::I64;
           R2 = lvl6_r8j2J_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.91230292 UTC

[section ""cstring" . lvl8_r8j2L_bytes" {
     lvl8_r8j2L_bytes:
         I8[] [101,110,100,32,111,102,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.914385564 UTC

[section ""data" . lvl9_r8j2M_closure" {
     lvl9_r8j2M_closure:
         const lvl9_r8j2M_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r8j2M_entry() //  [R1]
         { info_tbl: [(c8oVU,
                       label: lvl9_r8j2M_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oVU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oVV; else goto c8oVW;
       c8oVV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oVW: // global
           (_c8oVR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oVR::I64 == 0) goto c8oVT; else goto c8oVS;
       c8oVT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oVS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oVR::I64;
           R2 = lvl8_r8j2L_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.918628545 UTC

[section ""cstring" . lvl10_r8j2N_bytes" {
     lvl10_r8j2N_bytes:
         I8[] [105,108,108,101,103,97,108,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.920656467 UTC

[section ""data" . lvl11_r8j2O_closure" {
     lvl11_r8j2O_closure:
         const lvl11_r8j2O_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8j2O_entry() //  [R1]
         { info_tbl: [(c8oWc,
                       label: lvl11_r8j2O_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oWc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oWd; else goto c8oWe;
       c8oWd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oWe: // global
           (_c8oW9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oW9::I64 == 0) goto c8oWb; else goto c8oWa;
       c8oWb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oWa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oW9::I64;
           R2 = lvl10_r8j2N_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.924664776 UTC

[section ""cstring" . lvl12_r8j2P_bytes" {
     lvl12_r8j2P_bytes:
         I8[] [112,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.92716641 UTC

[section ""data" . lvl13_r8j2Q_closure" {
     lvl13_r8j2Q_closure:
         const lvl13_r8j2Q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r8j2Q_entry() //  [R1]
         { info_tbl: [(c8oWu,
                       label: lvl13_r8j2Q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oWv; else goto c8oWw;
       c8oWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oWw: // global
           (_c8oWr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oWr::I64 == 0) goto c8oWt; else goto c8oWs;
       c8oWt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oWs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oWr::I64;
           R2 = lvl12_r8j2P_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.931158236 UTC

[section ""cstring" . lvl14_r8j2R_bytes" {
     lvl14_r8j2R_bytes:
         I8[] [117,115,101,114,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.933051301 UTC

[section ""data" . lvl15_r8j2S_closure" {
     lvl15_r8j2S_closure:
         const lvl15_r8j2S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_r8j2S_entry() //  [R1]
         { info_tbl: [(c8oWM,
                       label: lvl15_r8j2S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oWM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oWN; else goto c8oWO;
       c8oWN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oWO: // global
           (_c8oWJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oWJ::I64 == 0) goto c8oWL; else goto c8oWK;
       c8oWL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oWK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oWJ::I64;
           R2 = lvl14_r8j2R_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.936971495 UTC

[section ""cstring" . lvl16_r8j2T_bytes" {
     lvl16_r8j2T_bytes:
         I8[] [117,110,115,97,116,105,115,102,105,101,100,32,99,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.939380612 UTC

[section ""data" . lvl17_r8j2U_closure" {
     lvl17_r8j2U_closure:
         const lvl17_r8j2U_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_r8j2U_entry() //  [R1]
         { info_tbl: [(c8oX4,
                       label: lvl17_r8j2U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oX4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oX5; else goto c8oX6;
       c8oX5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oX6: // global
           (_c8oX1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oX1::I64 == 0) goto c8oX3; else goto c8oX2;
       c8oX3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oX2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oX1::I64;
           R2 = lvl16_r8j2T_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.944424195 UTC

[section ""cstring" . lvl18_r8j2V_bytes" {
     lvl18_r8j2V_bytes:
         I8[] [115,121,115,116,101,109,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.946931043 UTC

[section ""data" . lvl19_r8j2W_closure" {
     lvl19_r8j2W_closure:
         const lvl19_r8j2W_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r8j2W_entry() //  [R1]
         { info_tbl: [(c8oXm,
                       label: lvl19_r8j2W_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oXm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oXn; else goto c8oXo;
       c8oXn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oXo: // global
           (_c8oXj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oXj::I64 == 0) goto c8oXl; else goto c8oXk;
       c8oXl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oXk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oXj::I64;
           R2 = lvl18_r8j2V_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.952141492 UTC

[section ""cstring" . lvl20_r8j2X_bytes" {
     lvl20_r8j2X_bytes:
         I8[] [112,114,111,116,111,99,111,108,32,101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.954677821 UTC

[section ""data" . lvl21_r8j2Y_closure" {
     lvl21_r8j2Y_closure:
         const lvl21_r8j2Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_r8j2Y_entry() //  [R1]
         { info_tbl: [(c8oXE,
                       label: lvl21_r8j2Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oXE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oXF; else goto c8oXG;
       c8oXF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oXG: // global
           (_c8oXB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oXB::I64 == 0) goto c8oXD; else goto c8oXC;
       c8oXD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oXC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oXB::I64;
           R2 = lvl20_r8j2X_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.959232474 UTC

[section ""cstring" . lvl22_r8j2Z_bytes" {
     lvl22_r8j2Z_bytes:
         I8[] [102,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.961047596 UTC

[section ""data" . lvl23_r8j30_closure" {
     lvl23_r8j30_closure:
         const lvl23_r8j30_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_r8j30_entry() //  [R1]
         { info_tbl: [(c8oXW,
                       label: lvl23_r8j30_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oXW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oXX; else goto c8oXY;
       c8oXX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oXY: // global
           (_c8oXT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oXT::I64 == 0) goto c8oXV; else goto c8oXU;
       c8oXV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oXU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oXT::I64;
           R2 = lvl22_r8j2Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.96496933 UTC

[section ""cstring" . lvl24_r8j31_bytes" {
     lvl24_r8j31_bytes:
         I8[] [105,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.966856355 UTC

[section ""data" . lvl25_r8j32_closure" {
     lvl25_r8j32_closure:
         const lvl25_r8j32_info;
         const 0;
         const 0;
         const 0;
 },
 lvl25_r8j32_entry() //  [R1]
         { info_tbl: [(c8oYe,
                       label: lvl25_r8j32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oYf; else goto c8oYg;
       c8oYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oYg: // global
           (_c8oYb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oYb::I64 == 0) goto c8oYd; else goto c8oYc;
       c8oYd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oYc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oYb::I64;
           R2 = lvl24_r8j31_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.970592943 UTC

[section ""cstring" . lvl26_r8j33_bytes" {
     lvl26_r8j33_bytes:
         I8[] [105,110,97,112,112,114,111,112,114,105,97,116,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.972533001 UTC

[section ""data" . lvl27_r8j34_closure" {
     lvl27_r8j34_closure:
         const lvl27_r8j34_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_r8j34_entry() //  [R1]
         { info_tbl: [(c8oYw,
                       label: lvl27_r8j34_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oYw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oYx; else goto c8oYy;
       c8oYx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oYy: // global
           (_c8oYt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oYt::I64 == 0) goto c8oYv; else goto c8oYu;
       c8oYv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oYu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oYt::I64;
           R2 = lvl26_r8j33_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.976965677 UTC

[section ""cstring" . lvl28_r8j35_bytes" {
     lvl28_r8j35_bytes:
         I8[] [104,97,114,100,119,97,114,101,32,102,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.979409027 UTC

[section ""data" . lvl29_r8j36_closure" {
     lvl29_r8j36_closure:
         const lvl29_r8j36_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_r8j36_entry() //  [R1]
         { info_tbl: [(c8oYO,
                       label: lvl29_r8j36_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oYO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oYP; else goto c8oYQ;
       c8oYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oYQ: // global
           (_c8oYL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oYL::I64 == 0) goto c8oYN; else goto c8oYM;
       c8oYN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oYM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oYL::I64;
           R2 = lvl28_r8j35_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.983285087 UTC

[section ""cstring" . lvl30_r8j37_bytes" {
     lvl30_r8j37_bytes:
         I8[] [117,110,115,117,112,112,111,114,116,101,100,32,111,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.985120782 UTC

[section ""data" . lvl31_r8j38_closure" {
     lvl31_r8j38_closure:
         const lvl31_r8j38_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_r8j38_entry() //  [R1]
         { info_tbl: [(c8oZ6,
                       label: lvl31_r8j38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oZ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oZ7; else goto c8oZ8;
       c8oZ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oZ8: // global
           (_c8oZ3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oZ3::I64 == 0) goto c8oZ5; else goto c8oZ4;
       c8oZ5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oZ4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oZ3::I64;
           R2 = lvl30_r8j37_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.988945582 UTC

[section ""cstring" . lvl32_r8j39_bytes" {
     lvl32_r8j39_bytes:
         I8[] [116,105,109,101,111,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.990788402 UTC

[section ""data" . lvl33_r8j3a_closure" {
     lvl33_r8j3a_closure:
         const lvl33_r8j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_r8j3a_entry() //  [R1]
         { info_tbl: [(c8oZo,
                       label: lvl33_r8j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oZo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oZp; else goto c8oZq;
       c8oZp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oZq: // global
           (_c8oZl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oZl::I64 == 0) goto c8oZn; else goto c8oZm;
       c8oZn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oZm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oZl::I64;
           R2 = lvl32_r8j39_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.995082886 UTC

[section ""cstring" . lvl34_r8j3b_bytes" {
     lvl34_r8j3b_bytes:
         I8[] [114,101,115,111,117,114,99,101,32,118,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:32.996877208 UTC

[section ""data" . lvl35_r8j3c_closure" {
     lvl35_r8j3c_closure:
         const lvl35_r8j3c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_r8j3c_entry() //  [R1]
         { info_tbl: [(c8oZG,
                       label: lvl35_r8j3c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oZG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oZH; else goto c8oZI;
       c8oZH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8oZI: // global
           (_c8oZD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oZD::I64 == 0) goto c8oZF; else goto c8oZE;
       c8oZF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oZE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oZD::I64;
           R2 = lvl34_r8j3b_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.002806505 UTC

[section ""cstring" . lvl36_r8j3d_bytes" {
     lvl36_r8j3d_bytes:
         I8[] [105,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.004626173 UTC

[section ""data" . lvl37_r8j3e_closure" {
     lvl37_r8j3e_closure:
         const lvl37_r8j3e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_r8j3e_entry() //  [R1]
         { info_tbl: [(c8oZY,
                       label: lvl37_r8j3e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oZY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oZZ; else goto c8p00;
       c8oZZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8p00: // global
           (_c8oZV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8oZV::I64 == 0) goto c8oZX; else goto c8oZW;
       c8oZX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8oZW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8oZV::I64;
           R2 = lvl36_r8j3d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.009645241 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec4_closure" {
     GHC.IO.Exception.$w$cshowsPrec4_closure:
         const GHC.IO.Exception.$w$cshowsPrec4_info;
         const 0;
 },
 GHC.IO.Exception.$w$cshowsPrec4_entry() //  [R2, R3]
         { info_tbl: [(c8p0B,
                       label: GHC.IO.Exception.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p0B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8p0C; else goto c8p0D;
       c8p0C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8p0D: // global
           I64[Sp - 16] = block_c8p0d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8p1z; else goto c8p0e;
       u8p1z: // global
           call _c8p0d(R1) args: 0, res: 0, upd: 0;
       c8p0e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p0d() //  [R1]
         { info_tbl: [(c8p0d,
                       label: block_c8p0d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p0d: // global
           _s8ooK::P64 = P64[Sp + 8];
           switch [0 .. 18] (%MO_UU_Conv_W32_W64(I32[I64[R1 - 1] + 20])) {
               case 0 : goto c8p0h;
               case 1 : goto c8p0i;
               case 2 : goto c8p0j;
               case 3 : goto c8p0k;
               case 4 : goto c8p0l;
               case 5 : goto c8p0m;
               case 6 : goto c8p0n;
               case 7 : goto c8p0o;
               case 8 : goto c8p0p;
               case 9 : goto c8p0q;
               case 10 : goto c8p0r;
               case 11 : goto c8p0s;
               case 12 : goto c8p0t;
               case 13 : goto c8p0u;
               case 14 : goto c8p0v;
               case 15 : goto c8p0w;
               case 16 : goto c8p0x;
               case 17 : goto c8p0y;
               case 18 : goto c8p0z;
           }
       c8p0z: // global
           R3 = _s8ooK::P64;
           R2 = lvl37_r8j3e_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0y: // global
           R3 = _s8ooK::P64;
           R2 = lvl35_r8j3c_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0x: // global
           R3 = _s8ooK::P64;
           R2 = lvl33_r8j3a_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0w: // global
           R3 = _s8ooK::P64;
           R2 = lvl31_r8j38_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0v: // global
           R3 = _s8ooK::P64;
           R2 = lvl29_r8j36_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0u: // global
           R3 = _s8ooK::P64;
           R2 = lvl27_r8j34_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0t: // global
           R3 = _s8ooK::P64;
           R2 = lvl25_r8j32_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0s: // global
           R3 = _s8ooK::P64;
           R2 = lvl23_r8j30_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0r: // global
           R3 = _s8ooK::P64;
           R2 = lvl21_r8j2Y_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0q: // global
           R3 = _s8ooK::P64;
           R2 = lvl19_r8j2W_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0p: // global
           R3 = _s8ooK::P64;
           R2 = lvl17_r8j2U_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0o: // global
           R3 = _s8ooK::P64;
           R2 = lvl15_r8j2S_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0n: // global
           R3 = _s8ooK::P64;
           R2 = lvl13_r8j2Q_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0m: // global
           R3 = _s8ooK::P64;
           R2 = lvl11_r8j2O_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0l: // global
           R3 = _s8ooK::P64;
           R2 = lvl9_r8j2M_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0k: // global
           R3 = _s8ooK::P64;
           R2 = lvl7_r8j2K_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0j: // global
           R3 = _s8ooK::P64;
           R2 = lvl5_r8j2I_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0i: // global
           R3 = _s8ooK::P64;
           R2 = lvl3_r8j2G_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8p0h: // global
           R3 = _s8ooK::P64;
           R2 = lvl1_r8j2E_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.019519075 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c8p1T,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p1T: // global
           _s8ooN::P64 = R3;
           R3 = R4;
           R2 = _s8ooN::P64;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.023049383 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshow_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshow_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshow_entry() //  [R2]
         { info_tbl: [(c8p24,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p24: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.02658778 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOErrorType_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8p2g,
                       label: GHC.IO.Exception.$fShowIOErrorType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2g: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$w$cshowsPrec4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.030192882 UTC

[section ""data" . GHC.IO.Exception.$fShowIOErrorType_closure" {
     GHC.IO.Exception.$fShowIOErrorType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fShowIOErrorType_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOErrorType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.035483539 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c==_closure" {
     GHC.IO.Exception.$fEqIOException_$c==_closure:
         const GHC.IO.Exception.$fEqIOException_$c==_info;
 },
 GHC.IO.Exception.$fEqIOException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8p2v,
                       label: GHC.IO.Exception.$fEqIOException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2v: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c8p2M; else goto c8p2N;
       c8p2M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8p2N: // global
           I64[Sp - 16] = block_c8p2s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8p7p; else goto c8p2t;
       u8p7p: // global
           call _c8p2s(R1) args: 0, res: 0, upd: 0;
       c8p2t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p2s() //  [R1]
         { info_tbl: [(c8p2s,
                       label: block_c8p2s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2s: // global
           I64[Sp - 40] = block_c8p2y_info;
           _s8ooV::P64 = P64[R1 + 7];
           _s8ooW::P64 = P64[R1 + 15];
           _s8ooX::P64 = P64[R1 + 23];
           _s8ooY::P64 = P64[R1 + 31];
           _s8ooZ::P64 = P64[R1 + 39];
           _s8op0::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8ooX::P64;
           P64[Sp - 24] = _s8ooY::P64;
           P64[Sp - 16] = _s8ooZ::P64;
           P64[Sp - 8] = _s8op0::P64;
           P64[Sp] = _s8ooW::P64;
           P64[Sp + 8] = _s8ooV::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8p7o; else goto c8p2z;
       u8p7o: // global
           call _c8p2y(R1) args: 0, res: 0, upd: 0;
       c8p2z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p2y() //  [R1]
         { info_tbl: [(c8p2y,
                       label: block_c8p2y_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2y: // global
           I64[Sp - 40] = block_c8p2D_info;
           _s8op2::P64 = P64[R1 + 7];
           _s8op4::P64 = P64[R1 + 23];
           _s8op5::P64 = P64[R1 + 31];
           _s8op6::P64 = P64[R1 + 39];
           _s8op7::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _s8op4::P64;
           P64[Sp - 24] = _s8op5::P64;
           P64[Sp - 16] = _s8op6::P64;
           P64[Sp - 8] = _s8op7::P64;
           P64[Sp] = _s8op2::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8p7q; else goto c8p2E;
       u8p7q: // global
           call _c8p2D(R1) args: 0, res: 0, upd: 0;
       c8p2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p2D() //  [R1]
         { info_tbl: [(c8p2D,
                       label: block_c8p2D_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2D: // global
           _s8op9::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           I64[Sp] = block_c8p2L_info;
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _s8op9::I64;
           if (R1 & 7 != 0) goto u8p7r; else goto c8p2U;
       u8p7r: // global
           call _c8p2L(R1) args: 0, res: 0, upd: 0;
       c8p2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p2L() //  [R1]
         { info_tbl: [(c8p2L,
                       label: block_c8p2L_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p2L: // global
           if (%MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]) == I64[Sp + 80]) goto c8p3c; else goto u8p75;
       c8p3c: // global
           I64[Sp] = block_c8p3b_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8p75: // global
           Sp = Sp + 96;
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _c8p3b() //  [R1]
         { info_tbl: [(c8p3b,
                       label: block_c8p3b_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3b: // global
           if (R1 & 7 == 1) goto u8p76; else goto c8p5b;
       u8p76: // global
           Sp = Sp + 96;
           call _c8p6E() args: 0, res: 0, upd: 0;
       c8p5b: // global
           I64[Sp] = block_c8p3n_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto u8p7t; else goto c8p5c;
       u8p7t: // global
           call _c8p3n(R1) args: 0, res: 0, upd: 0;
       c8p5c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p3n() //  [R1]
         { info_tbl: [(c8p3n,
                       label: block_c8p3n_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3n: // global
           _s8op2::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8p5j; else goto c8p5z;
       c8p5j: // global
           I64[Sp] = block_c8p5g_info;
           R1 = _s8op2::P64;
           if (R1 & 7 != 0) goto u8p7v; else goto c8p5k;
       u8p7v: // global
           call _c8p5g(R1) args: 0, res: 0, upd: 0;
       c8p5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8p5z: // global
           I64[Sp] = block_c8p5x_info;
           _s8opB::P64 = P64[R1 + 6];
           R1 = _s8op2::P64;
           P64[Sp + 88] = _s8opB::P64;
           if (R1 & 7 != 0) goto u8p7w; else goto c8p5A;
       u8p7w: // global
           call _c8p5x(R1) args: 0, res: 0, upd: 0;
       c8p5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p5g() //  [R1]
         { info_tbl: [(c8p5g,
                       label: block_c8p5g_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p5g: // global
           if (R1 & 7 == 1) goto u8p7e; else goto u8p7f;
       u8p7e: // global
           Sp = Sp + 8;
           call _s8ope() args: 0, res: 0, upd: 0;
       u8p7f: // global
           Sp = Sp + 96;
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _c8p5x() //  [R1]
         { info_tbl: [(c8p5x,
                       label: block_c8p5x_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p5x: // global
           if (R1 & 7 == 1) goto u8p77; else goto c8p5L;
       u8p77: // global
           Sp = Sp + 96;
           call _c8p6E() args: 0, res: 0, upd: 0;
       c8p5L: // global
           I64[Sp] = block_c8p5J_info;
           _s8opD::P64 = P64[R1 + 6];
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _s8opD::P64;
           if (R1 & 7 != 0) goto u8p7O; else goto c8p5M;
       u8p7O: // global
           call _c8p5J(R1) args: 0, res: 0, upd: 0;
       c8p5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p5J() //  [R1]
         { info_tbl: [(c8p5J,
                       label: block_c8p5J_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p5J: // global
           _s8opD::P64 = P64[Sp + 88];
           if (R1 & 7 == 1) goto c8p5T; else goto c8p6o;
       c8p5T: // global
           I64[Sp] = block_c8p5Q_info;
           _s8opG::P64 = P64[R1 + 15];
           R1 = _s8opD::P64;
           P64[Sp + 88] = _s8opG::P64;
           if (R1 & 7 != 0) goto u8p7Q; else goto c8p5U;
       u8p7Q: // global
           call _c8p5Q(R1) args: 0, res: 0, upd: 0;
       c8p5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8p6o: // global
           I64[Sp] = block_c8p6m_info;
           _s8opP::P64 = P64[R1 + 14];
           R1 = _s8opD::P64;
           P64[Sp + 88] = _s8opP::P64;
           if (R1 & 7 != 0) goto u8p7R; else goto c8p6p;
       u8p7R: // global
           call _c8p6m(R1) args: 0, res: 0, upd: 0;
       c8p6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p5Q() //  [R1]
         { info_tbl: [(c8p5Q,
                       label: block_c8p5Q_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p5Q: // global
           if (R1 & 7 == 1) goto c8p6f; else goto u8p7b;
       c8p6f: // global
           if (P64[Sp + 88] == P64[R1 + 15]) goto u8p7c; else goto u8p7d;
       u8p7c: // global
           Sp = Sp + 8;
           call _s8ope() args: 0, res: 0, upd: 0;
       u8p7d: // global
           Sp = Sp + 96;
           goto u8p7U;
       u8p7b: // global
           Sp = Sp + 96;
           goto u8p7U;
       u8p7U: // global
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _c8p6m() //  [R1]
         { info_tbl: [(c8p6m,
                       label: block_c8p6m_info
                       rep:StackRep [False, True, False, False, True, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p6m: // global
           if (R1 & 7 == 1) goto u8p78; else goto c8p6O;
       u8p78: // global
           Sp = Sp + 96;
           goto u8p7X;
       c8p6O: // global
           if (P64[Sp + 88] == P64[R1 + 14]) goto u8p79; else goto u8p7a;
       u8p79: // global
           Sp = Sp + 8;
           call _s8ope() args: 0, res: 0, upd: 0;
       u8p7a: // global
           Sp = Sp + 96;
           goto u8p7X;
       u8p7X: // global
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _s8ope() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8ope: // global
           I64[Sp + 8] = block_c8p3s_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8p3s() //  [R1]
         { info_tbl: [(c8p3s,
                       label: block_c8p3s_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3s: // global
           if (R1 & 7 == 1) goto u8p7g; else goto c8p4k;
       u8p7g: // global
           Sp = Sp + 80;
           call _c8p6E() args: 0, res: 0, upd: 0;
       c8p4k: // global
           I64[Sp] = block_c8p3E_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto u8p7x; else goto c8p4l;
       u8p7x: // global
           call _c8p3E(R1) args: 0, res: 0, upd: 0;
       c8p4l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p3E() //  [R1]
         { info_tbl: [(c8p3E,
                       label: block_c8p3E_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3E: // global
           _s8op6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8p4s; else goto c8p4I;
       c8p4s: // global
           I64[Sp + 8] = block_c8p4p_info;
           R1 = _s8op6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8p7z; else goto c8p4t;
       u8p7z: // global
           call _c8p4p(R1) args: 0, res: 0, upd: 0;
       c8p4t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8p4I: // global
           I64[Sp + 8] = block_c8p4G_info;
           _s8opq::P64 = P64[R1 + 6];
           R1 = _s8op6::P64;
           P64[Sp + 72] = _s8opq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8p7A; else goto c8p4J;
       u8p7A: // global
           call _c8p4G(R1) args: 0, res: 0, upd: 0;
       c8p4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p4p() //  [R1]
         { info_tbl: [(c8p4p,
                       label: block_c8p4p_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p4p: // global
           if (R1 & 7 == 1) goto u8p7k; else goto u8p7l;
       u8p7k: // global
           Sp = Sp + 8;
           call _s8opg() args: 0, res: 0, upd: 0;
       u8p7l: // global
           Sp = Sp + 72;
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _c8p4G() //  [R1]
         { info_tbl: [(c8p4G,
                       label: block_c8p4G_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p4G: // global
           if (R1 & 7 == 1) goto u8p7h; else goto c8p4Z;
       u8p7h: // global
           Sp = Sp + 72;
           call _c8p6E() args: 0, res: 0, upd: 0;
       c8p4Z: // global
           I64[Sp] = block_c8p4S_info;
           _s8ops::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8ops::P64;
           if (R1 & 7 != 0) goto u8p7H; else goto c8p4T;
       u8p7H: // global
           call _c8p4S(R1) args: 0, res: 0, upd: 0;
       c8p4T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p4S() //  [R1]
         { info_tbl: [(c8p4S,
                       label: block_c8p4S_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p4S: // global
           I64[Sp] = block_c8p4X_info;
           _s8opu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 64];
           I64[Sp + 64] = _s8opu::I64;
           if (R1 & 7 != 0) goto u8p7J; else goto c8p51;
       u8p7J: // global
           call _c8p4X(R1) args: 0, res: 0, upd: 0;
       c8p51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p4X() //  [R1]
         { info_tbl: [(c8p4X,
                       label: block_c8p4X_info
                       rep:StackRep [False, True, True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p4X: // global
           if (I64[Sp + 64] == I64[R1 + 7]) goto u8p7i; else goto u8p7j;
       u8p7i: // global
           Sp = Sp + 8;
           call _s8opg() args: 0, res: 0, upd: 0;
       u8p7j: // global
           Sp = Sp + 72;
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _s8opg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8opg: // global
           I64[Sp - 8] = block_c8p3J_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8p7Y; else goto c8p3L;
       u8p7Y: // global
           call _c8p3J(R1) args: 0, res: 0, upd: 0;
       c8p3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p3J() //  [R1]
         { info_tbl: [(c8p3J,
                       label: block_c8p3J_info
                       rep:StackRep [False, True, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3J: // global
           _s8op7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8p3S; else goto c8p48;
       c8p3S: // global
           I64[Sp + 64] = block_c8p3P_info;
           R1 = _s8op7::P64;
           Sp = Sp + 64;
           if (R1 & 7 != 0) goto u8p7B; else goto c8p3T;
       u8p7B: // global
           call _c8p3P(R1) args: 0, res: 0, upd: 0;
       c8p3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8p48: // global
           I64[Sp + 56] = block_c8p46_info;
           _s8opk::P64 = P64[R1 + 6];
           R1 = _s8op7::P64;
           P64[Sp + 64] = _s8opk::P64;
           Sp = Sp + 56;
           if (R1 & 7 != 0) goto u8p7C; else goto c8p49;
       u8p7C: // global
           call _c8p46(R1) args: 0, res: 0, upd: 0;
       c8p49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8p3P() //  [R1]
         { info_tbl: [(c8p3P,
                       label: block_c8p3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p3P: // global
           if (R1 & 7 == 1) goto c8p3Z; else goto u8p7n;
       c8p3Z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8p7n: // global
           Sp = Sp + 8;
           call _c8p6E() args: 0, res: 0, upd: 0;
     }
 },
 _c8p46() //  [R1]
         { info_tbl: [(c8p46,
                       label: block_c8p46_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p46: // global
           if (R1 & 7 == 1) goto u8p7m; else goto c8p4j;
       u8p7m: // global
           Sp = Sp + 16;
           call _c8p6E() args: 0, res: 0, upd: 0;
       c8p4j: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8p6E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p6E: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.08283401 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_$c/=_closure" {
     GHC.IO.Exception.$fEqIOException_$c/=_closure:
         const GHC.IO.Exception.$fEqIOException_$c/=_info;
 },
 GHC.IO.Exception.$fEqIOException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8paA,
                       label: GHC.IO.Exception.$fEqIOException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8paA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8paB; else goto c8paC;
       c8paB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqIOException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8paC: // global
           I64[Sp - 8] = block_c8pau_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Exception.$fEqIOException_$c==_entry(R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pau() //  [R1]
         { info_tbl: [(c8pau,
                       label: block_c8pau_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pau: // global
           if (R1 & 7 == 1) goto c8pax; else goto c8pay;
       c8pax: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8pay: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.088713723 UTC

[section ""data" . GHC.IO.Exception.$fEqIOException_closure" {
     GHC.IO.Exception.$fEqIOException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqIOException_$c==_closure+2;
         const GHC.IO.Exception.$fEqIOException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.090773597 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException1_closure" {
     GHC.IO.Exception.$fExceptionIOException1_closure:
         const GHC.IO.Exception.$fExceptionIOException1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException1_entry() //  [R1]
         { info_tbl: [(c8pb5,
                       label: GHC.IO.Exception.$fExceptionIOException1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pb5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pb6; else goto c8pb7;
       c8pb6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pb7: // global
           (_c8pb2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8pb2::I64 == 0) goto c8pb4; else goto c8pb3;
       c8pb4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8pb3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8pb2::I64;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.095341895 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException3_bytes" {
     GHC.IO.Exception.$fExceptionIOException3_bytes:
         I8[] [32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.096970392 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException2_bytes" {
     GHC.IO.Exception.$fExceptionIOException2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.101951989 UTC

[section ""data" . GHC.IO.Exception.$w$cshowsPrec3_closure" {
     GHC.IO.Exception.$w$cshowsPrec3_closure:
         const GHC.IO.Exception.$w$cshowsPrec3_info;
         const 0;
 },
 sat_s8oqc_entry() //  [R1]
         { info_tbl: [(c8pbM,
                       label: sat_s8oqc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pbM: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oqd_entry() //  [R1]
         { info_tbl: [(c8pbP,
                       label: sat_s8oqd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pbP: // global
           _s8oqd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pbQ; else goto c8pbR;
       c8pbR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pbT; else goto c8pbS;
       c8pbT: // global
           HpAlloc = 24;
           goto c8pbQ;
       c8pbQ: // global
           R1 = _s8oqd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oqd::P64;
           _s8oq6::P64 = P64[_s8oqd::P64 + 16];
           _s8oq9::P64 = P64[_s8oqd::P64 + 24];
           I64[Hp - 16] = sat_s8oqc_info;
           P64[Hp] = _s8oq6::P64;
           R3 = Hp - 16;
           R2 = _s8oq9::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqe_entry() //  [R1]
         { info_tbl: [(c8pbY,
                       label: sat_s8oqe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pbY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pbZ; else goto c8pc0;
       c8pbZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pc0: // global
           I64[Sp - 16] = block_c8pby_info;
           _s8oq6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s8oq6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pc6; else goto c8pbz;
       u8pc6: // global
           call _c8pby(R1) args: 0, res: 0, upd: 0;
       c8pbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pby() //  [R1]
         { info_tbl: [(c8pby,
                       label: block_c8pby_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pby: // global
           _s8oq6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pbV; else goto c8pbW;
       c8pbV: // global
           R1 = _s8oq6::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8pbW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8pc5; else goto c8pc4;
       c8pc5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8pc4: // global
           I64[Hp - 24] = sat_s8oqd_info;
           P64[Hp - 8] = _s8oq6::P64;
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionIOException3_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8oq8_entry() //  [R1]
         { info_tbl: [(c8pc7,
                       label: karg_s8oq8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pc7: // global
           _s8oq8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pc8; else goto c8pc9;
       c8pc9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8pcb; else goto c8pca;
       c8pcb: // global
           HpAlloc = 32;
           goto c8pc8;
       c8pc8: // global
           R1 = _s8oq8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pca: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oq8::P64;
           _s8oq2::P64 = P64[_s8oq8::P64 + 16];
           _s8oq4::P64 = P64[_s8oq8::P64 + 24];
           _s8oq6::P64 = P64[_s8oq8::P64 + 32];
           I64[Hp - 24] = sat_s8oqe_info;
           P64[Hp - 8] = _s8oq4::P64;
           P64[Hp] = _s8oq6::P64;
           R3 = Hp - 24;
           R2 = _s8oq2::P64;
           Sp = Sp - 16;
           call GHC.IO.Exception.$w$cshowsPrec4_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqi_entry() //  [R1]
         { info_tbl: [(c8pcm,
                       label: sat_s8oqi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pcm: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_s8oq7_entry() //  [R1]
         { info_tbl: [(c8pct,
                       label: eta_s8oq7_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pct: // global
           _s8oq7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8pcu; else goto c8pcv;
       c8pcv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8pcx; else goto c8pcw;
       c8pcx: // global
           HpAlloc = 40;
           goto c8pcu;
       c8pcu: // global
           R1 = _s8oq7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pcw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oq7::P64;
           _s8oq2::P64 = P64[_s8oq7::P64 + 16];
           _s8oq3::P64 = P64[_s8oq7::P64 + 24];
           _s8oq4::P64 = P64[_s8oq7::P64 + 32];
           _s8oq6::P64 = P64[_s8oq7::P64 + 40];
           I64[Hp - 32] = karg_s8oq8_info;
           P64[Hp - 16] = _s8oq2::P64;
           P64[Hp - 8] = _s8oq4::P64;
           P64[Hp] = _s8oq6::P64;
           I64[Sp - 32] = block_c8pcc_info;
           R1 = _s8oq3::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8pcD; else goto c8pcd;
       u8pcD: // global
           call _c8pcc(R1) args: 0, res: 0, upd: 0;
       c8pcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8pcc() //  [R1]
         { info_tbl: [(c8pcc,
                       label: block_c8pcc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pcc: // global
           _c8pbq::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pcq; else goto c8pcr;
       c8pcq: // global
           R1 = _c8pbq::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c8pcr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pcC; else goto c8pcB;
       c8pcC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8pcB: // global
           I64[Hp - 16] = sat_s8oqi_info;
           P64[Hp] = _c8pbq::P64;
           R3 = Hp - 16;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqp_entry() //  [R1]
         { info_tbl: [(c8pd6,
                       label: sat_s8oqp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pd6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pd7; else goto c8pd8;
       c8pd7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pd8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqq_entry() //  [R1]
         { info_tbl: [(c8pd9,
                       label: sat_s8oqq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pd9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pdd; else goto c8pdc;
       c8pdd: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pdc: // global
           _s8oq7::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8oqp_info;
           P64[Hp] = _s8oq7::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oqr_entry() //  [R1]
         { info_tbl: [(c8pde,
                       label: sat_s8oqr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pde: // global
           _s8oqr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pdf; else goto c8pdg;
       c8pdg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pdi; else goto c8pdh;
       c8pdi: // global
           HpAlloc = 24;
           goto c8pdf;
       c8pdf: // global
           R1 = _s8oqr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pdh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oqr::P64;
           _s8oq7::P64 = P64[_s8oqr::P64 + 16];
           _s8oqn::P64 = P64[_s8oqr::P64 + 24];
           I64[Hp - 16] = sat_s8oqq_info;
           P64[Hp] = _s8oq7::P64;
           R3 = Hp - 16;
           R2 = _s8oqn::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqv_entry() //  [R1]
         { info_tbl: [(c8pdx,
                       label: sat_s8oqv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pdx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pdy; else goto c8pdz;
       c8pdy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pdz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionIOException1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqw_entry() //  [R1]
         { info_tbl: [(c8pdA,
                       label: sat_s8oqw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pdA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pdE; else goto c8pdD;
       c8pdE: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pdD: // global
           _s8oq7::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s8oqv_info;
           P64[Hp] = _s8oq7::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oqx_entry() //  [R1]
         { info_tbl: [(c8pdF,
                       label: sat_s8oqx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pdF: // global
           _s8oqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pdG; else goto c8pdH;
       c8pdH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pdJ; else goto c8pdI;
       c8pdJ: // global
           HpAlloc = 24;
           goto c8pdG;
       c8pdG: // global
           R1 = _s8oqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oqx::P64;
           _s8oq7::P64 = P64[_s8oqx::P64 + 16];
           _s8oqs::P64 = P64[_s8oqx::P64 + 24];
           I64[Hp - 16] = sat_s8oqw_info;
           P64[Hp] = _s8oq7::P64;
           R3 = Hp - 16;
           R2 = _s8oqs::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oqz_entry() //  [R1]
         { info_tbl: [(c8pdQ,
                       label: sat_s8oqz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pdQ: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.$w$cshowsPrec3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8pdX,
                       label: GHC.IO.Exception.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pdX: // global
           _s8oq5::P64 = R6;
           _s8oq4::P64 = R5;
           _s8oq3::P64 = R4;
           _s8oq2::P64 = R3;
           _s8oq1::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pdY; else goto c8pdZ;
       c8pdZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8pe1; else goto c8pe0;
       c8pe1: // global
           HpAlloc = 48;
           goto c8pdY;
       c8pdY: // global
           R6 = _s8oq5::P64;
           R5 = _s8oq4::P64;
           R4 = _s8oq3::P64;
           R3 = _s8oq2::P64;
           R2 = _s8oq1::P64;
           R1 = GHC.IO.Exception.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8pe0: // global
           I64[Hp - 40] = eta_s8oq7_info;
           P64[Hp - 24] = _s8oq2::P64;
           P64[Hp - 16] = _s8oq3::P64;
           P64[Hp - 8] = _s8oq4::P64;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_c8pcE_info;
           R1 = _s8oq5::P64;
           P64[Sp - 8] = _s8oq1::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pep; else goto c8pcF;
       u8pep: // global
           call _c8pcE(R1) args: 0, res: 0, upd: 0;
       c8pcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pcE() //  [R1]
         { info_tbl: [(c8pcE,
                       label: block_c8pcE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pcE: // global
           if (R1 & 7 == 1) goto c8pdU; else goto c8pdV;
       c8pdU: // global
           _s8oq1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pcJ_info;
           R1 = _s8oq1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pen; else goto c8pcK;
       u8pen: // global
           call _c8pcJ(R1) args: 0, res: 0, upd: 0;
       c8pcK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pdV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pek; else goto c8pej;
       c8pek: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8pej: // global
           _s8oqy::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8oqz_info;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = _s8oqy::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8pcJ() //  [R1]
         { info_tbl: [(c8pcJ,
                       label: block_c8pcJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pcJ: // global
           if (R1 & 7 == 1) goto c8pe6; else goto c8pe8;
       c8pe6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8pe8: // global
           I64[Sp] = block_c8pcP_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u8peo; else goto c8pcQ;
       u8peo: // global
           call _c8pcP(R1) args: 0, res: 0, upd: 0;
       c8pcQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pcP() //  [R1]
         { info_tbl: [(c8pcP,
                       label: block_c8pcP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pcP: // global
           _c8pbm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pea; else goto c8pee;
       c8pea: // global
           Hp = Hp + 32;
           _s8oqm::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8peh; else goto c8pec;
       c8pec: // global
           _s8oqn::P64 = P64[_s8oqm::P64 + 7];
           I64[Hp - 24] = sat_s8oqr_info;
           P64[Hp - 8] = _c8pbm::P64;
           P64[Hp] = _s8oqn::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8pee: // global
           Hp = Hp + 32;
           _s8oqm::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8peh; else goto c8peg;
       c8peh: // global
           HpAlloc = 32;
           R1 = _s8oqm::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8peg: // global
           _s8oqs::P64 = P64[_s8oqm::P64 + 6];
           I64[Hp - 24] = sat_s8oqx_info;
           P64[Hp - 8] = _c8pbm::P64;
           P64[Hp] = _s8oqs::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.143933023 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_entry() //  [R2,
                                                                  R3, R4]
         { info_tbl: [(c8pgq,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pgr; else goto c8pgs;
       c8pgr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pgs: // global
           I64[Sp - 16] = block_c8pgn_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pgw; else goto c8pgo;
       u8pgw: // global
           call _c8pgn(R1) args: 0, res: 0, upd: 0;
       c8pgo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pgn() //  [R1]
         { info_tbl: [(c8pgn,
                       label: block_c8pgn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pgn: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.150080883 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cshow_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cshow_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cshow_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cshow_entry() //  [R2]
         { info_tbl: [(c8pgO,
                       label: GHC.IO.Exception.$fExceptionIOException_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pgO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pgP; else goto c8pgQ;
       c8pgP: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pgQ: // global
           I64[Sp - 8] = block_c8pgL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pgU; else goto c8pgM;
       u8pgU: // global
           call _c8pgL(R1) args: 0, res: 0, upd: 0;
       c8pgM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pgL() //  [R1]
         { info_tbl: [(c8pgL,
                       label: block_c8pgL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pgL: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = GHC.Types.[]_closure+1;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.156171637 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException1_closure" {
     GHC.IO.Exception.$fShowIOException1_closure:
         const GHC.IO.Exception.$fShowIOException1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException1_entry() //  [R2, R3]
         { info_tbl: [(c8phe,
                       label: GHC.IO.Exception.$fShowIOException1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8phf; else goto c8phg;
       c8phf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowIOException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8phg: // global
           I64[Sp - 16] = block_c8phb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8phk; else goto c8phc;
       u8phk: // global
           call _c8phb(R1) args: 0, res: 0, upd: 0;
       c8phc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8phb() //  [R1]
         { info_tbl: [(c8phb,
                       label: block_c8phb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phb: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Exception.$w$cshowsPrec3_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.161735984 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_$cshowList_closure" {
     GHC.IO.Exception.$fShowIOException_$cshowList_closure:
         const GHC.IO.Exception.$fShowIOException_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowIOException_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8phz,
                       label: GHC.IO.Exception.$fShowIOException_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowIOException1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.164980949 UTC

[section ""data" . GHC.IO.Exception.$fShowIOException_closure" {
     GHC.IO.Exception.$fShowIOException_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const GHC.IO.Exception.$fShowIOException_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.167216131 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_$cto_closure" {
     GHC.IO.Exception.$fGenericExitCode_$cto_closure:
         const GHC.IO.Exception.$fGenericExitCode_$cto_info;
 },
 GHC.IO.Exception.$fGenericExitCode_$cto_entry() //  [R2]
         { info_tbl: [(c8phR,
                       label: GHC.IO.Exception.$fGenericExitCode_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8phS; else goto c8phT;
       c8phS: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8phT: // global
           I64[Sp - 8] = block_c8phL_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8phL() //  [R1]
         { info_tbl: [(c8phL,
                       label: block_c8phL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phL: // global
           if (R1 & 7 == 1) goto c8phO; else goto c8phP;
       c8phO: // global
           I64[Sp] = block_c8phW_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8pi9; else goto c8phY;
       u8pi9: // global
           call _c8phW() args: 0, res: 0, upd: 0;
       c8phY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8phP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8pi8; else goto c8pi7;
       c8pi8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8pi7: // global
           _s8or7::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = _s8or7::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8phW() //  []
         { info_tbl: [(c8phW,
                       label: block_c8phW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8phW: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.175178544 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode2_closure" {
     GHC.IO.Exception.$fGenericExitCode2_closure:
         const GHC.Generics.L1_con_info;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.17734649 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode1_closure" {
     GHC.IO.Exception.$fGenericExitCode1_closure:
         const GHC.IO.Exception.$fGenericExitCode1_info;
 },
 GHC.IO.Exception.$fGenericExitCode1_entry() //  [R2]
         { info_tbl: [(c8piF,
                       label: GHC.IO.Exception.$fGenericExitCode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8piF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8piG; else goto c8piH;
       c8piG: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fGenericExitCode1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8piH: // global
           I64[Sp - 8] = block_c8piy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8piR; else goto c8piz;
       u8piR: // global
           call _c8piy(R1) args: 0, res: 0, upd: 0;
       c8piz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8piy() //  [R1]
         { info_tbl: [(c8piy,
                       label: block_c8piy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8piy: // global
           if (R1 & 7 == 1) goto c8piC; else goto c8piD;
       c8piC: // global
           R1 = GHC.IO.Exception.$fGenericExitCode2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8piD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8piQ; else goto c8piP;
       c8piQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8piP: // global
           _s8ora::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _s8ora::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.183626174 UTC

[section ""data" . GHC.IO.Exception.$fGenericExitCode_closure" {
     GHC.IO.Exception.$fGenericExitCode_closure:
         const GHC.Generics.C:Generic_con_info;
         const GHC.IO.Exception.$fGenericExitCode1_closure+1;
         const GHC.IO.Exception.$fGenericExitCode_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.185365643 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode3_bytes" {
     GHC.IO.Exception.$fExceptionExitCode3_bytes:
         I8[] [69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.187391286 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode2_closure" {
     GHC.IO.Exception.$fExceptionExitCode2_closure:
         const GHC.IO.Exception.$fExceptionExitCode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode2_entry() //  [R1]
         { info_tbl: [(c8pjf,
                       label: GHC.IO.Exception.$fExceptionExitCode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pjg; else goto c8pjh;
       c8pjg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pjh: // global
           (_c8pjc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8pjc::I64 == 0) goto c8pje; else goto c8pjd;
       c8pje: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8pjd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8pjc::I64;
           R2 = GHC.IO.Exception.$fExceptionExitCode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.191206805 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode1_bytes" {
     GHC.IO.Exception.$fExceptionExitCode1_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.194773611 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info;
         const 0;
 },
 sat_s8oro_entry() //  [R1]
         { info_tbl: [(c8pjQ,
                       label: sat_s8oro_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8pjW; else goto c8pjX;
       c8pjW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pjX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8pjN_info;
           _s8ord::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8ord::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8pk2; else goto c8pjO;
       u8pk2: // global
           call _c8pjN(R1) args: 0, res: 0, upd: 0;
       c8pjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8pjN() //  [R1]
         { info_tbl: [(c8pjN,
                       label: block_c8pjN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjN: // global
           _s8ord::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pjT_info;
           R4 = _s8ord::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8pjT() //  [R1, R2]
         { info_tbl: [(c8pjT,
                       label: block_c8pjT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pk1; else goto c8pk0;
       c8pk1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8pk0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8orv_entry() //  [R1]
         { info_tbl: [(c8pkf,
                       label: sat_s8orv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pkf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8pkm; else goto c8pkn;
       c8pkm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pkn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8pkc_info;
           _s8ord::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s8ord::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8pku; else goto c8pkd;
       u8pku: // global
           call _c8pkc(R1) args: 0, res: 0, upd: 0;
       c8pkd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8pkc() //  [R1]
         { info_tbl: [(c8pkc,
                       label: block_c8pkc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pkc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pkq; else goto c8pkp;
       c8pkq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8pkp: // global
           _s8orq::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8pkj_info;
           R4 = Hp - 14;
           R3 = _s8orq::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8pkj() //  [R1, R2]
         { info_tbl: [(c8pkj,
                       label: block_c8pkj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pkj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pkt; else goto c8pks;
       c8pkt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8pks: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8orw_entry() //  [R1]
         { info_tbl: [(c8pkv,
                       label: sat_s8orw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pkv: // global
           _s8orw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8pkw; else goto c8pkx;
       c8pkx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8pkz; else goto c8pky;
       c8pkz: // global
           HpAlloc = 32;
           goto c8pkw;
       c8pkw: // global
           R1 = _s8orw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8orw::P64;
           _s8ord::P64 = P64[_s8orw::P64 + 16];
           _s8orf::P64 = P64[_s8orw::P64 + 24];
           I64[Hp - 24] = sat_s8orv_info;
           P64[Hp - 8] = _s8ord::P64;
           P64[Hp] = _s8orf::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c8pkE,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pkE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8pkF; else goto c8pkG;
       c8pkF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pkG: // global
           I64[Sp - 24] = block_c8pjv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8pkS; else goto c8pjw;
       u8pkS: // global
           call _c8pjv(R1) args: 0, res: 0, upd: 0;
       c8pjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pjv() //  [R1]
         { info_tbl: [(c8pjv,
                       label: block_c8pjv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjv: // global
           if (R1 & 7 == 1) goto c8pkB; else goto c8pkC;
       c8pkB: // global
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8pkC: // global
           I64[Sp] = block_c8pjB_info;
           _s8orf::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8orf::P64;
           if (R1 & 7 != 0) goto u8pkR; else goto c8pjC;
       u8pkR: // global
           call _c8pjB(R1) args: 0, res: 0, upd: 0;
       c8pjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pjB() //  [R1]
         { info_tbl: [(c8pjB,
                       label: block_c8pjB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pjB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8pkM; else goto c8pkL;
       c8pkM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8pkL: // global
           _s8ord::P64 = P64[Sp + 16];
           _s8orf::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c8pkO; else goto c8pkQ;
       c8pkO: // global
           I64[Hp - 48] = sat_s8oro_info;
           P64[Hp - 32] = _s8ord::P64;
           P64[Hp - 24] = _s8orf::P64;
           _c8pjJ::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c8pjJ::P64;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8pkQ: // global
           I64[Hp - 48] = sat_s8orw_info;
           P64[Hp - 32] = _s8ord::P64;
           P64[Hp - 24] = _s8orf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.219962055 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cshow_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cshow_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_info;
         const 0;
 },
 sat_s8orF_entry() //  [R1]
         { info_tbl: [(c8pmc,
                       label: sat_s8orF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pmc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8pmi; else goto c8pmj;
       c8pmi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pmj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8pm9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8pmo; else goto c8pma;
       u8pmo: // global
           call _c8pm9(R1) args: 0, res: 0, upd: 0;
       c8pma: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8pm9() //  [R1]
         { info_tbl: [(c8pm9,
                       label: block_c8pm9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pm9: // global
           I64[Sp] = block_c8pmf_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8pmf() //  [R1, R2]
         { info_tbl: [(c8pmf,
                       label: block_c8pmf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pmf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pmn; else goto c8pmm;
       c8pmn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c8pmm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fExceptionExitCode_$cshow_entry() //  [R2]
         { info_tbl: [(c8pmt,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pmt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pmu; else goto c8pmv;
       c8pmu: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pmv: // global
           I64[Sp - 8] = block_c8plZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pmB; else goto c8pm0;
       u8pmB: // global
           call _c8plZ(R1) args: 0, res: 0, upd: 0;
       c8pm0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8plZ() //  [R1]
         { info_tbl: [(c8plZ,
                       label: block_c8plZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8plZ: // global
           if (R1 & 7 == 1) goto c8pmq; else goto c8pmr;
       c8pmq: // global
           R1 = GHC.IO.Exception.$fExceptionExitCode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8pmr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pmA; else goto c8pmz;
       c8pmA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8pmz: // global
           _s8orz::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_s8orF_info;
           P64[Hp] = _s8orz::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Exception.$fExceptionExitCode1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.231456145 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode1_closure" {
     GHC.IO.Exception.$fShowExitCode1_closure:
         const GHC.IO.Exception.$fShowExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8pnb,
                       label: GHC.IO.Exception.$fShowExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pnb: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fExceptionArrayException1_closure+1;
           call GHC.IO.Exception.$fShowExitCode_$cshowsPrec_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.234955179 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_$cshowList_closure" {
     GHC.IO.Exception.$fShowExitCode_$cshowList_closure:
         const GHC.IO.Exception.$fShowExitCode_$cshowList_info;
         const 0;
 },
 GHC.IO.Exception.$fShowExitCode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8pnm,
                       label: GHC.IO.Exception.$fShowExitCode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pnm: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fShowExitCode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.23852153 UTC

[section ""data" . GHC.IO.Exception.$fShowExitCode_closure" {
     GHC.IO.Exception.$fShowExitCode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure+3;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const GHC.IO.Exception.$fShowExitCode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.240281586 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme1_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.242060117 UTC

[section ""cstring" . GHC.IO.Exception.$fReadExitCode5_bytes" {
     GHC.IO.Exception.$fReadExitCode5_bytes:
         I8[] [69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.24396639 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode4_closure" {
     GHC.IO.Exception.$fReadExitCode4_closure:
         const GHC.IO.Exception.$fReadExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode4_entry() //  [R1]
         { info_tbl: [(c8pnC,
                       label: GHC.IO.Exception.$fReadExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pnC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pnD; else goto c8pnE;
       c8pnD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pnE: // global
           (_c8pnz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8pnz::I64 == 0) goto c8pnB; else goto c8pnA;
       c8pnB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8pnA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8pnz::I64;
           R2 = GHC.IO.Exception.$fReadExitCode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.248454383 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_lexeme_closure" {
     GHC.IO.Exception.$fReadExitCode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Exception.$fReadExitCode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.250599586 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode3_closure" {
     GHC.IO.Exception.$fReadExitCode3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.25366619 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode2_closure" {
     GHC.IO.Exception.$fReadExitCode2_closure:
         const GHC.IO.Exception.$fReadExitCode2_info;
         const 0;
 },
 sat_s8orL_entry() //  [R1]
         { info_tbl: [(c8pnY,
                       label: sat_s8orL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pnY: // global
           R2 = GHC.IO.Exception.ExitSuccess_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8orV_entry() //  [R1, R2]
         { info_tbl: [(c8por,
                       label: sat_s8orV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8por: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8pov; else goto c8pou;
       c8pov: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pou: // global
           _s8orJ::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _s8orJ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8orW_entry() //  [R1, R2]
         { info_tbl: [(c8pow,
                       label: sat_s8orW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pow: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8poA; else goto c8poz;
       c8poA: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8poz: // global
           _s8orJ::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8orV_info;
           P64[Hp] = _s8orJ::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Exception.$fReadExitCode3_closure+1;
           R2 = GHC.Read.$fReadInt2_closure+1;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8orZ_entry() //  [R1]
         { info_tbl: [(c8poB,
                       label: sat_s8orZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8poB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8poC; else goto c8poD;
       c8poC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8poD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8po7_info;
           _s8orJ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8orJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8poQ; else goto c8po8;
       u8poQ: // global
           call _c8po7(R1) args: 0, res: 0, upd: 0;
       c8po8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8po7() //  [R1]
         { info_tbl: [(c8po7,
                       label: block_c8po7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8po7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8poG; else goto c8poF;
       c8poG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8poF: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8poI; else goto c8poM;
       c8poI: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8poM: // global
           I64[Hp - 8] = sat_s8orW_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8poJ_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8poJ() //  [R1]
         { info_tbl: [(c8poJ,
                       label: block_c8poJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8poJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8poP; else goto c8poO;
       c8poP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8poO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode2_entry() //  [R2, R3]
         { info_tbl: [(c8poS,
                       label: GHC.IO.Exception.$fReadExitCode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8poS: // global
           _s8orJ::P64 = R3;
           _s8orI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8poT; else goto c8poU;
       c8poU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8poW; else goto c8poV;
       c8poW: // global
           HpAlloc = 16;
           goto c8poT;
       c8poT: // global
           R3 = _s8orJ::P64;
           R2 = _s8orI::P64;
           R1 = GHC.IO.Exception.$fReadExitCode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8poV: // global
           I64[Hp - 8] = sat_s8orL_info;
           P64[Hp] = _s8orJ::P64;
           I64[Sp - 24] = block_c8po1_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Exception.$fReadExitCode_lexeme1_closure+4;
           P64[Sp - 16] = _s8orI::P64;
           P64[Sp - 8] = _s8orJ::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8po1() //  [R1]
         { info_tbl: [(c8po1,
                       label: block_c8po1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8po1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8poZ; else goto c8poY;
       c8poZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8poY: // global
           I64[Hp - 40] = sat_s8orZ_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.271770669 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode1_closure" {
     GHC.IO.Exception.$fReadExitCode1_closure:
         const GHC.IO.Exception.$fReadExitCode1_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode1_entry() //  [R2, R3]
         { info_tbl: [(c8ppO,
                       label: GHC.IO.Exception.$fReadExitCode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ppO: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.275570926 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_info;
         const 0;
 },
 sat_s8os1_entry() //  [R1]
         { info_tbl: [(c8pq3,
                       label: sat_s8os1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pq4; else goto c8pq5;
       c8pq4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pq5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.$fReadExitCode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.$fReadExitCode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8pq6,
                       label: GHC.IO.Exception.$fReadExitCode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pq6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8pqa; else goto c8pq9;
       c8pqa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pq9: // global
           I64[Hp - 16] = sat_s8os1_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.281853624 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8pqt,
                       label: GHC.IO.Exception.$fReadExitCode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pqu; else goto c8pqv;
       c8pqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pqv: // global
           (_c8pqq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8pqq::I64 == 0) goto c8pqs; else goto c8pqr;
       c8pqs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8pqr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8pqq::I64;
           R2 = GHC.IO.Exception.$fReadExitCode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.286489877 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode6_closure" {
     GHC.IO.Exception.$fReadExitCode6_closure:
         const GHC.IO.Exception.$fReadExitCode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode6_entry() //  [R1]
         { info_tbl: [(c8pqK,
                       label: GHC.IO.Exception.$fReadExitCode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pqL; else goto c8pqM;
       c8pqL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8pqM: // global
           (_c8pqH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8pqH::I64 == 0) goto c8pqJ; else goto c8pqI;
       c8pqJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8pqI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8pqH::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.290611511 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_$creadList_closure" {
     GHC.IO.Exception.$fReadExitCode_$creadList_closure:
         const GHC.IO.Exception.$fReadExitCode_$creadList_info;
         const 0;
 },
 GHC.IO.Exception.$fReadExitCode_$creadList_entry() //  [R2]
         { info_tbl: [(c8pr0,
                       label: GHC.IO.Exception.$fReadExitCode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pr0: // global
           R3 = R2;
           R2 = GHC.IO.Exception.$fReadExitCode6_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.293941087 UTC

[section ""data" . GHC.IO.Exception.$fReadExitCode_closure" {
     GHC.IO.Exception.$fReadExitCode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure+1;
         const GHC.IO.Exception.$fReadExitCode_$creadList_closure+1;
         const GHC.IO.Exception.$fReadExitCode1_closure+2;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.296414328 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8prj,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8prj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8prk; else goto c8prl;
       c8prk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8prl: // global
           I64[Sp - 16] = block_c8prc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8prW; else goto c8prd;
       u8prW: // global
           call _c8prc(R1) args: 0, res: 0, upd: 0;
       c8prd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8prc() //  [R1]
         { info_tbl: [(c8prc,
                       label: block_c8prc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8prc: // global
           _s8os3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8prg; else goto c8prh;
       c8prg: // global
           I64[Sp + 8] = block_c8pro_info;
           R1 = _s8os3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8prU; else goto c8prq;
       u8prU: // global
           call _c8pro(R1) args: 0, res: 0, upd: 0;
       c8prq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8prh: // global
           I64[Sp] = block_c8prD_info;
           _s8os7::P64 = P64[R1 + 6];
           R1 = _s8os3::P64;
           P64[Sp + 8] = _s8os7::P64;
           if (R1 & 7 != 0) goto u8prV; else goto c8prF;
       u8prV: // global
           call _c8prD(R1) args: 0, res: 0, upd: 0;
       c8prF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pro() //  [R1]
         { info_tbl: [(c8pro,
                       label: block_c8pro_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pro: // global
           if (R1 & 7 == 1) goto u8prT; else goto c8prA;
       u8prT: // global
           Sp = Sp + 8;
           call _c8prL() args: 0, res: 0, upd: 0;
       c8prA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8prD() //  [R1]
         { info_tbl: [(c8prD,
                       label: block_c8prD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8prD: // global
           if (R1 & 7 == 1) goto u8prS; else goto c8prP;
       u8prS: // global
           Sp = Sp + 16;
           call _c8prL() args: 0, res: 0, upd: 0;
       c8prP: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8prL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8prL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.30741281 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$ccompare_closure" {
     GHC.IO.Exception.$fOrdExitCode_$ccompare_closure:
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8psG,
                       label: GHC.IO.Exception.$fOrdExitCode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8psG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8psH; else goto c8psI;
       c8psH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8psI: // global
           I64[Sp - 16] = block_c8psz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pth; else goto c8psA;
       u8pth: // global
           call _c8psz(R1) args: 0, res: 0, upd: 0;
       c8psA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8psz() //  [R1]
         { info_tbl: [(c8psz,
                       label: block_c8psz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8psz: // global
           _s8osb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8psD; else goto c8psE;
       c8psD: // global
           I64[Sp + 8] = block_c8psL_info;
           R1 = _s8osb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ptf; else goto c8psN;
       u8ptf: // global
           call _c8psL(R1) args: 0, res: 0, upd: 0;
       c8psN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8psE: // global
           I64[Sp] = block_c8pt0_info;
           _s8osf::P64 = P64[R1 + 6];
           R1 = _s8osb::P64;
           P64[Sp + 8] = _s8osf::P64;
           if (R1 & 7 != 0) goto u8ptg; else goto c8pt2;
       u8ptg: // global
           call _c8pt0(R1) args: 0, res: 0, upd: 0;
       c8pt2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8psL() //  [R1]
         { info_tbl: [(c8psL,
                       label: block_c8psL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8psL: // global
           if (R1 & 7 == 1) goto c8psT; else goto c8psX;
       c8psT: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8psX: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pt0() //  [R1]
         { info_tbl: [(c8pt0,
                       label: block_c8pt0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pt0: // global
           if (R1 & 7 == 1) goto c8pt8; else goto c8ptc;
       c8pt8: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ptc: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.317298876 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c==_closure" {
     GHC.IO.Exception.$fEqExitCode_$c==_closure:
         const GHC.IO.Exception.$fEqExitCode_$c==_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8ptZ,
                       label: GHC.IO.Exception.$fEqExitCode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ptZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pu0; else goto c8pu1;
       c8pu0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pu1: // global
           I64[Sp - 16] = block_c8ptS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8puC; else goto c8ptT;
       u8puC: // global
           call _c8ptS(R1) args: 0, res: 0, upd: 0;
       c8ptT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ptS() //  [R1]
         { info_tbl: [(c8ptS,
                       label: block_c8ptS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ptS: // global
           _s8osj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ptW; else goto c8ptX;
       c8ptW: // global
           I64[Sp + 8] = block_c8pu4_info;
           R1 = _s8osj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8puA; else goto c8pu6;
       u8puA: // global
           call _c8pu4(R1) args: 0, res: 0, upd: 0;
       c8pu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ptX: // global
           I64[Sp] = block_c8puj_info;
           _s8osn::P64 = P64[R1 + 6];
           R1 = _s8osj::P64;
           P64[Sp + 8] = _s8osn::P64;
           if (R1 & 7 != 0) goto u8puB; else goto c8pul;
       u8puB: // global
           call _c8puj(R1) args: 0, res: 0, upd: 0;
       c8pul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pu4() //  [R1]
         { info_tbl: [(c8pu4,
                       label: block_c8pu4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pu4: // global
           if (R1 & 7 == 1) goto c8puc; else goto u8puz;
       c8puc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8puz: // global
           Sp = Sp + 8;
           call _c8pur() args: 0, res: 0, upd: 0;
     }
 },
 _c8puj() //  [R1]
         { info_tbl: [(c8puj,
                       label: block_c8puj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8puj: // global
           if (R1 & 7 == 1) goto u8puy; else goto c8puv;
       u8puy: // global
           Sp = Sp + 16;
           call _c8pur() args: 0, res: 0, upd: 0;
       c8puv: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8pur() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pur: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.328928654 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_$c/=_closure" {
     GHC.IO.Exception.$fEqExitCode_$c/=_closure:
         const GHC.IO.Exception.$fEqExitCode_$c/=_info;
 },
 GHC.IO.Exception.$fEqExitCode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8pvm,
                       label: GHC.IO.Exception.$fEqExitCode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pvn; else goto c8pvo;
       c8pvn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqExitCode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pvo: // global
           I64[Sp - 16] = block_c8pvf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pwj; else goto c8pvg;
       u8pwj: // global
           call _c8pvf(R1) args: 0, res: 0, upd: 0;
       c8pvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pvf() //  [R1]
         { info_tbl: [(c8pvf,
                       label: block_c8pvf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvf: // global
           _s8osr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pvj; else goto c8pvk;
       c8pvj: // global
           I64[Sp + 8] = block_c8pvr_info;
           R1 = _s8osr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pwh; else goto c8pvt;
       u8pwh: // global
           call _c8pvr(R1) args: 0, res: 0, upd: 0;
       c8pvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pvk: // global
           I64[Sp] = block_c8pvG_info;
           _s8osv::P64 = P64[R1 + 6];
           R1 = _s8osr::P64;
           P64[Sp + 8] = _s8osv::P64;
           if (R1 & 7 != 0) goto u8pwi; else goto c8pvI;
       u8pwi: // global
           call _c8pvG(R1) args: 0, res: 0, upd: 0;
       c8pvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pvr() //  [R1]
         { info_tbl: [(c8pvr,
                       label: block_c8pvr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvr: // global
           if (R1 & 7 == 1) goto u8pwf; else goto u8pwg;
       u8pwf: // global
           Sp = Sp + 8;
           call _c8pw9() args: 0, res: 0, upd: 0;
       u8pwg: // global
           Sp = Sp + 8;
           call _c8pw8() args: 0, res: 0, upd: 0;
     }
 },
 _c8pvG() //  [R1]
         { info_tbl: [(c8pvG,
                       label: block_c8pvG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvG: // global
           if (R1 & 7 == 1) goto u8pwc; else goto c8pvY;
       u8pwc: // global
           Sp = Sp + 16;
           call _c8pw8() args: 0, res: 0, upd: 0;
       c8pvY: // global
           I64[Sp] = block_c8pvR_info;
           _s8osx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8osx::P64;
           if (R1 & 7 != 0) goto u8pwm; else goto c8pvS;
       u8pwm: // global
           call _c8pvR(R1) args: 0, res: 0, upd: 0;
       c8pvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pvR() //  [R1]
         { info_tbl: [(c8pvR,
                       label: block_c8pvR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvR: // global
           I64[Sp] = block_c8pvW_info;
           _s8osz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8osz::I64;
           if (R1 & 7 != 0) goto u8pwo; else goto c8pw0;
       u8pwo: // global
           call _c8pvW(R1) args: 0, res: 0, upd: 0;
       c8pw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pvW() //  [R1]
         { info_tbl: [(c8pvW,
                       label: block_c8pvW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pvW: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8pwd; else goto u8pwe;
       u8pwd: // global
           Sp = Sp + 16;
           call _c8pw9() args: 0, res: 0, upd: 0;
       u8pwe: // global
           Sp = Sp + 16;
           call _c8pw8() args: 0, res: 0, upd: 0;
     }
 },
 _c8pw9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pw9: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pw8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pw8: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.343819887 UTC

[section ""data" . GHC.IO.Exception.$fEqExitCode_closure" {
     GHC.IO.Exception.$fEqExitCode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqExitCode_$c==_closure+2;
         const GHC.IO.Exception.$fEqExitCode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.346459637 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c<=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c<=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c<=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8pxm,
                       label: GHC.IO.Exception.$fOrdExitCode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pxn; else goto c8pxo;
       c8pxn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pxo: // global
           I64[Sp - 16] = block_c8pxf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pyj; else goto c8pxg;
       u8pyj: // global
           call _c8pxf(R1) args: 0, res: 0, upd: 0;
       c8pxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pxf() //  [R1]
         { info_tbl: [(c8pxf,
                       label: block_c8pxf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxf: // global
           _s8osD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pxj; else goto c8pxk;
       c8pxj: // global
           I64[Sp + 8] = block_c8pxr_info;
           R1 = _s8osD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pyh; else goto c8pxt;
       u8pyh: // global
           call _c8pxr(R1) args: 0, res: 0, upd: 0;
       c8pxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pxk: // global
           I64[Sp] = block_c8pxG_info;
           _s8osI::P64 = P64[R1 + 6];
           R1 = _s8osD::P64;
           P64[Sp + 8] = _s8osI::P64;
           if (R1 & 7 != 0) goto u8pyi; else goto c8pxI;
       u8pyi: // global
           call _c8pxG(R1) args: 0, res: 0, upd: 0;
       c8pxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pxr() //  [R1]
         { info_tbl: [(c8pxr,
                       label: block_c8pxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxr: // global
           if (R1 & 7 == 1) goto u8pyf; else goto u8pyg;
       u8pyf: // global
           Sp = Sp + 8;
           call _c8py8() args: 0, res: 0, upd: 0;
       u8pyg: // global
           Sp = Sp + 8;
           call _c8py9() args: 0, res: 0, upd: 0;
     }
 },
 _c8pxG() //  [R1]
         { info_tbl: [(c8pxG,
                       label: block_c8pxG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxG: // global
           if (R1 & 7 == 1) goto u8pyc; else goto c8pxY;
       u8pyc: // global
           Sp = Sp + 16;
           call _c8py8() args: 0, res: 0, upd: 0;
       c8pxY: // global
           I64[Sp] = block_c8pxR_info;
           _s8osK::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8osK::P64;
           if (R1 & 7 != 0) goto u8pym; else goto c8pxS;
       u8pym: // global
           call _c8pxR(R1) args: 0, res: 0, upd: 0;
       c8pxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pxR() //  [R1]
         { info_tbl: [(c8pxR,
                       label: block_c8pxR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxR: // global
           I64[Sp] = block_c8pxW_info;
           _s8osM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8osM::I64;
           if (R1 & 7 != 0) goto u8pyo; else goto c8py0;
       u8pyo: // global
           call _c8pxW(R1) args: 0, res: 0, upd: 0;
       c8py0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pxW() //  [R1]
         { info_tbl: [(c8pxW,
                       label: block_c8pxW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pxW: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8pye; else goto u8pyd;
       u8pye: // global
           Sp = Sp + 16;
           call _c8py8() args: 0, res: 0, upd: 0;
       u8pyd: // global
           Sp = Sp + 16;
           call _c8py9() args: 0, res: 0, upd: 0;
     }
 },
 _c8py8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8py8: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8py9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8py9: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.361837396 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmax_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmax_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmax_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8pzl,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pzl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8pzm; else goto c8pzn;
       c8pzm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pzn: // global
           I64[Sp - 16] = block_c8pze_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pA1; else goto c8pzf;
       u8pA1: // global
           call _c8pze(R1) args: 0, res: 0, upd: 0;
       c8pzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pze() //  [R1]
         { info_tbl: [(c8pze,
                       label: block_c8pze_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pze: // global
           _s8osQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pzi; else goto c8pzj;
       c8pzi: // global
           R1 = _s8osQ::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8pzj: // global
           I64[Sp - 8] = block_c8pzt_info;
           _s8osS::P64 = R1;
           _s8osT::P64 = P64[R1 + 6];
           R1 = _s8osQ::P64;
           P64[Sp] = _s8osT::P64;
           P64[Sp + 8] = _s8osS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pA0; else goto c8pzv;
       u8pA0: // global
           call _c8pzt(R1) args: 0, res: 0, upd: 0;
       c8pzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pzt() //  [R1]
         { info_tbl: [(c8pzt,
                       label: block_c8pzt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pzt: // global
           if (R1 & 7 == 1) goto u8pzY; else goto c8pzL;
       u8pzY: // global
           Sp = Sp + 16;
           call _c8pzV() args: 0, res: 0, upd: 0;
       c8pzL: // global
           I64[Sp - 8] = block_c8pzE_info;
           _s8osU::P64 = R1;
           _s8osV::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8osV::P64;
           P64[Sp + 8] = _s8osU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pA2; else goto c8pzF;
       u8pA2: // global
           call _c8pzE(R1) args: 0, res: 0, upd: 0;
       c8pzF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pzE() //  [R1]
         { info_tbl: [(c8pzE,
                       label: block_c8pzE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pzE: // global
           I64[Sp] = block_c8pzJ_info;
           _s8osX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8osX::I64;
           if (R1 & 7 != 0) goto u8pA4; else goto c8pzN;
       u8pA4: // global
           call _c8pzJ(R1) args: 0, res: 0, upd: 0;
       c8pzN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pzJ() //  [R1]
         { info_tbl: [(c8pzJ,
                       label: block_c8pzJ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pzJ: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8pzZ; else goto c8pzW;
       u8pzZ: // global
           Sp = Sp + 24;
           call _c8pzV() args: 0, res: 0, upd: 0;
       c8pzW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pzV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pzV: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.379209582 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>=_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>=_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>=_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8pAT,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pAU; else goto c8pAV;
       c8pAU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pAV: // global
           I64[Sp - 16] = block_c8pAM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pBQ; else goto c8pAN;
       u8pBQ: // global
           call _c8pAM(R1) args: 0, res: 0, upd: 0;
       c8pAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pAM() //  [R1]
         { info_tbl: [(c8pAM,
                       label: block_c8pAM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pAM: // global
           _s8ot2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pAQ; else goto c8pAR;
       c8pAQ: // global
           I64[Sp + 8] = block_c8pAY_info;
           R1 = _s8ot2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pBO; else goto c8pB0;
       u8pBO: // global
           call _c8pAY(R1) args: 0, res: 0, upd: 0;
       c8pB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pAR: // global
           I64[Sp] = block_c8pBd_info;
           _s8ot6::P64 = P64[R1 + 6];
           R1 = _s8ot2::P64;
           P64[Sp + 8] = _s8ot6::P64;
           if (R1 & 7 != 0) goto u8pBP; else goto c8pBf;
       u8pBP: // global
           call _c8pBd(R1) args: 0, res: 0, upd: 0;
       c8pBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pAY() //  [R1]
         { info_tbl: [(c8pAY,
                       label: block_c8pAY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pAY: // global
           if (R1 & 7 == 1) goto u8pBM; else goto u8pBN;
       u8pBM: // global
           Sp = Sp + 8;
           call _c8pBF() args: 0, res: 0, upd: 0;
       u8pBN: // global
           Sp = Sp + 8;
           call _c8pBG() args: 0, res: 0, upd: 0;
     }
 },
 _c8pBd() //  [R1]
         { info_tbl: [(c8pBd,
                       label: block_c8pBd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pBd: // global
           if (R1 & 7 == 1) goto u8pBJ; else goto c8pBv;
       u8pBJ: // global
           Sp = Sp + 16;
           call _c8pBF() args: 0, res: 0, upd: 0;
       c8pBv: // global
           I64[Sp] = block_c8pBo_info;
           _s8ot8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ot8::P64;
           if (R1 & 7 != 0) goto u8pBT; else goto c8pBp;
       u8pBT: // global
           call _c8pBo(R1) args: 0, res: 0, upd: 0;
       c8pBp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pBo() //  [R1]
         { info_tbl: [(c8pBo,
                       label: block_c8pBo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pBo: // global
           I64[Sp] = block_c8pBt_info;
           _s8ota::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ota::I64;
           if (R1 & 7 != 0) goto u8pBV; else goto c8pBx;
       u8pBV: // global
           call _c8pBt(R1) args: 0, res: 0, upd: 0;
       c8pBx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pBt() //  [R1]
         { info_tbl: [(c8pBt,
                       label: block_c8pBt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pBt: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8pBL; else goto u8pBK;
       u8pBL: // global
           Sp = Sp + 16;
           call _c8pBF() args: 0, res: 0, upd: 0;
       u8pBK: // global
           Sp = Sp + 16;
           call _c8pBG() args: 0, res: 0, upd: 0;
     }
 },
 _c8pBF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pBF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pBG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pBG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.396329127 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$c>_closure" {
     GHC.IO.Exception.$fOrdExitCode_$c>_closure:
         const GHC.IO.Exception.$fOrdExitCode_$c>_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8pCL,
                       label: GHC.IO.Exception.$fOrdExitCode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pCL: // global
           _s8otf::P64 = R3;
           R3 = R2;
           R2 = _s8otf::P64;
           call GHC.IO.Exception.$fOrdExitCode_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.401422515 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_$cmin_closure" {
     GHC.IO.Exception.$fOrdExitCode_$cmin_closure:
         const GHC.IO.Exception.$fOrdExitCode_$cmin_info;
 },
 GHC.IO.Exception.$fOrdExitCode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8pD3,
                       label: GHC.IO.Exception.$fOrdExitCode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pD3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8pD4; else goto c8pD5;
       c8pD4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdExitCode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pD5: // global
           I64[Sp - 16] = block_c8pCW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pDO; else goto c8pCX;
       u8pDO: // global
           call _c8pCW(R1) args: 0, res: 0, upd: 0;
       c8pCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pCW() //  [R1]
         { info_tbl: [(c8pCW,
                       label: block_c8pCW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pCW: // global
           _s8otg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pD0; else goto c8pD1;
       c8pD0: // global
           I64[Sp + 8] = block_c8pD8_info;
           R1 = _s8otg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pDM; else goto c8pDa;
       u8pDM: // global
           call _c8pD8() args: 0, res: 0, upd: 0;
       c8pDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pD1: // global
           I64[Sp - 8] = block_c8pDh_info;
           _s8oti::P64 = R1;
           _s8otk::P64 = P64[R1 + 6];
           R1 = _s8otg::P64;
           P64[Sp] = _s8otk::P64;
           P64[Sp + 8] = _s8oti::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pDN; else goto c8pDj;
       u8pDN: // global
           call _c8pDh(R1) args: 0, res: 0, upd: 0;
       c8pDj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pD8() //  []
         { info_tbl: [(c8pD8,
                       label: block_c8pD8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pD8: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pDh() //  [R1]
         { info_tbl: [(c8pDh,
                       label: block_c8pDh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pDh: // global
           if (R1 & 7 == 1) goto c8pDp; else goto c8pDz;
       c8pDp: // global
           R1 = GHC.IO.Exception.ExitSuccess_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8pDz: // global
           I64[Sp - 8] = block_c8pDs_info;
           _s8otl::P64 = R1;
           _s8otm::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8otm::P64;
           P64[Sp + 8] = _s8otl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pDP; else goto c8pDt;
       u8pDP: // global
           call _c8pDs(R1) args: 0, res: 0, upd: 0;
       c8pDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pDs() //  [R1]
         { info_tbl: [(c8pDs,
                       label: block_c8pDs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pDs: // global
           I64[Sp] = block_c8pDx_info;
           _s8oto::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8oto::I64;
           if (R1 & 7 != 0) goto u8pDQ; else goto c8pDB;
       u8pDQ: // global
           call _c8pDx(R1) args: 0, res: 0, upd: 0;
       c8pDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pDx() //  [R1]
         { info_tbl: [(c8pDx,
                       label: block_c8pDx_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pDx: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c8pDJ; else goto c8pDK;
       c8pDJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8pDK: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.417800489 UTC

[section ""data" . GHC.IO.Exception.$fOrdExitCode_closure" {
     GHC.IO.Exception.$fOrdExitCode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqExitCode_closure+1;
         const GHC.IO.Exception.$fOrdExitCode_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdExitCode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.420512108 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8pEI,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pEI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pEJ; else goto c8pEK;
       c8pEJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pEK: // global
           I64[Sp - 16] = block_c8pEB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pFj; else goto c8pEC;
       u8pFj: // global
           call _c8pEB(R1) args: 0, res: 0, upd: 0;
       c8pEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pEB() //  [R1]
         { info_tbl: [(c8pEB,
                       label: block_c8pEB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pEB: // global
           _s8ott::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pEF; else goto c8pEG;
       c8pEF: // global
           I64[Sp] = block_c8pEN_info;
           _s8otv::P64 = P64[R1 + 7];
           R1 = _s8ott::P64;
           P64[Sp + 8] = _s8otv::P64;
           if (R1 & 7 != 0) goto u8pFh; else goto c8pEP;
       u8pFh: // global
           call _c8pEN(R1) args: 0, res: 0, upd: 0;
       c8pEP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pEG: // global
           I64[Sp] = block_c8pF2_info;
           _s8otz::P64 = P64[R1 + 6];
           R1 = _s8ott::P64;
           P64[Sp + 8] = _s8otz::P64;
           if (R1 & 7 != 0) goto u8pFi; else goto c8pF4;
       u8pFi: // global
           call _c8pF2(R1) args: 0, res: 0, upd: 0;
       c8pF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pEN() //  [R1]
         { info_tbl: [(c8pEN,
                       label: block_c8pEN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pEN: // global
           if (R1 & 7 == 1) goto c8pEV; else goto c8pEZ;
       c8pEV: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c8pEZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pF2() //  [R1]
         { info_tbl: [(c8pF2,
                       label: block_c8pF2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pF2: // global
           if (R1 & 7 == 1) goto c8pFa; else goto c8pFe;
       c8pFa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8pFe: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$c<1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.430960476 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdArrayException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8pFZ,
                       label: GHC.IO.Exception.$fOrdArrayException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pFZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pG0; else goto c8pG1;
       c8pG0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pG1: // global
           I64[Sp - 16] = block_c8pFS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pGA; else goto c8pFT;
       u8pGA: // global
           call _c8pFS(R1) args: 0, res: 0, upd: 0;
       c8pFT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pFS() //  [R1]
         { info_tbl: [(c8pFS,
                       label: block_c8pFS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pFS: // global
           _s8otE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pFW; else goto c8pFX;
       c8pFW: // global
           I64[Sp] = block_c8pG4_info;
           _s8otG::P64 = P64[R1 + 7];
           R1 = _s8otE::P64;
           P64[Sp + 8] = _s8otG::P64;
           if (R1 & 7 != 0) goto u8pGy; else goto c8pG6;
       u8pGy: // global
           call _c8pG4(R1) args: 0, res: 0, upd: 0;
       c8pG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pFX: // global
           I64[Sp] = block_c8pGj_info;
           _s8otK::P64 = P64[R1 + 6];
           R1 = _s8otE::P64;
           P64[Sp + 8] = _s8otK::P64;
           if (R1 & 7 != 0) goto u8pGz; else goto c8pGl;
       u8pGz: // global
           call _c8pGj(R1) args: 0, res: 0, upd: 0;
       c8pGl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pG4() //  [R1]
         { info_tbl: [(c8pG4,
                       label: block_c8pG4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pG4: // global
           if (R1 & 7 == 1) goto c8pGc; else goto c8pGg;
       c8pGc: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8pGg: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pGj() //  [R1]
         { info_tbl: [(c8pGj,
                       label: block_c8pGj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pGj: // global
           if (R1 & 7 == 1) goto c8pGr; else goto c8pGv;
       c8pGr: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8pGv: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.441434985 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c==_closure" {
     GHC.IO.Exception.$fEqArrayException_$c==_closure:
         const GHC.IO.Exception.$fEqArrayException_$c==_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8pHg,
                       label: GHC.IO.Exception.$fEqArrayException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pHg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pHh; else goto c8pHi;
       c8pHh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pHi: // global
           I64[Sp - 16] = block_c8pH9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pHT; else goto c8pHa;
       u8pHT: // global
           call _c8pH9(R1) args: 0, res: 0, upd: 0;
       c8pHa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pH9() //  [R1]
         { info_tbl: [(c8pH9,
                       label: block_c8pH9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pH9: // global
           _s8otP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pHd; else goto c8pHe;
       c8pHd: // global
           I64[Sp] = block_c8pHl_info;
           _s8otR::P64 = P64[R1 + 7];
           R1 = _s8otP::P64;
           P64[Sp + 8] = _s8otR::P64;
           if (R1 & 7 != 0) goto u8pHR; else goto c8pHn;
       u8pHR: // global
           call _c8pHl(R1) args: 0, res: 0, upd: 0;
       c8pHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pHe: // global
           I64[Sp] = block_c8pHA_info;
           _s8otV::P64 = P64[R1 + 6];
           R1 = _s8otP::P64;
           P64[Sp + 8] = _s8otV::P64;
           if (R1 & 7 != 0) goto u8pHS; else goto c8pHC;
       u8pHS: // global
           call _c8pHA(R1) args: 0, res: 0, upd: 0;
       c8pHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pHl() //  [R1]
         { info_tbl: [(c8pHl,
                       label: block_c8pHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pHl: // global
           if (R1 & 7 == 1) goto c8pHt; else goto u8pHQ;
       c8pHt: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
       u8pHQ: // global
           Sp = Sp + 16;
           call _c8pHI() args: 0, res: 0, upd: 0;
     }
 },
 _c8pHA() //  [R1]
         { info_tbl: [(c8pHA,
                       label: block_c8pHA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pHA: // global
           if (R1 & 7 == 1) goto u8pHP; else goto c8pHM;
       u8pHP: // global
           Sp = Sp + 16;
           call _c8pHI() args: 0, res: 0, upd: 0;
       c8pHM: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8pHI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pHI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.453491395 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_$c/=_closure" {
     GHC.IO.Exception.$fEqArrayException_$c/=_closure:
         const GHC.IO.Exception.$fEqArrayException_$c/=_info;
 },
 GHC.IO.Exception.$fEqArrayException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8pIB,
                       label: GHC.IO.Exception.$fEqArrayException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pIC; else goto c8pID;
       c8pIC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqArrayException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pID: // global
           I64[Sp - 16] = block_c8pIu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pJG; else goto c8pIv;
       u8pJG: // global
           call _c8pIu(R1) args: 0, res: 0, upd: 0;
       c8pIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pIu() //  [R1]
         { info_tbl: [(c8pIu,
                       label: block_c8pIu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pIu: // global
           _s8ou0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pIy; else goto c8pIz;
       c8pIy: // global
           I64[Sp] = block_c8pIG_info;
           _s8ou2::P64 = P64[R1 + 7];
           R1 = _s8ou0::P64;
           P64[Sp + 8] = _s8ou2::P64;
           if (R1 & 7 != 0) goto u8pJE; else goto c8pII;
       u8pJE: // global
           call _c8pIG(R1) args: 0, res: 0, upd: 0;
       c8pII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pIz: // global
           I64[Sp] = block_c8pJ6_info;
           _s8ou7::P64 = P64[R1 + 6];
           R1 = _s8ou0::P64;
           P64[Sp + 8] = _s8ou7::P64;
           if (R1 & 7 != 0) goto u8pJF; else goto c8pJ8;
       u8pJF: // global
           call _c8pJ6(R1) args: 0, res: 0, upd: 0;
       c8pJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pIG() //  [R1]
         { info_tbl: [(c8pIG,
                       label: block_c8pIG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pIG: // global
           if (R1 & 7 == 1) goto c8pIP; else goto u8pJB;
       c8pIP: // global
           _s8ou2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pIM_info;
           R3 = P64[R1 + 7];
           R2 = _s8ou2::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       u8pJB: // global
           Sp = Sp + 16;
           call _c8pJp() args: 0, res: 0, upd: 0;
     }
 },
 _c8pIM() //  [R1]
         { info_tbl: [(c8pIM,
                       label: block_c8pIM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pIM: // global
           if (R1 & 7 == 1) goto u8pJC; else goto u8pJD;
       u8pJC: // global
           Sp = Sp + 8;
           call _c8pJp() args: 0, res: 0, upd: 0;
       u8pJD: // global
           Sp = Sp + 8;
           call _c8pJt() args: 0, res: 0, upd: 0;
     }
 },
 _c8pJ6() //  [R1]
         { info_tbl: [(c8pJ6,
                       label: block_c8pJ6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pJ6: // global
           if (R1 & 7 == 1) goto u8pJy; else goto c8pJj;
       u8pJy: // global
           Sp = Sp + 16;
           call _c8pJp() args: 0, res: 0, upd: 0;
       c8pJj: // global
           _s8ou7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pJh_info;
           R3 = P64[R1 + 6];
           R2 = _s8ou7::P64;
           Sp = Sp + 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pJh() //  [R1]
         { info_tbl: [(c8pJh,
                       label: block_c8pJh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pJh: // global
           if (R1 & 7 == 1) goto u8pJz; else goto u8pJA;
       u8pJz: // global
           Sp = Sp + 8;
           call _c8pJp() args: 0, res: 0, upd: 0;
       u8pJA: // global
           Sp = Sp + 8;
           call _c8pJt() args: 0, res: 0, upd: 0;
     }
 },
 _c8pJp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pJp: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pJt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pJt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.467871204 UTC

[section ""data" . GHC.IO.Exception.$fEqArrayException_closure" {
     GHC.IO.Exception.$fEqArrayException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqArrayException_$c==_closure+2;
         const GHC.IO.Exception.$fEqArrayException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.470599856 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c<=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c<=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8pKJ,
                       label: GHC.IO.Exception.$fOrdArrayException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pKJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pKK; else goto c8pKL;
       c8pKK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pKL: // global
           I64[Sp - 16] = block_c8pKC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pLO; else goto c8pKD;
       u8pLO: // global
           call _c8pKC(R1) args: 0, res: 0, upd: 0;
       c8pKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pKC() //  [R1]
         { info_tbl: [(c8pKC,
                       label: block_c8pKC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pKC: // global
           _s8ouc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pKG; else goto c8pKH;
       c8pKG: // global
           I64[Sp] = block_c8pKO_info;
           _s8ouf::P64 = P64[R1 + 7];
           R1 = _s8ouc::P64;
           P64[Sp + 8] = _s8ouf::P64;
           if (R1 & 7 != 0) goto u8pLM; else goto c8pKQ;
       u8pLM: // global
           call _c8pKO(R1) args: 0, res: 0, upd: 0;
       c8pKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pKH: // global
           I64[Sp] = block_c8pLe_info;
           _s8ouk::P64 = P64[R1 + 6];
           R1 = _s8ouc::P64;
           P64[Sp + 8] = _s8ouk::P64;
           if (R1 & 7 != 0) goto u8pLN; else goto c8pLg;
       u8pLN: // global
           call _c8pLe(R1) args: 0, res: 0, upd: 0;
       c8pLg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pKO() //  [R1]
         { info_tbl: [(c8pKO,
                       label: block_c8pKO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pKO: // global
           if (R1 & 7 == 1) goto c8pKX; else goto u8pLJ;
       c8pKX: // global
           _s8ouf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pKU_info;
           R3 = P64[R1 + 7];
           R2 = _s8ouf::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8pLJ: // global
           Sp = Sp + 16;
           call _c8pLB() args: 0, res: 0, upd: 0;
     }
 },
 _c8pKU() //  [R1]
         { info_tbl: [(c8pKU,
                       label: block_c8pKU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pKU: // global
           if (R1 & 7 == 1) goto u8pLK; else goto u8pLL;
       u8pLK: // global
           Sp = Sp + 8;
           call _c8pLB() args: 0, res: 0, upd: 0;
       u8pLL: // global
           Sp = Sp + 8;
           call _c8pLx() args: 0, res: 0, upd: 0;
     }
 },
 _c8pLe() //  [R1]
         { info_tbl: [(c8pLe,
                       label: block_c8pLe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pLe: // global
           if (R1 & 7 == 1) goto u8pLG; else goto c8pLr;
       u8pLG: // global
           Sp = Sp + 16;
           call _c8pLx() args: 0, res: 0, upd: 0;
       c8pLr: // global
           _s8ouk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pLp_info;
           R3 = P64[R1 + 6];
           R2 = _s8ouk::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pLp() //  [R1]
         { info_tbl: [(c8pLp,
                       label: block_c8pLp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pLp: // global
           if (R1 & 7 == 1) goto u8pLH; else goto u8pLI;
       u8pLH: // global
           Sp = Sp + 8;
           call _c8pLB() args: 0, res: 0, upd: 0;
       u8pLI: // global
           Sp = Sp + 8;
           call _c8pLx() args: 0, res: 0, upd: 0;
     }
 },
 _c8pLB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pLB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pLx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pLx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.485900195 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmax_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmax_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8pMQ,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pMQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8pMR; else goto c8pMS;
       c8pMR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pMS: // global
           I64[Sp - 16] = block_c8pMJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pNU; else goto c8pMK;
       u8pNU: // global
           call _c8pMJ(R1) args: 0, res: 0, upd: 0;
       c8pMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pMJ() //  [R1]
         { info_tbl: [(c8pMJ,
                       label: block_c8pMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pMJ: // global
           _s8oup::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pMN; else goto c8pMO;
       c8pMN: // global
           I64[Sp - 8] = block_c8pMV_info;
           _s8our::P64 = R1;
           _s8ous::P64 = P64[R1 + 7];
           R1 = _s8oup::P64;
           P64[Sp] = _s8ous::P64;
           P64[Sp + 8] = _s8our::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pNS; else goto c8pMX;
       u8pNS: // global
           call _c8pMV(R1) args: 0, res: 0, upd: 0;
       c8pMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pMO: // global
           I64[Sp - 8] = block_c8pNl_info;
           _s8our::P64 = R1;
           _s8oux::P64 = P64[R1 + 6];
           R1 = _s8oup::P64;
           P64[Sp] = _s8oux::P64;
           P64[Sp + 8] = _s8our::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pNT; else goto c8pNn;
       u8pNT: // global
           call _c8pNl(R1) args: 0, res: 0, upd: 0;
       c8pNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pMV() //  [R1]
         { info_tbl: [(c8pMV,
                       label: block_c8pMV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pMV: // global
           if (R1 & 7 == 1) goto c8pN4; else goto u8pNP;
       c8pN4: // global
           I64[Sp] = block_c8pN1_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8pNP: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8pNi() args: 0, res: 0, upd: 0;
     }
 },
 _c8pN1() //  [R1]
         { info_tbl: [(c8pN1,
                       label: block_c8pN1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pN1: // global
           if (R1 & 7 == 1) goto u8pNQ; else goto u8pNR;
       u8pNQ: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8pNi() args: 0, res: 0, upd: 0;
       u8pNR: // global
           Sp = Sp + 16;
           call _c8pNE() args: 0, res: 0, upd: 0;
     }
 },
 _c8pNi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pNi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pNl() //  [R1]
         { info_tbl: [(c8pNl,
                       label: block_c8pNl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pNl: // global
           if (R1 & 7 == 1) goto u8pNN; else goto c8pNy;
       u8pNN: // global
           Sp = Sp + 16;
           call _c8pNE() args: 0, res: 0, upd: 0;
       c8pNy: // global
           I64[Sp] = block_c8pNw_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pNw() //  [R1]
         { info_tbl: [(c8pNw,
                       label: block_c8pNw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pNw: // global
           if (R1 & 7 == 1) goto c8pNI; else goto u8pNO;
       c8pNI: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u8pNO: // global
           Sp = Sp + 16;
           call _c8pNE() args: 0, res: 0, upd: 0;
     }
 },
 _c8pNE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pNE: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.502536637 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>=_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>=_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8pOY,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pOY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pOZ; else goto c8pP0;
       c8pOZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pP0: // global
           I64[Sp - 16] = block_c8pOR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pQ3; else goto c8pOS;
       u8pQ3: // global
           call _c8pOR(R1) args: 0, res: 0, upd: 0;
       c8pOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pOR() //  [R1]
         { info_tbl: [(c8pOR,
                       label: block_c8pOR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pOR: // global
           _s8ouD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pOV; else goto c8pOW;
       c8pOV: // global
           I64[Sp] = block_c8pP3_info;
           _s8ouF::P64 = P64[R1 + 7];
           R1 = _s8ouD::P64;
           P64[Sp + 8] = _s8ouF::P64;
           if (R1 & 7 != 0) goto u8pQ1; else goto c8pP5;
       u8pQ1: // global
           call _c8pP3(R1) args: 0, res: 0, upd: 0;
       c8pP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pOW: // global
           I64[Sp] = block_c8pPt_info;
           _s8ouK::P64 = P64[R1 + 6];
           R1 = _s8ouD::P64;
           P64[Sp + 8] = _s8ouK::P64;
           if (R1 & 7 != 0) goto u8pQ2; else goto c8pPv;
       u8pQ2: // global
           call _c8pPt(R1) args: 0, res: 0, upd: 0;
       c8pPv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pP3() //  [R1]
         { info_tbl: [(c8pP3,
                       label: block_c8pP3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pP3: // global
           if (R1 & 7 == 1) goto c8pPc; else goto u8pPY;
       c8pPc: // global
           _s8ouF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pP9_info;
           R3 = P64[R1 + 7];
           R2 = _s8ouF::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8pPY: // global
           Sp = Sp + 16;
           call _c8pPQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8pP9() //  [R1]
         { info_tbl: [(c8pP9,
                       label: block_c8pP9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pP9: // global
           if (R1 & 7 == 1) goto u8pPZ; else goto u8pQ0;
       u8pPZ: // global
           Sp = Sp + 8;
           call _c8pPQ() args: 0, res: 0, upd: 0;
       u8pQ0: // global
           Sp = Sp + 8;
           call _c8pPM() args: 0, res: 0, upd: 0;
     }
 },
 _c8pPt() //  [R1]
         { info_tbl: [(c8pPt,
                       label: block_c8pPt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pPt: // global
           if (R1 & 7 == 1) goto u8pPV; else goto c8pPG;
       u8pPV: // global
           Sp = Sp + 16;
           call _c8pPM() args: 0, res: 0, upd: 0;
       c8pPG: // global
           _s8ouK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8pPE_info;
           R3 = P64[R1 + 6];
           R2 = _s8ouK::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pPE() //  [R1]
         { info_tbl: [(c8pPE,
                       label: block_c8pPE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pPE: // global
           if (R1 & 7 == 1) goto u8pPW; else goto u8pPX;
       u8pPW: // global
           Sp = Sp + 8;
           call _c8pPQ() args: 0, res: 0, upd: 0;
       u8pPX: // global
           Sp = Sp + 8;
           call _c8pPM() args: 0, res: 0, upd: 0;
     }
 },
 _c8pPQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pPQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pPM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pPM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.517108984 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$c>_closure" {
     GHC.IO.Exception.$fOrdArrayException_$c>_closure:
         const GHC.IO.Exception.$fOrdArrayException_$c>_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8pQY,
                       label: GHC.IO.Exception.$fOrdArrayException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pQY: // global
           _s8ouQ::P64 = R3;
           R3 = R2;
           R2 = _s8ouQ::P64;
           call GHC.IO.Exception.$fOrdArrayException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.521614768 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_$cmin_closure" {
     GHC.IO.Exception.$fOrdArrayException_$cmin_closure:
         const GHC.IO.Exception.$fOrdArrayException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdArrayException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8pRg,
                       label: GHC.IO.Exception.$fOrdArrayException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pRg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8pRh; else goto c8pRi;
       c8pRh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdArrayException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pRi: // global
           I64[Sp - 16] = block_c8pR9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pSk; else goto c8pRa;
       u8pSk: // global
           call _c8pR9(R1) args: 0, res: 0, upd: 0;
       c8pRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pR9() //  [R1]
         { info_tbl: [(c8pR9,
                       label: block_c8pR9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pR9: // global
           _s8ouR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8pRd; else goto c8pRe;
       c8pRd: // global
           I64[Sp - 8] = block_c8pRl_info;
           _s8ouT::P64 = R1;
           _s8ouU::P64 = P64[R1 + 7];
           R1 = _s8ouR::P64;
           P64[Sp] = _s8ouU::P64;
           P64[Sp + 8] = _s8ouT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pSi; else goto c8pRn;
       u8pSi: // global
           call _c8pRl(R1) args: 0, res: 0, upd: 0;
       c8pRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pRe: // global
           I64[Sp - 8] = block_c8pRL_info;
           _s8ouT::P64 = R1;
           _s8ouZ::P64 = P64[R1 + 6];
           R1 = _s8ouR::P64;
           P64[Sp] = _s8ouZ::P64;
           P64[Sp + 8] = _s8ouT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pSj; else goto c8pRN;
       u8pSj: // global
           call _c8pRL(R1) args: 0, res: 0, upd: 0;
       c8pRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pRl() //  [R1]
         { info_tbl: [(c8pRl,
                       label: block_c8pRl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pRl: // global
           if (R1 & 7 == 1) goto c8pRu; else goto u8pSg;
       c8pRu: // global
           I64[Sp] = block_c8pRr_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8pSg: // global
           Sp = Sp + 16;
           call _c8pS8() args: 0, res: 0, upd: 0;
     }
 },
 _c8pRr() //  [R1]
         { info_tbl: [(c8pRr,
                       label: block_c8pRr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pRr: // global
           if (R1 & 7 == 1) goto u8pSh; else goto c8pRA;
       u8pSh: // global
           Sp = Sp + 16;
           call _c8pS8() args: 0, res: 0, upd: 0;
       c8pRA: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pRL() //  [R1]
         { info_tbl: [(c8pRL,
                       label: block_c8pRL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pRL: // global
           if (R1 & 7 == 1) goto u8pSd; else goto c8pRY;
       u8pSd: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8pS4() args: 0, res: 0, upd: 0;
       c8pRY: // global
           I64[Sp] = block_c8pRW_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8pRW() //  [R1]
         { info_tbl: [(c8pRW,
                       label: block_c8pRW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pRW: // global
           if (R1 & 7 == 1) goto u8pSe; else goto u8pSf;
       u8pSe: // global
           Sp = Sp + 16;
           call _c8pS8() args: 0, res: 0, upd: 0;
       u8pSf: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8pS4() args: 0, res: 0, upd: 0;
     }
 },
 _c8pS8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pS8: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pS4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pS4: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.537152078 UTC

[section ""data" . GHC.IO.Exception.$fOrdArrayException_closure" {
     GHC.IO.Exception.$fOrdArrayException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqArrayException_closure+1;
         const GHC.IO.Exception.$fOrdArrayException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdArrayException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.540055986 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c==_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c==_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c==_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8pTr,
                       label: GHC.IO.Exception.$fEqAsyncException_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pTr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pTs; else goto c8pTt;
       c8pTs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pTt: // global
           I64[Sp - 16] = block_c8pTi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pUK; else goto c8pTj;
       u8pUK: // global
           call _c8pTi(R1) args: 0, res: 0, upd: 0;
       c8pTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pTi() //  [R1]
         { info_tbl: [(c8pTi,
                       label: block_c8pTi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pTi: // global
           _s8ov5::P64 = P64[Sp + 8];
           _c8pTq::P64 = R1 & 7;
           if (_c8pTq::P64 < 3) goto u8pUw; else goto u8pUx;
       u8pUw: // global
           if (_c8pTq::P64 < 2) goto c8pTm; else goto c8pTn;
       c8pTm: // global
           I64[Sp + 8] = block_c8pTw_info;
           R1 = _s8ov5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pUG; else goto c8pTy;
       u8pUG: // global
           call _c8pTw(R1) args: 0, res: 0, upd: 0;
       c8pTy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pTn: // global
           I64[Sp + 8] = block_c8pTL_info;
           R1 = _s8ov5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pUH; else goto c8pTN;
       u8pUH: // global
           call _c8pTL(R1) args: 0, res: 0, upd: 0;
       c8pTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8pUx: // global
           if (_c8pTq::P64 < 4) goto c8pTo; else goto c8pTp;
       c8pTo: // global
           I64[Sp + 8] = block_c8pU0_info;
           R1 = _s8ov5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pUI; else goto c8pU2;
       u8pUI: // global
           call _c8pU0(R1) args: 0, res: 0, upd: 0;
       c8pU2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pTp: // global
           I64[Sp + 8] = block_c8pUf_info;
           R1 = _s8ov5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pUJ; else goto c8pUh;
       u8pUJ: // global
           call _c8pUf(R1) args: 0, res: 0, upd: 0;
       c8pUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pTw() //  [R1]
         { info_tbl: [(c8pTw,
                       label: block_c8pTw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pTw: // global
           if (R1 & 7 == 1) goto u8pUy; else goto u8pUz;
       u8pUy: // global
           Sp = Sp + 8;
           call _c8pUr() args: 0, res: 0, upd: 0;
       u8pUz: // global
           Sp = Sp + 8;
           call _c8pUn() args: 0, res: 0, upd: 0;
     }
 },
 _c8pTL() //  [R1]
         { info_tbl: [(c8pTL,
                       label: block_c8pTL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pTL: // global
           if (R1 & 7 == 2) goto u8pUA; else goto u8pUB;
       u8pUA: // global
           Sp = Sp + 8;
           call _c8pUr() args: 0, res: 0, upd: 0;
       u8pUB: // global
           Sp = Sp + 8;
           call _c8pUn() args: 0, res: 0, upd: 0;
     }
 },
 _c8pU0() //  [R1]
         { info_tbl: [(c8pU0,
                       label: block_c8pU0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pU0: // global
           if (R1 & 7 == 3) goto u8pUC; else goto u8pUD;
       u8pUC: // global
           Sp = Sp + 8;
           call _c8pUr() args: 0, res: 0, upd: 0;
       u8pUD: // global
           Sp = Sp + 8;
           call _c8pUn() args: 0, res: 0, upd: 0;
     }
 },
 _c8pUf() //  [R1]
         { info_tbl: [(c8pUf,
                       label: block_c8pUf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pUf: // global
           if (R1 & 7 == 4) goto u8pUE; else goto u8pUF;
       u8pUE: // global
           Sp = Sp + 8;
           call _c8pUr() args: 0, res: 0, upd: 0;
       u8pUF: // global
           Sp = Sp + 8;
           call _c8pUn() args: 0, res: 0, upd: 0;
     }
 },
 _c8pUr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pUr: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pUn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pUn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.55541135 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_$c/=_closure" {
     GHC.IO.Exception.$fEqAsyncException_$c/=_closure:
         const GHC.IO.Exception.$fEqAsyncException_$c/=_info;
 },
 GHC.IO.Exception.$fEqAsyncException_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8pVR,
                       label: GHC.IO.Exception.$fEqAsyncException_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8pVS; else goto c8pVT;
       c8pVS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fEqAsyncException_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8pVT: // global
           I64[Sp - 16] = block_c8pVI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pXa; else goto c8pVJ;
       u8pXa: // global
           call _c8pVI(R1) args: 0, res: 0, upd: 0;
       c8pVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pVI() //  [R1]
         { info_tbl: [(c8pVI,
                       label: block_c8pVI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pVI: // global
           _s8ovc::P64 = P64[Sp + 8];
           _c8pVQ::P64 = R1 & 7;
           if (_c8pVQ::P64 < 3) goto u8pWW; else goto u8pWX;
       u8pWW: // global
           if (_c8pVQ::P64 < 2) goto c8pVM; else goto c8pVN;
       c8pVM: // global
           I64[Sp + 8] = block_c8pVW_info;
           R1 = _s8ovc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pX6; else goto c8pVY;
       u8pX6: // global
           call _c8pVW(R1) args: 0, res: 0, upd: 0;
       c8pVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pVN: // global
           I64[Sp + 8] = block_c8pWb_info;
           R1 = _s8ovc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pX7; else goto c8pWd;
       u8pX7: // global
           call _c8pWb(R1) args: 0, res: 0, upd: 0;
       c8pWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8pWX: // global
           if (_c8pVQ::P64 < 4) goto c8pVO; else goto c8pVP;
       c8pVO: // global
           I64[Sp + 8] = block_c8pWq_info;
           R1 = _s8ovc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pX8; else goto c8pWs;
       u8pX8: // global
           call _c8pWq(R1) args: 0, res: 0, upd: 0;
       c8pWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8pVP: // global
           I64[Sp + 8] = block_c8pWF_info;
           R1 = _s8ovc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8pX9; else goto c8pWH;
       u8pX9: // global
           call _c8pWF(R1) args: 0, res: 0, upd: 0;
       c8pWH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pVW() //  [R1]
         { info_tbl: [(c8pVW,
                       label: block_c8pVW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pVW: // global
           if (R1 & 7 == 1) goto u8pWY; else goto u8pWZ;
       u8pWY: // global
           Sp = Sp + 8;
           call _c8pWR() args: 0, res: 0, upd: 0;
       u8pWZ: // global
           Sp = Sp + 8;
           call _c8pWN() args: 0, res: 0, upd: 0;
     }
 },
 _c8pWb() //  [R1]
         { info_tbl: [(c8pWb,
                       label: block_c8pWb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pWb: // global
           if (R1 & 7 == 2) goto u8pX0; else goto u8pX1;
       u8pX0: // global
           Sp = Sp + 8;
           call _c8pWR() args: 0, res: 0, upd: 0;
       u8pX1: // global
           Sp = Sp + 8;
           call _c8pWN() args: 0, res: 0, upd: 0;
     }
 },
 _c8pWq() //  [R1]
         { info_tbl: [(c8pWq,
                       label: block_c8pWq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pWq: // global
           if (R1 & 7 == 3) goto u8pX2; else goto u8pX3;
       u8pX2: // global
           Sp = Sp + 8;
           call _c8pWR() args: 0, res: 0, upd: 0;
       u8pX3: // global
           Sp = Sp + 8;
           call _c8pWN() args: 0, res: 0, upd: 0;
     }
 },
 _c8pWF() //  [R1]
         { info_tbl: [(c8pWF,
                       label: block_c8pWF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pWF: // global
           if (R1 & 7 == 4) goto u8pX4; else goto u8pX5;
       u8pX4: // global
           Sp = Sp + 8;
           call _c8pWR() args: 0, res: 0, upd: 0;
       u8pX5: // global
           Sp = Sp + 8;
           call _c8pWN() args: 0, res: 0, upd: 0;
     }
 },
 _c8pWR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pWR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8pWN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pWN: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.570978159 UTC

[section ""data" . GHC.IO.Exception.$fEqAsyncException_closure" {
     GHC.IO.Exception.$fEqAsyncException_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Exception.$fEqAsyncException_$c==_closure+2;
         const GHC.IO.Exception.$fEqAsyncException_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.573078258 UTC

[section ""data" . GHC.IO.Exception.ioe_filename_closure" {
     GHC.IO.Exception.ioe_filename_closure:
         const GHC.IO.Exception.ioe_filename_info;
 },
 GHC.IO.Exception.ioe_filename_entry() //  [R2]
         { info_tbl: [(c8pYc,
                       label: GHC.IO.Exception.ioe_filename_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pYc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pYd; else goto c8pYe;
       c8pYd: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_filename_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pYe: // global
           I64[Sp - 8] = block_c8pY9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pYi; else goto c8pYa;
       u8pYi: // global
           call _c8pY9(R1) args: 0, res: 0, upd: 0;
       c8pYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pY9() //  [R1]
         { info_tbl: [(c8pY9,
                       label: block_c8pY9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pY9: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.578788613 UTC

[section ""data" . GHC.IO.Exception.ioe_errno_closure" {
     GHC.IO.Exception.ioe_errno_closure:
         const GHC.IO.Exception.ioe_errno_info;
 },
 GHC.IO.Exception.ioe_errno_entry() //  [R2]
         { info_tbl: [(c8pYC,
                       label: GHC.IO.Exception.ioe_errno_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pYC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pYD; else goto c8pYE;
       c8pYD: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_errno_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pYE: // global
           I64[Sp - 8] = block_c8pYz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pYI; else goto c8pYA;
       u8pYI: // global
           call _c8pYz(R1) args: 0, res: 0, upd: 0;
       c8pYA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pYz() //  [R1]
         { info_tbl: [(c8pYz,
                       label: block_c8pYz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pYz: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.584269138 UTC

[section ""data" . GHC.IO.Exception.ioe_description_closure" {
     GHC.IO.Exception.ioe_description_closure:
         const GHC.IO.Exception.ioe_description_info;
 },
 GHC.IO.Exception.ioe_description_entry() //  [R2]
         { info_tbl: [(c8pZ2,
                       label: GHC.IO.Exception.ioe_description_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZ2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pZ3; else goto c8pZ4;
       c8pZ3: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_description_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pZ4: // global
           I64[Sp - 8] = block_c8pYZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pZ8; else goto c8pZ0;
       u8pZ8: // global
           call _c8pYZ(R1) args: 0, res: 0, upd: 0;
       c8pZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pYZ() //  [R1]
         { info_tbl: [(c8pYZ,
                       label: block_c8pYZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pYZ: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.589927086 UTC

[section ""data" . GHC.IO.Exception.ioe_location_closure" {
     GHC.IO.Exception.ioe_location_closure:
         const GHC.IO.Exception.ioe_location_info;
 },
 GHC.IO.Exception.ioe_location_entry() //  [R2]
         { info_tbl: [(c8pZs,
                       label: GHC.IO.Exception.ioe_location_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pZt; else goto c8pZu;
       c8pZt: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_location_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pZu: // global
           I64[Sp - 8] = block_c8pZp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pZy; else goto c8pZq;
       u8pZy: // global
           call _c8pZp(R1) args: 0, res: 0, upd: 0;
       c8pZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pZp() //  [R1]
         { info_tbl: [(c8pZp,
                       label: block_c8pZp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZp: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.595358276 UTC

[section ""data" . GHC.IO.Exception.ioe_type_closure" {
     GHC.IO.Exception.ioe_type_closure:
         const GHC.IO.Exception.ioe_type_info;
 },
 GHC.IO.Exception.ioe_type_entry() //  [R2]
         { info_tbl: [(c8pZS,
                       label: GHC.IO.Exception.ioe_type_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8pZT; else goto c8pZU;
       c8pZT: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_type_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8pZU: // global
           I64[Sp - 8] = block_c8pZP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8pZY; else goto c8pZQ;
       u8pZY: // global
           call _c8pZP(R1) args: 0, res: 0, upd: 0;
       c8pZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pZP() //  [R1]
         { info_tbl: [(c8pZP,
                       label: block_c8pZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZP: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.600694097 UTC

[section ""data" . GHC.IO.Exception.ioe_handle_closure" {
     GHC.IO.Exception.ioe_handle_closure:
         const GHC.IO.Exception.ioe_handle_info;
 },
 GHC.IO.Exception.ioe_handle_entry() //  [R2]
         { info_tbl: [(c8q0i,
                       label: GHC.IO.Exception.ioe_handle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q0i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8q0j; else goto c8q0k;
       c8q0j: // global
           R2 = R2;
           R1 = GHC.IO.Exception.ioe_handle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8q0k: // global
           I64[Sp - 8] = block_c8q0f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8q0o; else goto c8q0g;
       u8q0o: // global
           call _c8q0f(R1) args: 0, res: 0, upd: 0;
       c8q0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q0f() //  [R1]
         { info_tbl: [(c8q0f,
                       label: block_c8q0f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q0f: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.60725163 UTC

[section ""data" . GHC.IO.Exception.userError_closure" {
     GHC.IO.Exception.userError_closure:
         const GHC.IO.Exception.userError_info;
 },
 GHC.IO.Exception.userError_entry() //  [R2]
         { info_tbl: [(c8q0G,
                       label: GHC.IO.Exception.userError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q0G: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8q0K; else goto c8q0J;
       c8q0K: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.IO.Exception.userError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8q0J: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.61127909 UTC

[section ""cstring" . GHC.IO.Exception.unsupportedOperation2_bytes" {
     GHC.IO.Exception.unsupportedOperation2_bytes:
         I8[] [79,112,101,114,97,116,105,111,110,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.613355441 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation1_closure" {
     GHC.IO.Exception.unsupportedOperation1_closure:
         const GHC.IO.Exception.unsupportedOperation1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.unsupportedOperation1_entry() //  [R1]
         { info_tbl: [(c8q17,
                       label: GHC.IO.Exception.unsupportedOperation1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q17: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q18; else goto c8q19;
       c8q18: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8q19: // global
           (_c8q14::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8q14::I64 == 0) goto c8q16; else goto c8q15;
       c8q16: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8q15: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8q14::I64;
           R2 = GHC.IO.Exception.unsupportedOperation2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.617418932 UTC

[section ""data" . GHC.IO.Exception.unsupportedOperation_closure" {
     GHC.IO.Exception.unsupportedOperation_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Exception.unsupportedOperation1_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.619284992 UTC

[section ""data" . GHC.IO.Exception.untangle1_closure" {
     GHC.IO.Exception.untangle1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.621762305 UTC

[section ""data" . GHC.IO.Exception.untangle4_closure" {
     GHC.IO.Exception.untangle4_closure:
         const GHC.IO.Exception.untangle4_info;
 },
 GHC.IO.Exception.untangle4_entry() //  [R2]
         { info_tbl: [(c8q1r,
                       label: GHC.IO.Exception.untangle4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q1r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8q1s; else goto c8q1t;
       c8q1s: // global
           R2 = R2;
           R1 = GHC.IO.Exception.untangle4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8q1t: // global
           I64[Sp - 8] = block_c8q1o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8q1B; else goto c8q1p;
       u8q1B: // global
           call _c8q1o(R1) args: 0, res: 0, upd: 0;
       c8q1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q1o() //  [R1]
         { info_tbl: [(c8q1o,
                       label: block_c8q1o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q1o: // global
           if (I64[R1 + 7] == 124) goto c8q1A; else goto c8q1z;
       c8q1A: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8q1z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.627321133 UTC

[section ""cstring" . GHC.IO.Exception.untangle3_bytes" {
     GHC.IO.Exception.untangle3_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.629319702 UTC

[section ""data" . GHC.IO.Exception.untangle2_closure" {
     GHC.IO.Exception.untangle2_closure:
         const GHC.IO.Exception.untangle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.untangle2_entry() //  [R1]
         { info_tbl: [(c8q1X,
                       label: GHC.IO.Exception.untangle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q1X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q1Y; else goto c8q1Z;
       c8q1Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8q1Z: // global
           (_c8q1U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8q1U::I64 == 0) goto c8q1W; else goto c8q1V;
       c8q1W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8q1V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8q1U::I64;
           R2 = GHC.IO.Exception.untangle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.634631901 UTC

[section ""data" . GHC.IO.Exception.untangle_closure" {
     GHC.IO.Exception.untangle_closure:
         const GHC.IO.Exception.untangle_info;
         const 0;
 },
 sat_s8owi_entry() //  [R1]
         { info_tbl: [(c8q2O,
                       label: sat_s8owi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2O: // global
           R3 = GHC.IO.Exception.untangle2_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8owj_entry() //  [R1]
         { info_tbl: [(c8q2R,
                       label: sat_s8owj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2R: // global
           _s8owj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8q2S; else goto c8q2T;
       c8q2T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8q2V; else goto c8q2U;
       c8q2V: // global
           HpAlloc = 24;
           goto c8q2S;
       c8q2S: // global
           R1 = _s8owj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8q2U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8owj::P64;
           _s8owa::P64 = P64[_s8owj::P64 + 16];
           _s8owh::P64 = P64[_s8owj::P64 + 24];
           I64[Hp - 16] = sat_s8owi_info;
           P64[Hp] = _s8owh::P64;
           R3 = Hp - 16;
           R2 = _s8owa::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8owk_entry() //  [R1]
         { info_tbl: [(c8q2W,
                       label: sat_s8owk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2W: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8q30; else goto c8q2Z;
       c8q30: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8q2Z: // global
           _s8owa::P64 = P64[R1 + 16];
           _s8owh::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8owj_info;
           P64[Hp - 8] = _s8owa::P64;
           P64[Hp] = _s8owh::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Exception.$fExceptionArrayException3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Exception.untangle_entry() //  [R2, R3]
         { info_tbl: [(c8q31,
                       label: GHC.IO.Exception.untangle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q31: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8q32; else goto c8q33;
       c8q32: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.untangle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8q33: // global
           I64[Sp - 16] = block_c8q2c_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.CString.unpackCStringUtf8#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8q2c() //  [R1]
         { info_tbl: [(c8q2c,
                       label: block_c8q2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2c: // global
           I64[Sp] = block_c8q2g_info;
           R3 = R1;
           R2 = GHC.IO.Exception.untangle4_closure+1;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8q2g() //  [R1, R2]
         { info_tbl: [(c8q2g,
                       label: block_c8q2g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2g: // global
           I64[Sp - 8] = block_c8q2k_info;
           _s8owd::P64 = R1;
           R1 = R2;
           P64[Sp] = _s8owd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8q3q; else goto c8q2l;
       u8q3q: // global
           call _c8q2k(R1) args: 0, res: 0, upd: 0;
       c8q2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q2k() //  [R1]
         { info_tbl: [(c8q2k,
                       label: block_c8q2k_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2k: // global
           if (R1 & 7 == 1) goto c8q3c; else goto c8q3e;
       c8q3c: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp] = GHC.Types.[]_closure+1;
           call _c8q2A() args: 0, res: 0, upd: 0;
       c8q3e: // global
           I64[Sp - 8] = block_c8q2q_info;
           _s8own::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8own::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8q3r; else goto c8q2r;
       u8q3r: // global
           call _c8q2q(R1) args: 0, res: 0, upd: 0;
       c8q2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q2q() //  [R1]
         { info_tbl: [(c8q2q,
                       label: block_c8q2q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8q3h; else goto c8q3g;
       c8q3h: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8q3g: // global
           _s8owd::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 124) goto c8q3k; else goto c8q3j;
       c8q3k: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.IO.Exception.untangle1_closure+1;
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 16] = _s8owd::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           goto u8q3u;
       c8q3j: // global
           Hp = Hp - 24;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           P64[Sp + 16] = _s8owd::P64;
           Sp = Sp + 8;
           goto u8q3u;
       u8q3u: // global
           call _c8q2A() args: 0, res: 0, upd: 0;
     }
 },
 _c8q2A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2A: // global
           Hp = Hp + 32;
           _s8owg::P64 = P64[Sp + 8];
           _s8owh::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto c8q38; else goto c8q37;
       c8q38: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c8q2z_info;
           R2 = _s8owh::P64;
           R1 = _s8owg::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8q37: // global
           I64[Hp - 24] = sat_s8owk_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8owh::P64;
           R3 = Hp - 24;
           R2 = _s8owg::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8q2z() //  [R1, R2]
         { info_tbl: [(c8q2z,
                       label: block_c8q2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q2z: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c8q2A() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.657222541 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8q4C,
                       label: GHC.IO.Exception.$fOrdAsyncException_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q4C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q4D; else goto c8q4E;
       c8q4D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8q4E: // global
           I64[Sp - 16] = block_c8q4t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8q6n; else goto c8q4u;
       u8q6n: // global
           call _c8q4t(R1) args: 0, res: 0, upd: 0;
       c8q4u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q4t() //  [R1]
         { info_tbl: [(c8q4t,
                       label: block_c8q4t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q4t: // global
           _s8owt::P64 = P64[Sp + 8];
           _c8q4B::P64 = R1 & 7;
           if (_c8q4B::P64 < 3) goto u8q61; else goto u8q62;
       u8q61: // global
           if (_c8q4B::P64 < 2) goto c8q4x; else goto c8q4y;
       c8q4x: // global
           I64[Sp + 8] = block_c8q4H_info;
           R1 = _s8owt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q6j; else goto c8q4J;
       u8q6j: // global
           call _c8q4H(R1) args: 0, res: 0, upd: 0;
       c8q4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q4y: // global
           I64[Sp + 8] = block_c8q54_info;
           R1 = _s8owt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q6k; else goto c8q56;
       u8q6k: // global
           call _c8q54(R1) args: 0, res: 0, upd: 0;
       c8q56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8q62: // global
           if (_c8q4B::P64 < 4) goto c8q4z; else goto c8q4A;
       c8q4z: // global
           I64[Sp + 8] = block_c8q5r_info;
           R1 = _s8owt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q6l; else goto c8q5t;
       u8q6l: // global
           call _c8q5r(R1) args: 0, res: 0, upd: 0;
       c8q5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q4A: // global
           I64[Sp + 8] = block_c8q5K_info;
           R1 = _s8owt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q6m; else goto c8q5M;
       u8q6m: // global
           call _c8q5K(R1) args: 0, res: 0, upd: 0;
       c8q5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q4H() //  [R1]
         { info_tbl: [(c8q4H,
                       label: block_c8q4H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q4H: // global
           _c8q60::P64 = R1 & 7;
           if (_c8q60::P64 < 2) goto u8q67; else goto u8q63;
       u8q67: // global
           Sp = Sp + 8;
           call _c8q5W() args: 0, res: 0, upd: 0;
       u8q63: // global
           if (_c8q60::P64 != 3) goto u8q69; else goto u8q69;
       u8q69: // global
           Sp = Sp + 8;
           call _c8q5H() args: 0, res: 0, upd: 0;
     }
 },
 _c8q54() //  [R1]
         { info_tbl: [(c8q54,
                       label: block_c8q54_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q54: // global
           _c8q5Z::P64 = R1 & 7;
           if (_c8q5Z::P64 < 3) goto u8q64; else goto u8q65;
       u8q64: // global
           if (_c8q5Z::P64 < 2) goto u8q6b; else goto u8q6a;
       u8q6b: // global
           Sp = Sp + 8;
           call _c8q5S() args: 0, res: 0, upd: 0;
       u8q6a: // global
           Sp = Sp + 8;
           call _c8q5W() args: 0, res: 0, upd: 0;
       u8q65: // global
           if (_c8q5Z::P64 < 4) goto u8q6d; else goto u8q6d;
       u8q6d: // global
           Sp = Sp + 8;
           call _c8q5H() args: 0, res: 0, upd: 0;
     }
 },
 _c8q5r() //  [R1]
         { info_tbl: [(c8q5r,
                       label: block_c8q5r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q5r: // global
           _c8q5Y::P64 = R1 & 7;
           if (_c8q5Y::P64 != 3) goto u8q66; else goto u8q6e;
       u8q66: // global
           if (_c8q5Y::P64 != 4) goto u8q6g; else goto u8q6f;
       u8q6g: // global
           Sp = Sp + 8;
           call _c8q5S() args: 0, res: 0, upd: 0;
       u8q6f: // global
           Sp = Sp + 8;
           call _c8q5H() args: 0, res: 0, upd: 0;
       u8q6e: // global
           Sp = Sp + 8;
           call _c8q5W() args: 0, res: 0, upd: 0;
     }
 },
 _c8q5H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q5H: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8q5K() //  [R1]
         { info_tbl: [(c8q5K,
                       label: block_c8q5K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q5K: // global
           if (R1 & 7 == 4) goto u8q6h; else goto u8q6i;
       u8q6h: // global
           Sp = Sp + 8;
           call _c8q5W() args: 0, res: 0, upd: 0;
       u8q6i: // global
           Sp = Sp + 8;
           call _c8q5S() args: 0, res: 0, upd: 0;
     }
 },
 _c8q5W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q5W: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8q5S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q5S: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.674354573 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8q7x,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q7x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q7y; else goto c8q7z;
       c8q7y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8q7z: // global
           I64[Sp - 16] = block_c8q7o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8q8X; else goto c8q7p;
       u8q8X: // global
           call _c8q7o(R1) args: 0, res: 0, upd: 0;
       c8q7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q7o() //  [R1]
         { info_tbl: [(c8q7o,
                       label: block_c8q7o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q7o: // global
           _s8owA::P64 = P64[Sp + 8];
           _c8q7w::P64 = R1 & 7;
           if (_c8q7w::P64 < 3) goto u8q8H; else goto u8q8I;
       u8q8H: // global
           if (_c8q7w::P64 < 2) goto c8q7s; else goto c8q7t;
       c8q7s: // global
           I64[Sp + 8] = block_c8q7C_info;
           R1 = _s8owA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q8T; else goto c8q7E;
       u8q8T: // global
           call _c8q7C(R1) args: 0, res: 0, upd: 0;
       c8q7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q7t: // global
           I64[Sp + 8] = block_c8q7Z_info;
           R1 = _s8owA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q8U; else goto c8q81;
       u8q8U: // global
           call _c8q7Z(R1) args: 0, res: 0, upd: 0;
       c8q81: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8q8I: // global
           if (_c8q7w::P64 < 4) goto c8q7u; else goto c8q7v;
       c8q7u: // global
           I64[Sp + 8] = block_c8q8i_info;
           R1 = _s8owA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q8V; else goto c8q8k;
       u8q8V: // global
           call _c8q8i(R1) args: 0, res: 0, upd: 0;
       c8q8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q7v: // global
           I64[Sp + 8] = block_c8q8x_info;
           R1 = _s8owA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8q8W; else goto c8q8z;
       u8q8W: // global
           call _c8q8x() args: 0, res: 0, upd: 0;
       c8q8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q7C() //  [R1]
         { info_tbl: [(c8q7C,
                       label: block_c8q7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q7C: // global
           _c8q8G::P64 = R1 & 7;
           if (_c8q8G::P64 < 2) goto u8q8L; else goto u8q8J;
       u8q8L: // global
           Sp = Sp + 8;
           call _c8q8q() args: 0, res: 0, upd: 0;
       u8q8J: // global
           if (_c8q8G::P64 != 3) goto u8q8N; else goto u8q8N;
       u8q8N: // global
           Sp = Sp + 8;
           call _c8q8u() args: 0, res: 0, upd: 0;
     }
 },
 _c8q7Z() //  [R1]
         { info_tbl: [(c8q7Z,
                       label: block_c8q7Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q7Z: // global
           _c8q8F::P64 = R1 & 7;
           if (_c8q8F::P64 != 3) goto u8q8K; else goto u8q8O;
       u8q8K: // global
           if (_c8q8F::P64 != 4) goto u8q8Q; else goto u8q8P;
       u8q8Q: // global
           Sp = Sp + 8;
           call _c8q8q() args: 0, res: 0, upd: 0;
       u8q8P: // global
           Sp = Sp + 8;
           goto u8q91;
       u8q8O: // global
           Sp = Sp + 8;
           goto u8q91;
       u8q91: // global
           call _c8q8u() args: 0, res: 0, upd: 0;
     }
 },
 _c8q8i() //  [R1]
         { info_tbl: [(c8q8i,
                       label: block_c8q8i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q8i: // global
           if (R1 & 7 == 4) goto u8q8R; else goto u8q8S;
       u8q8R: // global
           Sp = Sp + 8;
           call _c8q8u() args: 0, res: 0, upd: 0;
       u8q8S: // global
           Sp = Sp + 8;
           call _c8q8q() args: 0, res: 0, upd: 0;
     }
 },
 _c8q8u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q8u: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8q8q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q8q: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8q8x() //  []
         { info_tbl: [(c8q8x,
                       label: block_c8q8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q8x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.691118391 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c<=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c<=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8qa1,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qa1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qa2; else goto c8qa3;
       c8qa2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qa3: // global
           I64[Sp - 16] = block_c8q9S_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8qbr; else goto c8q9T;
       u8qbr: // global
           call _c8q9S(R1) args: 0, res: 0, upd: 0;
       c8q9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8q9S() //  [R1]
         { info_tbl: [(c8q9S,
                       label: block_c8q9S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8q9S: // global
           _s8owG::P64 = P64[Sp + 8];
           _c8qa0::P64 = R1 & 7;
           if (_c8qa0::P64 < 3) goto u8qbb; else goto u8qbc;
       u8qbb: // global
           if (_c8qa0::P64 < 2) goto c8q9W; else goto c8q9X;
       c8q9W: // global
           I64[Sp + 8] = block_c8qa6_info;
           R1 = _s8owG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qbn; else goto c8qa8;
       u8qbn: // global
           call _c8qa6(R1) args: 0, res: 0, upd: 0;
       c8qa8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q9X: // global
           I64[Sp + 8] = block_c8qat_info;
           R1 = _s8owG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qbo; else goto c8qav;
       u8qbo: // global
           call _c8qat(R1) args: 0, res: 0, upd: 0;
       c8qav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8qbc: // global
           if (_c8qa0::P64 < 4) goto c8q9Y; else goto c8q9Z;
       c8q9Y: // global
           I64[Sp + 8] = block_c8qaM_info;
           R1 = _s8owG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qbp; else goto c8qaO;
       u8qbp: // global
           call _c8qaM(R1) args: 0, res: 0, upd: 0;
       c8qaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8q9Z: // global
           I64[Sp + 8] = block_c8qb1_info;
           R1 = _s8owG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qbq; else goto c8qb3;
       u8qbq: // global
           call _c8qb1() args: 0, res: 0, upd: 0;
       c8qb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qa6() //  [R1]
         { info_tbl: [(c8qa6,
                       label: block_c8qa6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qa6: // global
           _c8qba::P64 = R1 & 7;
           if (_c8qba::P64 < 2) goto u8qbf; else goto u8qbd;
       u8qbf: // global
           Sp = Sp + 8;
           call _c8qaU() args: 0, res: 0, upd: 0;
       u8qbd: // global
           if (_c8qba::P64 != 3) goto u8qbh; else goto u8qbh;
       u8qbh: // global
           Sp = Sp + 8;
           call _c8qaY() args: 0, res: 0, upd: 0;
     }
 },
 _c8qat() //  [R1]
         { info_tbl: [(c8qat,
                       label: block_c8qat_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qat: // global
           _c8qb9::P64 = R1 & 7;
           if (_c8qb9::P64 != 3) goto u8qbe; else goto u8qbi;
       u8qbe: // global
           if (_c8qb9::P64 != 4) goto u8qbk; else goto u8qbj;
       u8qbk: // global
           Sp = Sp + 8;
           call _c8qaU() args: 0, res: 0, upd: 0;
       u8qbj: // global
           Sp = Sp + 8;
           goto u8qbv;
       u8qbi: // global
           Sp = Sp + 8;
           goto u8qbv;
       u8qbv: // global
           call _c8qaY() args: 0, res: 0, upd: 0;
     }
 },
 _c8qaM() //  [R1]
         { info_tbl: [(c8qaM,
                       label: block_c8qaM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qaM: // global
           if (R1 & 7 == 4) goto u8qbl; else goto u8qbm;
       u8qbl: // global
           Sp = Sp + 8;
           call _c8qaY() args: 0, res: 0, upd: 0;
       u8qbm: // global
           Sp = Sp + 8;
           call _c8qaU() args: 0, res: 0, upd: 0;
     }
 },
 _c8qaY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qaY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qaU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qaU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qb1() //  []
         { info_tbl: [(c8qb1,
                       label: block_c8qb1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qb1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.706566684 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmax_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmax_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8qcv,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qcv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qcw; else goto c8qcx;
       c8qcw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qcx: // global
           I64[Sp - 16] = block_c8qcm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8qdu; else goto c8qcn;
       u8qdu: // global
           call _c8qcm(R1) args: 0, res: 0, upd: 0;
       c8qcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qcm() //  [R1]
         { info_tbl: [(c8qcm,
                       label: block_c8qcm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qcm: // global
           _s8owN::P64 = P64[Sp + 8];
           _c8qcu::P64 = R1 & 7;
           if (_c8qcu::P64 < 3) goto u8qdk; else goto u8qdl;
       u8qdk: // global
           if (_c8qcu::P64 < 2) goto c8qcq; else goto c8qcr;
       c8qcq: // global
           R1 = _s8owN::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8qcr: // global
           I64[Sp + 8] = block_c8qcD_info;
           R1 = _s8owN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qdr; else goto c8qcF;
       u8qdr: // global
           call _c8qcD(R1) args: 0, res: 0, upd: 0;
       c8qcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8qdl: // global
           if (_c8qcu::P64 < 4) goto c8qcs; else goto c8qct;
       c8qcs: // global
           I64[Sp + 8] = block_c8qcW_info;
           R1 = _s8owN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qds; else goto c8qcY;
       u8qds: // global
           call _c8qcW(R1) args: 0, res: 0, upd: 0;
       c8qcY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8qct: // global
           I64[Sp + 8] = block_c8qdb_info;
           R1 = _s8owN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qdt; else goto c8qdd;
       u8qdt: // global
           call _c8qdb() args: 0, res: 0, upd: 0;
       c8qdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qcD() //  [R1]
         { info_tbl: [(c8qcD,
                       label: block_c8qcD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qcD: // global
           _c8qdj::P64 = R1 & 7;
           if (_c8qdj::P64 != 3) goto u8qdm; else goto u8qdn;
       u8qdm: // global
           if (_c8qdj::P64 != 4) goto c8qcL; else goto u8qdo;
       c8qcL: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8qdo: // global
           Sp = Sp + 8;
           call _c8qd8() args: 0, res: 0, upd: 0;
       u8qdn: // global
           Sp = Sp + 8;
           call _c8qd4() args: 0, res: 0, upd: 0;
     }
 },
 _c8qcW() //  [R1]
         { info_tbl: [(c8qcW,
                       label: block_c8qcW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qcW: // global
           if (R1 & 7 == 4) goto u8qdp; else goto u8qdq;
       u8qdp: // global
           Sp = Sp + 8;
           call _c8qd8() args: 0, res: 0, upd: 0;
       u8qdq: // global
           Sp = Sp + 8;
           call _c8qd4() args: 0, res: 0, upd: 0;
     }
 },
 _c8qd8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qd8: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qd4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qd4: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qdb() //  []
         { info_tbl: [(c8qdb,
                       label: block_c8qdb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qdb: // global
           R1 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.721160788 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>=_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>=_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8qep,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qeq; else goto c8qer;
       c8qeq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qer: // global
           I64[Sp - 16] = block_c8qeg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8qfP; else goto c8qeh;
       u8qfP: // global
           call _c8qeg(R1) args: 0, res: 0, upd: 0;
       c8qeh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qeg() //  [R1]
         { info_tbl: [(c8qeg,
                       label: block_c8qeg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qeg: // global
           _s8owU::P64 = P64[Sp + 8];
           _c8qeo::P64 = R1 & 7;
           if (_c8qeo::P64 < 3) goto u8qfz; else goto u8qfA;
       u8qfz: // global
           if (_c8qeo::P64 < 2) goto c8qek; else goto c8qel;
       c8qek: // global
           I64[Sp + 8] = block_c8qeu_info;
           R1 = _s8owU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qfL; else goto c8qew;
       u8qfL: // global
           call _c8qeu(R1) args: 0, res: 0, upd: 0;
       c8qew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8qel: // global
           I64[Sp + 8] = block_c8qeR_info;
           R1 = _s8owU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qfM; else goto c8qeT;
       u8qfM: // global
           call _c8qeR(R1) args: 0, res: 0, upd: 0;
       c8qeT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8qfA: // global
           if (_c8qeo::P64 < 4) goto c8qem; else goto c8qen;
       c8qem: // global
           I64[Sp + 8] = block_c8qfa_info;
           R1 = _s8owU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qfN; else goto c8qfc;
       u8qfN: // global
           call _c8qfa(R1) args: 0, res: 0, upd: 0;
       c8qfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8qen: // global
           I64[Sp + 8] = block_c8qfp_info;
           R1 = _s8owU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qfO; else goto c8qfr;
       u8qfO: // global
           call _c8qfp() args: 0, res: 0, upd: 0;
       c8qfr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qeu() //  [R1]
         { info_tbl: [(c8qeu,
                       label: block_c8qeu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qeu: // global
           _c8qfy::P64 = R1 & 7;
           if (_c8qfy::P64 < 2) goto u8qfD; else goto u8qfB;
       u8qfD: // global
           Sp = Sp + 8;
           call _c8qfi() args: 0, res: 0, upd: 0;
       u8qfB: // global
           if (_c8qfy::P64 != 3) goto u8qfF; else goto u8qfF;
       u8qfF: // global
           Sp = Sp + 8;
           call _c8qfm() args: 0, res: 0, upd: 0;
     }
 },
 _c8qeR() //  [R1]
         { info_tbl: [(c8qeR,
                       label: block_c8qeR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qeR: // global
           _c8qfx::P64 = R1 & 7;
           if (_c8qfx::P64 != 3) goto u8qfC; else goto u8qfG;
       u8qfC: // global
           if (_c8qfx::P64 != 4) goto u8qfI; else goto u8qfH;
       u8qfI: // global
           Sp = Sp + 8;
           call _c8qfi() args: 0, res: 0, upd: 0;
       u8qfH: // global
           Sp = Sp + 8;
           goto u8qfT;
       u8qfG: // global
           Sp = Sp + 8;
           goto u8qfT;
       u8qfT: // global
           call _c8qfm() args: 0, res: 0, upd: 0;
     }
 },
 _c8qfa() //  [R1]
         { info_tbl: [(c8qfa,
                       label: block_c8qfa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qfa: // global
           if (R1 & 7 == 4) goto u8qfJ; else goto u8qfK;
       u8qfJ: // global
           Sp = Sp + 8;
           call _c8qfm() args: 0, res: 0, upd: 0;
       u8qfK: // global
           Sp = Sp + 8;
           call _c8qfi() args: 0, res: 0, upd: 0;
     }
 },
 _c8qfm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qfm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qfi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qfi: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qfp() //  []
         { info_tbl: [(c8qfp,
                       label: block_c8qfp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qfp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.736521134 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$c>_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$c>_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$c>_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8qgK,
                       label: GHC.IO.Exception.$fOrdAsyncException_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qgK: // global
           _s8ox1::P64 = R3;
           R3 = R2;
           R2 = _s8ox1::P64;
           call GHC.IO.Exception.$fOrdAsyncException_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.743043879 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_$cmin_closure" {
     GHC.IO.Exception.$fOrdAsyncException_$cmin_closure:
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_info;
 },
 GHC.IO.Exception.$fOrdAsyncException_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8qh4,
                       label: GHC.IO.Exception.$fOrdAsyncException_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qh4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qh5; else goto c8qh6;
       c8qh5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.$fOrdAsyncException_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qh6: // global
           I64[Sp - 16] = block_c8qgV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8qhZ; else goto c8qgW;
       u8qhZ: // global
           call _c8qgV(R1) args: 0, res: 0, upd: 0;
       c8qgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qgV() //  [R1]
         { info_tbl: [(c8qgV,
                       label: block_c8qgV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qgV: // global
           _s8ox2::P64 = P64[Sp + 8];
           _c8qh3::P64 = R1 & 7;
           if (_c8qh3::P64 < 3) goto u8qhT; else goto u8qhU;
       u8qhT: // global
           if (_c8qh3::P64 < 2) goto c8qgZ; else goto c8qh0;
       c8qgZ: // global
           I64[Sp + 8] = block_c8qh9_info;
           R1 = _s8ox2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qhW; else goto c8qhb;
       u8qhW: // global
           call _c8qh9() args: 0, res: 0, upd: 0;
       c8qhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8qh0: // global
           I64[Sp + 8] = block_c8qhi_info;
           R1 = _s8ox2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qhX; else goto c8qhk;
       u8qhX: // global
           call _c8qhi(R1) args: 0, res: 0, upd: 0;
       c8qhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8qhU: // global
           if (_c8qh3::P64 < 4) goto c8qh1; else goto c8qh2;
       c8qh1: // global
           I64[Sp + 8] = block_c8qhB_info;
           R1 = _s8ox2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qhY; else goto c8qhD;
       u8qhY: // global
           call _c8qhB(R1) args: 0, res: 0, upd: 0;
       c8qhD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8qh2: // global
           R1 = _s8ox2::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qh9() //  []
         { info_tbl: [(c8qh9,
                       label: block_c8qh9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qh9: // global
           R1 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qhi() //  [R1]
         { info_tbl: [(c8qhi,
                       label: block_c8qhi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qhi: // global
           _c8qhS::P64 = R1 & 7;
           if (_c8qhS::P64 == 3) goto c8qhy; else goto u8qhV;
       u8qhV: // global
           if (_c8qhS::P64 == 4) goto c8qhy; else goto c8qhq;
       c8qhy: // global
           R1 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qhq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qhB() //  [R1]
         { info_tbl: [(c8qhB,
                       label: block_c8qhB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qhB: // global
           if (R1 & 7 == 4) goto c8qhN; else goto c8qhJ;
       c8qhN: // global
           R1 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qhJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.757299889 UTC

[section ""data" . GHC.IO.Exception.$fOrdAsyncException_closure" {
     GHC.IO.Exception.$fOrdAsyncException_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Exception.$fEqAsyncException_closure+1;
         const GHC.IO.Exception.$fOrdAsyncException_$ccompare_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c<=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$c>=_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmax_closure+2;
         const GHC.IO.Exception.$fOrdAsyncException_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.759437824 UTC

[section ""cstring" . GHC.IO.Exception.$trModule4_bytes" {
     GHC.IO.Exception.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.761986031 UTC

[section ""data" . GHC.IO.Exception.$trModule3_closure" {
     GHC.IO.Exception.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.764083898 UTC

[section ""cstring" . GHC.IO.Exception.$trModule2_bytes" {
     GHC.IO.Exception.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.766248722 UTC

[section ""data" . GHC.IO.Exception.$trModule1_closure" {
     GHC.IO.Exception.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.768480578 UTC

[section ""data" . GHC.IO.Exception.$trModule_closure" {
     GHC.IO.Exception.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Exception.$trModule3_closure+1;
         const GHC.IO.Exception.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.770771032 UTC

[section ""data" . $krep_r8j3f_closure" {
     $krep_r8j3f_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.772871883 UTC

[section ""data" . $krep1_r8j3g_closure" {
     $krep1_r8j3g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.775247275 UTC

[section ""data" . $krep2_r8j3h_closure" {
     $krep2_r8j3h_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.777237076 UTC

[section ""data" . $krep3_r8j3i_closure" {
     $krep3_r8j3i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.779686922 UTC

[section ""data" . $krep4_r8j3j_closure" {
     $krep4_r8j3j_closure:
         const :_con_info;
         const $krep1_r8j3g_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.78173343 UTC

[section ""data" . $krep5_r8j3k_closure" {
     $krep5_r8j3k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.783462943 UTC

[section ""data" . $krep6_r8j3l_closure" {
     $krep6_r8j3l_closure:
         const :_con_info;
         const $krep3_r8j3i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.785280864 UTC

[section ""data" . $krep7_r8j3m_closure" {
     $krep7_r8j3m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8j3l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.786933734 UTC

[section ""data" . $krep8_r8j3n_closure" {
     $krep8_r8j3n_closure:
         const :_con_info;
         const $krep2_r8j3h_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.788667879 UTC

[section ""data" . $krep9_r8j3o_closure" {
     $krep9_r8j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8j3n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.790496672 UTC

[section ""data" . $krep10_r8j3p_closure" {
     $krep10_r8j3p_closure:
         const :_con_info;
         const $krep9_r8j3o_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.792708858 UTC

[section ""data" . $krep11_r8j3q_closure" {
     $krep11_r8j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep10_r8j3p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.794803489 UTC

[section ""data" . $krep12_r8j3r_closure" {
     $krep12_r8j3r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.796544958 UTC

[section ""data" . $krep13_r8j3s_closure" {
     $krep13_r8j3s_closure:
         const :_con_info;
         const $krep12_r8j3r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.798281824 UTC

[section ""data" . $krep14_r8j3t_closure" {
     $krep14_r8j3t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Exception.$tcException_closure;
         const $krep13_r8j3s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.799912563 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.80161349 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.803250845 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
         const GHC.Types.krep$*_closure;
         const 5532209509574600699;
         const 13011219155706606307;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.805088093 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.807256425 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.808956135 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.810646142 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1_closure+1;
         const 6834741829236713234;
         const 5957659317954655195;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.813119971 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_entry() //  [R1]
         { info_tbl: [(c8qjf,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qjf: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qjg; else goto c8qjh;
       c8qjg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qjh: // global
           (_c8qj7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qj7::I64 == 0) goto c8qj9; else goto c8qj8;
       c8qj9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qj8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qj7::I64;
           I64[Sp - 24] = block_c8qja_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 13011219155706606307;
           R2 = 5532209509574600699;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qja() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qja,
                       label: block_c8qja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qja: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qjb() args: 0, res: 0, upd: 0;
     }
 },
 _c8qjb() //  []
         { info_tbl: [(c8qjb,
                       label: block_c8qjb_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qjb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qjk; else goto c8qjj;
       c8qjk: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qjb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qjj: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.8223388 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes:
         I8[] [66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.824020615 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.825792196 UTC

[section ""data" . GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13946898568638194917;
         const 3504019511763148288;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.827683492 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.829747462 UTC

[section ""cstring" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes:
         I8[] [39,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.831459086 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.83314536 UTC

[section ""data" . GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2_closure+1;
         const GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1_closure+1;
         const 13856829326869447687;
         const 12209020643191939554;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.835633806 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_entry() //  [R1]
         { info_tbl: [(c8qk5,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qk5: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qk6; else goto c8qk7;
       c8qk6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qk7: // global
           (_c8qjX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qjX::I64 == 0) goto c8qjZ; else goto c8qjY;
       c8qjZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qjY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qjX::I64;
           I64[Sp - 24] = block_c8qk0_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3504019511763148288;
           R2 = 13946898568638194917;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qk0() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qk0,
                       label: block_c8qk0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qk0: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qk1() args: 0, res: 0, upd: 0;
     }
 },
 _c8qk1() //  []
         { info_tbl: [(c8qk1,
                       label: block_c8qk1_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qk1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qka; else goto c8qk9;
       c8qka: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qk1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qk9: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.84389762 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionDeadlock5_bytes" {
     GHC.IO.Exception.$fExceptionDeadlock5_bytes:
         I8[] [68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.845545355 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock4_closure" {
     GHC.IO.Exception.$fExceptionDeadlock4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.84722066 UTC

[section ""data" . GHC.IO.Exception.$tcDeadlock_closure" {
     GHC.IO.Exception.$tcDeadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
         const GHC.Types.krep$*_closure;
         const 18363794241794644491;
         const 11186984538024031318;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.849062824 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock1_closure" {
     GHC.IO.Exception.$tc'Deadlock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcDeadlock_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.851362846 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Deadlock3_bytes" {
     GHC.IO.Exception.$tc'Deadlock3_bytes:
         I8[] [39,68,101,97,100,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.853074099 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock2_closure" {
     GHC.IO.Exception.$tc'Deadlock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Deadlock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.855038465 UTC

[section ""data" . GHC.IO.Exception.$tc'Deadlock_closure" {
     GHC.IO.Exception.$tc'Deadlock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Deadlock2_closure+1;
         const GHC.IO.Exception.$tc'Deadlock1_closure+1;
         const 8732553870978897242;
         const 16079179228471909431;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.85750827 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock3_closure" {
     GHC.IO.Exception.$fExceptionDeadlock3_closure:
         const GHC.IO.Exception.$fExceptionDeadlock3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock3_entry() //  [R1]
         { info_tbl: [(c8qkV,
                       label: GHC.IO.Exception.$fExceptionDeadlock3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qkV: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qkW; else goto c8qkX;
       c8qkW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qkX: // global
           (_c8qkN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qkN::I64 == 0) goto c8qkP; else goto c8qkO;
       c8qkP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qkO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qkN::I64;
           I64[Sp - 24] = block_c8qkQ_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qkQ() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qkQ,
                       label: block_c8qkQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qkQ: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qkR() args: 0, res: 0, upd: 0;
     }
 },
 _c8qkR() //  []
         { info_tbl: [(c8qkR,
                       label: block_c8qkR_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qkR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8ql0; else goto c8qkZ;
       c8ql0: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qkR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qkZ: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.866441129 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qlA,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qlA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qlE; else goto c8qlF;
       c8qlE: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qlF: // global
           I64[Sp - 8] = block_c8qlx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qm0; else goto c8qly;
       u8qm0: // global
           call _c8qlx(R1) args: 0, res: 0, upd: 0;
       c8qly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qlx() //  [R1]
         { info_tbl: [(c8qlx,
                       label: block_c8qlx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qlx: // global
           I64[Sp - 8] = block_c8qlD_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qlD() //  [R1]
         { info_tbl: [(c8qlD,
                       label: block_c8qlD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qlD: // global
           I64[Sp] = block_c8qlK_info;
           R3 = GHC.IO.Exception.$fExceptionDeadlock3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qlK() //  [R1]
         { info_tbl: [(c8qlK,
                       label: block_c8qlK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qlK: // global
           if (R1 & 7 == 1) goto c8qlR; else goto c8qlV;
       c8qlR: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qlV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qlY; else goto c8qlX;
       c8qlY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qlX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.875561326 UTC

[section ""data" . GHC.IO.Exception.$fExceptionDeadlock_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fShowDeadlock_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionDeadlock_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qmw,
                       label: GHC.IO.Exception.$fExceptionDeadlock_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qmw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qmA; else goto c8qmz;
       c8qmA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qmz: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionDeadlock_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.880261255 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes:
         I8[] [65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.881926861 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.883670179 UTC

[section ""data" . GHC.IO.Exception.$tcAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tcAllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
         const GHC.Types.krep$*_closure;
         const 13160607835047152551;
         const 6828489586181860176;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.886159629 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAllocationLimitExceeded_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.887904307 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes:
         I8[] [39,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.889825438 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.891436324 UTC

[section ""data" . GHC.IO.Exception.$tc'AllocationLimitExceeded_closure" {
     GHC.IO.Exception.$tc'AllocationLimitExceeded_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded2_closure+1;
         const GHC.IO.Exception.$tc'AllocationLimitExceeded1_closure+1;
         const 14911686161474736107;
         const 16735957051754280572;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.893910908 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_entry() //  [R1]
         { info_tbl: [(c8qn1,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qn1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qn2; else goto c8qn3;
       c8qn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qn3: // global
           (_c8qmT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qmT::I64 == 0) goto c8qmV; else goto c8qmU;
       c8qmV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qmU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qmT::I64;
           I64[Sp - 24] = block_c8qmW_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6828489586181860176;
           R2 = 13160607835047152551;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qmW() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qmW,
                       label: block_c8qmW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qmW: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qmX() args: 0, res: 0, upd: 0;
     }
 },
 _c8qmX() //  []
         { info_tbl: [(c8qmX,
                       label: block_c8qmX_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qmX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qn6; else goto c8qn5;
       c8qn6: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qmX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qn5: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.902243491 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionCompactionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionCompactionFailed4_bytes:
         I8[] [67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.903886776 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed3_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.905645851 UTC

[section ""data" . GHC.IO.Exception.$tcCompactionFailed_closure" {
     GHC.IO.Exception.$tcCompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7633933266579528523;
         const 6393060685738357435;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.907473033 UTC

[section ""data" . $krep15_r8j3u_closure" {
     $krep15_r8j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcCompactionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.909183238 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed1_closure" {
     GHC.IO.Exception.$tc'CompactionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep15_r8j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.910980928 UTC

[section ""cstring" . GHC.IO.Exception.$tc'CompactionFailed3_bytes" {
     GHC.IO.Exception.$tc'CompactionFailed3_bytes:
         I8[] [39,67,111,109,112,97,99,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.912606104 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed2_closure" {
     GHC.IO.Exception.$tc'CompactionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'CompactionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.915206641 UTC

[section ""data" . GHC.IO.Exception.$tc'CompactionFailed_closure" {
     GHC.IO.Exception.$tc'CompactionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed2_closure+1;
         const GHC.IO.Exception.$tc'CompactionFailed1_closure+4;
         const 5917738941224226344;
         const 8436844331187314000;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.91773074 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed2_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed2_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed2_entry() //  [R1]
         { info_tbl: [(c8qnS,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qnS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qnT; else goto c8qnU;
       c8qnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qnU: // global
           (_c8qnK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qnK::I64 == 0) goto c8qnM; else goto c8qnL;
       c8qnM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qnL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qnK::I64;
           I64[Sp - 24] = block_c8qnN_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionCompactionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6393060685738357435;
           R2 = 7633933266579528523;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qnN() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qnN,
                       label: block_c8qnN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qnN: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qnO() args: 0, res: 0, upd: 0;
     }
 },
 _c8qnO() //  []
         { info_tbl: [(c8qnO,
                       label: block_c8qnO_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qnO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qnX; else goto c8qnW;
       c8qnX: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qnO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qnW: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.926075828 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAssertionFailed4_bytes" {
     GHC.IO.Exception.$fExceptionAssertionFailed4_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.927806539 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed3_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.929608204 UTC

[section ""data" . GHC.IO.Exception.$tcAssertionFailed_closure" {
     GHC.IO.Exception.$tcAssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
         const GHC.Types.krep$*_closure;
         const 7013231185527166567;
         const 11481669896152761825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.931412581 UTC

[section ""data" . $krep16_r8j3v_closure" {
     $krep16_r8j3v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAssertionFailed_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.933096996 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed1_closure" {
     GHC.IO.Exception.$tc'AssertionFailed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep16_r8j3v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.934880172 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AssertionFailed3_bytes" {
     GHC.IO.Exception.$tc'AssertionFailed3_bytes:
         I8[] [39,65,115,115,101,114,116,105,111,110,70,97,105,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.936518263 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed2_closure" {
     GHC.IO.Exception.$tc'AssertionFailed2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AssertionFailed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.938354448 UTC

[section ""data" . GHC.IO.Exception.$tc'AssertionFailed_closure" {
     GHC.IO.Exception.$tc'AssertionFailed_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed2_closure+1;
         const GHC.IO.Exception.$tc'AssertionFailed1_closure+4;
         const 6421416346863765662;
         const 16131786633010342764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.940748984 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed2_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed2_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed2_entry() //  [R1]
         { info_tbl: [(c8qoJ,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qoJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qoK; else goto c8qoL;
       c8qoK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qoL: // global
           (_c8qoB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qoB::I64 == 0) goto c8qoD; else goto c8qoC;
       c8qoD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qoC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qoB::I64;
           I64[Sp - 24] = block_c8qoE_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAssertionFailed3_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 11481669896152761825;
           R2 = 7013231185527166567;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qoE() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qoE,
                       label: block_c8qoE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qoE: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qoF() args: 0, res: 0, upd: 0;
     }
 },
 _c8qoF() //  []
         { info_tbl: [(c8qoF,
                       label: block_c8qoF_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qoF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qoO; else goto c8qoN;
       c8qoO: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qoF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qoN: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.95025498 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qpo,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qpo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qps; else goto c8qpt;
       c8qps: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qpt: // global
           I64[Sp - 8] = block_c8qpl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qpO; else goto c8qpm;
       u8qpO: // global
           call _c8qpl(R1) args: 0, res: 0, upd: 0;
       c8qpm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qpl() //  [R1]
         { info_tbl: [(c8qpl,
                       label: block_c8qpl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qpl: // global
           I64[Sp - 8] = block_c8qpr_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qpr() //  [R1]
         { info_tbl: [(c8qpr,
                       label: block_c8qpr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qpr: // global
           I64[Sp] = block_c8qpy_info;
           R3 = GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qpy() //  [R1]
         { info_tbl: [(c8qpy,
                       label: block_c8qpy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qpy: // global
           if (R1 & 7 == 1) goto c8qpF; else goto c8qpJ;
       c8qpF: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qpJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qpM; else goto c8qpL;
       c8qpM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qpL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.959455027 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fShowAssertionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAssertionFailed1_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qqk,
                       label: GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qqk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qqo; else goto c8qqn;
       c8qqo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qqn: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAssertionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.964650673 UTC

[section ""cstring" . lvl38_r8j3w_bytes" {
     lvl38_r8j3w_bytes:
         I8[] [65,115,115,101,114,116,105,111,110,32,102,97,105,108,101,100,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:33.968916719 UTC

[section ""data" . GHC.IO.Exception.assertError1_closure" {
     GHC.IO.Exception.assertError1_closure:
         const GHC.IO.Exception.assertError1_info;
         const 0;
 },
 sat_s8oy2_entry() //  [R1]
         { info_tbl: [(c8qr4,
                       label: sat_s8oy2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qr4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8qr5; else goto c8qr6;
       c8qr5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qr6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8qr2_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8qr2() //  [R1]
         { info_tbl: [(c8qr2,
                       label: block_c8qr2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qr2: // global
           R3 = R1;
           R2 = GHC.Exception.errorCallWithCallStackException9_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 n_s8oxX_entry() //  [R1]
         { info_tbl: [(c8qre,
                       label: n_s8oxX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qre: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8qrf; else goto c8qrg;
       c8qrf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qrg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8qqS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8qrn; else goto c8qqT;
       u8qrn: // global
           call _c8qqS(R1) args: 0, res: 0, upd: 0;
       c8qqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8qqS() //  [R1]
         { info_tbl: [(c8qqS,
                       label: block_c8qqS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qqS: // global
           if (R1 & 7 == 1) goto c8qrb; else goto c8qrc;
       c8qrb: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8qrc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qrm; else goto c8qrl;
       c8qrm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8qrl: // global
           I64[Hp - 40] = sat_s8oy2_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException11_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oy7_entry() //  [R1]
         { info_tbl: [(c8qrC,
                       label: sat_s8oy7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qrC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qrD; else goto c8qrE;
       c8qrD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qrE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oyg_entry() //  [R1]
         { info_tbl: [(c8qs1,
                       label: sat_s8oyg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qs1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qs2; else goto c8qs3;
       c8qs2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qs3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.errorCallWithCallStackException1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8oyb_entry() //  [R1, R2]
         { info_tbl: [(c8qs8,
                       label: go_s8oyb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qs8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8qs9; else goto c8qsa;
       c8qs9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qsa: // global
           I64[Sp - 24] = block_c8qrQ_info;
           _s8oyb::P64 = R1;
           _s8oxX::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s8oxX::P64;
           P64[Sp - 8] = _s8oyb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8qsh; else goto c8qrR;
       u8qsh: // global
           call _c8qrQ(R1) args: 0, res: 0, upd: 0;
       c8qrR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qrQ() //  [R1]
         { info_tbl: [(c8qrQ,
                       label: block_c8qrQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qrQ: // global
           if (R1 & 7 == 1) goto c8qs5; else goto c8qs6;
       c8qs5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8qs6: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8qsg; else goto c8qsf;
       c8qsg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qsf: // global
           _s8oye::P64 = P64[R1 + 6];
           _s8oyf::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _s8oyf::P64;
           I64[Hp - 40] = sat_s8oyg_info;
           P64[Hp - 24] = _s8oye::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oyj_entry() //  [R1]
         { info_tbl: [(c8qsk,
                       label: sat_s8oyj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qsk: // global
           _s8oyj::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8qsl; else goto c8qsm;
       c8qsm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qso; else goto c8qsn;
       c8qso: // global
           HpAlloc = 16;
           goto c8qsl;
       c8qsl: // global
           R1 = _s8oyj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qsn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oyj::P64;
           _s8oxX::P64 = P64[_s8oyj::P64 + 16];
           _s8oy3::P64 = P64[_s8oyj::P64 + 24];
           I64[Hp - 8] = go_s8oyb_info;
           P64[Hp] = _s8oxX::P64;
           I64[Sp - 24] = block_c8qsi_info;
           R2 = _s8oy3::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s8oyb_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8qsi() //  [R1]
         { info_tbl: [(c8qsi,
                       label: block_c8qsi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qsi: // global
           R3 = R1;
           R2 = GHC.IO.Exception.untangle2_closure;
           Sp = Sp + 8;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oyl_entry() //  [R1]
         { info_tbl: [(c8qsw,
                       label: sat_s8oyl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qsw: // global
           _s8oyl::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8qsx; else goto c8qsy;
       c8qsy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qsA; else goto c8qsz;
       c8qsA: // global
           HpAlloc = 24;
           goto c8qsx;
       c8qsx: // global
           R1 = _s8oyl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qsz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oyl::P64;
           _s8oxU::P64 = P64[_s8oyl::P64 + 16];
           _s8oxV::P64 = P64[_s8oyl::P64 + 24];
           I64[Hp - 16] = n_s8oxX_info;
           P64[Hp] = _s8oxV::P64;
           I64[Sp - 32] = block_c8qro_info;
           R2 = _s8oxU::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Stack.Types.getCallStack_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8qro() //  [R1]
         { info_tbl: [(c8qro,
                       label: block_c8qro_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qro: // global
           _c8qqO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8qst; else goto c8qsu;
       c8qst: // global
           I64[Sp + 8] = block_c8qrs_info;
           R1 = _c8qqO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8qsQ; else goto c8qrt;
       u8qsQ: // global
           call _c8qrs(R1) args: 0, res: 0, upd: 0;
       c8qrt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       c8qsu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8qsO; else goto c8qsN;
       c8qsO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8qsN: // global
           I64[Hp - 48] = sat_s8oyj_info;
           P64[Hp - 32] = _c8qqO::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Exception.errorCallWithCallStackException6_closure;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _c8qrs() //  [R1]
         { info_tbl: [(c8qrs,
                       label: block_c8qrs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qrs: // global
           if (R1 & 7 == 1) goto c8qsF; else goto c8qsH;
       c8qsF: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8qsH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qsK; else goto c8qsJ;
       c8qsK: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8qsJ: // global
           _s8oy5::P64 = P64[R1 + 6];
           _s8oy6::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_s8oy7_info;
           P64[Hp - 24] = _s8oy6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8oy5::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.OldList.intercalate1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oym_entry() //  [R1]
         { info_tbl: [(c8qsR,
                       label: sat_s8oym_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qsR: // global
           _s8oym::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8qsS; else goto c8qsT;
       c8qsT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8qsV; else goto c8qsU;
       c8qsV: // global
           HpAlloc = 32;
           goto c8qsS;
       c8qsS: // global
           R1 = _s8oym::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qsU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oym::P64;
           _s8oxU::P64 = P64[_s8oym::P64 + 16];
           _s8oxV::P64 = P64[_s8oym::P64 + 24];
           I64[Hp - 24] = sat_s8oyl_info;
           P64[Hp - 8] = _s8oxU::P64;
           P64[Hp] = _s8oxV::P64;
           R3 = Hp - 24;
           R2 = lvl38_r8j3w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oyn_entry() //  [R1]
         { info_tbl: [(c8qsW,
                       label: sat_s8oyn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qsW: // global
           _s8oyn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8qsX; else goto c8qsY;
       c8qsY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8qt0; else goto c8qsZ;
       c8qt0: // global
           HpAlloc = 32;
           goto c8qsX;
       c8qsX: // global
           R1 = _s8oyn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qsZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8oyn::P64;
           _s8oxU::P64 = P64[_s8oyn::P64 + 16];
           _s8oxV::P64 = P64[_s8oyn::P64 + 24];
           I64[Hp - 24] = sat_s8oym_info;
           P64[Hp - 8] = _s8oxU::P64;
           P64[Hp] = _s8oxV::P64;
           R2 = Hp - 24;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.assertError1_entry() //  [R2, R3]
         { info_tbl: [(c8qt1,
                       label: GHC.IO.Exception.assertError1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qt1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8qt5; else goto c8qt4;
       c8qt5: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qt4: // global
           I64[Hp - 24] = sat_s8oyn_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.006449624 UTC

[section ""data" . GHC.IO.Exception.assertError_closure" {
     GHC.IO.Exception.assertError_closure:
         const GHC.IO.Exception.assertError_info;
         const 0;
 },
 GHC.IO.Exception.assertError_entry() //  [R2, R3, R4]
         { info_tbl: [(c8qv9,
                       label: GHC.IO.Exception.assertError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qv9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8qva; else goto c8qvb;
       c8qva: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.assertError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qvb: // global
           I64[Sp - 24] = block_c8qv2_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8qvo; else goto c8qv3;
       u8qvo: // global
           call _c8qv2(R1) args: 0, res: 0, upd: 0;
       c8qv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qv2() //  [R1]
         { info_tbl: [(c8qv2,
                       label: block_c8qv2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qv2: // global
           if (R1 & 7 == 1) goto c8qv6; else goto c8qv7;
       c8qv6: // global
           I64[Sp] = block_c8qve_info;
           R1 = GHC.Stack.CCS.currentCallStack_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c8qv7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qve() //  [R1]
         { info_tbl: [(c8qve,
                       label: block_c8qve_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qve: // global
           I64[Sp + 16] = block_c8qvg_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Exception.assertError1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qvg() //  [R1]
         { info_tbl: [(c8qvg,
                       label: block_c8qvg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qvg: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.014907461 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes:
         I8[] [83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.016519232 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.018184675 UTC

[section ""data" . GHC.IO.Exception.$tcSomeAsyncException_closure" {
     GHC.IO.Exception.$tcSomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
         const GHC.Types.krep$*_closure;
         const 7698277271892269964;
         const 12603180528693821542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.019928303 UTC

[section ""data" . $krep17_r8j3x_closure" {
     $krep17_r8j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcSomeAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.021867799 UTC

[section ""data" . $krep18_r8j3y_closure" {
     $krep18_r8j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r8j3r_closure+2;
         const $krep17_r8j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.023582485 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException1_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r8j3t_closure+1;
         const $krep18_r8j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.025914302 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SomeAsyncException3_bytes" {
     GHC.IO.Exception.$tc'SomeAsyncException3_bytes:
         I8[] [39,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.027492312 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException2_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SomeAsyncException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.029099067 UTC

[section ""data" . GHC.IO.Exception.$tc'SomeAsyncException_closure" {
     GHC.IO.Exception.$tc'SomeAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException2_closure+1;
         const GHC.IO.Exception.$tc'SomeAsyncException1_closure+4;
         const 2590663161510005226;
         const 12089333203895315586;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.031565884 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_entry() //  [R1]
         { info_tbl: [(c8qw3,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qw3: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qw4; else goto c8qw5;
       c8qw4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qw5: // global
           (_c8qvV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qvV::I64 == 0) goto c8qvX; else goto c8qvW;
       c8qvX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qvW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qvV::I64;
           I64[Sp - 24] = block_c8qvY_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded7_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12603180528693821542;
           R2 = 7698277271892269964;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qvY() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qvY,
                       label: block_c8qvY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qvY: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qvZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8qvZ() //  []
         { info_tbl: [(c8qvZ,
                       label: block_c8qvZ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qvZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qw8; else goto c8qw7;
       c8qw8: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qvZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qw7: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.040730771 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qwI,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qwM; else goto c8qwN;
       c8qwM: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qwN: // global
           I64[Sp - 8] = block_c8qwF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qx8; else goto c8qwG;
       u8qx8: // global
           call _c8qwF(R1) args: 0, res: 0, upd: 0;
       c8qwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qwF() //  [R1]
         { info_tbl: [(c8qwF,
                       label: block_c8qwF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qwF: // global
           I64[Sp - 8] = block_c8qwL_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qwL() //  [R1]
         { info_tbl: [(c8qwL,
                       label: block_c8qwL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qwL: // global
           I64[Sp] = block_c8qwS_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qwS() //  [R1]
         { info_tbl: [(c8qwS,
                       label: block_c8qwS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qwS: // global
           if (R1 & 7 == 1) goto c8qwZ; else goto c8qx3;
       c8qwZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qx6; else goto c8qx5;
       c8qx6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qx5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.05072005 UTC

[section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fShowSomeAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qxE,
                       label: GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qxE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qxI; else goto c8qxH;
       c8qxI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qxH: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionSomeAsyncException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.055898756 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionFromException_closure" {
     GHC.IO.Exception.asyncExceptionFromException_closure:
         const GHC.IO.Exception.asyncExceptionFromException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionFromException_entry() //  [R2, R3]
         { info_tbl: [(c8qxY,
                       label: GHC.IO.Exception.asyncExceptionFromException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qxY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8qy2; else goto c8qy3;
       c8qy2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionFromException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qy3: // global
           I64[Sp - 16] = block_c8qxV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8qyR; else goto c8qxW;
       u8qyR: // global
           call _c8qxV(R1) args: 0, res: 0, upd: 0;
       c8qxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qxV() //  [R1]
         { info_tbl: [(c8qxV,
                       label: block_c8qxV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qxV: // global
           I64[Sp - 8] = block_c8qy1_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qy1() //  [R1]
         { info_tbl: [(c8qy1,
                       label: block_c8qy1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qy1: // global
           I64[Sp] = block_c8qy8_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qy8() //  [R1]
         { info_tbl: [(c8qy8,
                       label: block_c8qy8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qy8: // global
           if (R1 & 7 == 1) goto u8qyP; else goto c8qys;
       u8qyP: // global
           Sp = Sp + 24;
           call _c8qyF() args: 0, res: 0, upd: 0;
       c8qys: // global
           _s8oyO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8qyi_info;
           R1 = _s8oyO::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qyi() //  [R1]
         { info_tbl: [(c8qyi,
                       label: block_c8qyi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qyi: // global
           I64[Sp - 8] = block_c8qym_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qym() //  [R1]
         { info_tbl: [(c8qym,
                       label: block_c8qym_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qym: // global
           I64[Sp] = block_c8qyq_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qyq() //  [R1]
         { info_tbl: [(c8qyq,
                       label: block_c8qyq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qyq: // global
           I64[Sp] = block_c8qyy_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qyy() //  [R1]
         { info_tbl: [(c8qyy,
                       label: block_c8qyy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qyy: // global
           if (R1 & 7 == 1) goto u8qyQ; else goto c8qyJ;
       u8qyQ: // global
           Sp = Sp + 24;
           call _c8qyF() args: 0, res: 0, upd: 0;
       c8qyJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qyM; else goto c8qyL;
       c8qyM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qyL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qyF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qyF: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.072849223 UTC

[section ""data" . GHC.IO.Exception.asyncExceptionToException_closure" {
     GHC.IO.Exception.asyncExceptionToException_closure:
         const GHC.IO.Exception.asyncExceptionToException_info;
         const 0;
 },
 GHC.IO.Exception.asyncExceptionToException_entry() //  [R2, R3]
         { info_tbl: [(c8qzL,
                       label: GHC.IO.Exception.asyncExceptionToException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qzL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qzP; else goto c8qzO;
       c8qzP: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.asyncExceptionToException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qzO: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.076836241 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionAsyncException11_bytes" {
     GHC.IO.Exception.$fExceptionAsyncException11_bytes:
         I8[] [65,115,121,110,99,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.078520322 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException10_closure" {
     GHC.IO.Exception.$fExceptionAsyncException10_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.080322365 UTC

[section ""data" . GHC.IO.Exception.$tcAsyncException_closure" {
     GHC.IO.Exception.$tcAsyncException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
         const GHC.Types.krep$*_closure;
         const 3223192752092240512;
         const 6151543105744102738;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.082075454 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow1_closure" {
     GHC.IO.Exception.$tc'HeapOverflow1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcAsyncException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.083729298 UTC

[section ""cstring" . GHC.IO.Exception.$tc'StackOverflow2_bytes" {
     GHC.IO.Exception.$tc'StackOverflow2_bytes:
         I8[] [39,83,116,97,99,107,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.085673822 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow1_closure" {
     GHC.IO.Exception.$tc'StackOverflow1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'StackOverflow2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.08732605 UTC

[section ""data" . GHC.IO.Exception.$tc'StackOverflow_closure" {
     GHC.IO.Exception.$tc'StackOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'StackOverflow1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 7140728310745047686;
         const 9210977118047764825;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.089050799 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HeapOverflow3_bytes" {
     GHC.IO.Exception.$tc'HeapOverflow3_bytes:
         I8[] [39,72,101,97,112,79,118,101,114,102,108,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.091281041 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow2_closure" {
     GHC.IO.Exception.$tc'HeapOverflow2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HeapOverflow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.0929573 UTC

[section ""data" . GHC.IO.Exception.$tc'HeapOverflow_closure" {
     GHC.IO.Exception.$tc'HeapOverflow_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow2_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 6603650813243937168;
         const 2046005135570222520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.094783222 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ThreadKilled2_bytes" {
     GHC.IO.Exception.$tc'ThreadKilled2_bytes:
         I8[] [39,84,104,114,101,97,100,75,105,108,108,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.09643051 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled1_closure" {
     GHC.IO.Exception.$tc'ThreadKilled1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ThreadKilled2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.098475821 UTC

[section ""data" . GHC.IO.Exception.$tc'ThreadKilled_closure" {
     GHC.IO.Exception.$tc'ThreadKilled_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ThreadKilled1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 13600447017231937444;
         const 101896852196063416;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.100259407 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserInterrupt2_bytes" {
     GHC.IO.Exception.$tc'UserInterrupt2_bytes:
         I8[] [39,85,115,101,114,73,110,116,101,114,114,117,112,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.102004937 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt1_closure" {
     GHC.IO.Exception.$tc'UserInterrupt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserInterrupt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.103680515 UTC

[section ""data" . GHC.IO.Exception.$tc'UserInterrupt_closure" {
     GHC.IO.Exception.$tc'UserInterrupt_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserInterrupt1_closure+1;
         const GHC.IO.Exception.$tc'HeapOverflow1_closure+1;
         const 1214873852534998649;
         const 13851718192780849484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.107090592 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException9_closure" {
     GHC.IO.Exception.$fExceptionAsyncException9_closure:
         const GHC.IO.Exception.$fExceptionAsyncException9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException9_entry() //  [R1]
         { info_tbl: [(c8qAm,
                       label: GHC.IO.Exception.$fExceptionAsyncException9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qAm: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qAn; else goto c8qAo;
       c8qAn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qAo: // global
           (_c8qAe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qAe::I64 == 0) goto c8qAg; else goto c8qAf;
       c8qAg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qAf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qAe::I64;
           I64[Sp - 24] = block_c8qAh_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionAsyncException10_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6151543105744102738;
           R2 = 3223192752092240512;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qAh() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qAh,
                       label: block_c8qAh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qAh: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qAi() args: 0, res: 0, upd: 0;
     }
 },
 _c8qAi() //  []
         { info_tbl: [(c8qAi,
                       label: block_c8qAi_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qAi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qAr; else goto c8qAq;
       c8qAr: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qAi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qAq: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.116493109 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionArrayException7_bytes" {
     GHC.IO.Exception.$fExceptionArrayException7_bytes:
         I8[] [65,114,114,97,121,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.118432596 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException6_closure" {
     GHC.IO.Exception.$fExceptionArrayException6_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionArrayException7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.120294823 UTC

[section ""data" . GHC.IO.Exception.$tcArrayException_closure" {
     GHC.IO.Exception.$tcArrayException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException6_closure+1;
         const GHC.Types.krep$*_closure;
         const 14361659568498315305;
         const 6805143727974531880;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.123153683 UTC

[section ""data" . $krep19_r8j3z_closure" {
     $krep19_r8j3z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcArrayException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.125320939 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds1_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep19_r8j3z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.127154422 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes" {
     GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes:
         I8[] [39,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.12908117 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds2_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IndexOutOfBounds3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.13090626 UTC

[section ""data" . GHC.IO.Exception.$tc'IndexOutOfBounds_closure" {
     GHC.IO.Exception.$tc'IndexOutOfBounds_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds2_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 14241149568806879436;
         const 10551655754853710333;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.132953421 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UndefinedElement2_bytes" {
     GHC.IO.Exception.$tc'UndefinedElement2_bytes:
         I8[] [39,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.13482701 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement1_closure" {
     GHC.IO.Exception.$tc'UndefinedElement1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UndefinedElement2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.136682166 UTC

[section ""data" . GHC.IO.Exception.$tc'UndefinedElement_closure" {
     GHC.IO.Exception.$tc'UndefinedElement_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UndefinedElement1_closure+1;
         const GHC.IO.Exception.$tc'IndexOutOfBounds1_closure+4;
         const 9439210122732754255;
         const 8562757414325900819;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.139312853 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException5_closure" {
     GHC.IO.Exception.$fExceptionArrayException5_closure:
         const GHC.IO.Exception.$fExceptionArrayException5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException5_entry() //  [R1]
         { info_tbl: [(c8qBg,
                       label: GHC.IO.Exception.$fExceptionArrayException5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qBh; else goto c8qBi;
       c8qBh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qBi: // global
           (_c8qB8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qB8::I64 == 0) goto c8qBa; else goto c8qB9;
       c8qBa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qB9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qB8::I64;
           I64[Sp - 24] = block_c8qBb_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionArrayException6_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 6805143727974531880;
           R2 = 14361659568498315305;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qBb() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qBb,
                       label: block_c8qBb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBb: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qBc() args: 0, res: 0, upd: 0;
     }
 },
 _c8qBc() //  []
         { info_tbl: [(c8qBc,
                       label: block_c8qBc_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qBl; else goto c8qBk;
       c8qBl: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qBc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qBk: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.148103639 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qBV,
                       label: GHC.IO.Exception.$fExceptionArrayException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qBZ; else goto c8qC0;
       c8qBZ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qC0: // global
           I64[Sp - 8] = block_c8qBS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qCl; else goto c8qBT;
       u8qCl: // global
           call _c8qBS(R1) args: 0, res: 0, upd: 0;
       c8qBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qBS() //  [R1]
         { info_tbl: [(c8qBS,
                       label: block_c8qBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBS: // global
           I64[Sp - 8] = block_c8qBY_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qBY() //  [R1]
         { info_tbl: [(c8qBY,
                       label: block_c8qBY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qBY: // global
           I64[Sp] = block_c8qC5_info;
           R3 = GHC.IO.Exception.$fExceptionArrayException5_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qC5() //  [R1]
         { info_tbl: [(c8qC5,
                       label: block_c8qC5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qC5: // global
           if (R1 & 7 == 1) goto c8qCc; else goto c8qCg;
       c8qCc: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qCg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qCj; else goto c8qCi;
       c8qCj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qCi: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.158418586 UTC

[section ""data" . GHC.IO.Exception.$fExceptionArrayException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fShowArrayException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionArrayException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionArrayException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qCR,
                       label: GHC.IO.Exception.$fExceptionArrayException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qCR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qCV; else goto c8qCU;
       c8qCV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qCU: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionArrayException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.162754789 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionFixIOException5_bytes" {
     GHC.IO.Exception.$fExceptionFixIOException5_bytes:
         I8[] [70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.164464362 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException4_closure" {
     GHC.IO.Exception.$fExceptionFixIOException4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.16616037 UTC

[section ""data" . GHC.IO.Exception.$tcFixIOException_closure" {
     GHC.IO.Exception.$tcFixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
         const GHC.Types.krep$*_closure;
         const 175794591112768165;
         const 12820711924146365796;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.167941628 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException1_closure" {
     GHC.IO.Exception.$tc'FixIOException1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcFixIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.170006773 UTC

[section ""cstring" . GHC.IO.Exception.$tc'FixIOException3_bytes" {
     GHC.IO.Exception.$tc'FixIOException3_bytes:
         I8[] [39,70,105,120,73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.171663867 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException2_closure" {
     GHC.IO.Exception.$tc'FixIOException2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'FixIOException3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.173399554 UTC

[section ""data" . GHC.IO.Exception.$tc'FixIOException_closure" {
     GHC.IO.Exception.$tc'FixIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'FixIOException2_closure+1;
         const GHC.IO.Exception.$tc'FixIOException1_closure+1;
         const 1253631570386628537;
         const 15724415228749653558;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.175892194 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException3_closure" {
     GHC.IO.Exception.$fExceptionFixIOException3_closure:
         const GHC.IO.Exception.$fExceptionFixIOException3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException3_entry() //  [R1]
         { info_tbl: [(c8qDm,
                       label: GHC.IO.Exception.$fExceptionFixIOException3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qDm: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qDn; else goto c8qDo;
       c8qDn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qDo: // global
           (_c8qDe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qDe::I64 == 0) goto c8qDg; else goto c8qDf;
       c8qDg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qDf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qDe::I64;
           I64[Sp - 24] = block_c8qDh_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionFixIOException4_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 12820711924146365796;
           R2 = 175794591112768165;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qDh() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qDh,
                       label: block_c8qDh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qDh: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qDi() args: 0, res: 0, upd: 0;
     }
 },
 _c8qDi() //  []
         { info_tbl: [(c8qDi,
                       label: block_c8qDi_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qDi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qDr; else goto c8qDq;
       c8qDr: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qDi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qDq: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.184353804 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qE1,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qE1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qE5; else goto c8qE6;
       c8qE5: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qE6: // global
           I64[Sp - 8] = block_c8qDY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qEr; else goto c8qDZ;
       u8qEr: // global
           call _c8qDY(R1) args: 0, res: 0, upd: 0;
       c8qDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qDY() //  [R1]
         { info_tbl: [(c8qDY,
                       label: block_c8qDY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qDY: // global
           I64[Sp - 8] = block_c8qE4_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qE4() //  [R1]
         { info_tbl: [(c8qE4,
                       label: block_c8qE4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qE4: // global
           I64[Sp] = block_c8qEb_info;
           R3 = GHC.IO.Exception.$fExceptionFixIOException3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qEb() //  [R1]
         { info_tbl: [(c8qEb,
                       label: block_c8qEb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qEb: // global
           if (R1 & 7 == 1) goto c8qEi; else goto c8qEm;
       c8qEi: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qEm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qEp; else goto c8qEo;
       c8qEp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qEo: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.194769728 UTC

[section ""data" . GHC.IO.Exception.$fExceptionFixIOException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fShowFixIOException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qEX,
                       label: GHC.IO.Exception.$fExceptionFixIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qEX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qF1; else goto c8qF0;
       c8qF1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qF0: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionFixIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.19927176 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionExitCode6_bytes" {
     GHC.IO.Exception.$fExceptionExitCode6_bytes:
         I8[] [69,120,105,116,67,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.200842264 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode5_closure" {
     GHC.IO.Exception.$fExceptionExitCode5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionExitCode6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.202547907 UTC

[section ""data" . GHC.IO.Exception.$tcExitCode_closure" {
     GHC.IO.Exception.$tcExitCode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode5_closure+1;
         const GHC.Types.krep$*_closure;
         const 8177210543059932106;
         const 3694335570555580912;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.20434768 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess1_closure" {
     GHC.IO.Exception.$tc'ExitSuccess1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcExitCode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.206016238 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitSuccess3_bytes" {
     GHC.IO.Exception.$tc'ExitSuccess3_bytes:
         I8[] [39,69,120,105,116,83,117,99,99,101,115,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.207657881 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess2_closure" {
     GHC.IO.Exception.$tc'ExitSuccess2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitSuccess3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.209947934 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitSuccess_closure" {
     GHC.IO.Exception.$tc'ExitSuccess_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess2_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 6011095708053053284;
         const 14896688531190285489;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.211677533 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure1_closure" {
     GHC.IO.Exception.$tc'ExitFailure1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r8j3f_closure+1;
         const GHC.IO.Exception.$tc'ExitSuccess1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.213530957 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ExitFailure3_bytes" {
     GHC.IO.Exception.$tc'ExitFailure3_bytes:
         I8[] [39,69,120,105,116,70,97,105,108,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.215265303 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure2_closure" {
     GHC.IO.Exception.$tc'ExitFailure2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ExitFailure3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.216993154 UTC

[section ""data" . GHC.IO.Exception.$tc'ExitFailure_closure" {
     GHC.IO.Exception.$tc'ExitFailure_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure2_closure+1;
         const GHC.IO.Exception.$tc'ExitFailure1_closure+4;
         const 13149331685465745995;
         const 10453046320643141131;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.220215229 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode4_closure" {
     GHC.IO.Exception.$fExceptionExitCode4_closure:
         const GHC.IO.Exception.$fExceptionExitCode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode4_entry() //  [R1]
         { info_tbl: [(c8qFw,
                       label: GHC.IO.Exception.$fExceptionExitCode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qFw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qFx; else goto c8qFy;
       c8qFx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qFy: // global
           (_c8qFo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qFo::I64 == 0) goto c8qFq; else goto c8qFp;
       c8qFq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qFp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qFo::I64;
           I64[Sp - 24] = block_c8qFr_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionExitCode5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 3694335570555580912;
           R2 = 8177210543059932106;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qFr() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qFr,
                       label: block_c8qFr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qFr: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qFs() args: 0, res: 0, upd: 0;
     }
 },
 _c8qFs() //  []
         { info_tbl: [(c8qFs,
                       label: block_c8qFs_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qFs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qFB; else goto c8qFA;
       c8qFB: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qFs_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qFA: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.229308763 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qGb,
                       label: GHC.IO.Exception.$fExceptionExitCode_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qGf; else goto c8qGg;
       c8qGf: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qGg: // global
           I64[Sp - 8] = block_c8qG8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qGB; else goto c8qG9;
       u8qGB: // global
           call _c8qG8(R1) args: 0, res: 0, upd: 0;
       c8qG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qG8() //  [R1]
         { info_tbl: [(c8qG8,
                       label: block_c8qG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qG8: // global
           I64[Sp - 8] = block_c8qGe_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qGe() //  [R1]
         { info_tbl: [(c8qGe,
                       label: block_c8qGe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qGe: // global
           I64[Sp] = block_c8qGl_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qGl() //  [R1]
         { info_tbl: [(c8qGl,
                       label: block_c8qGl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qGl: // global
           if (R1 & 7 == 1) goto c8qGs; else goto c8qGw;
       c8qGs: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qGw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qGz; else goto c8qGy;
       c8qGz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qGy: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.239070778 UTC

[section ""data" . GHC.IO.Exception.$fExceptionExitCode_closure" {
     GHC.IO.Exception.$fExceptionExitCode_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fShowExitCode_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionExitCode_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qH7,
                       label: GHC.IO.Exception.$fExceptionExitCode_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qH7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qHb; else goto c8qHa;
       c8qHb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qHa: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionExitCode_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.243661175 UTC

[section ""cstring" . GHC.IO.Exception.$tcIOErrorType2_bytes" {
     GHC.IO.Exception.$tcIOErrorType2_bytes:
         I8[] [73,79,69,114,114,111,114,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.245333053 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType1_closure" {
     GHC.IO.Exception.$tcIOErrorType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tcIOErrorType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.246958381 UTC

[section ""data" . GHC.IO.Exception.$tcIOErrorType_closure" {
     GHC.IO.Exception.$tcIOErrorType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tcIOErrorType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13260403802836574836;
         const 9962456285013293537;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.248762981 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists1_closure" {
     GHC.IO.Exception.$tc'AlreadyExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOErrorType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.2504493 UTC

[section ""cstring" . GHC.IO.Exception.$tc'AlreadyExists3_bytes" {
     GHC.IO.Exception.$tc'AlreadyExists3_bytes:
         I8[] [39,65,108,114,101,97,100,121,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.25270455 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists2_closure" {
     GHC.IO.Exception.$tc'AlreadyExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.254773491 UTC

[section ""data" . GHC.IO.Exception.$tc'AlreadyExists_closure" {
     GHC.IO.Exception.$tc'AlreadyExists_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists2_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 13383994725479033447;
         const 16077735236426702934;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.256590266 UTC

[section ""cstring" . GHC.IO.Exception.$tc'NoSuchThing2_bytes" {
     GHC.IO.Exception.$tc'NoSuchThing2_bytes:
         I8[] [39,78,111,83,117,99,104,84,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.258248569 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing1_closure" {
     GHC.IO.Exception.$tc'NoSuchThing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'NoSuchThing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.259928025 UTC

[section ""data" . GHC.IO.Exception.$tc'NoSuchThing_closure" {
     GHC.IO.Exception.$tc'NoSuchThing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'NoSuchThing1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 1065788776620214811;
         const 7708272823769791518;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.261746445 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceBusy2_bytes" {
     GHC.IO.Exception.$tc'ResourceBusy2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,66,117,115,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.263331307 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy1_closure" {
     GHC.IO.Exception.$tc'ResourceBusy1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceBusy2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.265061307 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceBusy_closure" {
     GHC.IO.Exception.$tc'ResourceBusy_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceBusy1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 81041156937828521;
         const 16732677038738772765;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.266856011 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceExhausted2_bytes" {
     GHC.IO.Exception.$tc'ResourceExhausted2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.26854423 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted1_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceExhausted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.270234384 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceExhausted_closure" {
     GHC.IO.Exception.$tc'ResourceExhausted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceExhausted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 661664682644939150;
         const 17978068149744050586;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.272001169 UTC

[section ""cstring" . GHC.IO.Exception.$tc'EOF2_bytes" {
     GHC.IO.Exception.$tc'EOF2_bytes:
         I8[] [39,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.274074785 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF1_closure" {
     GHC.IO.Exception.$tc'EOF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'EOF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.2756925 UTC

[section ""data" . GHC.IO.Exception.$tc'EOF_closure" {
     GHC.IO.Exception.$tc'EOF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'EOF1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 15446447841260182649;
         const 9615135582901540009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.278022049 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IllegalOperation2_bytes" {
     GHC.IO.Exception.$tc'IllegalOperation2_bytes:
         I8[] [39,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.279792076 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation1_closure" {
     GHC.IO.Exception.$tc'IllegalOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IllegalOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.281469901 UTC

[section ""data" . GHC.IO.Exception.$tc'IllegalOperation_closure" {
     GHC.IO.Exception.$tc'IllegalOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IllegalOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2997750042243464947;
         const 13732497530673208550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.283243581 UTC

[section ""cstring" . GHC.IO.Exception.$tc'PermissionDenied2_bytes" {
     GHC.IO.Exception.$tc'PermissionDenied2_bytes:
         I8[] [39,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.284849258 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied1_closure" {
     GHC.IO.Exception.$tc'PermissionDenied1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'PermissionDenied2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.287057565 UTC

[section ""data" . GHC.IO.Exception.$tc'PermissionDenied_closure" {
     GHC.IO.Exception.$tc'PermissionDenied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'PermissionDenied1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17002959889944859215;
         const 11679101384562499698;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.288790169 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UserError2_bytes" {
     GHC.IO.Exception.$tc'UserError2_bytes:
         I8[] [39,85,115,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.290425973 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError1_closure" {
     GHC.IO.Exception.$tc'UserError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UserError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.292111558 UTC

[section ""data" . GHC.IO.Exception.$tc'UserError_closure" {
     GHC.IO.Exception.$tc'UserError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UserError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2110707588451626880;
         const 793010194601470118;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.293838408 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes:
         I8[] [39,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.295438465 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.297126872 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.$tc'UnsatisfiedConstraints_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsatisfiedConstraints1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 7774786765253276509;
         const 11159080782866109022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.299017777 UTC

[section ""cstring" . GHC.IO.Exception.$tc'SystemError2_bytes" {
     GHC.IO.Exception.$tc'SystemError2_bytes:
         I8[] [39,83,121,115,116,101,109,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.300641262 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError1_closure" {
     GHC.IO.Exception.$tc'SystemError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'SystemError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.302733958 UTC

[section ""data" . GHC.IO.Exception.$tc'SystemError_closure" {
     GHC.IO.Exception.$tc'SystemError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'SystemError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14723310935893761222;
         const 8619015840207109406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.305172768 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ProtocolError2_bytes" {
     GHC.IO.Exception.$tc'ProtocolError2_bytes:
         I8[] [39,80,114,111,116,111,99,111,108,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.306886932 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError1_closure" {
     GHC.IO.Exception.$tc'ProtocolError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ProtocolError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.308625139 UTC

[section ""data" . GHC.IO.Exception.$tc'ProtocolError_closure" {
     GHC.IO.Exception.$tc'ProtocolError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ProtocolError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2348878698518162749;
         const 1616623917153004368;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.310392995 UTC

[section ""cstring" . GHC.IO.Exception.$tc'OtherError2_bytes" {
     GHC.IO.Exception.$tc'OtherError2_bytes:
         I8[] [39,79,116,104,101,114,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.312073775 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError1_closure" {
     GHC.IO.Exception.$tc'OtherError1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'OtherError2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.314297869 UTC

[section ""data" . GHC.IO.Exception.$tc'OtherError_closure" {
     GHC.IO.Exception.$tc'OtherError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'OtherError1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 11457353566076247204;
         const 7448318885269020484;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.316088433 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InvalidArgument2_bytes" {
     GHC.IO.Exception.$tc'InvalidArgument2_bytes:
         I8[] [39,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.317752685 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument1_closure" {
     GHC.IO.Exception.$tc'InvalidArgument1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InvalidArgument2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.319412623 UTC

[section ""data" . GHC.IO.Exception.$tc'InvalidArgument_closure" {
     GHC.IO.Exception.$tc'InvalidArgument_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InvalidArgument1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 2877905627043716713;
         const 870624010466166536;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.321208517 UTC

[section ""cstring" . GHC.IO.Exception.$tc'InappropriateType2_bytes" {
     GHC.IO.Exception.$tc'InappropriateType2_bytes:
         I8[] [39,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.322918656 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType1_closure" {
     GHC.IO.Exception.$tc'InappropriateType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'InappropriateType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.32453131 UTC

[section ""data" . GHC.IO.Exception.$tc'InappropriateType_closure" {
     GHC.IO.Exception.$tc'InappropriateType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'InappropriateType1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 12194312324817842633;
         const 15900888301186079347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.326728428 UTC

[section ""cstring" . GHC.IO.Exception.$tc'HardwareFault2_bytes" {
     GHC.IO.Exception.$tc'HardwareFault2_bytes:
         I8[] [39,72,97,114,100,119,97,114,101,70,97,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.328328161 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault1_closure" {
     GHC.IO.Exception.$tc'HardwareFault1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'HardwareFault2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.330681866 UTC

[section ""data" . GHC.IO.Exception.$tc'HardwareFault_closure" {
     GHC.IO.Exception.$tc'HardwareFault_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'HardwareFault1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 56378797976289033;
         const 18431513512258190916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.332420471 UTC

[section ""cstring" . GHC.IO.Exception.$tc'UnsupportedOperation2_bytes" {
     GHC.IO.Exception.$tc'UnsupportedOperation2_bytes:
         I8[] [39,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.334046822 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation1_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'UnsupportedOperation2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.335616361 UTC

[section ""data" . GHC.IO.Exception.$tc'UnsupportedOperation_closure" {
     GHC.IO.Exception.$tc'UnsupportedOperation_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'UnsupportedOperation1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 8512525638220727204;
         const 8859286885870192330;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.337802052 UTC

[section ""cstring" . GHC.IO.Exception.$tc'TimeExpired2_bytes" {
     GHC.IO.Exception.$tc'TimeExpired2_bytes:
         I8[] [39,84,105,109,101,69,120,112,105,114,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.339354108 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired1_closure" {
     GHC.IO.Exception.$tc'TimeExpired1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'TimeExpired2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.341036627 UTC

[section ""data" . GHC.IO.Exception.$tc'TimeExpired_closure" {
     GHC.IO.Exception.$tc'TimeExpired_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'TimeExpired1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 10911629093425571025;
         const 350480745296812363;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.342815283 UTC

[section ""cstring" . GHC.IO.Exception.$tc'ResourceVanished2_bytes" {
     GHC.IO.Exception.$tc'ResourceVanished2_bytes:
         I8[] [39,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.34445106 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished1_closure" {
     GHC.IO.Exception.$tc'ResourceVanished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'ResourceVanished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.3462514 UTC

[section ""data" . GHC.IO.Exception.$tc'ResourceVanished_closure" {
     GHC.IO.Exception.$tc'ResourceVanished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'ResourceVanished1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 14859807110076739958;
         const 15612633629389469803;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.348057489 UTC

[section ""cstring" . GHC.IO.Exception.$tc'Interrupted2_bytes" {
     GHC.IO.Exception.$tc'Interrupted2_bytes:
         I8[] [39,73,110,116,101,114,114,117,112,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.350143949 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted1_closure" {
     GHC.IO.Exception.$tc'Interrupted1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'Interrupted2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.351831299 UTC

[section ""data" . GHC.IO.Exception.$tc'Interrupted_closure" {
     GHC.IO.Exception.$tc'Interrupted_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'Interrupted1_closure+1;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const 17492795632142579451;
         const 15910845476779721305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.353661635 UTC

[section ""cstring" . GHC.IO.Exception.$fExceptionIOException6_bytes" {
     GHC.IO.Exception.$fExceptionIOException6_bytes:
         I8[] [73,79,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.355984255 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException5_closure" {
     GHC.IO.Exception.$fExceptionIOException5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$fExceptionIOException6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.35781451 UTC

[section ""data" . GHC.IO.Exception.$tcIOException_closure" {
     GHC.IO.Exception.$tcIOException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$fExceptionIOException5_closure+1;
         const GHC.Types.krep$*_closure;
         const 10434000377887324342;
         const 16509375198449321302;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.359723662 UTC

[section ""data" . $krep20_r8j3A_closure" {
     $krep20_r8j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Exception.$tcIOException_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.361883373 UTC

[section ""data" . $krep21_r8j3B_closure" {
     $krep21_r8j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8j3q_closure+1;
         const $krep20_r8j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.363575884 UTC

[section ""data" . $krep22_r8j3C_closure" {
     $krep22_r8j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8j3k_closure+1;
         const $krep21_r8j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.365198243 UTC

[section ""data" . $krep23_r8j3D_closure" {
     $krep23_r8j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep22_r8j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.36691444 UTC

[section ""data" . $krep24_r8j3E_closure" {
     $krep24_r8j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r8j3o_closure+1;
         const $krep23_r8j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.36862389 UTC

[section ""data" . $krep25_r8j3F_closure" {
     $krep25_r8j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Exception.$tc'AlreadyExists1_closure+1;
         const $krep24_r8j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.370346335 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError1_closure" {
     GHC.IO.Exception.$tc'IOError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8j3m_closure+1;
         const $krep25_r8j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.372088217 UTC

[section ""cstring" . GHC.IO.Exception.$tc'IOError3_bytes" {
     GHC.IO.Exception.$tc'IOError3_bytes:
         I8[] [39,73,79,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.373881342 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError2_closure" {
     GHC.IO.Exception.$tc'IOError2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Exception.$tc'IOError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.375527812 UTC

[section ""data" . GHC.IO.Exception.$tc'IOError_closure" {
     GHC.IO.Exception.$tc'IOError_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Exception.$trModule_closure+1;
         const GHC.IO.Exception.$tc'IOError2_closure+1;
         const GHC.IO.Exception.$tc'IOError1_closure+4;
         const 16489485703680136625;
         const 16514523686887444952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.377975109 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException4_closure" {
     GHC.IO.Exception.$fExceptionIOException4_closure:
         const GHC.IO.Exception.$fExceptionIOException4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException4_entry() //  [R1]
         { info_tbl: [(c8qIH,
                       label: GHC.IO.Exception.$fExceptionIOException4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qIH: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8qII; else goto c8qIJ;
       c8qII: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qIJ: // global
           (_c8qIz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qIz::I64 == 0) goto c8qIB; else goto c8qIA;
       c8qIB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qIA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qIz::I64;
           I64[Sp - 24] = block_c8qIC_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionIOException5_closure+1;
           R4 = GHC.IO.Exception.$trModule_closure+1;
           R3 = 16509375198449321302;
           R2 = 10434000377887324342;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c8qIC() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c8qIC,
                       label: block_c8qIC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qIC: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c8qID() args: 0, res: 0, upd: 0;
     }
 },
 _c8qID() //  []
         { info_tbl: [(c8qID,
                       label: block_c8qID_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qID: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8qIM; else goto c8qIL;
       c8qIM: // global
           HpAlloc = 48;
           I64[Sp] = block_c8qID_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c8qIL: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.387652848 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qJm,
                       label: GHC.IO.Exception.$fExceptionIOException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qJq; else goto c8qJr;
       c8qJq: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qJr: // global
           I64[Sp - 8] = block_c8qJj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qJM; else goto c8qJk;
       u8qJM: // global
           call _c8qJj(R1) args: 0, res: 0, upd: 0;
       c8qJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qJj() //  [R1]
         { info_tbl: [(c8qJj,
                       label: block_c8qJj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qJj: // global
           I64[Sp - 8] = block_c8qJp_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qJp() //  [R1]
         { info_tbl: [(c8qJp,
                       label: block_c8qJp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qJp: // global
           I64[Sp] = block_c8qJw_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qJw() //  [R1]
         { info_tbl: [(c8qJw,
                       label: block_c8qJw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qJw: // global
           if (R1 & 7 == 1) goto c8qJD; else goto c8qJH;
       c8qJD: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qJH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qJK; else goto c8qJJ;
       c8qJK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qJJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.397380983 UTC

[section ""data" . GHC.IO.Exception.$fExceptionIOException_closure" {
     GHC.IO.Exception.$fExceptionIOException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Exception.$fShowIOException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionIOException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionIOException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionIOException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qKi,
                       label: GHC.IO.Exception.$fExceptionIOException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qKi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qKm; else goto c8qKl;
       c8qKm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qKl: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionIOException_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.402126999 UTC

[section ""data" . GHC.IO.Exception.ioError1_closure" {
     GHC.IO.Exception.ioError1_closure:
         const GHC.IO.Exception.ioError1_info;
         const 0;
 },
 sat_s8ozU_entry() //  [R1]
         { info_tbl: [(c8qKD,
                       label: sat_s8ozU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qKD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qKE; else goto c8qKF;
       c8qKE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qKF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Exception.ioError1_entry() //  [R2]
         { info_tbl: [(c8qKG,
                       label: GHC.IO.Exception.ioError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qKG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qKK; else goto c8qKJ;
       c8qKK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.ioError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qKJ: // global
           I64[Hp - 16] = sat_s8ozU_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.407854082 UTC

[section ""data" . GHC.IO.Exception.ioException_closure" {
     GHC.IO.Exception.ioException_closure:
         const GHC.IO.Exception.ioException_info;
         const 0;
 },
 GHC.IO.Exception.ioException_entry() //  [R2]
         { info_tbl: [(c8qKZ,
                       label: GHC.IO.Exception.ioException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qKZ: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.411063788 UTC

[section ""data" . GHC.IO.Exception.ioError_closure" {
     GHC.IO.Exception.ioError_closure:
         const GHC.IO.Exception.ioError_info;
         const 0;
 },
 GHC.IO.Exception.ioError_entry() //  [R2]
         { info_tbl: [(c8qLa,
                       label: GHC.IO.Exception.ioError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qLa: // global
           R2 = R2;
           call GHC.IO.Exception.ioError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.414206239 UTC

[section ""data" . GHC.IO.Exception.$fxExceptionIOException_closure" {
     GHC.IO.Exception.$fxExceptionIOException_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Exception.$fExceptionIOException_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.416406333 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qLp,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qLp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qLt; else goto c8qLu;
       c8qLt: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qLu: // global
           I64[Sp - 8] = block_c8qLm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qLP; else goto c8qLn;
       u8qLP: // global
           call _c8qLm(R1) args: 0, res: 0, upd: 0;
       c8qLn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qLm() //  [R1]
         { info_tbl: [(c8qLm,
                       label: block_c8qLm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qLm: // global
           I64[Sp - 8] = block_c8qLs_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qLs() //  [R1]
         { info_tbl: [(c8qLs,
                       label: block_c8qLs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qLs: // global
           I64[Sp] = block_c8qLz_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qLz() //  [R1]
         { info_tbl: [(c8qLz,
                       label: block_c8qLz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qLz: // global
           if (R1 & 7 == 1) goto c8qLG; else goto c8qLK;
       c8qLG: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qLK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qLN; else goto c8qLM;
       c8qLN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qLM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.426674409 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qMl,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qMl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qMp; else goto c8qMo;
       c8qMp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qMo: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.43163156 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnMVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnMVar_entry() //  [R1]
         { info_tbl: [(c8qME,
                       label: GHC.IO.Exception.blockedIndefinitelyOnMVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qMF; else goto c8qMG;
       c8qMF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qMG: // global
           (_c8qMB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qMB::I64 == 0) goto c8qMD; else goto c8qMC;
       c8qMD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qMC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qMB::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.435934895 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qMW,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qN0; else goto c8qN1;
       c8qN0: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qN1: // global
           I64[Sp - 8] = block_c8qMT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qNm; else goto c8qMU;
       u8qNm: // global
           call _c8qMT(R1) args: 0, res: 0, upd: 0;
       c8qMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qMT() //  [R1]
         { info_tbl: [(c8qMT,
                       label: block_c8qMT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qMT: // global
           I64[Sp - 8] = block_c8qMZ_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qMZ() //  [R1]
         { info_tbl: [(c8qMZ,
                       label: block_c8qMZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qMZ: // global
           I64[Sp] = block_c8qN6_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qN6() //  [R1]
         { info_tbl: [(c8qN6,
                       label: block_c8qN6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qN6: // global
           if (R1 & 7 == 1) goto c8qNd; else goto c8qNh;
       c8qNd: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qNh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qNk; else goto c8qNj;
       c8qNk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qNj: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.445066759 UTC

[section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qNS,
                       label: GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qNS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qNW; else goto c8qNV;
       c8qNW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qNV: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.450151928 UTC

[section ""data" . GHC.IO.Exception.blockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.blockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.blockedIndefinitelyOnSTM_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.blockedIndefinitelyOnSTM_entry() //  [R1]
         { info_tbl: [(c8qOb,
                       label: GHC.IO.Exception.blockedIndefinitelyOnSTM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qOc; else goto c8qOd;
       c8qOc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qOd: // global
           (_c8qO8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qO8::I64 == 0) goto c8qOa; else goto c8qO9;
       c8qOa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qO9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qO8::I64;
           R2 = GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.454947534 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8qPk_srtd" {
     u8qPk_srtd:
         const S8oB9_srt+688;
         const 35;
         const 25771900929;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qOt,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qOx; else goto c8qOy;
       c8qOx: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qOy: // global
           I64[Sp - 8] = block_c8qOq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qPh; else goto c8qOr;
       u8qPh: // global
           call _c8qOq(R1) args: 0, res: 0, upd: 0;
       c8qOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8qPl_srtd" {
     u8qPl_srtd:
         const S8oB9_srt+688;
         const 35;
         const 17181966337;
 },
 _c8qOq() //  [R1]
         { info_tbl: [(c8qOq,
                       label: block_c8qOq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOq: // global
           I64[Sp - 8] = block_c8qOw_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8qPm_srtd" {
     u8qPm_srtd:
         const S8oB9_srt+688;
         const 35;
         const 17181966337;
 },
 _c8qOw() //  [R1]
         { info_tbl: [(c8qOw,
                       label: block_c8qOw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOw: // global
           I64[Sp] = block_c8qOD_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qOD() //  [R1]
         { info_tbl: [(c8qOD,
                       label: block_c8qOD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOD: // global
           if (R1 & 7 == 1) goto u8qPf; else goto c8qOT;
       u8qPf: // global
           Sp = Sp + 16;
           call _c8qP5() args: 0, res: 0, upd: 0;
       c8qOT: // global
           _s8oAa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8qON_info;
           R1 = _s8oAa::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qON() //  [R1]
         { info_tbl: [(c8qON,
                       label: block_c8qON_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qON: // global
           I64[Sp - 8] = block_c8qOR_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qOR() //  [R1]
         { info_tbl: [(c8qOR,
                       label: block_c8qOR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOR: // global
           I64[Sp] = block_c8qOY_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qOY() //  [R1]
         { info_tbl: [(c8qOY,
                       label: block_c8qOY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qOY: // global
           if (R1 & 7 == 1) goto u8qPg; else goto c8qP9;
       u8qPg: // global
           Sp = Sp + 16;
           call _c8qP5() args: 0, res: 0, upd: 0;
       c8qP9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qPc; else goto c8qPb;
       c8qPc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qPb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qP5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qP5: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.472877079 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qQc,
                       label: GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qQg; else goto c8qQf;
       c8qQg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qQf: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.479505318 UTC

[section ""data" . GHC.IO.Exception.allocationLimitExceeded_closure" {
     GHC.IO.Exception.allocationLimitExceeded_closure:
         const GHC.IO.Exception.allocationLimitExceeded_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.allocationLimitExceeded_entry() //  [R1]
         { info_tbl: [(c8qQu,
                       label: GHC.IO.Exception.allocationLimitExceeded_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qQv; else goto c8qQw;
       c8qQv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qQw: // global
           (_c8qQr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qQr::I64 == 0) goto c8qQt; else goto c8qQs;
       c8qQt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qQs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qQr::I64;
           R2 = GHC.IO.Exception.AllocationLimitExceeded_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.484120449 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qQM,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qQQ; else goto c8qQR;
       c8qQQ: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qQR: // global
           I64[Sp - 8] = block_c8qQJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qRc; else goto c8qQK;
       u8qRc: // global
           call _c8qQJ(R1) args: 0, res: 0, upd: 0;
       c8qQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qQJ() //  [R1]
         { info_tbl: [(c8qQJ,
                       label: block_c8qQJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQJ: // global
           I64[Sp - 8] = block_c8qQP_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qQP() //  [R1]
         { info_tbl: [(c8qQP,
                       label: block_c8qQP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQP: // global
           I64[Sp] = block_c8qQW_info;
           R3 = GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qQW() //  [R1]
         { info_tbl: [(c8qQW,
                       label: block_c8qQW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQW: // global
           if (R1 & 7 == 1) goto c8qR3; else goto c8qR7;
       c8qR3: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8qR7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qRa; else goto c8qR9;
       c8qRa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qR9: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.493940541 UTC

[section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fShowCompactionFailed_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qRI,
                       label: GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qRI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qRM; else goto c8qRL;
       c8qRM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qRL: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionCompactionFailed_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.499517263 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactMutable2_bytes" {
     GHC.IO.Exception.cannotCompactMutable2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,109,117,116,97,98,108,101,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.501792116 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable1_closure" {
     GHC.IO.Exception.cannotCompactMutable1_closure:
         const GHC.IO.Exception.cannotCompactMutable1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable1_entry() //  [R1]
         { info_tbl: [(c8qS2,
                       label: GHC.IO.Exception.cannotCompactMutable1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qS2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qS3; else goto c8qS4;
       c8qS3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qS4: // global
           (_c8qRZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qRZ::I64 == 0) goto c8qS1; else goto c8qS0;
       c8qS1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qS0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qRZ::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.506259261 UTC

[section ""data" . GHC.IO.Exception.cannotCompactMutable_closure" {
     GHC.IO.Exception.cannotCompactMutable_closure:
         const GHC.IO.Exception.cannotCompactMutable_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactMutable_entry() //  [R1]
         { info_tbl: [(c8qSj,
                       label: GHC.IO.Exception.cannotCompactMutable_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qSk; else goto c8qSl;
       c8qSk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qSl: // global
           (_c8qSg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qSg::I64 == 0) goto c8qSi; else goto c8qSh;
       c8qSi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qSh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qSg::I64;
           R2 = GHC.IO.Exception.cannotCompactMutable1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.510274334 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactPinned2_bytes" {
     GHC.IO.Exception.cannotCompactPinned2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,112,105,110,110,101,100,32,111,98,106,101,99,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.512293295 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned1_closure" {
     GHC.IO.Exception.cannotCompactPinned1_closure:
         const GHC.IO.Exception.cannotCompactPinned1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned1_entry() //  [R1]
         { info_tbl: [(c8qSB,
                       label: GHC.IO.Exception.cannotCompactPinned1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qSC; else goto c8qSD;
       c8qSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qSD: // global
           (_c8qSy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qSy::I64 == 0) goto c8qSA; else goto c8qSz;
       c8qSA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qSz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qSy::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.516535318 UTC

[section ""data" . GHC.IO.Exception.cannotCompactPinned_closure" {
     GHC.IO.Exception.cannotCompactPinned_closure:
         const GHC.IO.Exception.cannotCompactPinned_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactPinned_entry() //  [R1]
         { info_tbl: [(c8qSS,
                       label: GHC.IO.Exception.cannotCompactPinned_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qSS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qST; else goto c8qSU;
       c8qST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qSU: // global
           (_c8qSP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qSP::I64 == 0) goto c8qSR; else goto c8qSQ;
       c8qSR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qSQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qSP::I64;
           R2 = GHC.IO.Exception.cannotCompactPinned1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.520823155 UTC

[section ""cstring" . GHC.IO.Exception.cannotCompactFunction2_bytes" {
     GHC.IO.Exception.cannotCompactFunction2_bytes:
         I8[] [99,97,110,110,111,116,32,99,111,109,112,97,99,116,32,102,117,110,99,116,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.522800685 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction1_closure" {
     GHC.IO.Exception.cannotCompactFunction1_closure:
         const GHC.IO.Exception.cannotCompactFunction1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction1_entry() //  [R1]
         { info_tbl: [(c8qTa,
                       label: GHC.IO.Exception.cannotCompactFunction1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qTb; else goto c8qTc;
       c8qTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qTc: // global
           (_c8qT7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qT7::I64 == 0) goto c8qT9; else goto c8qT8;
       c8qT9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qT8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qT7::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.526999902 UTC

[section ""data" . GHC.IO.Exception.cannotCompactFunction_closure" {
     GHC.IO.Exception.cannotCompactFunction_closure:
         const GHC.IO.Exception.cannotCompactFunction_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.cannotCompactFunction_entry() //  [R1]
         { info_tbl: [(c8qTr,
                       label: GHC.IO.Exception.cannotCompactFunction_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qTs; else goto c8qTt;
       c8qTs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qTt: // global
           (_c8qTo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qTo::I64 == 0) goto c8qTq; else goto c8qTp;
       c8qTq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qTp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qTo::I64;
           R2 = GHC.IO.Exception.cannotCompactFunction1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.532544442 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info;
         const 0;
 },
 section ""relreadonly" . u8qUA_srtd" {
     u8qUA_srtd:
         const S8oB9_srt+688;
         const 47;
         const 105553118363649;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry() //  [R2]
         { info_tbl: [(c8qTJ,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qTN; else goto c8qTO;
       c8qTN: // global
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qTO: // global
           I64[Sp - 8] = block_c8qTG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8qUx; else goto c8qTH;
       u8qUx: // global
           call _c8qTG(R1) args: 0, res: 0, upd: 0;
       c8qTH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8qUB_srtd" {
     u8qUB_srtd:
         const S8oB9_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8qTG() //  [R1]
         { info_tbl: [(c8qTG,
                       label: block_c8qTG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTG: // global
           I64[Sp - 8] = block_c8qTM_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u8qUC_srtd" {
     u8qUC_srtd:
         const S8oB9_srt+688;
         const 47;
         const 70368746274817;
 },
 _c8qTM() //  [R1]
         { info_tbl: [(c8qTM,
                       label: block_c8qTM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTM: // global
           I64[Sp] = block_c8qTT_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qTT() //  [R1]
         { info_tbl: [(c8qTT,
                       label: block_c8qTT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qTT: // global
           if (R1 & 7 == 1) goto u8qUv; else goto c8qU9;
       u8qUv: // global
           Sp = Sp + 16;
           call _c8qUl() args: 0, res: 0, upd: 0;
       c8qU9: // global
           _s8oAt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8qU3_info;
           R1 = _s8oAt::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qU3() //  [R1]
         { info_tbl: [(c8qU3,
                       label: block_c8qU3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qU3: // global
           I64[Sp - 8] = block_c8qU7_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qU7() //  [R1]
         { info_tbl: [(c8qU7,
                       label: block_c8qU7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qU7: // global
           I64[Sp] = block_c8qUe_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8qUe() //  [R1]
         { info_tbl: [(c8qUe,
                       label: block_c8qUe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qUe: // global
           if (R1 & 7 == 1) goto u8qUw; else goto c8qUp;
       u8qUw: // global
           Sp = Sp + 16;
           call _c8qUl() args: 0, res: 0, upd: 0;
       c8qUp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qUs; else goto c8qUr;
       c8qUs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qUr: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qUl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qUl: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.550218474 UTC

[section ""data" . GHC.IO.Exception.$fExceptionAsyncException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fShowAsyncException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure+1;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure" {
     GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure:
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info;
         const 0;
 },
 GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry() //  [R2]
         { info_tbl: [(c8qVs,
                       label: GHC.IO.Exception.$fExceptionAsyncException_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qVs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qVw; else goto c8qVv;
       c8qVw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qVv: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = GHC.IO.Exception.$fExceptionAsyncException_closure+1;
           P64[Hp] = R2;
           R2 = Hp - 15;
           call GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.555212645 UTC

[section ""data" . GHC.IO.Exception.heapOverflow_closure" {
     GHC.IO.Exception.heapOverflow_closure:
         const GHC.IO.Exception.heapOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.heapOverflow_entry() //  [R1]
         { info_tbl: [(c8qVK,
                       label: GHC.IO.Exception.heapOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qVL; else goto c8qVM;
       c8qVL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qVM: // global
           (_c8qVH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qVH::I64 == 0) goto c8qVJ; else goto c8qVI;
       c8qVJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qVI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qVH::I64;
           R2 = GHC.IO.Exception.HeapOverflow_closure+2;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.559528916 UTC

[section ""data" . GHC.IO.Exception.stackOverflow_closure" {
     GHC.IO.Exception.stackOverflow_closure:
         const GHC.IO.Exception.stackOverflow_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Exception.stackOverflow_entry() //  [R1]
         { info_tbl: [(c8qW1,
                       label: GHC.IO.Exception.stackOverflow_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qW1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qW2; else goto c8qW3;
       c8qW2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8qW3: // global
           (_c8qVY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8qVY::I64 == 0) goto c8qW0; else goto c8qVZ;
       c8qW0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8qVZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8qVY::I64;
           R2 = GHC.IO.Exception.StackOverflow_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.564207939 UTC

[section ""data" . GHC.IO.Exception.IOError_closure" {
     GHC.IO.Exception.IOError_closure:
         const GHC.IO.Exception.IOError_info;
 },
 GHC.IO.Exception.IOError_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8qWh,
                       label: GHC.IO.Exception.IOError_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qWh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8qWl; else goto c8qWk;
       c8qWl: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.IOError_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8qWk: // global
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.568837162 UTC

[section ""data" . GHC.IO.Exception.AlreadyExists_closure" {
     GHC.IO.Exception.AlreadyExists_closure:
         const GHC.IO.Exception.AlreadyExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.570644309 UTC

[section ""data" . GHC.IO.Exception.NoSuchThing_closure" {
     GHC.IO.Exception.NoSuchThing_closure:
         const GHC.IO.Exception.NoSuchThing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.572307701 UTC

[section ""data" . GHC.IO.Exception.ResourceBusy_closure" {
     GHC.IO.Exception.ResourceBusy_closure:
         const GHC.IO.Exception.ResourceBusy_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.574044851 UTC

[section ""data" . GHC.IO.Exception.ResourceExhausted_closure" {
     GHC.IO.Exception.ResourceExhausted_closure:
         const GHC.IO.Exception.ResourceExhausted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.575778666 UTC

[section ""data" . GHC.IO.Exception.EOF_closure" {
     GHC.IO.Exception.EOF_closure:
         const GHC.IO.Exception.EOF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.577384094 UTC

[section ""data" . GHC.IO.Exception.IllegalOperation_closure" {
     GHC.IO.Exception.IllegalOperation_closure:
         const GHC.IO.Exception.IllegalOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.579098375 UTC

[section ""data" . GHC.IO.Exception.PermissionDenied_closure" {
     GHC.IO.Exception.PermissionDenied_closure:
         const GHC.IO.Exception.PermissionDenied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.580796268 UTC

[section ""data" . GHC.IO.Exception.UserError_closure" {
     GHC.IO.Exception.UserError_closure:
         const GHC.IO.Exception.UserError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.58285137 UTC

[section ""data" . GHC.IO.Exception.UnsatisfiedConstraints_closure" {
     GHC.IO.Exception.UnsatisfiedConstraints_closure:
         const GHC.IO.Exception.UnsatisfiedConstraints_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.584522839 UTC

[section ""data" . GHC.IO.Exception.SystemError_closure" {
     GHC.IO.Exception.SystemError_closure:
         const GHC.IO.Exception.SystemError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.586319587 UTC

[section ""data" . GHC.IO.Exception.ProtocolError_closure" {
     GHC.IO.Exception.ProtocolError_closure:
         const GHC.IO.Exception.ProtocolError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.588015042 UTC

[section ""data" . GHC.IO.Exception.OtherError_closure" {
     GHC.IO.Exception.OtherError_closure:
         const GHC.IO.Exception.OtherError_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.589710436 UTC

[section ""data" . GHC.IO.Exception.InvalidArgument_closure" {
     GHC.IO.Exception.InvalidArgument_closure:
         const GHC.IO.Exception.InvalidArgument_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.591396912 UTC

[section ""data" . GHC.IO.Exception.InappropriateType_closure" {
     GHC.IO.Exception.InappropriateType_closure:
         const GHC.IO.Exception.InappropriateType_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.593725394 UTC

[section ""data" . GHC.IO.Exception.HardwareFault_closure" {
     GHC.IO.Exception.HardwareFault_closure:
         const GHC.IO.Exception.HardwareFault_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.596157423 UTC

[section ""data" . GHC.IO.Exception.UnsupportedOperation_closure" {
     GHC.IO.Exception.UnsupportedOperation_closure:
         const GHC.IO.Exception.UnsupportedOperation_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.598445706 UTC

[section ""data" . GHC.IO.Exception.TimeExpired_closure" {
     GHC.IO.Exception.TimeExpired_closure:
         const GHC.IO.Exception.TimeExpired_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.600649128 UTC

[section ""data" . GHC.IO.Exception.ResourceVanished_closure" {
     GHC.IO.Exception.ResourceVanished_closure:
         const GHC.IO.Exception.ResourceVanished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.603735968 UTC

[section ""data" . GHC.IO.Exception.Interrupted_closure" {
     GHC.IO.Exception.Interrupted_closure:
         const GHC.IO.Exception.Interrupted_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.605908453 UTC

[section ""data" . GHC.IO.Exception.ExitSuccess_closure" {
     GHC.IO.Exception.ExitSuccess_closure:
         const GHC.IO.Exception.ExitSuccess_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.608040205 UTC

[section ""data" . GHC.IO.Exception.ExitFailure_closure" {
     GHC.IO.Exception.ExitFailure_closure:
         const GHC.IO.Exception.ExitFailure_info;
 },
 GHC.IO.Exception.ExitFailure_entry() //  [R2]
         { info_tbl: [(c8qWS,
                       label: GHC.IO.Exception.ExitFailure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qWS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qWW; else goto c8qWV;
       c8qWW: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.ExitFailure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qWV: // global
           I64[Hp - 8] = GHC.IO.Exception.ExitFailure_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.611864129 UTC

[section ""data" . GHC.IO.Exception.FixIOException_closure" {
     GHC.IO.Exception.FixIOException_closure:
         const GHC.IO.Exception.FixIOException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.613921539 UTC

[section ""data" . GHC.IO.Exception.IndexOutOfBounds_closure" {
     GHC.IO.Exception.IndexOutOfBounds_closure:
         const GHC.IO.Exception.IndexOutOfBounds_info;
 },
 GHC.IO.Exception.IndexOutOfBounds_entry() //  [R2]
         { info_tbl: [(c8qX9,
                       label: GHC.IO.Exception.IndexOutOfBounds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qX9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qXd; else goto c8qXc;
       c8qXd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.IndexOutOfBounds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qXc: // global
           I64[Hp - 8] = GHC.IO.Exception.IndexOutOfBounds_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.618532448 UTC

[section ""data" . GHC.IO.Exception.UndefinedElement_closure" {
     GHC.IO.Exception.UndefinedElement_closure:
         const GHC.IO.Exception.UndefinedElement_info;
 },
 GHC.IO.Exception.UndefinedElement_entry() //  [R2]
         { info_tbl: [(c8qXp,
                       label: GHC.IO.Exception.UndefinedElement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qXp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qXt; else goto c8qXs;
       c8qXt: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Exception.UndefinedElement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8qXs: // global
           I64[Hp - 8] = GHC.IO.Exception.UndefinedElement_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.622228342 UTC

[section ""data" . GHC.IO.Exception.StackOverflow_closure" {
     GHC.IO.Exception.StackOverflow_closure:
         const GHC.IO.Exception.StackOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.623909665 UTC

[section ""data" . GHC.IO.Exception.HeapOverflow_closure" {
     GHC.IO.Exception.HeapOverflow_closure:
         const GHC.IO.Exception.HeapOverflow_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.626125931 UTC

[section ""data" . GHC.IO.Exception.ThreadKilled_closure" {
     GHC.IO.Exception.ThreadKilled_closure:
         const GHC.IO.Exception.ThreadKilled_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.628016846 UTC

[section ""data" . GHC.IO.Exception.UserInterrupt_closure" {
     GHC.IO.Exception.UserInterrupt_closure:
         const GHC.IO.Exception.UserInterrupt_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.630039718 UTC

[section ""data" . GHC.IO.Exception.SomeAsyncException_closure" {
     GHC.IO.Exception.SomeAsyncException_closure:
         const GHC.IO.Exception.SomeAsyncException_info;
 },
 GHC.IO.Exception.SomeAsyncException_entry() //  [R2, R3]
         { info_tbl: [(c8qXJ,
                       label: GHC.IO.Exception.SomeAsyncException_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qXJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8qXN; else goto c8qXM;
       c8qXN: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Exception.SomeAsyncException_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qXM: // global
           I64[Hp - 16] = GHC.IO.Exception.SomeAsyncException_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.634394576 UTC

[section ""data" . GHC.IO.Exception.AllocationLimitExceeded_closure" {
     GHC.IO.Exception.AllocationLimitExceeded_closure:
         const GHC.IO.Exception.AllocationLimitExceeded_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.63615042 UTC

[section ""data" . GHC.IO.Exception.Deadlock_closure" {
     GHC.IO.Exception.Deadlock_closure:
         const GHC.IO.Exception.Deadlock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.63783006 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.639485933 UTC

[section ""data" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.641343759 UTC

[GHC.IO.Exception.IOError_con_entry() //  [R1]
         { info_tbl: [(c8qXY,
                       label: GHC.IO.Exception.IOError_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,79,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qXY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.644797088 UTC

[section ""relreadonly" . GHC.IO.Exception.IOErrorType_closure_tbl" {
     GHC.IO.Exception.IOErrorType_closure_tbl:
         const GHC.IO.Exception.AlreadyExists_closure+1;
         const GHC.IO.Exception.NoSuchThing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.IO.Exception.PermissionDenied_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.IO.Exception.UnsatisfiedConstraints_closure+1;
         const GHC.IO.Exception.SystemError_closure+1;
         const GHC.IO.Exception.ProtocolError_closure+1;
         const GHC.IO.Exception.OtherError_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Exception.HardwareFault_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.IO.Exception.TimeExpired_closure+1;
         const GHC.IO.Exception.ResourceVanished_closure+1;
         const GHC.IO.Exception.Interrupted_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.646998289 UTC

[GHC.IO.Exception.AlreadyExists_con_entry() //  [R1]
         { info_tbl: [(c8qY6,
                       label: GHC.IO.Exception.AlreadyExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,114,101,97,100,121,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qY6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.650795135 UTC

[GHC.IO.Exception.NoSuchThing_con_entry() //  [R1]
         { info_tbl: [(c8qYd,
                       label: GHC.IO.Exception.NoSuchThing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,78,111,83,117,99,104,84,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.654097318 UTC

[GHC.IO.Exception.ResourceBusy_con_entry() //  [R1]
         { info_tbl: [(c8qYk,
                       label: GHC.IO.Exception.ResourceBusy_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,66,117,115,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.658178746 UTC

[GHC.IO.Exception.ResourceExhausted_con_entry() //  [R1]
         { info_tbl: [(c8qYr,
                       label: GHC.IO.Exception.ResourceExhausted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,69,120,104,97,117,115,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYr: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.661458484 UTC

[GHC.IO.Exception.EOF_con_entry() //  [R1]
         { info_tbl: [(c8qYy,
                       label: GHC.IO.Exception.EOF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,79,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.664710832 UTC

[GHC.IO.Exception.IllegalOperation_con_entry() //  [R1]
         { info_tbl: [(c8qYF,
                       label: GHC.IO.Exception.IllegalOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,108,108,101,103,97,108,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.667848724 UTC

[GHC.IO.Exception.PermissionDenied_con_entry() //  [R1]
         { info_tbl: [(c8qYM,
                       label: GHC.IO.Exception.PermissionDenied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 6
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,101,114,109,105,115,115,105,111,110,68,101,110,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYM: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.67160784 UTC

[GHC.IO.Exception.UserError_con_entry() //  [R1]
         { info_tbl: [(c8qYT,
                       label: GHC.IO.Exception.UserError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 7
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qYT: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.674940163 UTC

[GHC.IO.Exception.UnsatisfiedConstraints_con_entry() //  [R1]
         { info_tbl: [(c8qZ0,
                       label: GHC.IO.Exception.UnsatisfiedConstraints_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 8
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,97,116,105,115,102,105,101,100,67,111,110,115,116,114,97,105,110,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZ0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.678120853 UTC

[GHC.IO.Exception.SystemError_con_entry() //  [R1]
         { info_tbl: [(c8qZ7,
                       label: GHC.IO.Exception.SystemError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 9
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,121,115,116,101,109,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZ7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.681433942 UTC

[GHC.IO.Exception.ProtocolError_con_entry() //  [R1]
         { info_tbl: [(c8qZe,
                       label: GHC.IO.Exception.ProtocolError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 10
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,80,114,111,116,111,99,111,108,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZe: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.685227287 UTC

[GHC.IO.Exception.OtherError_con_entry() //  [R1]
         { info_tbl: [(c8qZl,
                       label: GHC.IO.Exception.OtherError_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 11
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,79,116,104,101,114,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.689173216 UTC

[GHC.IO.Exception.InvalidArgument_con_entry() //  [R1]
         { info_tbl: [(c8qZs,
                       label: GHC.IO.Exception.InvalidArgument_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 12
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,118,97,108,105,100,65,114,103,117,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZs: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.692481763 UTC

[GHC.IO.Exception.InappropriateType_con_entry() //  [R1]
         { info_tbl: [(c8qZz,
                       label: GHC.IO.Exception.InappropriateType_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 13
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,97,112,112,114,111,112,114,105,97,116,101,84,121,112,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.695842262 UTC

[GHC.IO.Exception.HardwareFault_con_entry() //  [R1]
         { info_tbl: [(c8qZG,
                       label: GHC.IO.Exception.HardwareFault_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 14
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,97,114,100,119,97,114,101,70,97,117,108,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.69911146 UTC

[GHC.IO.Exception.UnsupportedOperation_con_entry() //  [R1]
         { info_tbl: [(c8qZN,
                       label: GHC.IO.Exception.UnsupportedOperation_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 15
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,115,117,112,112,111,114,116,101,100,79,112,101,114,97,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.702750009 UTC

[GHC.IO.Exception.TimeExpired_con_entry() //  [R1]
         { info_tbl: [(c8qZU,
                       label: GHC.IO.Exception.TimeExpired_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 16
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,105,109,101,69,120,112,105,114,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qZU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.706111388 UTC

[GHC.IO.Exception.ResourceVanished_con_entry() //  [R1]
         { info_tbl: [(c8r01,
                       label: GHC.IO.Exception.ResourceVanished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 17
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,82,101,115,111,117,114,99,101,86,97,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r01: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.709303312 UTC

[GHC.IO.Exception.Interrupted_con_entry() //  [R1]
         { info_tbl: [(c8r08,
                       label: GHC.IO.Exception.Interrupted_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 18
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,116,101,114,114,117,112,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r08: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.712516653 UTC

[GHC.IO.Exception.ExitSuccess_con_entry() //  [R1]
         { info_tbl: [(c8r0f,
                       label: GHC.IO.Exception.ExitSuccess_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,83,117,99,99,101,115,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.716965237 UTC

[GHC.IO.Exception.ExitFailure_con_entry() //  [R1]
         { info_tbl: [(c8r0m,
                       label: GHC.IO.Exception.ExitFailure_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,69,120,105,116,70,97,105,108,117,114,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0m: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.720241373 UTC

[section ""relreadonly" . GHC.IO.Exception.FixIOException_closure_tbl" {
     GHC.IO.Exception.FixIOException_closure_tbl:
         const GHC.IO.Exception.FixIOException_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.722505321 UTC

[GHC.IO.Exception.FixIOException_con_entry() //  [R1]
         { info_tbl: [(c8r0u,
                       label: GHC.IO.Exception.FixIOException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,70,105,120,73,79,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0u: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.726007264 UTC

[GHC.IO.Exception.IndexOutOfBounds_con_entry() //  [R1]
         { info_tbl: [(c8r0B,
                       label: GHC.IO.Exception.IndexOutOfBounds_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,73,110,100,101,120,79,117,116,79,102,66,111,117,110,100,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0B: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.729157108 UTC

[GHC.IO.Exception.UndefinedElement_con_entry() //  [R1]
         { info_tbl: [(c8r0I,
                       label: GHC.IO.Exception.UndefinedElement_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,110,100,101,102,105,110,101,100,69,108,101,109,101,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0I: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.732354269 UTC

[section ""relreadonly" . GHC.IO.Exception.AsyncException_closure_tbl" {
     GHC.IO.Exception.AsyncException_closure_tbl:
         const GHC.IO.Exception.StackOverflow_closure+1;
         const GHC.IO.Exception.HeapOverflow_closure+2;
         const GHC.IO.Exception.ThreadKilled_closure+3;
         const GHC.IO.Exception.UserInterrupt_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.734212681 UTC

[GHC.IO.Exception.StackOverflow_con_entry() //  [R1]
         { info_tbl: [(c8r0Q,
                       label: GHC.IO.Exception.StackOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,116,97,99,107,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0Q: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.737849877 UTC

[GHC.IO.Exception.HeapOverflow_con_entry() //  [R1]
         { info_tbl: [(c8r0X,
                       label: GHC.IO.Exception.HeapOverflow_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,72,101,97,112,79,118,101,114,102,108,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r0X: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.740895956 UTC

[GHC.IO.Exception.ThreadKilled_con_entry() //  [R1]
         { info_tbl: [(c8r14,
                       label: GHC.IO.Exception.ThreadKilled_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,84,104,114,101,97,100,75,105,108,108,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r14: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.744797945 UTC

[GHC.IO.Exception.UserInterrupt_con_entry() //  [R1]
         { info_tbl: [(c8r1b,
                       label: GHC.IO.Exception.UserInterrupt_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,85,115,101,114,73,110,116,101,114,114,117,112,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1b: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.748156155 UTC

[GHC.IO.Exception.SomeAsyncException_con_entry() //  [R1]
         { info_tbl: [(c8r1i,
                       label: GHC.IO.Exception.SomeAsyncException_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,83,111,109,101,65,115,121,110,99,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1i: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.75187534 UTC

[section ""relreadonly" . GHC.IO.Exception.AllocationLimitExceeded_closure_tbl" {
     GHC.IO.Exception.AllocationLimitExceeded_closure_tbl:
         const GHC.IO.Exception.AllocationLimitExceeded_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.753632775 UTC

[GHC.IO.Exception.AllocationLimitExceeded_con_entry() //  [R1]
         { info_tbl: [(c8r1q,
                       label: GHC.IO.Exception.AllocationLimitExceeded_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,65,108,108,111,99,97,116,105,111,110,76,105,109,105,116,69,120,99,101,101,100,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1q: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.756775325 UTC

[section ""relreadonly" . GHC.IO.Exception.Deadlock_closure_tbl" {
     GHC.IO.Exception.Deadlock_closure_tbl:
         const GHC.IO.Exception.Deadlock_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.758512507 UTC

[GHC.IO.Exception.Deadlock_con_entry() //  [R1]
         { info_tbl: [(c8r1y,
                       label: GHC.IO.Exception.Deadlock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,68,101,97,100,108,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1y: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.762014878 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnSTM_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.763785127 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_entry() //  [R1]
         { info_tbl: [(c8r1G,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1G: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.767054799 UTC

[section ""relreadonly" . GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl" {
     GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure_tbl:
         const GHC.IO.Exception.BlockedIndefinitelyOnMVar_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.768787812 UTC

[GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_entry() //  [R1]
         { info_tbl: [(c8r1O,
                       label: GHC.IO.Exception.BlockedIndefinitelyOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,69,120,99,101,112,116,105,111,110,46,66,108,111,99,107,101,100,73,110,100,101,102,105,110,105,116,101,108,121,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8r1O: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:34.772426655 UTC

[section ""relreadonly" . S8oB9_srt" {
     S8oB9_srt:
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow_closure;
         const GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1_closure;
         const GHC.IO.Exception.$fExceptionDeadlock1_closure;
         const GHC.IO.Exception.$fShowDeadlock_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cshow_closure;
         const GHC.IO.Exception.$fShowDeadlock1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow_closure;
         const GHC.IO.Exception.$fShowAllocationLimitExceeded1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException3_closure;
         const GHC.IO.Exception.$fExceptionAsyncException5_closure;
         const GHC.IO.Exception.$fExceptionAsyncException7_closure;
         const GHC.IO.Exception.$w$cshowsPrec1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cshow_closure;
         const GHC.IO.Exception.$fExceptionFixIOException1_closure;
         const GHC.IO.Exception.$fShowFixIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowFixIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec4_closure;
         const lvl1_r8j2E_closure;
         const lvl3_r8j2G_closure;
         const lvl5_r8j2I_closure;
         const lvl7_r8j2K_closure;
         const lvl9_r8j2M_closure;
         const lvl11_r8j2O_closure;
         const lvl13_r8j2Q_closure;
         const lvl15_r8j2S_closure;
         const lvl17_r8j2U_closure;
         const lvl19_r8j2W_closure;
         const lvl21_r8j2Y_closure;
         const lvl23_r8j30_closure;
         const lvl25_r8j32_closure;
         const lvl27_r8j34_closure;
         const lvl29_r8j36_closure;
         const lvl31_r8j38_closure;
         const lvl33_r8j3a_closure;
         const lvl35_r8j3c_closure;
         const lvl37_r8j3e_closure;
         const GHC.IO.Exception.$fExceptionIOException1_closure;
         const GHC.IO.Exception.$w$cshowsPrec3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cshow_closure;
         const GHC.IO.Exception.$fShowIOException1_closure;
         const GHC.IO.Exception.$fExceptionExitCode2_closure;
         const GHC.IO.Exception.$fShowExitCode_$cshowsPrec_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cshow_closure;
         const GHC.IO.Exception.$fShowExitCode1_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Exception.$fReadExitCode2_closure;
         const GHC.IO.Exception.$fReadExitCode_lexeme1_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Exception.$fReadExitCode1_closure;
         const GHC.IO.Exception.$fReadExitCode_$creadListPrec_closure;
         const GHC.IO.Exception.$fReadExitCode6_closure;
         const GHC.IO.Exception.untangle2_closure;
         const GHC.IO.Exception.untangle_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionDeadlock3_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_closure;
         const GHC.IO.Exception.$fExceptionDeadlock_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed2_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_closure;
         const GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException_closure;
         const GHC.Exception.errorCallWithCallStackException9_closure;
         const GHC.Exception.errorCallWithCallStackException11_closure;
         const GHC.Exception.errorCallWithCallStackException6_closure;
         const GHC.IO.Exception.assertError1_closure;
         const GHC.IO.Exception.assertError_closure;
         const GHC.Stack.CCS.currentCallStack_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.asyncExceptionFromException_closure;
         const GHC.IO.Exception.asyncExceptionToException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionArrayException5_closure;
         const GHC.IO.Exception.$fExceptionArrayException_closure;
         const GHC.IO.Exception.$fExceptionArrayException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException3_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const GHC.IO.Exception.$fExceptionExitCode_closure;
         const GHC.IO.Exception.$fExceptionExitCode_$ctoException_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Exception.ioError1_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded3_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed2_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_closure;
         const GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException_closure;
         const GHC.IO.Exception.cannotCompactMutable1_closure;
         const GHC.IO.Exception.cannotCompactPinned1_closure;
         const GHC.IO.Exception.cannotCompactFunction1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
 }]

