
==================== Output Cmm ====================
2018-03-16 16:05:55.164116382 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:55.165369106 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { info_tbl: [(caXdQ,
                       label: GHC.IO.FD.$WFD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXdQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXdZ; else goto caXe0;
       caXdZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXe0: // global
           I64[Sp - 16] = block_caXdN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXe6; else goto caXdO;
       uaXe6: // global
           call _caXdN(R1) args: 0, res: 0, upd: 0;
       caXdO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXdN() //  [R1]
         { info_tbl: [(caXdN,
                       label: block_caXdN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXdN: // global
           I64[Sp] = block_caXdT_info;
           _saWVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saWVh::I64;
           if (R1 & 7 != 0) goto uaXe5; else goto caXdU;
       uaXe5: // global
           call _caXdT(R1) args: 0, res: 0, upd: 0;
       caXdU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXdT() //  [R1]
         { info_tbl: [(caXdT,
                       label: block_caXdT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXdT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXe4; else goto caXe3;
       caXe4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXe3: // global
           _saWVj::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saWVj::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.167445162 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { info_tbl: [(caXeg,
                       label: GHC.IO.FD.$fBufferedIOFD5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXeg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caXeh; else goto uaXeQ;
       caXeh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uaXeQ: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _caXe8() args: 0, res: 0, upd: 0;
     }
 },
 _caXe8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXe8: // global
           I64[Sp - 8] = block_caXeb_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXeb() //  [R1]
         { info_tbl: [(caXeb,
                       label: block_caXeb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXeb: // global
           I64[Sp - 8] = block_caXed_info;
           _saWVq::P64 = R1;
           R1 = R1;
           P64[Sp] = _saWVq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXeS; else goto caXee;
       uaXeS: // global
           call _caXed(R1) args: 0, res: 0, upd: 0;
       caXee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXed() //  [R1]
         { info_tbl: [(caXed,
                       label: block_caXed_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXed: // global
           if (I64[R1 + 7] == (-1)) goto caXeO; else goto caXep;
       caXeO: // global
           _saWVk::P64 = P64[Sp + 16];
           _saWVl::P64 = P64[Sp + 24];
           _saWVm::P64 = P64[Sp + 32];
           (_saWVx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _saWVy::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWVx::I64));
           if (_saWVy::I64 != 4) goto uaXeP; else goto caXeE;
       uaXeP: // global
           if (_saWVy::I64 != 11) goto caXey; else goto caXeK;
       caXey: // global
           R2 = _saWVk::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       caXeK: // global
           R1 = _saWVm::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       caXeE: // global
           P64[Sp + 16] = _saWVk::P64;
           P64[Sp + 24] = _saWVl::P64;
           P64[Sp + 32] = _saWVm::P64;
           Sp = Sp + 16;
           call _caXe8() args: 0, res: 0, upd: 0;
       caXep: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.169780684 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.170512195 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { info_tbl: [(caXf2,
                       label: lvl1_raWUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXf2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXf3; else goto caXf4;
       caXf3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXf4: // global
           (_caXeZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXeZ::I64 == 0) goto caXf1; else goto caXf0;
       caXf1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXf0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXeZ::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.171402093 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.172121894 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { info_tbl: [(caXfb,
                       label: GHC.IO.FD.$fBufferedIOFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXfc; else goto caXfd;
       caXfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXfd: // global
           (_caXf8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXf8::I64 == 0) goto caXfa; else goto caXf9;
       caXfa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXf9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXf8::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.172982647 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.173676082 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { info_tbl: [(caXfi,
                       label: GHC.IO.FD.$fBufferedIOFD3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfi: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.174375984 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.174910758 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.177011656 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfm: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWVZ_entry() //  [R1]
         { info_tbl: [(caXfB,
                       label: sat_saWVZ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXfL; else goto caXfK;
       caXfL: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXfK: // global
           (_saWVX::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWVX::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWWc_entry() //  [R1]
         { info_tbl: [(caXg5,
                       label: sat_saWWc_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXg5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXge; else goto caXgf;
       caXge: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXgf: // global
           I64[Sp - 8] = block_caXgb_info;
           Sp = Sp - 8;
           _caXg8::I64 = I64[R1 + 7];
           _caXg9::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caXga::I64 = I64[R1 + 31];
           _uaXgl::P64 = CurrentTSO;
           I64[I64[_uaXgl::P64 + 24] + 16] = Sp;
           _uaXgm::I64 = CurrentNursery;
           P64[_uaXgm::I64 + 8] = Hp + 8;
           I64[_uaXgl::P64 + 104] = I64[_uaXgl::P64 + 104] - ((Hp + 8) - I64[_uaXgm::I64]);
           (_uaXgj::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWWa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caXg8::I64, _caXg9::I64, _caXga::I64);
           (_uaXgk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXgj::I64);
           BaseReg = _uaXgk::I64;
           _uaXgn::P64 = CurrentTSO;
           _uaXgo::P64 = I64[_uaXgn::P64 + 24];
           Sp = I64[_uaXgo::P64 + 16];
           SpLim = _uaXgo::P64 + 192;
           HpAlloc = 0;
           _uaXgp::I64 = CurrentNursery;
           _uaXgq::I64 = I64[_uaXgp::I64 + 8];
           Hp = _uaXgq::I64 - 8;
           _uaXgr::I64 = I64[_uaXgp::I64];
           HpLim = _uaXgr::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXgp::I64 + 48]) << 12) - 1);
           I64[_uaXgn::P64 + 104] = I64[_uaXgn::P64 + 104] + (_uaXgq::I64 - _uaXgr::I64);
           R1 = _saWWa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXgb() //  [R1]
         { info_tbl: [(caXgb,
                       label: block_caXgb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXgb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXgi; else goto caXgh;
       caXgi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXgh: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(caXgw,
                       label: GHC.IO.FD.$wreadRawBufferPtrNoBlock_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXgw: // global
           _saWVE::I64 = R6;
           _saWVD::I64 = R5;
           _saWVC::I64 = R4;
           _saWVB::I64 = R3;
           _saWVA::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caXgx; else goto caXgy;
       caXgy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXgA; else goto caXgz;
       caXgA: // global
           HpAlloc = 40;
           goto caXgx;
       caXgx: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVC::I64;
           I64[Sp - 16] = _saWVD::I64;
           I64[Sp - 8] = _saWVE::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caXgz: // global
           if (_saWVC::I64 == 0) goto caXgv; else goto caXgu;
       caXgv: // global
           (_saWW3::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWVB::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWW4::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWW3::I64));
           if (_saWW4::I64 != 0) goto uaXha; else goto caXh4;
       uaXha: // global
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVD::I64;
           I64[Sp - 16] = _saWVE::I64;
           I64[Sp - 8] = _saWW4::I64;
           Sp = Sp - 40;
           call _caXfW() args: 0, res: 0, upd: 0;
       caXh4: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXgu: // global
           I64[Hp - 32] = sat_saWVZ_info;
           I64[Hp - 24] = _saWVB::I64;
           I64[Hp - 16] = _saWVD::I64;
           I64[Hp - 8] = _saWVE::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWVA::P64;
           Sp = Sp - 8;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caXfW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXh1; else goto caXh0;
       caXh1: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caXfV_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXh0: // global
           I64[Hp - 32] = sat_saWWc_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caXfV() //  [R1]
         { info_tbl: [(caXfV,
                       label: block_caXfV_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXfV: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caXfW() args: 0, res: 0, upd: 0;
     }
 },
 _saWVH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saWVH: // global
           _saWVA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caXgE_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _saWVA::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXgE() //  [R1]
         { info_tbl: [(caXgE,
                       label: block_caXgE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXgE: // global
           I64[Sp] = block_caXgG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXhh; else goto caXgJ;
       uaXhh: // global
           call _caXgG(R1) args: 0, res: 0, upd: 0;
       caXgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXgG() //  [R1]
         { info_tbl: [(caXgG,
                       label: block_caXgG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXgG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXgP; else goto caXgO;
       caXgP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXgO: // global
           _saWVP::I64 = I64[R1 + 7];
           if (_saWVP::I64 != (-1)) goto uaXh8; else goto caXgV;
       uaXh8: // global
           if (_saWVP::I64 != 0) goto caXgU; else goto caXgW;
       caXgU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXgW: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXgV: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.181284836 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXhp,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caXhD; else goto caXhE;
       caXhD: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXhE: // global
           I64[Sp - 40] = block_caXhm_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaXhO; else goto caXhn;
       uaXhO: // global
           call _caXhm(R1) args: 0, res: 0, upd: 0;
       caXhn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXhm() //  [R1]
         { info_tbl: [(caXhm,
                       label: block_caXhm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhm: // global
           I64[Sp - 8] = block_caXhs_info;
           _saWWk::I64 = I64[R1 + 7];
           _saWWl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWWl::I64;
           I64[Sp + 16] = _saWWk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXhN; else goto caXht;
       uaXhN: // global
           call _caXhs(R1) args: 0, res: 0, upd: 0;
       caXht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXhs() //  [R1]
         { info_tbl: [(caXhs,
                       label: block_caXhs_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhs: // global
           I64[Sp] = block_caXhx_info;
           _saWWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWWn::I64;
           if (R1 & 7 != 0) goto uaXhP; else goto caXhy;
       uaXhP: // global
           call _caXhx(R1) args: 0, res: 0, upd: 0;
       caXhy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXhx() //  [R1]
         { info_tbl: [(caXhx,
                       label: block_caXhx_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhx: // global
           I64[Sp] = block_caXhC_info;
           _saWWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWWp::I64;
           if (R1 & 7 != 0) goto uaXhQ; else goto caXhI;
       uaXhQ: // global
           call _caXhC(R1) args: 0, res: 0, upd: 0;
       caXhI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXhC() //  [R1]
         { info_tbl: [(caXhC,
                       label: block_caXhC_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhC: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.183511828 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhS: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caXhY,
                       label: GHC.IO.FD.$w$creadNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXhY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXi3; else goto caXi4;
       caXi3: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caXi4: // global
           I64[Sp - 8] = block_caXi0_info;
           R6 = 0;
           _saWWx::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _saWWx::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caXi0() //  [R1]
         { info_tbl: [(caXi0,
                       label: block_caXi0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXi0: // global
           I64[Sp] = block_caXi2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXij; else goto caXi6;
       uaXij: // global
           call _caXi2(R1) args: 0, res: 0, upd: 0;
       caXi6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXi2() //  [R1]
         { info_tbl: [(caXi2,
                       label: block_caXi2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXi2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXic; else goto caXib;
       caXic: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXib: // global
           if (I64[R1 + 7] == (-1)) goto caXii; else goto caXih;
       caXii: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXih: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.185536631 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { info_tbl: [(caXir,
                       label: GHC.IO.FD.$fRawIOFD3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXir: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXiA; else goto caXiB;
       caXiA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXiB: // global
           I64[Sp - 24] = block_caXio_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXiK; else goto caXip;
       uaXiK: // global
           call _caXio(R1) args: 0, res: 0, upd: 0;
       caXip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXio() //  [R1]
         { info_tbl: [(caXio,
                       label: block_caXio_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXio: // global
           I64[Sp - 8] = block_caXiu_info;
           _saWWK::I64 = I64[R1 + 7];
           _saWWL::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWWL::I64;
           I64[Sp + 8] = _saWWK::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXiJ; else goto caXiv;
       uaXiJ: // global
           call _caXiu(R1) args: 0, res: 0, upd: 0;
       caXiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXiu() //  [R1]
         { info_tbl: [(caXiu,
                       label: block_caXiu_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXiu: // global
           I64[Sp] = block_caXiz_info;
           _saWWN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWWN::I64;
           if (R1 & 7 != 0) goto uaXiL; else goto caXiE;
       uaXiL: // global
           call _caXiz(R1) args: 0, res: 0, upd: 0;
       caXiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXiz() //  [R1]
         { info_tbl: [(caXiz,
                       label: block_caXiz_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXiz: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.187032167 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.187764438 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { info_tbl: [(caXiS,
                       label: GHC.IO.FD.$fBufferedIOFD_loc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXiS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXiT; else goto caXiU;
       caXiT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXiU: // global
           (_caXiP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXiP::I64 == 0) goto caXiR; else goto caXiQ;
       caXiR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXiQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXiP::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.188950922 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { info_tbl: [(caXj2,
                       label: GHC.IO.FD.$fBufferedIOFD14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXj2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXj3; else goto caXj4;
       caXj3: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXj4: // global
           I64[Sp - 8] = block_caXiZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXjc; else goto caXj0;
       uaXjc: // global
           call _caXiZ(R1) args: 0, res: 0, upd: 0;
       caXj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXiZ() //  [R1]
         { info_tbl: [(caXiZ,
                       label: block_caXiZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXiZ: // global
           if (I64[R1 + 7] == (-1)) goto caXjb; else goto caXja;
       caXjb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXja: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.190266414 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.191000658 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { info_tbl: [(caXjj,
                       label: GHC.IO.FD.$fBufferedIOFD12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXjk; else goto caXjl;
       caXjk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXjl: // global
           (_caXjg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXjg::I64 == 0) goto caXji; else goto caXjh;
       caXji: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXjh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXjg::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.194802833 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjn: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWXe_entry() //  [R1]
         { info_tbl: [(caXjG,
                       label: sat_saWXe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjG: // global
           _saWXe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caXjH; else goto caXjI;
       caXjI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXjK; else goto caXjJ;
       caXjK: // global
           HpAlloc = 16;
           goto caXjH;
       caXjH: // global
           R1 = _saWXe::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXjJ: // global
           _saWWV::I64 = I64[_saWXe::P64 + 7];
           (_saWX8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWX8::I64 == 0) goto caXjF; else goto caXjE;
       caXjF: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caXjU_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caXjE: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caXjU() //  []
         { info_tbl: [(caXjU,
                       label: block_caXjU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXk_entry() //  [R1]
         { info_tbl: [(caXk6,
                       label: sat_saWXk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXk6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXka; else goto caXkb;
       caXka: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXkb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caXk3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXkf; else goto caXk4;
       uaXkf: // global
           call _caXk3(R1) args: 0, res: 0, upd: 0;
       caXk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXk3() //  [R1]
         { info_tbl: [(caXk3,
                       label: block_caXk3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXk3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXke; else goto caXkd;
       caXke: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXkd: // global
           _saWXj::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWXj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWXt_entry() //  [R1]
         { info_tbl: [(caXkp,
                       label: sat_saWXt_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXkp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXkz; else goto caXky;
       caXkz: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXky: // global
           (_saWXr::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXr::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXP_entry() //  [R1]
         { info_tbl: [(caXl0,
                       label: sat_saWXP_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXl0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXl9; else goto caXla;
       caXl9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXla: // global
           I64[Sp - 8] = block_caXl6_info;
           Sp = Sp - 8;
           _caXl3::I64 = I64[R1 + 7];
           _caXl4::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caXl5::I64 = I64[R1 + 31];
           _uaXlg::P64 = CurrentTSO;
           I64[I64[_uaXlg::P64 + 24] + 16] = Sp;
           _uaXlh::I64 = CurrentNursery;
           P64[_uaXlh::I64 + 8] = Hp + 8;
           I64[_uaXlg::P64 + 104] = I64[_uaXlg::P64 + 104] - ((Hp + 8) - I64[_uaXlh::I64]);
           (_uaXle::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWXN::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caXl3::I64, _caXl4::I64, _caXl5::I64);
           (_uaXlf::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXle::I64);
           BaseReg = _uaXlf::I64;
           _uaXli::P64 = CurrentTSO;
           _uaXlj::P64 = I64[_uaXli::P64 + 24];
           Sp = I64[_uaXlj::P64 + 16];
           SpLim = _uaXlj::P64 + 192;
           HpAlloc = 0;
           _uaXlk::I64 = CurrentNursery;
           _uaXll::I64 = I64[_uaXlk::I64 + 8];
           Hp = _uaXll::I64 - 8;
           _uaXlm::I64 = I64[_uaXlk::I64];
           HpLim = _uaXlm::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXlk::I64 + 48]) << 12) - 1);
           I64[_uaXli::P64 + 104] = I64[_uaXli::P64 + 104] + (_uaXll::I64 - _uaXlm::I64);
           R1 = _saWXN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXl6() //  [R1]
         { info_tbl: [(caXl6,
                       label: block_caXl6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXl6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXld; else goto caXlc;
       caXld: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXlc: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXX_entry() //  [R1]
         { info_tbl: [(caXlw,
                       label: sat_saWXX_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXlw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXlG; else goto caXlF;
       caXlG: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXlF: // global
           (_saWXV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXV::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXlK,
                       label: GHC.IO.FD.$wreadRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXlK: // global
           _saWWY::I64 = R6;
           _saWWX::I64 = R5;
           _saWWW::I64 = R4;
           _saWWV::I64 = R3;
           _saWWU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caXlL; else goto caXlM;
       caXlM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXlO; else goto caXlN;
       caXlO: // global
           HpAlloc = 40;
           goto caXlL;
       caXlL: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWW::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caXlN: // global
           if (_saWWW::I64 == 0) goto caXlJ; else goto caXlI;
       caXlJ: // global
           (_saWXx::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWWV::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWYb::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWXx::I64));
           if (_saWYb::I64 != (-1)) goto caXmz; else goto caXmK;
       caXmz: // global
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWX::I64;
           I64[Sp - 16] = _saWWY::I64;
           I64[Sp - 8] = _saWYb::I64;
           Sp = Sp - 40;
           call _caXkJ() args: 0, res: 0, upd: 0;
       caXmK: // global
           I64[Sp - 40] = block_caXmH_info;
           R2 = _saWWU::P64;
           P64[Sp - 32] = _saWWU::P64;
           I64[Sp - 24] = _saWWV::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caXlI: // global
           I64[Hp - 32] = sat_saWXt_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWWV::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWWU::P64;
           Sp = Sp - 16;
           call _caXju() args: 0, res: 0, upd: 0;
     }
 },
 _caXmH() //  [R1]
         { info_tbl: [(caXmH,
                       label: block_caXmH_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXmH: // global
           I64[Sp] = block_caXmJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXn8; else goto caXmN;
       uaXn8: // global
           call _caXmJ(R1) args: 0, res: 0, upd: 0;
       caXmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXmJ() //  [R1]
         { info_tbl: [(caXmJ,
                       label: block_caXmJ_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXmJ: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _caXkJ() args: 0, res: 0, upd: 0;
     }
 },
 _caXkJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXkJ: // global
           Hp = Hp + 16;
           _saWXA::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caXlX; else goto caXlW;
       caXlX: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caXkI_info;
           R1 = _saWXA::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXlW: // global
           if (_saWXA::I64 == 0) goto caXmt; else goto caXm6;
       caXmt: // global
           _saWWV::I64 = I64[Sp + 8];
           (_saWY2::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWY2::I64 == 0) goto caXmq; else goto caXmi;
       caXmq: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caXkO_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caXmi: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           I64[Sp - 8] = block_caXmg_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       caXm6: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _caXkO() args: 0, res: 0, upd: 0;
     }
 },
 _caXkI() //  [R1]
         { info_tbl: [(caXkI,
                       label: block_caXkI_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXkI: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caXkJ() args: 0, res: 0, upd: 0;
     }
 },
 _caXmg() //  []
         { info_tbl: [(caXmg,
                       label: block_caXmg_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXmg: // global
           call _caXkO() args: 0, res: 0, upd: 0;
     }
 },
 _caXkO() //  []
         { info_tbl: [(caXkO,
                       label: block_caXkO_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXkO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXm0; else goto caXlZ;
       caXm0: // global
           HpAlloc = 40;
           I64[Sp] = block_caXkO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caXlZ: // global
           _saWWU::P64 = P64[Sp + 8];
           _saWWV::I64 = I64[Sp + 16];
           _saWWX::I64 = I64[Sp + 24];
           _saWWY::I64 = I64[Sp + 32];
           _saWWZ::I64 = I64[Sp + 48];
           (_saWXG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWXG::I64 == 0) goto caXm3; else goto caXm2;
       caXm3: // global
           I64[Hp - 32] = sat_saWXX_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaXn4;
       caXm2: // global
           I64[Hp - 32] = sat_saWXP_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaXn4;
       uaXn4: // global
           call _caXju() args: 0, res: 0, upd: 0;
     }
 },
 _caXju() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXju: // global
           Hp = Hp + 16;
           _saWX2::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caXlR; else goto caXlQ;
       caXlR: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caXjt_info;
           R1 = _saWX2::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXlQ: // global
           I64[Hp - 8] = sat_saWXe_info;
           I64[Hp] = I64[Sp];
           _saWWU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caXjX_info;
           R5 = Hp - 7;
           R4 = _saWX2::P64;
           R3 = _saWWU::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXjt() //  [R1]
         { info_tbl: [(caXjt,
                       label: block_caXjt_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjt: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caXju() args: 0, res: 0, upd: 0;
     }
 },
 _caXjX() //  [R1]
         { info_tbl: [(caXjX,
                       label: block_caXjX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXjX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXlU; else goto caXlT;
       caXlU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXlT: // global
           I64[Hp - 16] = sat_saWXk_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.202611444 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXnh,
                       label: GHC.IO.FD.$fRawIOFD5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnh: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caXnv; else goto caXnw;
       caXnv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXnw: // global
           I64[Sp - 40] = block_caXne_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaXnG; else goto caXnf;
       uaXnG: // global
           call _caXne(R1) args: 0, res: 0, upd: 0;
       caXnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXne() //  [R1]
         { info_tbl: [(caXne,
                       label: block_caXne_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXne: // global
           I64[Sp - 8] = block_caXnk_info;
           _saWYo::I64 = I64[R1 + 7];
           _saWYp::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWYp::I64;
           I64[Sp + 16] = _saWYo::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXnF; else goto caXnl;
       uaXnF: // global
           call _caXnk(R1) args: 0, res: 0, upd: 0;
       caXnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnk() //  [R1]
         { info_tbl: [(caXnk,
                       label: block_caXnk_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnk: // global
           I64[Sp] = block_caXnp_info;
           _saWYr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWYr::I64;
           if (R1 & 7 != 0) goto uaXnH; else goto caXnq;
       uaXnH: // global
           call _caXnp(R1) args: 0, res: 0, upd: 0;
       caXnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnp() //  [R1]
         { info_tbl: [(caXnp,
                       label: block_caXnp_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnp: // global
           I64[Sp] = block_caXnu_info;
           _saWYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWYt::I64;
           if (R1 & 7 != 0) goto uaXnI; else goto caXnA;
       uaXnI: // global
           call _caXnu(R1) args: 0, res: 0, upd: 0;
       caXnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnu() //  [R1]
         { info_tbl: [(caXnu,
                       label: block_caXnu_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnu: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.204717314 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { info_tbl: [(caXnQ,
                       label: GHC.IO.FD.$fRawIOFD4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXnZ; else goto caXo0;
       caXnZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXo0: // global
           I64[Sp - 24] = block_caXnN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXoa; else goto caXnO;
       uaXoa: // global
           call _caXnN(R1) args: 0, res: 0, upd: 0;
       caXnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnN() //  [R1]
         { info_tbl: [(caXnN,
                       label: block_caXnN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnN: // global
           I64[Sp - 8] = block_caXnT_info;
           _saWYB::I64 = I64[R1 + 7];
           _saWYC::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWYC::I64;
           I64[Sp + 8] = _saWYB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXo9; else goto caXnU;
       uaXo9: // global
           call _caXnT(R1) args: 0, res: 0, upd: 0;
       caXnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnT() //  [R1]
         { info_tbl: [(caXnT,
                       label: block_caXnT_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnT: // global
           I64[Sp] = block_caXnY_info;
           _saWYE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWYE::I64;
           if (R1 & 7 != 0) goto uaXob; else goto caXo3;
       uaXob: // global
           call _caXnY(R1) args: 0, res: 0, upd: 0;
       caXo3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXnY() //  [R1]
         { info_tbl: [(caXnY,
                       label: block_caXnY_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXnY: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.208922254 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXod: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWZ2_entry() //  [R1]
         { info_tbl: [(caXow,
                       label: sat_saWZ2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXow: // global
           _saWZ2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caXox; else goto caXoy;
       caXoy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXoA; else goto caXoz;
       caXoA: // global
           HpAlloc = 16;
           goto caXox;
       caXox: // global
           R1 = _saWZ2::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXoz: // global
           _saWYJ::I64 = I64[_saWZ2::P64 + 7];
           (_saWYW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWYW::I64 == 0) goto caXov; else goto caXou;
       caXov: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caXoK_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caXou: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caXoK() //  []
         { info_tbl: [(caXoK,
                       label: block_caXoK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXoK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZ9_entry() //  [R1]
         { info_tbl: [(caXoW,
                       label: sat_saWZ9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXoW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXp3; else goto caXp4;
       caXp3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXp4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caXoT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXp8; else goto caXoU;
       uaXp8: // global
           call _caXoT(R1) args: 0, res: 0, upd: 0;
       caXoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXoT() //  [R1]
         { info_tbl: [(caXoT,
                       label: block_caXoT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXoT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXp7; else goto caXp6;
       caXp7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXp6: // global
           _saWZ8::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saWZ8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWZi_entry() //  [R1]
         { info_tbl: [(caXpi,
                       label: sat_saWZi_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXpi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXps; else goto caXpr;
       caXps: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXpr: // global
           (_saWZg::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZg::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZB_entry() //  [R1]
         { info_tbl: [(caXpO,
                       label: sat_saWZB_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXpO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXpX; else goto caXpY;
       caXpX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXpY: // global
           I64[Sp - 8] = block_caXpU_info;
           Sp = Sp - 8;
           _caXpR::I64 = I64[R1 + 7];
           _caXpS::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caXpT::I64 = I64[R1 + 31];
           _uaXq4::P64 = CurrentTSO;
           I64[I64[_uaXq4::P64 + 24] + 16] = Sp;
           _uaXq5::I64 = CurrentNursery;
           P64[_uaXq5::I64 + 8] = Hp + 8;
           I64[_uaXq4::P64 + 104] = I64[_uaXq4::P64 + 104] - ((Hp + 8) - I64[_uaXq5::I64]);
           (_uaXq2::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWZz::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caXpR::I64, _caXpS::I64, _caXpT::I64);
           (_uaXq3::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXq2::I64);
           BaseReg = _uaXq3::I64;
           _uaXq6::P64 = CurrentTSO;
           _uaXq7::P64 = I64[_uaXq6::P64 + 24];
           Sp = I64[_uaXq7::P64 + 16];
           SpLim = _uaXq7::P64 + 192;
           HpAlloc = 0;
           _uaXq8::I64 = CurrentNursery;
           _uaXq9::I64 = I64[_uaXq8::I64 + 8];
           Hp = _uaXq9::I64 - 8;
           _uaXqa::I64 = I64[_uaXq8::I64];
           HpLim = _uaXqa::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXq8::I64 + 48]) << 12) - 1);
           I64[_uaXq6::P64 + 104] = I64[_uaXq6::P64 + 104] + (_uaXq9::I64 - _uaXqa::I64);
           R1 = _saWZz::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXpU() //  [R1]
         { info_tbl: [(caXpU,
                       label: block_caXpU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXq1; else goto caXq0;
       caXq1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXq0: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZJ_entry() //  [R1]
         { info_tbl: [(caXqk,
                       label: sat_saWZJ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXqk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXqu; else goto caXqt;
       caXqu: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXqt: // global
           (_saWZH::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZH::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXqy,
                       label: GHC.IO.FD.$wwriteRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXqy: // global
           _saWYM::I64 = R6;
           _saWYL::I64 = R5;
           _saWYK::I64 = R4;
           _saWYJ::I64 = R3;
           _saWYI::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caXqz; else goto caXqA;
       caXqA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXqC; else goto caXqB;
       caXqC: // global
           HpAlloc = 40;
           goto caXqz;
       caXqz: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYK::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caXqB: // global
           if (_saWYK::I64 == 0) goto caXqx; else goto caXqw;
       caXqx: // global
           (_saWZm::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWYJ::I64, 1, 0, 0);
           Hp = Hp - 40;
           _saWZK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWZm::I64));
           if (_saWZK::I64 != 0) goto uaXrs; else goto uaXrr;
       uaXrs: // global
           P64[Sp - 32] = _saWYI::P64;
           I64[Sp - 24] = _saWYJ::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call _caXpC() args: 0, res: 0, upd: 0;
       uaXrr: // global
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYL::I64;
           I64[Sp - 16] = _saWYM::I64;
           I64[Sp - 8] = _saWZK::I64;
           Sp = Sp - 40;
           call _caXr1() args: 0, res: 0, upd: 0;
       caXqw: // global
           I64[Hp - 32] = sat_saWZi_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWYJ::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWYI::P64;
           Sp = Sp - 16;
           call _caXok() args: 0, res: 0, upd: 0;
     }
 },
 _caXr1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXr1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXr5; else goto caXr4;
       caXr5: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caXqZ_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXr4: // global
           _saWYI::P64 = P64[Sp];
           _saWYJ::I64 = I64[Sp + 8];
           _saWYL::I64 = I64[Sp + 16];
           _saWYM::I64 = I64[Sp + 24];
           (_saWZO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZO::I64 == 0) goto caXrn; else goto caXrf;
       caXrn: // global
           Hp = Hp - 16;
           I64[Sp] = block_caXpC_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           P64[Sp + 8] = _saWYI::P64;
           I64[Sp + 16] = _saWYJ::I64;
           I64[Sp + 24] = _saWYL::I64;
           I64[Sp + 32] = _saWYM::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caXrf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           I64[Sp - 8] = block_caXrd_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXqZ() //  [R1]
         { info_tbl: [(caXqZ,
                       label: block_caXqZ_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXqZ: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caXr1() args: 0, res: 0, upd: 0;
     }
 },
 _caXrd() //  []
         { info_tbl: [(caXrd,
                       label: block_caXrd_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXrd: // global
           _saWYJ::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _saWYL::I64 = I64[Sp + 24];
           I64[Sp + 24] = _saWYJ::I64;
           _saWYM::I64 = I64[Sp + 32];
           I64[Sp + 32] = _saWYL::I64;
           I64[Sp + 40] = _saWYM::I64;
           Sp = Sp + 8;
           call _caXpC() args: 0, res: 0, upd: 0;
     }
 },
 _caXpC() //  []
         { info_tbl: [(caXpC,
                       label: block_caXpC_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXpC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caXqL; else goto caXqK;
       caXqL: // global
           HpAlloc = 40;
           I64[Sp] = block_caXpC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caXqK: // global
           _saWYI::P64 = P64[Sp + 8];
           _saWYJ::I64 = I64[Sp + 16];
           _saWYL::I64 = I64[Sp + 24];
           _saWYM::I64 = I64[Sp + 32];
           _saWYN::I64 = I64[Sp + 40];
           (_saWZs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZs::I64 == 0) goto caXqO; else goto caXqN;
       caXqO: // global
           I64[Hp - 32] = sat_saWZJ_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaXrA;
       caXqN: // global
           I64[Hp - 32] = sat_saWZB_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaXrA;
       uaXrA: // global
           call _caXok() args: 0, res: 0, upd: 0;
     }
 },
 _caXok() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXok: // global
           Hp = Hp + 16;
           _saWYQ::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caXqF; else goto caXqE;
       caXqF: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caXoj_info;
           R1 = _saWYQ::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXqE: // global
           I64[Hp - 8] = sat_saWZ2_info;
           I64[Hp] = I64[Sp];
           _saWYI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caXoN_info;
           R5 = Hp - 7;
           R4 = _saWYQ::P64;
           R3 = _saWYI::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXoj() //  [R1]
         { info_tbl: [(caXoj,
                       label: block_caXoj_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXoj: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caXok() args: 0, res: 0, upd: 0;
     }
 },
 _caXoN() //  [R1]
         { info_tbl: [(caXoN,
                       label: block_caXoN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXoN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXqI; else goto caXqH;
       caXqI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXqH: // global
           I64[Hp - 16] = sat_saWZ9_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.215537149 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXrN,
                       label: GHC.IO.FD.writeRawBufferPtr1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXrN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caXs1; else goto caXs2;
       caXs1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXs2: // global
           I64[Sp - 40] = block_caXrK_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaXsc; else goto caXrL;
       uaXsc: // global
           call _caXrK(R1) args: 0, res: 0, upd: 0;
       caXrL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXrK() //  [R1]
         { info_tbl: [(caXrK,
                       label: block_caXrK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXrK: // global
           I64[Sp - 8] = block_caXrQ_info;
           _saX04::I64 = I64[R1 + 7];
           _saX05::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saX05::I64;
           I64[Sp + 16] = _saX04::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXsb; else goto caXrR;
       uaXsb: // global
           call _caXrQ(R1) args: 0, res: 0, upd: 0;
       caXrR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXrQ() //  [R1]
         { info_tbl: [(caXrQ,
                       label: block_caXrQ_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXrQ: // global
           I64[Sp] = block_caXrV_info;
           _saX07::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saX07::I64;
           if (R1 & 7 != 0) goto uaXsd; else goto caXrW;
       uaXsd: // global
           call _caXrV(R1) args: 0, res: 0, upd: 0;
       caXrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXrV() //  [R1]
         { info_tbl: [(caXrV,
                       label: block_caXrV_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXrV: // global
           I64[Sp] = block_caXs0_info;
           _saX09::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saX09::I64;
           if (R1 & 7 != 0) goto uaXse; else goto caXs6;
       uaXse: // global
           call _caXs0(R1) args: 0, res: 0, upd: 0;
       caXs6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXs0() //  [R1]
         { info_tbl: [(caXs0,
                       label: block_caXs0_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXs0: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.217995823 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsg: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caXsm,
                       label: GHC.IO.FD.$wfdWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caXsr; else goto uaXsK;
       caXsr: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       uaXsK: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caXsh() args: 0, res: 0, upd: 0;
     }
 },
 _caXsh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsh: // global
           I64[Sp - 8] = block_caXso_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _caXso() //  [R1]
         { info_tbl: [(caXso,
                       label: block_caXso_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXso: // global
           I64[Sp] = block_caXsq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXsN; else goto caXsu;
       uaXsN: // global
           call _caXsq(R1) args: 0, res: 0, upd: 0;
       caXsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXsq() //  [R1]
         { info_tbl: [(caXsq,
                       label: block_caXsq_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsq: // global
           _saX0f::I64 = I64[Sp + 32];
           _saX0m::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_saX0m::I64,
                            _saX0f::I64)) goto caXsC; else goto caXsD;
       caXsC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXsD: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _saX0m::I64;
           I64[Sp + 32] = _saX0f::I64 - _saX0m::I64;
           Sp = Sp + 8;
           call _caXsh() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.22017362 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { info_tbl: [(caXsW,
                       label: GHC.IO.FD.$fRawIOFD2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXt5; else goto caXt6;
       caXt5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXt6: // global
           I64[Sp - 24] = block_caXsT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXtf; else goto caXsU;
       uaXtf: // global
           call _caXsT(R1) args: 0, res: 0, upd: 0;
       caXsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXsT() //  [R1]
         { info_tbl: [(caXsT,
                       label: block_caXsT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsT: // global
           I64[Sp - 8] = block_caXsZ_info;
           _saX0v::I64 = I64[R1 + 7];
           _saX0w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX0w::I64;
           I64[Sp + 8] = _saX0v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXte; else goto caXt0;
       uaXte: // global
           call _caXsZ(R1) args: 0, res: 0, upd: 0;
       caXt0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXsZ() //  [R1]
         { info_tbl: [(caXsZ,
                       label: block_caXsZ_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXsZ: // global
           I64[Sp] = block_caXt4_info;
           _saX0y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX0y::I64;
           if (R1 & 7 != 0) goto uaXtg; else goto caXt9;
       uaXtg: // global
           call _caXt4(R1) args: 0, res: 0, upd: 0;
       caXt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXt4() //  [R1]
         { info_tbl: [(caXt4,
                       label: block_caXt4_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXt4: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.225177141 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXti: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX0O_entry() //  [R1]
         { info_tbl: [(caXtv,
                       label: sat_saX0O_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXtv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXtF; else goto caXtE;
       caXtF: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXtE: // global
           (_saX0M::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX0M::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1e_entry() //  [R1]
         { info_tbl: [(caXu2,
                       label: sat_saX1e_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXu2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXub; else goto caXuc;
       caXub: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXuc: // global
           I64[Sp - 8] = block_caXu8_info;
           Sp = Sp - 8;
           _caXu5::I64 = I64[R1 + 7];
           _caXu6::I64 = I64[R1 + 15];
           _caXu7::I64 = I64[R1 + 23];
           _uaXui::P64 = CurrentTSO;
           I64[I64[_uaXui::P64 + 24] + 16] = Sp;
           _uaXuj::I64 = CurrentNursery;
           P64[_uaXuj::I64 + 8] = Hp + 8;
           I64[_uaXui::P64 + 104] = I64[_uaXui::P64 + 104] - ((Hp + 8) - I64[_uaXuj::I64]);
           (_uaXug::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX1c::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caXu5::I64, _caXu6::I64, _caXu7::I64);
           (_uaXuh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXug::I64);
           BaseReg = _uaXuh::I64;
           _uaXuk::P64 = CurrentTSO;
           _uaXul::P64 = I64[_uaXuk::P64 + 24];
           Sp = I64[_uaXul::P64 + 16];
           SpLim = _uaXul::P64 + 192;
           HpAlloc = 0;
           _uaXum::I64 = CurrentNursery;
           _uaXun::I64 = I64[_uaXum::I64 + 8];
           Hp = _uaXun::I64 - 8;
           _uaXuo::I64 = I64[_uaXum::I64];
           HpLim = _uaXuo::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXum::I64 + 48]) << 12) - 1);
           I64[_uaXuk::P64 + 104] = I64[_uaXuk::P64 + 104] + (_uaXun::I64 - _uaXuo::I64);
           R1 = _saX1c::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXu8() //  [R1]
         { info_tbl: [(caXu8,
                       label: block_caXu8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXu8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXuf; else goto caXue;
       caXuf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXue: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1u_entry() //  [R1]
         { info_tbl: [(caXuy,
                       label: sat_saX1u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXuy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXuI; else goto caXuH;
       caXuI: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXuH: // global
           (_saX1s::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX1s::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caXuM,
                       label: GHC.IO.FD.$w$cwriteNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXuM: // global
           _saX0E::I64 = R5;
           _saX0D::I64 = R4;
           _saX0C::I64 = R3;
           _saX0B::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto caXuN; else goto caXuO;
       caXuO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caXuQ; else goto caXuP;
       caXuQ: // global
           HpAlloc = 32;
           goto caXuN;
       caXuN: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0C::I64;
           I64[Sp - 16] = _saX0D::I64;
           I64[Sp - 8] = _saX0E::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caXuP: // global
           if (_saX0C::I64 == 0) goto caXuL; else goto caXuK;
       caXuL: // global
           (_saX10::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saX0B::I64, 1, 0, 0);
           Hp = Hp - 32;
           _saX11::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX10::I64));
           if (_saX11::I64 != 0) goto uaXw4; else goto caXvZ;
       uaXw4: // global
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0D::I64;
           I64[Sp - 16] = _saX0E::I64;
           I64[Sp - 8] = _saX11::I64;
           Sp = Sp - 32;
           call _caXtQ() args: 0, res: 0, upd: 0;
       caXvZ: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXuK: // global
           I64[Hp - 24] = sat_saX0O_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp - 8] = block_caXuR_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXtQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXtQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caXvf; else goto caXve;
       caXvf: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caXtP_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXve: // global
           _saX0B::I64 = I64[Sp];
           _saX0D::I64 = I64[Sp + 8];
           _saX0E::I64 = I64[Sp + 16];
           (_saX15::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX15::I64 == 0) goto caXvF; else goto caXvk;
       caXvF: // global
           I64[Hp - 24] = sat_saX1u_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caXvC_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       caXvk: // global
           I64[Hp - 24] = sat_saX1e_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caXvg_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXtP() //  [R1]
         { info_tbl: [(caXtP,
                       label: block_caXtP_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXtP: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caXtQ() args: 0, res: 0, upd: 0;
     }
 },
 _caXvC() //  [R1]
         { info_tbl: [(caXvC,
                       label: block_caXvC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXvC: // global
           I64[Sp] = block_caXvE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXwe; else goto caXvH;
       uaXwe: // global
           call _caXvE(R1) args: 0, res: 0, upd: 0;
       caXvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXvE() //  [R1]
         { info_tbl: [(caXvE,
                       label: block_caXvE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXvE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXvN; else goto caXvM;
       caXvN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXvM: // global
           _saX1A::I64 = I64[R1 + 7];
           if (_saX1A::I64 != (-1)) goto caXvV; else goto uaXw7;
       caXvV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1A::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaXw7: // global
           Sp = Sp + 8;
           call _caXvW() args: 0, res: 0, upd: 0;
     }
 },
 _caXvg() //  [R1]
         { info_tbl: [(caXvg,
                       label: block_caXvg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXvg: // global
           I64[Sp] = block_caXvi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXwc; else goto caXvm;
       uaXwc: // global
           call _caXvi(R1) args: 0, res: 0, upd: 0;
       caXvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXvi() //  [R1]
         { info_tbl: [(caXvi,
                       label: block_caXvi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXvi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXvs; else goto caXvr;
       caXvs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXvr: // global
           _saX1k::I64 = I64[R1 + 7];
           if (_saX1k::I64 != (-1)) goto caXvA; else goto uaXw6;
       caXvA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1k::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaXw6: // global
           Sp = Sp + 8;
           call _caXvW() args: 0, res: 0, upd: 0;
     }
 },
 _caXuR() //  [R1]
         { info_tbl: [(caXuR,
                       label: block_caXuR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXuR: // global
           I64[Sp] = block_caXuT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXwa; else goto caXuV;
       uaXwa: // global
           call _caXuT(R1) args: 0, res: 0, upd: 0;
       caXuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXuT() //  [R1]
         { info_tbl: [(caXuT,
                       label: block_caXuT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXuT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXv1; else goto caXv0;
       caXv1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXv0: // global
           _saX0U::I64 = I64[R1 + 7];
           if (_saX0U::I64 != (-1)) goto caXv9; else goto uaXw3;
       caXv9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX0U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaXw3: // global
           Sp = Sp + 8;
           call _caXvW() args: 0, res: 0, upd: 0;
     }
 },
 _caXvW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXvW: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.230503376 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { info_tbl: [(caXwn,
                       label: GHC.IO.FD.$fRawIOFD1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXww; else goto caXwx;
       caXww: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXwx: // global
           I64[Sp - 24] = block_caXwk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXwG; else goto caXwl;
       uaXwG: // global
           call _caXwk(R1) args: 0, res: 0, upd: 0;
       caXwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXwk() //  [R1]
         { info_tbl: [(caXwk,
                       label: block_caXwk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwk: // global
           I64[Sp - 8] = block_caXwq_info;
           _saX1I::I64 = I64[R1 + 7];
           _saX1J::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX1J::I64;
           I64[Sp + 8] = _saX1I::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXwF; else goto caXwr;
       uaXwF: // global
           call _caXwq(R1) args: 0, res: 0, upd: 0;
       caXwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXwq() //  [R1]
         { info_tbl: [(caXwq,
                       label: block_caXwq_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwq: // global
           I64[Sp] = block_caXwv_info;
           _saX1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX1L::I64;
           if (R1 & 7 != 0) goto uaXwH; else goto caXwA;
       uaXwH: // global
           call _caXwv(R1) args: 0, res: 0, upd: 0;
       caXwA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXwv() //  [R1]
         { info_tbl: [(caXwv,
                       label: block_caXwv_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwv: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.231986432 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.233087922 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { info_tbl: [(caXwP,
                       label: GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caXx7; else goto caXx8;
       caXx7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXx8: // global
           I64[Sp - 16] = block_caXwM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXxf; else goto caXwN;
       uaXxf: // global
           call _caXwM(R1) args: 0, res: 0, upd: 0;
       caXwN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXwM() //  [R1]
         { info_tbl: [(caXwM,
                       label: block_caXwM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwM: // global
           I64[Sp - 40] = block_caXwS_info;
           _saX1T::P64 = P64[R1 + 7];
           _saX1U::P64 = P64[R1 + 15];
           _saX1S::I64 = I64[R1 + 23];
           _saX1V::I64 = I64[R1 + 31];
           _saX1W::I64 = I64[R1 + 39];
           _saX1X::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _saX1U::P64;
           I64[Sp - 24] = _saX1V::I64;
           I64[Sp - 16] = _saX1W::I64;
           I64[Sp - 8] = _saX1X::I64;
           P64[Sp] = _saX1T::P64;
           I64[Sp + 8] = _saX1S::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaXxe; else goto caXwT;
       uaXxe: // global
           call _caXwS(R1) args: 0, res: 0, upd: 0;
       caXwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXwS() //  [R1]
         { info_tbl: [(caXwS,
                       label: block_caXwS_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXwS: // global
           I64[Sp] = block_caXx3_info;
           _saX1W::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _saX1W::I64;
           R4 = I64[Sp + 48] + _saX1W::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXx3() //  [R1]
         { info_tbl: [(caXx3,
                       label: block_caXx3_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXx3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caXxd; else goto caXxc;
       caXxd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXxc: // global
           _saX1S::I64 = I64[Sp + 48];
           _saX1T::P64 = P64[Sp + 40];
           _saX1U::P64 = P64[Sp + 8];
           _saX1V::I64 = I64[Sp + 16];
           call MO_Touch(_saX1T::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX1T::P64;
           P64[Hp - 32] = _saX1U::P64;
           I64[Hp - 24] = _saX1S::I64;
           I64[Hp - 16] = _saX1V::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.235126935 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { info_tbl: [(caXxn,
                       label: GHC.IO.FD.fdIsNonBlocking_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXxr; else goto caXxs;
       caXxr: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXxs: // global
           I64[Sp - 8] = block_caXxk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXxw; else goto caXxl;
       uaXxw: // global
           call _caXxk(R1) args: 0, res: 0, upd: 0;
       caXxl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXxk() //  [R1]
         { info_tbl: [(caXxk,
                       label: block_caXxk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXxv; else goto caXxu;
       caXxv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXxu: // global
           _saX2b::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saX2b::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.236465612 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { info_tbl: [(caXxE,
                       label: GHC.IO.FD.fdFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXxI; else goto caXxJ;
       caXxI: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXxJ: // global
           I64[Sp - 8] = block_caXxB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXxN; else goto caXxC;
       uaXxN: // global
           call _caXxB(R1) args: 0, res: 0, upd: 0;
       caXxC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXxB() //  [R1]
         { info_tbl: [(caXxB,
                       label: block_caXxB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXxM; else goto caXxL;
       caXxM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXxL: // global
           _saX2e::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2e::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.237974431 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { info_tbl: [(caXxV,
                       label: GHC.IO.FD.$fShowFD_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXy1; else goto caXy2;
       caXy1: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXy2: // global
           I64[Sp - 8] = block_caXxS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXy7; else goto caXxT;
       uaXy7: // global
           call _caXxS(R1) args: 0, res: 0, upd: 0;
       caXxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXxS() //  [R1]
         { info_tbl: [(caXxS,
                       label: block_caXxS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxS: // global
           I64[Sp] = block_caXxY_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXxY() //  [R1, R2]
         { info_tbl: [(caXxY,
                       label: block_caXxY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXxY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXy6; else goto caXy5;
       caXy6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caXy5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.239526392 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { info_tbl: [(caXyj,
                       label: GHC.IO.FD.$fBufferedIOFD15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXyj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXym; else goto caXyn;
       caXym: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXyn: // global
           I64[Sp - 16] = block_caXyc_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXyc() //  [R1]
         { info_tbl: [(caXyc,
                       label: block_caXyc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXyc: // global
           I64[Sp - 8] = block_caXye_info;
           _saX2s::P64 = R1;
           R1 = 8192;
           P64[Sp] = _saX2s::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXye() //  [R1]
         { info_tbl: [(caXye,
                       label: block_caXye_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXye: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caXyr; else goto caXyq;
       caXyr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXyq: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.241172783 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_saX2E_entry() //  [R1]
         { info_tbl: [(caXyD,
                       label: sat_saX2E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXyD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXyH; else goto caXyI;
       caXyH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXyI: // global
           I64[Sp - 8] = block_caXyA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXyM; else goto caXyB;
       uaXyM: // global
           call _caXyA(R1) args: 0, res: 0, upd: 0;
       caXyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXyA() //  [R1]
         { info_tbl: [(caXyA,
                       label: block_caXyA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXyA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXyL; else goto caXyK;
       caXyL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXyK: // global
           _saX2C::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2C::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { info_tbl: [(caXyN,
                       label: GHC.IO.FD.$fIODeviceFD12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXyN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXyR; else goto caXyQ;
       caXyR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXyQ: // global
           I64[Hp - 16] = sat_saX2E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.242996687 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_saX2L_entry() //  [R1]
         { info_tbl: [(caXz3,
                       label: sat_saX2L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXz3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXz7; else goto caXz8;
       caXz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXz8: // global
           I64[Sp - 8] = block_caXz0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXzc; else goto caXz1;
       uaXzc: // global
           call _caXz0(R1) args: 0, res: 0, upd: 0;
       caXz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXz0() //  [R1]
         { info_tbl: [(caXz0,
                       label: block_caXz0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXz0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXzb; else goto caXza;
       caXzb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXza: // global
           _saX2J::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2J::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { info_tbl: [(caXzd,
                       label: GHC.IO.FD.$fIODeviceFD9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXzh; else goto caXzg;
       caXzh: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXzg: // global
           I64[Hp - 16] = sat_saX2L_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.24479743 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_saX2R_entry() //  [R1]
         { info_tbl: [(caXzt,
                       label: sat_saX2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXzx; else goto caXzy;
       caXzx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXzy: // global
           I64[Sp - 8] = block_caXzq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXzC; else goto caXzr;
       uaXzC: // global
           call _caXzq(R1) args: 0, res: 0, upd: 0;
       caXzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXzq() //  [R1]
         { info_tbl: [(caXzq,
                       label: block_caXzq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXzB; else goto caXzA;
       caXzB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXzA: // global
           _saX2P::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2P::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { info_tbl: [(caXzD,
                       label: GHC.IO.FD.$fIODeviceFD8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXzH; else goto caXzG;
       caXzH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXzG: // global
           I64[Hp - 16] = sat_saX2R_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.246864945 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_saX30_entry() //  [R1]
         { info_tbl: [(caXzX,
                       label: sat_saX30_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXzY; else goto caXzZ;
       caXzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caXzQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXA6; else goto caXzR;
       uaXA6: // global
           call _caXzQ(R1) args: 0, res: 0, upd: 0;
       caXzR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXzQ() //  [R1]
         { info_tbl: [(caXzQ,
                       label: block_caXzQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXzQ: // global
           if (R1 & 7 == 1) goto caXzU; else goto caXzV;
       caXzU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXzV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saX2Y_entry() //  [R1]
         { info_tbl: [(caXAe,
                       label: sat_saX2Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXAi; else goto caXAj;
       caXAi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXAj: // global
           I64[Sp - 8] = block_caXAb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXAn; else goto caXAc;
       uaXAn: // global
           call _caXAb(R1) args: 0, res: 0, upd: 0;
       caXAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXAb() //  [R1]
         { info_tbl: [(caXAb,
                       label: block_caXAb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXAm; else goto caXAl;
       caXAm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXAl: // global
           _saX2W::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2W::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { info_tbl: [(caXAo,
                       label: GHC.IO.FD.$fIODeviceFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caXAs; else goto caXAr;
       caXAs: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXAr: // global
           I64[Hp - 40] = sat_saX30_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_saX2Y_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.248755624 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.249474296 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.251072246 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.251621324 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.252162567 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.252760988 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.253346661 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.253955935 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.254469601 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.255004833 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.255626942 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.256197869 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.256745763 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.257344679 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.25788993 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.258491356 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.259534773 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caXAA,
                       label: GHC.IO.FD.$fShowFD_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXAG; else goto caXAH;
       caXAG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXAH: // global
           I64[Sp - 16] = block_caXAx_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXAM; else goto caXAy;
       uaXAM: // global
           call _caXAx(R1) args: 0, res: 0, upd: 0;
       caXAy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXAx() //  [R1]
         { info_tbl: [(caXAx,
                       label: block_caXAx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAx: // global
           I64[Sp] = block_caXAD_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXAD() //  [R1, R2]
         { info_tbl: [(caXAD,
                       label: block_caXAD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXAL; else goto caXAK;
       caXAL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caXAK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.261153735 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(caXAU,
                       label: GHC.IO.FD.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXAV; else goto caXAW;
       caXAV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXAW: // global
           I64[Sp - 16] = block_caXAR_info;
           R4 = GHC.Types.[]_closure+1;
           _saX3c::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _saX3c::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXAR() //  [R1, R2]
         { info_tbl: [(caXAR,
                       label: block_caXAR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXAR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXAZ; else goto caXAY;
       caXAZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caXAY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.262698848 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { info_tbl: [(caXB7,
                       label: GHC.IO.FD.$fShowFD1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXB7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXB8; else goto caXB9;
       caXB8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXB9: // global
           I64[Sp - 16] = block_caXB4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXBd; else goto caXB5;
       uaXBd: // global
           call _caXB4(R1) args: 0, res: 0, upd: 0;
       caXB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXB4() //  [R1]
         { info_tbl: [(caXB4,
                       label: block_caXB4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXB4: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.263982753 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caXBi,
                       label: GHC.IO.FD.$fShowFD_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXBi: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.264739999 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.265674774 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { info_tbl: [(caXBv,
                       label: output_flags_raWV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXBv: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caXBN; else goto caXBO;
       caXBO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXBQ; else goto caXBP;
       caXBQ: // global
           HpAlloc = 16;
           goto caXBN;
       caXBN: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXBP: // global
           (_caXBo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_caXBo::I64 == 0) goto caXBq; else goto caXBp;
       caXBq: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       caXBp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXBo::I64;
           (_saX3r::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX3v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3r::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3v::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.267086125 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { info_tbl: [(caXC0,
                       label: write_flags_raWV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXC0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXCk; else goto caXCl;
       caXCk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXCl: // global
           (_caXBU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXBU::I64 == 0) goto caXBW; else goto caXBV;
       caXBW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXBV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXBU::I64;
           I64[Sp - 24] = block_caXBX_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXCp; else goto caXBY;
       uaXCp: // global
           call _caXBX(R1) args: 0, res: 0, upd: 0;
       caXBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXBX() //  [R1]
         { info_tbl: [(caXBX,
                       label: block_caXBX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXBX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXCo; else goto caXCn;
       caXCo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXCn: // global
           _saX3D::I64 = I64[R1 + 7];
           (_saX3H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3D::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3H::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.268688079 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { info_tbl: [(caXCz,
                       label: append_flags_raWV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXCz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXCT; else goto caXCU;
       caXCT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXCU: // global
           (_caXCt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXCt::I64 == 0) goto caXCv; else goto caXCu;
       caXCv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXCu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXCt::I64;
           I64[Sp - 24] = block_caXCw_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXCY; else goto caXCx;
       uaXCY: // global
           call _caXCw(R1) args: 0, res: 0, upd: 0;
       caXCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXCw() //  [R1]
         { info_tbl: [(caXCw,
                       label: block_caXCw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXCw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXCX; else goto caXCW;
       caXCX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXCW: // global
           _saX3O::I64 = I64[R1 + 7];
           (_saX3S::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3O::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3S::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.270322798 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { info_tbl: [(caXD8,
                       label: rw_flags_raWV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXD8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXDs; else goto caXDt;
       caXDs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXDt: // global
           (_caXD2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXD2::I64 == 0) goto caXD4; else goto caXD3;
       caXD4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXD3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXD2::I64;
           I64[Sp - 24] = block_caXD5_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXDx; else goto caXD6;
       uaXDx: // global
           call _caXD5(R1) args: 0, res: 0, upd: 0;
       caXD6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXD5() //  [R1]
         { info_tbl: [(caXD5,
                       label: block_caXD5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXD5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXDw; else goto caXDv;
       caXDw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXDv: // global
           _saX3Z::I64 = I64[R1 + 7];
           (_saX43::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3Z::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX43::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.27190008 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { info_tbl: [(caXDI,
                       label: read_flags_raWV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXDI: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caXE0; else goto caXE1;
       caXE1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXE3; else goto caXE2;
       caXE3: // global
           HpAlloc = 16;
           goto caXE0;
       caXE0: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXE2: // global
           (_caXDB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_caXDB::I64 == 0) goto caXDD; else goto caXDC;
       caXDD: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       caXDC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXDB::I64;
           (_saX4c::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX4g::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4c::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4g::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.273651346 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { info_tbl: [(caXEb,
                       label: GHC.IO.FD.$fIODeviceFD16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXEb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXEc; else goto caXEd;
       caXEc: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXEd: // global
           I64[Sp - 8] = block_caXE8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXEl; else goto caXE9;
       uaXEl: // global
           call _caXE8(R1) args: 0, res: 0, upd: 0;
       caXE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXE8() //  [R1]
         { info_tbl: [(caXE8,
                       label: block_caXE8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXE8: // global
           if (I64[R1 + 7] == (-1)) goto caXEk; else goto caXEj;
       caXEk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXEj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.274758634 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.275505511 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { info_tbl: [(caXEs,
                       label: GHC.IO.FD.$fIODeviceFD14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXEs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXEt; else goto caXEu;
       caXEt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXEu: // global
           (_caXEp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXEp::I64 == 0) goto caXEr; else goto caXEq;
       caXEr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXEq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXEp::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.277922611 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_saX4E_entry() //  [R1]
         { info_tbl: [(caXEH,
                       label: sat_saX4E_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXEH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXER; else goto caXEQ;
       caXER: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXEQ: // global
           (_saX4C::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4C::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX4I_entry() //  [R1]
         { info_tbl: [(caXEY,
                       label: sat_saX4I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXEY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXEZ; else goto caXF0;
       caXEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { info_tbl: [(caXF1,
                       label: GHC.IO.FD.$w$ctell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXF1: // global
           _saX4r::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caXF2; else goto caXF3;
       caXF3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXF5; else goto caXF4;
       caXF5: // global
           HpAlloc = 24;
           goto caXF2;
       caXF2: // global
           R2 = _saX4r::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXF4: // global
           (_saX4w::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_saX4E_info;
           I64[Hp - 8] = _saX4r::I64;
           I64[Hp] = _saX4w::I64;
           I64[Sp - 8] = block_caXES_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXES() //  [R1]
         { info_tbl: [(caXES,
                       label: block_caXES_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXES: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXF8; else goto caXF7;
       caXF8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXF7: // global
           I64[Hp - 16] = sat_saX4I_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.279841213 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { info_tbl: [(caXFg,
                       label: GHC.IO.FD.$fIODeviceFD13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXFh; else goto caXFi;
       caXFh: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXFi: // global
           I64[Sp - 8] = block_caXFd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXFm; else goto caXFe;
       uaXFm: // global
           call _caXFd(R1) args: 0, res: 0, upd: 0;
       caXFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXFd() //  [R1]
         { info_tbl: [(caXFd,
                       label: block_caXFd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFd: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.280849427 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.281602276 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { info_tbl: [(caXFt,
                       label: GHC.IO.FD.$fIODeviceFD18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXFu; else goto caXFv;
       caXFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXFv: // global
           (_caXFq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXFq::I64 == 0) goto caXFs; else goto caXFr;
       caXFs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXFr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXFq::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.283348363 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_saX51_entry() //  [R1]
         { info_tbl: [(caXFT,
                       label: sat_saX51_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXFX; else goto caXFW;
       caXFX: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXFW: // global
           (_saX4Z::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4Z::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { info_tbl: [(caXFY,
                       label: GHC.IO.FD.$w$cseek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXFZ; else goto caXG0;
       caXFZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXG0: // global
           I64[Sp - 24] = block_caXFA_info;
           _saX4O::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _saX4O::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXFA() //  [R1]
         { info_tbl: [(caXFA,
                       label: block_caXFA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFA: // global
           I64[Sp] = block_caXG1_info;
           _saX4S::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX4S::I64;
           if (R1 & 7 != 0) goto uaXGA; else goto caXG9;
       uaXGA: // global
           call _caXG1(R1) args: 0, res: 0, upd: 0;
       caXG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXG1() //  [R1]
         { info_tbl: [(caXG1,
                       label: block_caXG1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXG1: // global
           _caXGr::P64 = R1 & 7;
           if (_caXGr::P64 < 3) goto uaXGv; else goto caXGn;
       uaXGv: // global
           if (_caXGr::P64 < 2) goto caXGf; else goto caXGj;
       caXGf: // global
           (_saX59::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX59::I64));
           goto uaXGE;
       caXGj: // global
           (_saX5e::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5e::I64));
           goto uaXGE;
       caXGn: // global
           (_saX5j::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5j::I64));
           goto uaXGE;
       uaXGE: // global
           call _caXFH() args: 0, res: 0, upd: 0;
     }
 },
 _caXFH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFH: // global
           Hp = Hp + 32;
           _saX4U::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caXG6; else goto caXG5;
       caXG6: // global
           HpAlloc = 32;
           I64[Sp] = block_caXFG_info;
           R1 = _saX4U::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXG5: // global
           I64[Hp - 24] = sat_saX51_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX4U::I64;
           I64[Sp + 16] = block_caXG3_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXFG() //  [R1]
         { info_tbl: [(caXFG,
                       label: block_caXFG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXFG: // global
           I64[Sp] = R1;
           call _caXFH() args: 0, res: 0, upd: 0;
     }
 },
 _caXG3() //  []
         { info_tbl: [(caXG3,
                       label: block_caXG3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXG3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.286020698 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { info_tbl: [(caXGM,
                       label: GHC.IO.FD.$fIODeviceFD17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXGM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXGN; else goto caXGO;
       caXGN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXGO: // global
           I64[Sp - 24] = block_caXGJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXGS; else goto caXGK;
       uaXGS: // global
           call _caXGJ(R1) args: 0, res: 0, upd: 0;
       caXGK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXGJ() //  [R1]
         { info_tbl: [(caXGJ,
                       label: block_caXGJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXGJ: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.287092691 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.287684519 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.288280619 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.288847282 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.289606791 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { info_tbl: [(caXGZ,
                       label: lvl4_raWVa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXGZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXH0; else goto caXH1;
       caXH0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXH1: // global
           (_caXGW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXGW::I64 == 0) goto caXGY; else goto caXGX;
       caXGY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXGX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXGW::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.290654538 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { info_tbl: [(caXH8,
                       label: GHC.IO.FD.$fIODeviceFD11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXH8: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.291715098 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { info_tbl: [(caXHh,
                       label: GHC.IO.FD.$wsetSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXHi; else goto caXHj;
       caXHi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXHj: // global
           I64[Sp - 16] = block_caXHf_info;
           _saX5v::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _saX5v::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXHf() //  [R1]
         { info_tbl: [(caXHf,
                       label: block_caXHf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXHf: // global
           (_saX5C::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_saX5C::I64) == 0 :: W32) goto caXHB; else goto caXHv;
       caXHB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXHv: // global
           (_saX5H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX5H::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.293091812 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { info_tbl: [(caXHN,
                       label: GHC.IO.FD.$fIODeviceFD10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXHN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXHO; else goto caXHP;
       caXHO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXHP: // global
           I64[Sp - 16] = block_caXHK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXHT; else goto caXHL;
       uaXHT: // global
           call _caXHK(R1) args: 0, res: 0, upd: 0;
       caXHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXHK() //  [R1]
         { info_tbl: [(caXHK,
                       label: block_caXHK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXHK: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.294266785 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXHY,
                       label: GHC.IO.FD.writeRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXHY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.295184075 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXI5,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXI5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.296085693 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXIc,
                       label: GHC.IO.FD.readRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXIc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.297808642 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXIg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXIm,
                       label: GHC.IO.FD.$w$cfillReadBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXIm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caXIx; else goto caXIy;
       caXIx: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caXIy: // global
           I64[Sp - 32] = block_caXIu_info;
           _saX5T::P64 = R6;
           R6 = 0;
           _saX5S::P64 = R5;
           _saX5W::I64 = I64[Sp + 16];
           R5 = R4 + _saX5W::I64;
           _saX5R::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _saX5W::I64;
           I64[Sp - 24] = _saX5R::I64;
           P64[Sp - 16] = _saX5S::P64;
           P64[Sp - 8] = _saX5T::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caXIu() //  [R1]
         { info_tbl: [(caXIu,
                       label: block_caXIu_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXIu: // global
           I64[Sp] = block_caXIw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXIX; else goto caXIA;
       uaXIX: // global
           call _caXIw(R1) args: 0, res: 0, upd: 0;
       caXIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXIw() //  [R1]
         { info_tbl: [(caXIw,
                       label: block_caXIw_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXIw: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caXIG; else goto caXIF;
       caXIG: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXIF: // global
           _saX5R::I64 = I64[Sp + 8];
           _saX5S::P64 = P64[Sp + 16];
           _saX5T::P64 = P64[Sp + 24];
           _saX5U::I64 = I64[Sp + 32];
           _saX5V::I64 = I64[Sp + 40];
           _saX5W::I64 = I64[Sp + 48];
           _saX66::I64 = I64[R1 + 7];
           if (_saX66::I64 == (-1)) goto caXIW; else goto caXIR;
       caXIW: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _caXIV::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _caXIV::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXIR: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64 + _saX66::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.300360251 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { info_tbl: [(caXJ5,
                       label: GHC.IO.FD.$fBufferedIOFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJ5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXJ9; else goto caXJa;
       caXJ9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXJa: // global
           I64[Sp - 16] = block_caXJ2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXJi; else goto caXJ3;
       uaXJi: // global
           call _caXJ2(R1) args: 0, res: 0, upd: 0;
       caXJ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXJ2() //  [R1]
         { info_tbl: [(caXJ2,
                       label: block_caXJ2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJ2: // global
           I64[Sp - 8] = block_caXJ8_info;
           _saX6j::I64 = I64[R1 + 7];
           _saX6k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6k::I64;
           I64[Sp + 8] = _saX6j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXJh; else goto caXJc;
       uaXJh: // global
           call _caXJ8(R1) args: 0, res: 0, upd: 0;
       caXJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXJ8() //  [R1]
         { info_tbl: [(caXJ8,
                       label: block_caXJ8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJ8: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.302759332 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saX6L_entry() //  [R1]
         { info_tbl: [(caXJE,
                       label: sat_saX6L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJE: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caXJF; else goto caXJG;
       caXJF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXJG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caXJB_info;
           _saX6v::P64 = P64[R1 + 16];
           _saX6w::P64 = P64[R1 + 24];
           _saX6u::I64 = I64[R1 + 40];
           _saX6x::I64 = I64[R1 + 48];
           _saX6y::I64 = I64[R1 + 56];
           _saX6z::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saX6u::I64;
           P64[Sp - 56] = _saX6v::P64;
           P64[Sp - 48] = _saX6w::P64;
           I64[Sp - 40] = _saX6x::I64;
           I64[Sp - 32] = _saX6y::I64;
           I64[Sp - 24] = _saX6z::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaXJY; else goto caXJC;
       uaXJY: // global
           call _caXJB(R1) args: 0, res: 0, upd: 0;
       caXJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXJB() //  [R1]
         { info_tbl: [(caXJB,
                       label: block_caXJB_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caXJL; else goto caXJK;
       caXJL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXJK: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6z::I64 = I64[Sp + 48];
           _saX6J::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_saX6J::I64 == _saX6z::I64) goto caXJX; else goto caXJU;
       caXJX: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXJU: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = _saX6J::I64;
           I64[Hp] = _saX6z::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXJZ,
                       label: GHC.IO.FD.$w$cflushWriteBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXK1; else goto caXK2;
       caXK1: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caXK2: // global
           I64[Sp - 32] = block_caXJu_info;
           _saX6v::P64 = R5;
           _saX6y::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _saX6y::I64;
           _saX6u::I64 = R4;
           R4 = R4 + _saX6y::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _saX6u::I64;
           P64[Sp - 16] = _saX6v::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXJu() //  [R1]
         { info_tbl: [(caXJu,
                       label: block_caXJu_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXJu: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caXK5; else goto caXK4;
       caXK5: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXK4: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6y::I64 = I64[Sp + 40];
           _saX6z::I64 = I64[Sp + 48];
           call MO_Touch(_saX6v::P64);
           I64[Hp - 88] = sat_saX6L_info;
           P64[Hp - 72] = _saX6v::P64;
           P64[Hp - 64] = _saX6w::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saX6u::I64;
           I64[Hp - 40] = _saX6x::I64;
           I64[Hp - 32] = _saX6y::I64;
           I64[Hp - 24] = _saX6z::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.306628505 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { info_tbl: [(caXKd,
                       label: GHC.IO.FD.$fBufferedIOFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXKh; else goto caXKi;
       caXKh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXKi: // global
           I64[Sp - 16] = block_caXKa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXKq; else goto caXKb;
       uaXKq: // global
           call _caXKa(R1) args: 0, res: 0, upd: 0;
       caXKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXKa() //  [R1]
         { info_tbl: [(caXKa,
                       label: block_caXKa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKa: // global
           I64[Sp - 8] = block_caXKg_info;
           _saX6R::I64 = I64[R1 + 7];
           _saX6S::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6S::I64;
           I64[Sp + 8] = _saX6R::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXKp; else goto caXKk;
       uaXKp: // global
           call _caXKg(R1) args: 0, res: 0, upd: 0;
       caXKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXKg() //  [R1]
         { info_tbl: [(caXKg,
                       label: block_caXKg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKg: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.308406104 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_saX7a_entry() //  [R1]
         { info_tbl: [(caXKL,
                       label: sat_saX7a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXKM; else goto caXKX;
       caXKM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXKX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto caXKK; else goto caXKJ;
       caXKK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXKJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { info_tbl: [(caXKY,
                       label: GHC.IO.FD.$fIODeviceFD21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXKZ; else goto caXL0;
       caXKZ: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXL0: // global
           I64[Sp - 8] = block_caXKv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXL4; else goto caXKw;
       uaXL4: // global
           call _caXKv(R1) args: 0, res: 0, upd: 0;
       caXKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXKv() //  [R1]
         { info_tbl: [(caXKv,
                       label: block_caXKv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXKv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXL3; else goto caXL2;
       caXL3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXL2: // global
           (_saX78::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_saX7a_info;
           I64[Hp] = _saX78::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.310294738 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { info_tbl: [(caXLc,
                       label: GHC.IO.FD.$fIODeviceFD25_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXLd; else goto caXLe;
       caXLd: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXLe: // global
           I64[Sp - 8] = block_caXL9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXLm; else goto caXLa;
       uaXLm: // global
           call _caXL9(R1) args: 0, res: 0, upd: 0;
       caXLa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXL9() //  [R1]
         { info_tbl: [(caXL9,
                       label: block_caXL9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXL9: // global
           if (I64[R1 + 7] == (-1)) goto caXLl; else goto caXLk;
       caXLl: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caXLk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.31131157 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.312037124 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { info_tbl: [(caXLt,
                       label: GHC.IO.FD.$fIODeviceFD28_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXLu; else goto caXLv;
       caXLu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXLv: // global
           (_caXLq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXLq::I64 == 0) goto caXLs; else goto caXLr;
       caXLs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXLr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXLq::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.314145758 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_saX7u_entry() //  [R1]
         { info_tbl: [(caXLM,
                       label: sat_saX7u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXM2; else goto caXM3;
       caXM2: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXM3: // global
           I64[Sp - 8] = block_caXLW_info;
           Sp = Sp - 8;
           _caXLS::I64 = I64[R1 + 7];
           _caXLT::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _caXLU::I64 = I64[R1 + 15];
           _uaXM9::P64 = CurrentTSO;
           I64[I64[_uaXM9::P64 + 24] + 16] = Sp;
           _uaXMa::I64 = CurrentNursery;
           P64[_uaXMa::I64 + 8] = Hp + 8;
           I64[_uaXM9::P64 + 104] = I64[_uaXM9::P64 + 104] - ((Hp + 8) - I64[_uaXMa::I64]);
           (_uaXM7::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX7r::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_caXLS::I64, _caXLT::I64, _caXLU::I64, 0);
           (_uaXM8::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXM7::I64);
           BaseReg = _uaXM8::I64;
           _uaXMb::P64 = CurrentTSO;
           _uaXMc::P64 = I64[_uaXMb::P64 + 24];
           Sp = I64[_uaXMc::P64 + 16];
           SpLim = _uaXMc::P64 + 192;
           HpAlloc = 0;
           _uaXMd::I64 = CurrentNursery;
           _uaXMe::I64 = I64[_uaXMd::I64 + 8];
           Hp = _uaXMe::I64 - 8;
           _uaXMf::I64 = I64[_uaXMd::I64];
           HpLim = _uaXMf::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXMd::I64 + 48]) << 12) - 1);
           I64[_uaXMb::P64 + 104] = I64[_uaXMb::P64 + 104] + (_uaXMe::I64 - _uaXMf::I64);
           R1 = _saX7r::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXLW() //  [R1]
         { info_tbl: [(caXLW,
                       label: block_caXLW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXM6; else goto caXM5;
       caXM6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXM5: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX7B_entry() //  [R1]
         { info_tbl: [(caXMq,
                       label: sat_saX7B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXMq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXMr; else goto caXMs;
       caXMr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXMs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caXMn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXMC; else goto caXMo;
       uaXMC: // global
           call _caXMn(R1) args: 0, res: 0, upd: 0;
       caXMo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXMn() //  [R1]
         { info_tbl: [(caXMn,
                       label: block_caXMn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXMn: // global
           _saX7A::I64 = I64[R1 + 7];
           if (_saX7A::I64 != 0) goto uaXMB; else goto caXMz;
       uaXMB: // global
           if (_saX7A::I64 != 1) goto caXMy; else goto caXMA;
       caXMy: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caXMA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXMz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { info_tbl: [(caXMK,
                       label: GHC.IO.FD.$w$cready_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 18} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXMK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXML; else goto caXMM;
       caXML: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXMM: // global
           I64[Sp - 24] = block_caXMD_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXN5; else goto caXME;
       uaXN5: // global
           call _caXMD(R1) args: 0, res: 0, upd: 0;
       caXME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXMD() //  [R1]
         { info_tbl: [(caXMD,
                       label: block_caXMD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXMD: // global
           if (R1 & 7 == 1) goto caXMH; else goto caXMI;
       caXMH: // global
           I64[Sp] = 0;
           goto uaXN4;
       caXMI: // global
           I64[Sp] = 1;
           goto uaXN4;
       uaXN4: // global
           call _caXLD() args: 0, res: 0, upd: 0;
     }
 },
 _caXLD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLD: // global
           Hp = Hp + 32;
           _saX7k::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caXMP; else goto caXMO;
       caXMP: // global
           HpAlloc = 32;
           I64[Sp] = block_caXLC_info;
           R1 = _saX7k::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXMO: // global
           I64[Hp - 24] = sat_saX7u_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX7k::I64;
           I64[Sp + 16] = block_caXMh_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXLC() //  [R1]
         { info_tbl: [(caXLC,
                       label: block_caXLC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXLC: // global
           I64[Sp] = R1;
           call _caXLD() args: 0, res: 0, upd: 0;
     }
 },
 _caXMh() //  [R1]
         { info_tbl: [(caXMh,
                       label: block_caXMh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXMh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXMS; else goto caXMR;
       caXMS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXMR: // global
           I64[Hp - 16] = sat_saX7B_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.317549509 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { info_tbl: [(caXNd,
                       label: GHC.IO.FD.$fIODeviceFD27_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXNh; else goto caXNi;
       caXNh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXNi: // global
           I64[Sp - 24] = block_caXNa_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXNq; else goto caXNb;
       uaXNq: // global
           call _caXNa(R1) args: 0, res: 0, upd: 0;
       caXNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXNa() //  [R1]
         { info_tbl: [(caXNa,
                       label: block_caXNa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNa: // global
           I64[Sp] = block_caXNg_info;
           _saX7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX7I::I64;
           if (R1 & 7 != 0) goto uaXNp; else goto caXNk;
       uaXNp: // global
           call _caXNg(R1) args: 0, res: 0, upd: 0;
       caXNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXNg() //  [R1]
         { info_tbl: [(caXNg,
                       label: block_caXNg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNg: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.319506254 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_saX7W_entry() //  [R1]
         { info_tbl: [(caXNN,
                       label: sat_saX7W_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXNO; else goto caXNP;
       caXNO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXNP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caXNG_info;
           _saX7Q::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX7Q::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXO2; else goto caXNH;
       uaXO2: // global
           call _caXNG(R1) args: 0, res: 0, upd: 0;
       caXNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXNG() //  [R1]
         { info_tbl: [(caXNG,
                       label: block_caXNG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNG: // global
           _saX7Q::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caXNK; else goto caXNL;
       caXNK: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXO1; else goto caXNU;
       caXNU: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXNL: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXO1; else goto caXO0;
       caXO1: // global
           HpAlloc = 24;
           R1 = _saX7V::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXO0: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { info_tbl: [(caXO3,
                       label: GHC.IO.FD.setNonBlockingMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXO3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXO4; else goto caXO5;
       caXO4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXO5: // global
           I64[Sp - 16] = block_caXNv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXOa; else goto caXNw;
       uaXOa: // global
           call _caXNv(R1) args: 0, res: 0, upd: 0;
       caXNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXNv() //  [R1]
         { info_tbl: [(caXNv,
                       label: block_caXNv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNv: // global
           I64[Sp - 8] = block_caXNA_info;
           R3 = P64[Sp + 8];
           _saX7Q::I64 = I64[R1 + 7];
           R2 = _saX7Q::I64;
           I64[Sp] = _saX7Q::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXNA() //  [R1]
         { info_tbl: [(caXNA,
                       label: block_caXNA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXNA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caXO9; else goto caXO8;
       caXO9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXO8: // global
           I64[Hp - 24] = sat_saX7W_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.321764275 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { info_tbl: [(caXOf,
                       label: GHC.IO.FD.setNonBlockingMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.322477255 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.323183772 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { info_tbl: [(caXOo,
                       label: lvl6_raWVc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXOp; else goto caXOq;
       caXOp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXOq: // global
           (_caXOl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXOl::I64 == 0) goto caXOn; else goto caXOm;
       caXOn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXOm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXOl::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.324215066 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { info_tbl: [(caXOx,
                       label: GHC.IO.FD.$fIODeviceFD2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOx: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.325436235 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { info_tbl: [(caXOM,
                       label: GHC.IO.FD.$w$cdup2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXON; else goto caXOO;
       caXON: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXOO: // global
           _saX82::I64 = R4;
           _saX81::I64 = R3;
           _caXOG::I64 = R4;
           (_saX87::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _caXOG::I64);
           _saX88::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX87::I64));
           if (_saX88::I64 != (-1)) goto uaXP3; else goto caXOL;
       uaXP3: // global
           I64[Sp - 24] = _saX81::I64;
           I64[Sp - 16] = _saX82::I64;
           I64[Sp - 8] = _saX88::I64;
           Sp = Sp - 24;
           call _caXOR() args: 0, res: 0, upd: 0;
       caXOL: // global
           (_saX8d::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX8d::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caXOR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXOW; else goto caXOV;
       caXOW: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caXOQ_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXOV: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXOQ() //  [R1]
         { info_tbl: [(caXOQ,
                       label: block_caXOQ_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXOQ: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caXOR() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.32717788 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { info_tbl: [(caXPe,
                       label: GHC.IO.FD.$fIODeviceFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXPi; else goto caXPj;
       caXPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXPj: // global
           I64[Sp - 16] = block_caXPb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaXPr; else goto caXPc;
       uaXPr: // global
           call _caXPb(R1) args: 0, res: 0, upd: 0;
       caXPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXPb() //  [R1]
         { info_tbl: [(caXPb,
                       label: block_caXPb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPb: // global
           I64[Sp - 8] = block_caXPh_info;
           _saX8j::I64 = I64[R1 + 7];
           _saX8k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX8k::I64;
           I64[Sp + 8] = _saX8j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXPq; else goto caXPl;
       uaXPq: // global
           call _caXPh(R1) args: 0, res: 0, upd: 0;
       caXPl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXPh() //  [R1]
         { info_tbl: [(caXPh,
                       label: block_caXPh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPh: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.328454378 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.329177959 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { info_tbl: [(caXPy,
                       label: GHC.IO.FD.$fIODeviceFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXPz; else goto caXPA;
       caXPz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXPA: // global
           (_caXPv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXPv::I64 == 0) goto caXPx; else goto caXPw;
       caXPx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXPw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXPv::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.331940154 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_saX8C_entry() //  [R1]
         { info_tbl: [(caXPX,
                       label: sat_saX8C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXQ1; else goto caXQ2;
       caXQ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXQ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caXPU_info;
           _saX8p::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX8p::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXQ6; else goto caXPV;
       uaXQ6: // global
           call _caXPU(R1) args: 0, res: 0, upd: 0;
       caXPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXPU() //  [R1]
         { info_tbl: [(caXPU,
                       label: block_caXPU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXQ5; else goto caXQ4;
       caXQ5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXQ4: // global
           _saX8B::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8B::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { info_tbl: [(caXQa,
                       label: GHC.IO.FD.$w$cdup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXQb; else goto caXQc;
       caXQb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXQc: // global
           _saX8p::I64 = R3;
           (_saX8u::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _saX8v::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX8u::I64));
           if (_saX8v::I64 != (-1)) goto uaXQo; else goto caXQ9;
       uaXQo: // global
           I64[Sp - 16] = _saX8p::I64;
           I64[Sp - 8] = _saX8v::I64;
           Sp = Sp - 16;
           call _caXQe() args: 0, res: 0, upd: 0;
       caXQ9: // global
           I64[Sp - 16] = block_caXPO_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _saX8p::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXQe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQe: // global
           Hp = Hp + 24;
           _saX8v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caXQj; else goto caXQi;
       caXQj: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caXQd_info;
           R1 = _saX8v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXQi: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8v::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXQd() //  [R1]
         { info_tbl: [(caXQd,
                       label: block_caXQd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQd: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caXQe() args: 0, res: 0, upd: 0;
     }
 },
 _caXPO() //  [R1]
         { info_tbl: [(caXPO,
                       label: block_caXPO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXPO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caXQn; else goto caXQm;
       caXQn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXQm: // global
           I64[Hp - 24] = sat_saX8C_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.334518208 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { info_tbl: [(caXQz,
                       label: GHC.IO.FD.$fIODeviceFD3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXQA; else goto caXQB;
       caXQA: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXQB: // global
           I64[Sp - 8] = block_caXQw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXQF; else goto caXQx;
       uaXQF: // global
           call _caXQw(R1) args: 0, res: 0, upd: 0;
       caXQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXQw() //  [R1]
         { info_tbl: [(caXQw,
                       label: block_caXQw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQw: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.33597552 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_saX8N_entry() //  [R1]
         { info_tbl: [(caXQR,
                       label: sat_saX8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXQV; else goto caXQW;
       caXQV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXQW: // global
           I64[Sp - 8] = block_caXQO_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXR0; else goto caXQP;
       uaXR0: // global
           call _caXQO(R1) args: 0, res: 0, upd: 0;
       caXQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXQO() //  [R1]
         { info_tbl: [(caXQO,
                       label: block_caXQO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXQZ; else goto caXQY;
       caXQZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXQY: // global
           _saX8L::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8L::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { info_tbl: [(caXR6,
                       label: GHC.IO.FD.$fIODeviceFD6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXR6: // global
           _saX8I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caXR7; else goto caXR8;
       caXR8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXRa; else goto caXR9;
       caXRa: // global
           HpAlloc = 24;
           goto caXR7;
       caXR7: // global
           R2 = _saX8I::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXR9: // global
           I64[Hp - 16] = sat_saX8N_info;
           P64[Hp] = _saX8I::P64;
           I64[Sp - 8] = block_caXR1_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXR1() //  [R1]
         { info_tbl: [(caXR1,
                       label: block_caXR1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXR1: // global
           I64[Sp] = block_caXR3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXRf; else goto caXR4;
       uaXRf: // global
           call _caXR3(R1) args: 0, res: 0, upd: 0;
       caXR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXR3() //  [R1]
         { info_tbl: [(caXR3,
                       label: block_caXR3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXR3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.338462159 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_saX90_entry() //  [R1]
         { info_tbl: [(caXRr,
                       label: sat_saX90_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXRv; else goto caXRw;
       caXRv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXRw: // global
           I64[Sp - 8] = block_caXRo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXRA; else goto caXRp;
       uaXRA: // global
           call _caXRo(R1) args: 0, res: 0, upd: 0;
       caXRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXRo() //  [R1]
         { info_tbl: [(caXRo,
                       label: block_caXRo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXRz; else goto caXRy;
       caXRz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXRy: // global
           _saX8Y::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8Y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX99_entry() //  [R1]
         { info_tbl: [(caXRU,
                       label: sat_saX99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXRV; else goto caXRW;
       caXRV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXRW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caXRM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaXS7; else goto caXRN;
       uaXS7: // global
           call _caXRM(R1) args: 0, res: 0, upd: 0;
       caXRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXRM() //  [R1]
         { info_tbl: [(caXRM,
                       label: block_caXRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRM: // global
           _caXRT::P64 = R1 & 7;
           if (_caXRT::P64 == 3) goto caXRS; else goto uaXS6;
       uaXS6: // global
           if (_caXRT::P64 == 4) goto caXRS; else goto caXRQ;
       caXRS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXRQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { info_tbl: [(caXS8,
                       label: GHC.IO.FD.$fIODeviceFD20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXS8: // global
           _saX8V::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caXS9; else goto caXSa;
       caXSa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXSc; else goto caXSb;
       caXSc: // global
           HpAlloc = 24;
           goto caXS9;
       caXS9: // global
           R2 = _saX8V::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXSb: // global
           I64[Hp - 16] = sat_saX90_info;
           P64[Hp] = _saX8V::P64;
           I64[Sp - 8] = block_caXRB_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXRB() //  [R1]
         { info_tbl: [(caXRB,
                       label: block_caXRB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRB: // global
           I64[Sp] = block_caXRD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXSh; else goto caXRE;
       uaXSh: // global
           call _caXRD(R1) args: 0, res: 0, upd: 0;
       caXRE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXRD() //  [R1]
         { info_tbl: [(caXRD,
                       label: block_caXRD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caXSg; else goto caXSf;
       caXSg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXSf: // global
           _saX95::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_saX99_info;
           P64[Hp] = _saX95::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.34091195 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { info_tbl: [(caXSp,
                       label: GHC.IO.FD.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXSp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXSq; else goto caXSr;
       caXSq: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXSr: // global
           I64[Sp - 8] = block_caXSm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXSx; else goto caXSn;
       uaXSx: // global
           call _caXSm(R1) args: 0, res: 0, upd: 0;
       caXSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXSm() //  [R1]
         { info_tbl: [(caXSm,
                       label: block_caXSm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXSm: // global
           (_saX9i::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.342014719 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { info_tbl: [(caXSC,
                       label: GHC.IO.FD.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXSC: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.342733344 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.343427705 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { info_tbl: [(caXSL,
                       label: GHC.IO.FD.$fIODeviceFD23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXSL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXSM; else goto caXSN;
       caXSM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXSN: // global
           (_caXSI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXSI::I64 == 0) goto caXSK; else goto caXSJ;
       caXSK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXSJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXSI::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.344721958 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_saX9t_entry() //  [R1]
         { info_tbl: [(caXSZ,
                       label: sat_saX9t_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXSZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXTa; else goto caXT9;
       caXTa: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXT9: // global
           (_saX9q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9q::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { info_tbl: [(caXTd,
                       label: GHC.IO.FD.$wclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXTd: // global
           _saX9j::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caXTe; else goto caXTf;
       caXTf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXTh; else goto caXTg;
       caXTh: // global
           HpAlloc = 16;
           goto caXTe;
       caXTe: // global
           R2 = _saX9j::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXTg: // global
           I64[Hp - 8] = sat_saX9t_info;
           I64[Hp] = _saX9j::I64;
           I64[Sp - 8] = block_caXTb_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caXTb() //  []
         { info_tbl: [(caXTb,
                       label: block_caXTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXTb: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.346487375 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { info_tbl: [(caXTq,
                       label: GHC.IO.FD.$fIODeviceFD26_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXTq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXTr; else goto caXTs;
       caXTr: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXTs: // global
           I64[Sp - 8] = block_caXTn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXTw; else goto caXTo;
       uaXTw: // global
           call _caXTn(R1) args: 0, res: 0, upd: 0;
       caXTo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXTn() //  [R1]
         { info_tbl: [(caXTn,
                       label: block_caXTn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXTn: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.347976513 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_saX9W_entry() //  [R1]
         { info_tbl: [(caXTO,
                       label: sat_saX9W_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXTO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXTZ; else goto caXTY;
       caXTZ: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXTY: // global
           (_saX9T::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9T::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { info_tbl: [(caXU3,
                       label: GHC.IO.FD.$w$cclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXU3: // global
           _saX9B::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caXU4; else goto caXU5;
       caXU5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXU7; else goto caXU6;
       caXU7: // global
           HpAlloc = 16;
           goto caXU4;
       caXU4: // global
           R2 = _saX9B::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXU6: // global
           (_saX9G::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_saX9B::I64);
           (_saX9K::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX9K::I64 == 0) goto caXU2; else goto caXU1;
       caXU2: // global
           I64[Hp - 8] = sat_saX9W_info;
           I64[Hp] = _saX9B::I64;
           I64[Sp - 8] = block_caXUc_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       caXU1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9B::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _caXUc() //  []
         { info_tbl: [(caXUc,
                       label: block_caXUc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUc: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.349749801 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { info_tbl: [(caXUm,
                       label: GHC.IO.FD.$fIODeviceFD22_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXUn; else goto caXUo;
       caXUn: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caXUo: // global
           I64[Sp - 8] = block_caXUj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXUs; else goto caXUk;
       uaXUs: // global
           call _caXUj(R1) args: 0, res: 0, upd: 0;
       caXUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXUj() //  [R1]
         { info_tbl: [(caXUj,
                       label: block_caXUj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUj: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.350759915 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.351450401 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.352192177 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { info_tbl: [(caXUz,
                       label: GHC.IO.FD.mkFD6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXUA; else goto caXUB;
       caXUA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXUB: // global
           (_caXUw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXUw::I64 == 0) goto caXUy; else goto caXUx;
       caXUy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXUx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXUw::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.353086644 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.353883775 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { info_tbl: [(caXUI,
                       label: GHC.IO.FD.mkFD10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXUJ; else goto caXUK;
       caXUJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXUK: // global
           (_caXUF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXUF::I64 == 0) goto caXUH; else goto caXUG;
       caXUH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXUG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXUF::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.354819539 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.35561735 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { info_tbl: [(caXUR,
                       label: GHC.IO.FD.mkFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXUR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXUS; else goto caXUT;
       caXUS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXUT: // global
           (_caXUO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXUO::I64 == 0) goto caXUQ; else goto caXUP;
       caXUQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXUP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXUO::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.356569005 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.357532976 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { info_tbl: [(caXV0,
                       label: GHC.IO.FD.mkFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXV0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXV1; else goto caXV2;
       caXV1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXV2: // global
           (_caXUX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXUX::I64 == 0) goto caXUZ; else goto caXUY;
       caXUZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXUY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXUX::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.359396561 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.360179786 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { info_tbl: [(caXV9,
                       label: GHC.IO.FD.mkFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXV9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caXVa; else goto caXVb;
       caXVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXVb: // global
           (_caXV6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caXV6::I64 == 0) goto caXV8; else goto caXV7;
       caXV8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caXV7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caXV6::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.363688992 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_saXaj_entry() //  [R1]
         { info_tbl: [(caXVx,
                       label: sat_saXaj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXVx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXVy; else goto caXVz;
       caXVy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caXVu_info;
           _saXa8::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saXa8::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXVX; else goto caXVv;
       uaXVX: // global
           call _caXVu(R1) args: 0, res: 0, upd: 0;
       caXVv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXVu() //  [R1]
         { info_tbl: [(caXVu,
                       label: block_caXVu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXVu: // global
           I64[Sp] = block_caXVC_info;
           _saXah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saXah::I64;
           if (R1 & 7 != 0) goto uaXVW; else goto caXVE;
       uaXVW: // global
           call _caXVC(R1) args: 0, res: 0, upd: 0;
       caXVE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXVC() //  [R1]
         { info_tbl: [(caXVC,
                       label: block_caXVC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXVC: // global
           _saXah::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caXVK; else goto caXVR;
       caXVK: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXVU; else goto caXVM;
       caXVM: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXVR: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXVU; else goto caXVT;
       caXVU: // global
           HpAlloc = 24;
           R1 = _saXai::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXVT: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saXaG_entry() //  [R1]
         { info_tbl: [(caXWX,
                       label: sat_saXaG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXWX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caXWY; else goto caXWZ;
       caXWY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caXWZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caXWQ_info;
           _saXan::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saXan::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXXc; else goto caXWR;
       uaXXc: // global
           call _caXWQ(R1) args: 0, res: 0, upd: 0;
       caXWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caXWQ() //  [R1]
         { info_tbl: [(caXWQ,
                       label: block_caXWQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXWQ: // global
           _saXan::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caXWU; else goto caXWV;
       caXWU: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXXb; else goto caXX4;
       caXX4: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caXWV: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caXXb; else goto caXXa;
       caXXb: // global
           HpAlloc = 24;
           R1 = _saXaF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caXXa: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caXXk,
                       label: GHC.IO.FD.$wmkFD_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXXk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caXXl; else goto caXXm;
       caXXl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXXm: // global
           I64[Sp - 32] = block_caXXd_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXYR; else goto caXXe;
       uaXYR: // global
           call _caXXd(R1) args: 0, res: 0, upd: 0;
       caXXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXXd() //  [R1]
         { info_tbl: [(caXXd,
                       label: block_caXXd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXXd: // global
           if (R1 & 7 == 1) goto caXXh; else goto caXXi;
       caXXh: // global
           I64[Sp] = block_caXYf_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       caXXi: // global
           I64[Sp] = block_caXYr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaXYQ; else goto caXYt;
       uaXYQ: // global
           call _caXYr(R1) args: 0, res: 0, upd: 0;
       caXYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXYf() //  [R1]
         { info_tbl: [(caXYf,
                       label: block_caXYf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXYf: // global
           I64[Sp] = block_caXYh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaXYT; else goto caXYk;
       uaXYT: // global
           call _caXYh(R1) args: 0, res: 0, upd: 0;
       caXYk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXYh() //  [R1]
         { info_tbl: [(caXYh,
                       label: block_caXYh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXYh: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _caXYr() //  [R1]
         { info_tbl: [(caXYr,
                       label: block_caXYr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXYr: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _saXaa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saXaa: // global
           I64[Sp - 8] = block_caXVl_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaXYW; else goto caXVm;
       uaXYW: // global
           call _caXVl(R1) args: 0, res: 0, upd: 0;
       caXVm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXVl() //  [R1]
         { info_tbl: [(caXVl,
                       label: block_caXVl_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXVl: // global
           _caXYE::P64 = R1 & 7;
           if (_caXYE::P64 == 1) goto caXXw; else goto uaXYG;
       caXXw: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaXYG: // global
           _saXa5::P64 = P64[Sp + 32];
           if (_caXYE::P64 == 3) goto caXXy; else goto caXXq;
       caXXy: // global
           I64[Sp] = block_caXW1_info;
           R1 = _saXa5::P64;
           if (R1 & 7 != 0) goto uaXYL; else goto caXW2;
       uaXYL: // global
           call _caXW1(R1) args: 0, res: 0, upd: 0;
       caXW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caXXq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caXXt; else goto caXXs;
       caXXt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXXs: // global
           I64[Hp - 48] = sat_saXaj_info;
           P64[Hp - 32] = _saXa5::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXW1() //  [R1]
         { info_tbl: [(caXW1,
                       label: block_caXW1_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXW1: // global
           _saXad::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caXW6_info;
           _saXan::I64 = I64[R1 + 7];
           R1 = _saXad::P64;
           I64[Sp + 32] = _saXan::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaXYM; else goto caXW7;
       uaXYM: // global
           call _caXW6(R1) args: 0, res: 0, upd: 0;
       caXW7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXW6() //  [R1]
         { info_tbl: [(caXW6,
                       label: block_caXW6_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXW6: // global
           _saXae::P64 = P64[Sp + 8];
           _saXap::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXap::I64, 0)) goto caXYb; else goto caXYc;
       caXYb: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       caXYc: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       saXar: // global
           I64[Sp + 8] = block_caXWj_info;
           R1 = _saXae::P64;
           I64[Sp + 16] = _saXas::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaXYN; else goto caXWk;
       uaXYN: // global
           call _caXWj(R1) args: 0, res: 0, upd: 0;
       caXWk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXWj() //  [R1]
         { info_tbl: [(caXWj,
                       label: block_caXWj_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXWj: // global
           _saXa6::P64 = P64[Sp + 24];
           _saXau::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXau::I64, 0)) goto caXY6; else goto caXY7;
       caXY6: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       caXY7: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       saXaw: // global
           I64[Sp] = block_caXXD_info;
           R1 = _saXa6::P64;
           I64[Sp + 24] = _saXax::I64;
           if (R1 & 7 != 0) goto uaXYO; else goto caXXS;
       uaXYO: // global
           call _caXXD(R1) args: 0, res: 0, upd: 0;
       caXXS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXXD() //  [R1]
         { info_tbl: [(caXXD,
                       label: block_caXXD_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXXD: // global
           _saXan::I64 = I64[Sp + 16];
           _saXas::I64 = I64[Sp + 8];
           _saXax::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto caXY2; else goto caXXY;
       caXY2: // global
           _saXaz::I64 = 0;
           goto saXay;
       caXXY: // global
           _saXaz::I64 = 1;
           goto saXay;
       saXay: // global
           (_saXaD::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_saXan::I64, _saXas::I64, _saXax::I64, _saXaz::I64);
           _saXaE::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXaD::I64));
           if (_saXaE::I64 != (-1)) goto uaXYJ; else goto caXXO;
       uaXYJ: // global
           I64[Sp + 24] = _saXaE::I64;
           Sp = Sp + 16;
           call _caXWK() args: 0, res: 0, upd: 0;
       caXXO: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXWK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXWK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caXXL; else goto caXXK;
       caXXL: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caXWJ_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXXK: // global
           I64[Hp - 48] = sat_saXaG_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXWJ() //  [R1]
         { info_tbl: [(caXWJ,
                       label: block_caXWJ_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXWJ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caXWK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.369126509 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { info_tbl: [(caXZ1,
                       label: GHC.IO.FD.mkFD1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZ1: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.370284369 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caXZ8,
                       label: GHC.IO.FD.mkFD_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZ8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.37512233 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_saXbr_entry() //  [R1]
         { info_tbl: [(caXZJ,
                       label: sat_saXbr_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caXZM; else goto caXZN;
       caXZM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caXZN: // global
           I64[Sp - 8] = block_caXZF_info;
           Sp = Sp - 8;
           _caXZC::I64 = I64[R1 + 7];
           _caXZD::I64 = I64[R1 + 15];
           _uaXZT::P64 = CurrentTSO;
           I64[I64[_uaXZT::P64 + 24] + 16] = Sp;
           _uaXZU::I64 = CurrentNursery;
           P64[_uaXZU::I64 + 8] = Hp + 8;
           I64[_uaXZT::P64 + 104] = I64[_uaXZT::P64 + 104] - ((Hp + 8) - I64[_uaXZU::I64]);
           (_uaXZR::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saXbo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_caXZC::I64, _caXZD::I64, 438);
           (_uaXZS::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaXZR::I64);
           BaseReg = _uaXZS::I64;
           _uaXZV::P64 = CurrentTSO;
           _uaXZW::P64 = I64[_uaXZV::P64 + 24];
           Sp = I64[_uaXZW::P64 + 16];
           SpLim = _uaXZW::P64 + 192;
           HpAlloc = 0;
           _uaXZX::I64 = CurrentNursery;
           _uaXZY::I64 = I64[_uaXZX::I64 + 8];
           Hp = _uaXZY::I64 - 8;
           _uaXZZ::I64 = I64[_uaXZX::I64];
           HpLim = _uaXZZ::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaXZX::I64 + 48]) << 12) - 1);
           I64[_uaXZV::P64 + 104] = I64[_uaXZV::P64 + 104] + (_uaXZY::I64 - _uaXZZ::I64);
           R1 = _saXbo::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXZF() //  [R1]
         { info_tbl: [(caXZF,
                       label: block_caXZF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caXZQ; else goto caXZP;
       caXZQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caXZP: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbI_entry() //  [R1]
         { info_tbl: [(caY0l,
                       label: sat_saXbI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caY0m; else goto caY0n;
       caY0m: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caY0n: // global
           I64[Sp - 24] = block_caY0i_info;
           _saXbz::P64 = P64[R1 + 15];
           _saXbA::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _saXbz::P64;
           P64[Sp - 8] = _saXbA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaY0t; else goto caY0j;
       uaY0t: // global
           call _caY0i(R1) args: 0, res: 0, upd: 0;
       caY0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY0i() //  [R1]
         { info_tbl: [(caY0i,
                       label: block_caY0i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0i: // global
           _saXbz::P64 = P64[Sp + 8];
           _saXbA::P64 = P64[Sp + 16];
           (_saXbH::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _saXbA::P64;
           R2 = _saXbz::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbJ_entry() //  [R1, R2]
         { info_tbl: [(caY0u,
                       label: sat_saXbJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caY0v; else goto caY0w;
       caY0v: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caY0w: // global
           I64[Sp - 16] = block_caY08_info;
           _saXbu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _saXbu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaY0A; else goto caY09;
       uaY0A: // global
           call _caY08(R1) args: 0, res: 0, upd: 0;
       caY09: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY08() //  [R1]
         { info_tbl: [(caY08,
                       label: block_caY08_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY08: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caY0z; else goto caY0y;
       caY0z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY0y: // global
           _saXbz::P64 = P64[R1 + 7];
           _saXbA::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_saXbI_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _saXbz::P64;
           P64[Hp] = _saXbA::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbw_entry() //  [R1]
         { info_tbl: [(caY0G,
                       label: sat_saXbw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0G: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaY5j_srtd" {
     uaY5j_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_saXcZ_entry() //  [R1, R2]
         { info_tbl: [(caY0J,
                       label: sat_saXcZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caY0K; else goto caY0L;
       caY0K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caY0L: // global
           I64[Sp - 24] = block_caXZm_info;
           _saXb8::P64 = P64[R1 + 6];
           _saXb9::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _saXb8::P64;
           P64[Sp - 8] = _saXb9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaY4M; else goto caXZn;
       uaY4M: // global
           call _caXZm(R1) args: 0, res: 0, upd: 0;
       caXZn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5k_srtd" {
     uaY5k_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caXZm() //  [R1]
         { info_tbl: [(caXZm,
                       label: block_caXZm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZm: // global
           I64[Sp - 8] = block_caY0M_info;
           _saXbh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saXbh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaY4K; else goto caY1S;
       uaY4K: // global
           call _caY0M(R1) args: 0, res: 0, upd: 0;
       caY1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5l_srtd" {
     uaY5l_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caY0M() //  [R1]
         { info_tbl: [(caY0M,
                       label: block_caY0M_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0M: // global
           _saXb8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto caY1Z; else goto caY2L;
       caY1Z: // global
           I64[Sp] = block_caY1W_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto uaY4N; else goto caY20;
       uaY4N: // global
           call _caY1W(R1) args: 0, res: 0, upd: 0;
       caY20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caY2L: // global
           I64[Sp] = block_caY2J_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto uaY4O; else goto caY2M;
       uaY4O: // global
           call _caY2J(R1) args: 0, res: 0, upd: 0;
       caY2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5m_srtd" {
     uaY5m_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caY1W() //  [R1]
         { info_tbl: [(caY1W,
                       label: block_caY1W_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1W: // global
           _caY4p::P64 = R1 & 7;
           if (_caY4p::P64 < 3) goto uaY4t; else goto uaY4u;
       uaY4t: // global
           if (_caY4p::P64 < 2) goto caY27; else goto caY2h;
       caY27: // global
           I64[Sp] = block_caY24_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto uaY4X; else goto caY28;
       uaY4X: // global
           call _caY24(R1) args: 0, res: 0, upd: 0;
       caY28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caY2h: // global
           I64[Sp] = block_caY2f_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto uaY4Y; else goto caY2i;
       uaY4Y: // global
           call _caY2f(R1) args: 0, res: 0, upd: 0;
       caY2i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaY4u: // global
           if (_caY4p::P64 < 4) goto caY2r; else goto caY2B;
       caY2r: // global
           I64[Sp] = block_caY2p_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto uaY4Z; else goto caY2s;
       uaY4Z: // global
           call _caY2p(R1) args: 0, res: 0, upd: 0;
       caY2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caY2B: // global
           I64[Sp] = block_caY2z_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto uaY50; else goto caY2C;
       uaY50: // global
           call _caY2z(R1) args: 0, res: 0, upd: 0;
       caY2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5n_srtd" {
     uaY5n_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY24() //  [R1]
         { info_tbl: [(caY24,
                       label: block_caY24_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY24: // global
           I64[Sp] = I64[R1 + 7];
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5o_srtd" {
     uaY5o_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY2f() //  [R1]
         { info_tbl: [(caY2f,
                       label: block_caY2f_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY2f: // global
           I64[Sp] = I64[R1 + 7];
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5p_srtd" {
     uaY5p_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY2p() //  [R1]
         { info_tbl: [(caY2p,
                       label: block_caY2p_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY2p: // global
           I64[Sp] = I64[R1 + 7];
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5q_srtd" {
     uaY5q_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY2z() //  [R1]
         { info_tbl: [(caY2z,
                       label: block_caY2z_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY2z: // global
           I64[Sp] = I64[R1 + 7];
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5r_srtd" {
     uaY5r_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caY2J() //  [R1]
         { info_tbl: [(caY2J,
                       label: block_caY2J_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY2J: // global
           _caY3u::P64 = R1 & 7;
           if (_caY3u::P64 < 3) goto uaY4v; else goto uaY4w;
       uaY4v: // global
           if (_caY3u::P64 < 2) goto caY2T; else goto caY33;
       caY2T: // global
           I64[Sp] = block_caY2Q_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto uaY55; else goto caY2U;
       uaY55: // global
           call _caY2Q(R1) args: 0, res: 0, upd: 0;
       caY2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caY33: // global
           I64[Sp] = block_caY31_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto uaY56; else goto caY34;
       uaY56: // global
           call _caY31(R1) args: 0, res: 0, upd: 0;
       caY34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaY4w: // global
           if (_caY3u::P64 < 4) goto caY3d; else goto caY3n;
       caY3d: // global
           I64[Sp] = block_caY3b_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto uaY57; else goto caY3e;
       uaY57: // global
           call _caY3b(R1) args: 0, res: 0, upd: 0;
       caY3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caY3n: // global
           I64[Sp] = block_caY3l_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto uaY58; else goto caY3o;
       uaY58: // global
           call _caY3l(R1) args: 0, res: 0, upd: 0;
       caY3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5s_srtd" {
     uaY5s_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY2Q() //  [R1]
         { info_tbl: [(caY2Q,
                       label: block_caY2Q_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY2Q: // global
           _saXci::I64 = I64[R1 + 7];
           (_saXcm::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXci::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcm::I64));
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5t_srtd" {
     uaY5t_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY31() //  [R1]
         { info_tbl: [(caY31,
                       label: block_caY31_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY31: // global
           _saXct::I64 = I64[R1 + 7];
           (_saXcx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXct::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcx::I64));
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5u_srtd" {
     uaY5u_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY3b() //  [R1]
         { info_tbl: [(caY3b,
                       label: block_caY3b_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY3b: // global
           _saXcE::I64 = I64[R1 + 7];
           (_saXcI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcE::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcI::I64));
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5v_srtd" {
     uaY5v_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caY3l() //  [R1]
         { info_tbl: [(caY3l,
                       label: block_caY3l_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY3l: // global
           _saXcP::I64 = I64[R1 + 7];
           (_saXcT::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcP::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcT::I64));
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 _caXZu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZu: // global
           Hp = Hp + 24;
           _saXbj::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caY0T; else goto caY0S;
       caY0T: // global
           HpAlloc = 24;
           I64[Sp] = block_caXZt_info;
           R1 = _saXbj::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caY0S: // global
           I64[Hp - 16] = sat_saXbr_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saXbj::I64;
           I64[Sp + 8] = block_caY01_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5w_srtd" {
     uaY5w_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caXZt() //  [R1]
         { info_tbl: [(caXZt,
                       label: block_caXZt_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZt: // global
           I64[Sp] = R1;
           call _caXZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaY5x_srtd" {
     uaY5x_srtd:
         const SaXeV_srt+352;
         const 39;
         const 274877906945;
 },
 _caY01() //  [R1]
         { info_tbl: [(caY01,
                       label: block_caY01_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY01: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caY0W; else goto caY0V;
       caY0W: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY0V: // global
           I64[Hp - 40] = sat_saXbJ_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saXbw_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_caY0O_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY0O() //  [R1]
         { info_tbl: [(caY0O,
                       label: block_caY0O_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0O: // global
           I64[Sp] = block_caY0Q_info;
           _saXbM::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _saXbM::P64;
           if (R1 & 7 != 0) goto uaY4P; else goto caY0Y;
       uaY4P: // global
           call _caY0Q(R1) args: 0, res: 0, upd: 0;
       caY0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY0Q() //  [R1]
         { info_tbl: [(caY0Q,
                       label: block_caY0Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY0Q: // global
           I64[Sp - 8] = block_caY12_info;
           _saXbO::P64 = P64[R1 + 7];
           _saXbP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _saXbP::P64;
           P64[Sp + 8] = _saXbO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaY4Q; else goto caY14;
       uaY4Q: // global
           call _caY12(R1) args: 0, res: 0, upd: 0;
       caY14: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY12() //  [R1]
         { info_tbl: [(caY12,
                       label: block_caY12_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY12: // global
           if (R1 & 7 == 2) goto caY1f; else goto uaY4G;
       caY1f: // global
           _saXbP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caY1d_info;
           R1 = _saXbP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaY4R; else goto caY1g;
       uaY4R: // global
           call _caY1d(R1) args: 0, res: 0, upd: 0;
       caY1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaY4G: // global
           Sp = Sp + 24;
           call _caY1m() args: 0, res: 0, upd: 0;
     }
 },
 _caY1d() //  [R1]
         { info_tbl: [(caY1d,
                       label: block_caY1d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1d: // global
           if (R1 & 7 == 3) goto caY1r; else goto uaY4H;
       caY1r: // global
           I64[Sp + 16] = block_caY1p_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaY4T; else goto caY1s;
       uaY4T: // global
           call _caY1p(R1) args: 0, res: 0, upd: 0;
       caY1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaY4H: // global
           Sp = Sp + 16;
           call _caY1m() args: 0, res: 0, upd: 0;
     }
 },
 _caY1p() //  [R1]
         { info_tbl: [(caY1p,
                       label: block_caY1p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1p: // global
           (_saXbY::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _saXbZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXbY::I64));
           if (_saXbZ::I64 == 0) goto uaY4I; else goto caY1F;
       uaY4I: // global
           I64[Sp - 8] = _saXbZ::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _caY1L() args: 0, res: 0, upd: 0;
       caY1F: // global
           (_saXc3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saXc3::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caY1L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caY1R; else goto caY1Q;
       caY1R: // global
           HpAlloc = 24;
           _saXbZ::I64 = I64[Sp];
           I64[Sp] = block_caY1K_info;
           R1 = _saXbZ::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caY1Q: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caY1K() //  [R1]
         { info_tbl: [(caY1K,
                       label: block_caY1K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1K: // global
           I64[Sp] = R1;
           call _caY1L() args: 0, res: 0, upd: 0;
     }
 },
 _caY1m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY1m: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaY5y_srtd" {
     uaY5y_srtd:
         const SaXeV_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(caY5d,
                       label: GHC.IO.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY5d: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caY5e; else goto caY5f;
       caY5e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caY5f: // global
           I64[Sp - 32] = block_caXZf_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaY5z_srtd" {
     uaY5z_srtd:
         const SaXeV_srt+264;
         const 58;
         const 279788325873647617;
 },
 _caXZf() //  [R1]
         { info_tbl: [(caXZf,
                       label: block_caXZf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXZf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caY5i; else goto caY5h;
       caY5i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY5h: // global
           I64[Hp - 16] = sat_saXcZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.384826647 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { info_tbl: [(caY5E,
                       label: GHC.IO.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY5E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.387655897 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY5I: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saXdj_entry() //  [R1]
         { info_tbl: [(caY65,
                       label: sat_saXdj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY65: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caY6c; else goto caY6d;
       caY6c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caY6d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caY62_info;
           _saXd3::P64 = P64[R1 + 16];
           _saXd4::P64 = P64[R1 + 24];
           _saXd2::I64 = I64[R1 + 40];
           _saXd5::I64 = I64[R1 + 48];
           _saXd6::I64 = I64[R1 + 56];
           _saXd7::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saXd2::I64;
           P64[Sp - 56] = _saXd3::P64;
           P64[Sp - 48] = _saXd4::P64;
           I64[Sp - 40] = _saXd5::I64;
           I64[Sp - 32] = _saXd6::I64;
           I64[Sp - 24] = _saXd7::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaY6h; else goto caY63;
       uaY6h: // global
           call _caY62(R1) args: 0, res: 0, upd: 0;
       caY63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caY62() //  [R1]
         { info_tbl: [(caY62,
                       label: block_caY62_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY62: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caY6g; else goto caY6f;
       caY6g: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caY6f: // global
           _saXdi::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _saXdi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caY6i,
                       label: GHC.IO.FD.$w$cfillReadBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6i: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caY6k; else goto caY6l;
       caY6k: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caY6l: // global
           I64[Sp - 32] = block_caY5V_info;
           _saXd4::P64 = R6;
           R6 = 0;
           _saXd3::P64 = R5;
           _saXd7::I64 = I64[Sp + 16];
           R5 = R4 + _saXd7::I64;
           _saXd2::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _saXd7::I64;
           I64[Sp - 24] = _saXd2::I64;
           P64[Sp - 16] = _saXd3::P64;
           P64[Sp - 8] = _saXd4::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _caY5V() //  [R1]
         { info_tbl: [(caY5V,
                       label: block_caY5V_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY5V: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caY6o; else goto caY6n;
       caY6o: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY6n: // global
           _saXd2::I64 = I64[Sp + 8];
           _saXd3::P64 = P64[Sp + 16];
           _saXd4::P64 = P64[Sp + 24];
           _saXd5::I64 = I64[Sp + 32];
           _saXd6::I64 = I64[Sp + 40];
           _saXd7::I64 = I64[Sp + 48];
           call MO_Touch(_saXd3::P64);
           I64[Hp - 88] = sat_saXdj_info;
           P64[Hp - 72] = _saXd3::P64;
           P64[Hp - 64] = _saXd4::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saXd2::I64;
           I64[Hp - 40] = _saXd5::I64;
           I64[Hp - 32] = _saXd6::I64;
           I64[Hp - 24] = _saXd7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.390392836 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { info_tbl: [(caY6w,
                       label: GHC.IO.FD.$fBufferedIOFD11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caY6A; else goto caY6B;
       caY6A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caY6B: // global
           I64[Sp - 16] = block_caY6t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaY6J; else goto caY6u;
       uaY6J: // global
           call _caY6t(R1) args: 0, res: 0, upd: 0;
       caY6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY6t() //  [R1]
         { info_tbl: [(caY6t,
                       label: block_caY6t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6t: // global
           I64[Sp - 8] = block_caY6z_info;
           _saXdp::I64 = I64[R1 + 7];
           _saXdq::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saXdq::I64;
           I64[Sp + 8] = _saXdp::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaY6I; else goto caY6D;
       uaY6I: // global
           call _caY6z(R1) args: 0, res: 0, upd: 0;
       caY6D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY6z() //  [R1]
         { info_tbl: [(caY6z,
                       label: block_caY6z_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6z: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.39210628 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_saXdI_entry() //  [R1]
         { info_tbl: [(caY6V,
                       label: sat_saXdI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caY6Z; else goto caY70;
       caY6Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caY70: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caY6S_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaY74; else goto caY6T;
       uaY74: // global
           call _caY6S(R1) args: 0, res: 0, upd: 0;
       caY6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caY6S() //  [R1]
         { info_tbl: [(caY6S,
                       label: block_caY6S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY6S: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caY73; else goto caY72;
       caY73: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caY72: // global
           _saXdD::P64 = P64[R1 + 7];
           _saXdC::I64 = I64[R1 + 23];
           _saXdF::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saXdD::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _saXdC::I64;
           I64[Hp - 16] = _saXdF::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { info_tbl: [(caY75,
                       label: GHC.IO.FD.$fBufferedIOFD6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY75: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caY79; else goto caY78;
       caY79: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caY78: // global
           I64[Hp - 16] = sat_saXdI_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.393561762 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.394344639 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { info_tbl: [(caY7f,
                       label: GHC.IO.FD.FD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caY7j; else goto caY7i;
       caY7j: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caY7i: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.395223656 UTC

[GHC.IO.FD.FD_con_entry() //  [R1]
         { info_tbl: [(caY7k,
                       label: GHC.IO.FD.FD_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7k: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.395903826 UTC

[section ""relreadonly" . SaXeV_srt" {
     SaXeV_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.397021607 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:55.397925541 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { info_tbl: [(caY7s,
                       label: GHC.IO.FD.$WFD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caY7B; else goto caY7C;
       caY7B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caY7C: // global
           I64[Sp - 16] = block_caY7p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaY7I; else goto caY7q;
       uaY7I: // global
           call _caY7p(R1) args: 0, res: 0, upd: 0;
       caY7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY7p() //  [R1]
         { info_tbl: [(caY7p,
                       label: block_caY7p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7p: // global
           I64[Sp] = block_caY7v_info;
           _saWVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saWVh::I64;
           if (R1 & 7 != 0) goto uaY7H; else goto caY7w;
       uaY7H: // global
           call _caY7v(R1) args: 0, res: 0, upd: 0;
       caY7w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY7v() //  [R1]
         { info_tbl: [(caY7v,
                       label: block_caY7v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caY7G; else goto caY7F;
       caY7G: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY7F: // global
           _saWVj::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saWVj::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.399825068 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { info_tbl: [(caY7S,
                       label: GHC.IO.FD.$fBufferedIOFD5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caY7T; else goto uaY8s;
       caY7T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uaY8s: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _caY7K() args: 0, res: 0, upd: 0;
     }
 },
 _caY7K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7K: // global
           I64[Sp - 8] = block_caY7N_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY7N() //  [R1]
         { info_tbl: [(caY7N,
                       label: block_caY7N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7N: // global
           I64[Sp - 8] = block_caY7P_info;
           _saWVq::P64 = R1;
           R1 = R1;
           P64[Sp] = _saWVq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaY8u; else goto caY7Q;
       uaY8u: // global
           call _caY7P(R1) args: 0, res: 0, upd: 0;
       caY7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY7P() //  [R1]
         { info_tbl: [(caY7P,
                       label: block_caY7P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY7P: // global
           if (I64[R1 + 7] == (-1)) goto caY8q; else goto caY81;
       caY8q: // global
           _saWVk::P64 = P64[Sp + 16];
           _saWVl::P64 = P64[Sp + 24];
           _saWVm::P64 = P64[Sp + 32];
           (_saWVx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _saWVy::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWVx::I64));
           if (_saWVy::I64 != 4) goto uaY8r; else goto caY8g;
       uaY8r: // global
           if (_saWVy::I64 != 11) goto caY8a; else goto caY8m;
       caY8a: // global
           R2 = _saWVk::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       caY8m: // global
           R1 = _saWVm::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       caY8g: // global
           P64[Sp + 16] = _saWVk::P64;
           P64[Sp + 24] = _saWVl::P64;
           P64[Sp + 32] = _saWVm::P64;
           Sp = Sp + 16;
           call _caY7K() args: 0, res: 0, upd: 0;
       caY81: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.401401588 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.402096561 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { info_tbl: [(caY8D,
                       label: lvl1_raWUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caY8E; else goto caY8F;
       caY8E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caY8F: // global
           (_caY8A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caY8A::I64 == 0) goto caY8C; else goto caY8B;
       caY8C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caY8B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caY8A::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.40295391 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.403687082 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { info_tbl: [(caY8M,
                       label: GHC.IO.FD.$fBufferedIOFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY8M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caY8N; else goto caY8O;
       caY8N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caY8O: // global
           (_caY8J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caY8J::I64 == 0) goto caY8L; else goto caY8K;
       caY8L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caY8K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caY8J::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.404540009 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.405366722 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { info_tbl: [(caY8T,
                       label: GHC.IO.FD.$fBufferedIOFD3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY8T: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.406064433 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.406656489 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.408842333 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY8X: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWVZ_entry() //  [R1]
         { info_tbl: [(caY9c,
                       label: sat_saWVZ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY9c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caY9m; else goto caY9l;
       caY9m: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caY9l: // global
           (_saWVX::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWVX::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWWc_entry() //  [R1]
         { info_tbl: [(caY9G,
                       label: sat_saWWc_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY9G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caY9P; else goto caY9Q;
       caY9P: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caY9Q: // global
           I64[Sp - 8] = block_caY9M_info;
           Sp = Sp - 8;
           _caY9J::I64 = I64[R1 + 7];
           _caY9K::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caY9L::I64 = I64[R1 + 31];
           _uaY9W::P64 = CurrentTSO;
           I64[I64[_uaY9W::P64 + 24] + 16] = Sp;
           _uaY9X::I64 = CurrentNursery;
           P64[_uaY9X::I64 + 8] = Hp + 8;
           I64[_uaY9W::P64 + 104] = I64[_uaY9W::P64 + 104] - ((Hp + 8) - I64[_uaY9X::I64]);
           (_uaY9U::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWWa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caY9J::I64, _caY9K::I64, _caY9L::I64);
           (_uaY9V::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaY9U::I64);
           BaseReg = _uaY9V::I64;
           _uaY9Y::P64 = CurrentTSO;
           _uaY9Z::P64 = I64[_uaY9Y::P64 + 24];
           Sp = I64[_uaY9Z::P64 + 16];
           SpLim = _uaY9Z::P64 + 192;
           HpAlloc = 0;
           _uaYa0::I64 = CurrentNursery;
           _uaYa1::I64 = I64[_uaYa0::I64 + 8];
           Hp = _uaYa1::I64 - 8;
           _uaYa2::I64 = I64[_uaYa0::I64];
           HpLim = _uaYa2::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYa0::I64 + 48]) << 12) - 1);
           I64[_uaY9Y::P64 + 104] = I64[_uaY9Y::P64 + 104] + (_uaYa1::I64 - _uaYa2::I64);
           R1 = _saWWa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caY9M() //  [R1]
         { info_tbl: [(caY9M,
                       label: block_caY9M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY9M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caY9T; else goto caY9S;
       caY9T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caY9S: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(caYa7,
                       label: GHC.IO.FD.$wreadRawBufferPtrNoBlock_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYa7: // global
           _saWVE::I64 = R6;
           _saWVD::I64 = R5;
           _saWVC::I64 = R4;
           _saWVB::I64 = R3;
           _saWVA::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caYa8; else goto caYa9;
       caYa9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYab; else goto caYaa;
       caYab: // global
           HpAlloc = 40;
           goto caYa8;
       caYa8: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVC::I64;
           I64[Sp - 16] = _saWVD::I64;
           I64[Sp - 8] = _saWVE::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caYaa: // global
           if (_saWVC::I64 == 0) goto caYa6; else goto caYa5;
       caYa6: // global
           (_saWW3::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWVB::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWW4::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWW3::I64));
           if (_saWW4::I64 != 0) goto uaYaL; else goto caYaF;
       uaYaL: // global
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVD::I64;
           I64[Sp - 16] = _saWVE::I64;
           I64[Sp - 8] = _saWW4::I64;
           Sp = Sp - 40;
           call _caY9x() args: 0, res: 0, upd: 0;
       caYaF: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYa5: // global
           I64[Hp - 32] = sat_saWVZ_info;
           I64[Hp - 24] = _saWVB::I64;
           I64[Hp - 16] = _saWVD::I64;
           I64[Hp - 8] = _saWVE::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWVA::P64;
           Sp = Sp - 8;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caY9x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY9x: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYaC; else goto caYaB;
       caYaC: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caY9w_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYaB: // global
           I64[Hp - 32] = sat_saWWc_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caY9w() //  [R1]
         { info_tbl: [(caY9w,
                       label: block_caY9w_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caY9w: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caY9x() args: 0, res: 0, upd: 0;
     }
 },
 _saWVH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saWVH: // global
           _saWVA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caYaf_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _saWVA::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYaf() //  [R1]
         { info_tbl: [(caYaf,
                       label: block_caYaf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYaf: // global
           I64[Sp] = block_caYah_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYaS; else goto caYak;
       uaYaS: // global
           call _caYah(R1) args: 0, res: 0, upd: 0;
       caYak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYah() //  [R1]
         { info_tbl: [(caYah,
                       label: block_caYah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYah: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYaq; else goto caYap;
       caYaq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYap: // global
           _saWVP::I64 = I64[R1 + 7];
           if (_saWVP::I64 != (-1)) goto uaYaJ; else goto caYaw;
       uaYaJ: // global
           if (_saWVP::I64 != 0) goto caYav; else goto caYax;
       caYav: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYax: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYaw: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.41430615 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYb0,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYb0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caYbe; else goto caYbf;
       caYbe: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYbf: // global
           I64[Sp - 40] = block_caYaX_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaYbp; else goto caYaY;
       uaYbp: // global
           call _caYaX(R1) args: 0, res: 0, upd: 0;
       caYaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYaX() //  [R1]
         { info_tbl: [(caYaX,
                       label: block_caYaX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYaX: // global
           I64[Sp - 8] = block_caYb3_info;
           _saWWk::I64 = I64[R1 + 7];
           _saWWl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWWl::I64;
           I64[Sp + 16] = _saWWk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYbo; else goto caYb4;
       uaYbo: // global
           call _caYb3(R1) args: 0, res: 0, upd: 0;
       caYb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYb3() //  [R1]
         { info_tbl: [(caYb3,
                       label: block_caYb3_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYb3: // global
           I64[Sp] = block_caYb8_info;
           _saWWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWWn::I64;
           if (R1 & 7 != 0) goto uaYbq; else goto caYb9;
       uaYbq: // global
           call _caYb8(R1) args: 0, res: 0, upd: 0;
       caYb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYb8() //  [R1]
         { info_tbl: [(caYb8,
                       label: block_caYb8_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYb8: // global
           I64[Sp] = block_caYbd_info;
           _saWWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWWp::I64;
           if (R1 & 7 != 0) goto uaYbr; else goto caYbj;
       uaYbr: // global
           call _caYbd(R1) args: 0, res: 0, upd: 0;
       caYbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYbd() //  [R1]
         { info_tbl: [(caYbd,
                       label: block_caYbd_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbd: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.416509683 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbt: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caYbz,
                       label: GHC.IO.FD.$w$creadNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYbE; else goto caYbF;
       caYbE: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caYbF: // global
           I64[Sp - 8] = block_caYbB_info;
           R6 = 0;
           _saWWx::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _saWWx::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caYbB() //  [R1]
         { info_tbl: [(caYbB,
                       label: block_caYbB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbB: // global
           I64[Sp] = block_caYbD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYbU; else goto caYbH;
       uaYbU: // global
           call _caYbD(R1) args: 0, res: 0, upd: 0;
       caYbH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYbD() //  [R1]
         { info_tbl: [(caYbD,
                       label: block_caYbD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYbN; else goto caYbM;
       caYbN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYbM: // global
           if (I64[R1 + 7] == (-1)) goto caYbT; else goto caYbS;
       caYbT: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYbS: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.418730272 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { info_tbl: [(caYc2,
                       label: GHC.IO.FD.$fRawIOFD3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYc2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYcb; else goto caYcc;
       caYcb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYcc: // global
           I64[Sp - 24] = block_caYbZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYcl; else goto caYc0;
       uaYcl: // global
           call _caYbZ(R1) args: 0, res: 0, upd: 0;
       caYc0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYbZ() //  [R1]
         { info_tbl: [(caYbZ,
                       label: block_caYbZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYbZ: // global
           I64[Sp - 8] = block_caYc5_info;
           _saWWK::I64 = I64[R1 + 7];
           _saWWL::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWWL::I64;
           I64[Sp + 8] = _saWWK::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYck; else goto caYc6;
       uaYck: // global
           call _caYc5(R1) args: 0, res: 0, upd: 0;
       caYc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYc5() //  [R1]
         { info_tbl: [(caYc5,
                       label: block_caYc5_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYc5: // global
           I64[Sp] = block_caYca_info;
           _saWWN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWWN::I64;
           if (R1 & 7 != 0) goto uaYcm; else goto caYcf;
       uaYcm: // global
           call _caYca(R1) args: 0, res: 0, upd: 0;
       caYcf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYca() //  [R1]
         { info_tbl: [(caYca,
                       label: block_caYca_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYca: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.420188489 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.420944581 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { info_tbl: [(caYct,
                       label: GHC.IO.FD.$fBufferedIOFD_loc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYct: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYcu; else goto caYcv;
       caYcu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYcv: // global
           (_caYcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYcq::I64 == 0) goto caYcs; else goto caYcr;
       caYcs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYcr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYcq::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.422099337 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { info_tbl: [(caYcD,
                       label: GHC.IO.FD.$fBufferedIOFD14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYcD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYcE; else goto caYcF;
       caYcE: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYcF: // global
           I64[Sp - 8] = block_caYcA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYcN; else goto caYcB;
       uaYcN: // global
           call _caYcA(R1) args: 0, res: 0, upd: 0;
       caYcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYcA() //  [R1]
         { info_tbl: [(caYcA,
                       label: block_caYcA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYcA: // global
           if (I64[R1 + 7] == (-1)) goto caYcM; else goto caYcL;
       caYcM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYcL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.423176622 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.42388485 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { info_tbl: [(caYcU,
                       label: GHC.IO.FD.$fBufferedIOFD12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYcU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYcV; else goto caYcW;
       caYcV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYcW: // global
           (_caYcR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYcR::I64 == 0) goto caYcT; else goto caYcS;
       caYcT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYcS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYcR::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.427630661 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYcY: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWXe_entry() //  [R1]
         { info_tbl: [(caYdh,
                       label: sat_saWXe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYdh: // global
           _saWXe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caYdi; else goto caYdj;
       caYdj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYdl; else goto caYdk;
       caYdl: // global
           HpAlloc = 16;
           goto caYdi;
       caYdi: // global
           R1 = _saWXe::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYdk: // global
           _saWWV::I64 = I64[_saWXe::P64 + 7];
           (_saWX8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWX8::I64 == 0) goto caYdg; else goto caYdf;
       caYdg: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caYdv_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caYdf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caYdv() //  []
         { info_tbl: [(caYdv,
                       label: block_caYdv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYdv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXk_entry() //  [R1]
         { info_tbl: [(caYdH,
                       label: sat_saWXk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYdH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYdL; else goto caYdM;
       caYdL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYdM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caYdE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYdQ; else goto caYdF;
       uaYdQ: // global
           call _caYdE(R1) args: 0, res: 0, upd: 0;
       caYdF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYdE() //  [R1]
         { info_tbl: [(caYdE,
                       label: block_caYdE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYdE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYdP; else goto caYdO;
       caYdP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYdO: // global
           _saWXj::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWXj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWXt_entry() //  [R1]
         { info_tbl: [(caYe0,
                       label: sat_saWXt_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYe0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYea; else goto caYe9;
       caYea: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYe9: // global
           (_saWXr::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXr::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXP_entry() //  [R1]
         { info_tbl: [(caYeB,
                       label: sat_saWXP_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYeB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYeK; else goto caYeL;
       caYeK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYeL: // global
           I64[Sp - 8] = block_caYeH_info;
           Sp = Sp - 8;
           _caYeE::I64 = I64[R1 + 7];
           _caYeF::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caYeG::I64 = I64[R1 + 31];
           _uaYeR::P64 = CurrentTSO;
           I64[I64[_uaYeR::P64 + 24] + 16] = Sp;
           _uaYeS::I64 = CurrentNursery;
           P64[_uaYeS::I64 + 8] = Hp + 8;
           I64[_uaYeR::P64 + 104] = I64[_uaYeR::P64 + 104] - ((Hp + 8) - I64[_uaYeS::I64]);
           (_uaYeP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWXN::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caYeE::I64, _caYeF::I64, _caYeG::I64);
           (_uaYeQ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaYeP::I64);
           BaseReg = _uaYeQ::I64;
           _uaYeT::P64 = CurrentTSO;
           _uaYeU::P64 = I64[_uaYeT::P64 + 24];
           Sp = I64[_uaYeU::P64 + 16];
           SpLim = _uaYeU::P64 + 192;
           HpAlloc = 0;
           _uaYeV::I64 = CurrentNursery;
           _uaYeW::I64 = I64[_uaYeV::I64 + 8];
           Hp = _uaYeW::I64 - 8;
           _uaYeX::I64 = I64[_uaYeV::I64];
           HpLim = _uaYeX::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYeV::I64 + 48]) << 12) - 1);
           I64[_uaYeT::P64 + 104] = I64[_uaYeT::P64 + 104] + (_uaYeW::I64 - _uaYeX::I64);
           R1 = _saWXN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYeH() //  [R1]
         { info_tbl: [(caYeH,
                       label: block_caYeH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYeH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYeO; else goto caYeN;
       caYeO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYeN: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXX_entry() //  [R1]
         { info_tbl: [(caYf7,
                       label: sat_saWXX_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYf7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYfh; else goto caYfg;
       caYfh: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYfg: // global
           (_saWXV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXV::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYfl,
                       label: GHC.IO.FD.$wreadRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYfl: // global
           _saWWY::I64 = R6;
           _saWWX::I64 = R5;
           _saWWW::I64 = R4;
           _saWWV::I64 = R3;
           _saWWU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caYfm; else goto caYfn;
       caYfn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYfp; else goto caYfo;
       caYfp: // global
           HpAlloc = 40;
           goto caYfm;
       caYfm: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWW::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caYfo: // global
           if (_saWWW::I64 == 0) goto caYfk; else goto caYfj;
       caYfk: // global
           (_saWXx::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWWV::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWYb::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWXx::I64));
           if (_saWYb::I64 != (-1)) goto caYga; else goto caYgl;
       caYga: // global
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWX::I64;
           I64[Sp - 16] = _saWWY::I64;
           I64[Sp - 8] = _saWYb::I64;
           Sp = Sp - 40;
           call _caYek() args: 0, res: 0, upd: 0;
       caYgl: // global
           I64[Sp - 40] = block_caYgi_info;
           R2 = _saWWU::P64;
           P64[Sp - 32] = _saWWU::P64;
           I64[Sp - 24] = _saWWV::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caYfj: // global
           I64[Hp - 32] = sat_saWXt_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWWV::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWWU::P64;
           Sp = Sp - 16;
           call _caYd5() args: 0, res: 0, upd: 0;
     }
 },
 _caYgi() //  [R1]
         { info_tbl: [(caYgi,
                       label: block_caYgi_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYgi: // global
           I64[Sp] = block_caYgk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYgJ; else goto caYgo;
       uaYgJ: // global
           call _caYgk(R1) args: 0, res: 0, upd: 0;
       caYgo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYgk() //  [R1]
         { info_tbl: [(caYgk,
                       label: block_caYgk_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYgk: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _caYek() args: 0, res: 0, upd: 0;
     }
 },
 _caYek() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYek: // global
           Hp = Hp + 16;
           _saWXA::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caYfy; else goto caYfx;
       caYfy: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caYej_info;
           R1 = _saWXA::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYfx: // global
           if (_saWXA::I64 == 0) goto caYg4; else goto caYfH;
       caYg4: // global
           _saWWV::I64 = I64[Sp + 8];
           (_saWY2::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWY2::I64 == 0) goto caYg1; else goto caYfT;
       caYg1: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caYep_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caYfT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           I64[Sp - 8] = block_caYfR_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       caYfH: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _caYep() args: 0, res: 0, upd: 0;
     }
 },
 _caYej() //  [R1]
         { info_tbl: [(caYej,
                       label: block_caYej_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYej: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caYek() args: 0, res: 0, upd: 0;
     }
 },
 _caYfR() //  []
         { info_tbl: [(caYfR,
                       label: block_caYfR_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYfR: // global
           call _caYep() args: 0, res: 0, upd: 0;
     }
 },
 _caYep() //  []
         { info_tbl: [(caYep,
                       label: block_caYep_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYep: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYfB; else goto caYfA;
       caYfB: // global
           HpAlloc = 40;
           I64[Sp] = block_caYep_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caYfA: // global
           _saWWU::P64 = P64[Sp + 8];
           _saWWV::I64 = I64[Sp + 16];
           _saWWX::I64 = I64[Sp + 24];
           _saWWY::I64 = I64[Sp + 32];
           _saWWZ::I64 = I64[Sp + 48];
           (_saWXG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWXG::I64 == 0) goto caYfE; else goto caYfD;
       caYfE: // global
           I64[Hp - 32] = sat_saWXX_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaYgF;
       caYfD: // global
           I64[Hp - 32] = sat_saWXP_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaYgF;
       uaYgF: // global
           call _caYd5() args: 0, res: 0, upd: 0;
     }
 },
 _caYd5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYd5: // global
           Hp = Hp + 16;
           _saWX2::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caYfs; else goto caYfr;
       caYfs: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caYd4_info;
           R1 = _saWX2::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYfr: // global
           I64[Hp - 8] = sat_saWXe_info;
           I64[Hp] = I64[Sp];
           _saWWU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caYdy_info;
           R5 = Hp - 7;
           R4 = _saWX2::P64;
           R3 = _saWWU::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYd4() //  [R1]
         { info_tbl: [(caYd4,
                       label: block_caYd4_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYd4: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caYd5() args: 0, res: 0, upd: 0;
     }
 },
 _caYdy() //  [R1]
         { info_tbl: [(caYdy,
                       label: block_caYdy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYdy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYfv; else goto caYfu;
       caYfv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYfu: // global
           I64[Hp - 16] = sat_saWXk_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.434610333 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYgS,
                       label: GHC.IO.FD.$fRawIOFD5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYgS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caYh6; else goto caYh7;
       caYh6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYh7: // global
           I64[Sp - 40] = block_caYgP_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaYhh; else goto caYgQ;
       uaYhh: // global
           call _caYgP(R1) args: 0, res: 0, upd: 0;
       caYgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYgP() //  [R1]
         { info_tbl: [(caYgP,
                       label: block_caYgP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYgP: // global
           I64[Sp - 8] = block_caYgV_info;
           _saWYo::I64 = I64[R1 + 7];
           _saWYp::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWYp::I64;
           I64[Sp + 16] = _saWYo::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYhg; else goto caYgW;
       uaYhg: // global
           call _caYgV(R1) args: 0, res: 0, upd: 0;
       caYgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYgV() //  [R1]
         { info_tbl: [(caYgV,
                       label: block_caYgV_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYgV: // global
           I64[Sp] = block_caYh0_info;
           _saWYr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWYr::I64;
           if (R1 & 7 != 0) goto uaYhi; else goto caYh1;
       uaYhi: // global
           call _caYh0(R1) args: 0, res: 0, upd: 0;
       caYh1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYh0() //  [R1]
         { info_tbl: [(caYh0,
                       label: block_caYh0_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYh0: // global
           I64[Sp] = block_caYh5_info;
           _saWYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWYt::I64;
           if (R1 & 7 != 0) goto uaYhj; else goto caYhb;
       uaYhj: // global
           call _caYh5(R1) args: 0, res: 0, upd: 0;
       caYhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYh5() //  [R1]
         { info_tbl: [(caYh5,
                       label: block_caYh5_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYh5: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.436835049 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { info_tbl: [(caYhr,
                       label: GHC.IO.FD.$fRawIOFD4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYhA; else goto caYhB;
       caYhA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYhB: // global
           I64[Sp - 24] = block_caYho_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYhL; else goto caYhp;
       uaYhL: // global
           call _caYho(R1) args: 0, res: 0, upd: 0;
       caYhp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYho() //  [R1]
         { info_tbl: [(caYho,
                       label: block_caYho_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYho: // global
           I64[Sp - 8] = block_caYhu_info;
           _saWYB::I64 = I64[R1 + 7];
           _saWYC::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWYC::I64;
           I64[Sp + 8] = _saWYB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYhK; else goto caYhv;
       uaYhK: // global
           call _caYhu(R1) args: 0, res: 0, upd: 0;
       caYhv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYhu() //  [R1]
         { info_tbl: [(caYhu,
                       label: block_caYhu_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhu: // global
           I64[Sp] = block_caYhz_info;
           _saWYE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWYE::I64;
           if (R1 & 7 != 0) goto uaYhM; else goto caYhE;
       uaYhM: // global
           call _caYhz(R1) args: 0, res: 0, upd: 0;
       caYhE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYhz() //  [R1]
         { info_tbl: [(caYhz,
                       label: block_caYhz_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhz: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.442342285 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhO: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWZ2_entry() //  [R1]
         { info_tbl: [(caYi7,
                       label: sat_saWZ2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYi7: // global
           _saWZ2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caYi8; else goto caYi9;
       caYi9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYib; else goto caYia;
       caYib: // global
           HpAlloc = 16;
           goto caYi8;
       caYi8: // global
           R1 = _saWZ2::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYia: // global
           _saWYJ::I64 = I64[_saWZ2::P64 + 7];
           (_saWYW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWYW::I64 == 0) goto caYi6; else goto caYi5;
       caYi6: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caYil_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caYi5: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caYil() //  []
         { info_tbl: [(caYil,
                       label: block_caYil_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYil: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZ9_entry() //  [R1]
         { info_tbl: [(caYix,
                       label: sat_saWZ9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYix: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYiE; else goto caYiF;
       caYiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYiF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caYiu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYiJ; else goto caYiv;
       uaYiJ: // global
           call _caYiu(R1) args: 0, res: 0, upd: 0;
       caYiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYiu() //  [R1]
         { info_tbl: [(caYiu,
                       label: block_caYiu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYiu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYiI; else goto caYiH;
       caYiI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYiH: // global
           _saWZ8::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saWZ8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWZi_entry() //  [R1]
         { info_tbl: [(caYiT,
                       label: sat_saWZi_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYiT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYj3; else goto caYj2;
       caYj3: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYj2: // global
           (_saWZg::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZg::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZB_entry() //  [R1]
         { info_tbl: [(caYjp,
                       label: sat_saWZB_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYjp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYjy; else goto caYjz;
       caYjy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYjz: // global
           I64[Sp - 8] = block_caYjv_info;
           Sp = Sp - 8;
           _caYjs::I64 = I64[R1 + 7];
           _caYjt::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caYju::I64 = I64[R1 + 31];
           _uaYjF::P64 = CurrentTSO;
           I64[I64[_uaYjF::P64 + 24] + 16] = Sp;
           _uaYjG::I64 = CurrentNursery;
           P64[_uaYjG::I64 + 8] = Hp + 8;
           I64[_uaYjF::P64 + 104] = I64[_uaYjF::P64 + 104] - ((Hp + 8) - I64[_uaYjG::I64]);
           (_uaYjD::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWZz::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caYjs::I64, _caYjt::I64, _caYju::I64);
           (_uaYjE::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaYjD::I64);
           BaseReg = _uaYjE::I64;
           _uaYjH::P64 = CurrentTSO;
           _uaYjI::P64 = I64[_uaYjH::P64 + 24];
           Sp = I64[_uaYjI::P64 + 16];
           SpLim = _uaYjI::P64 + 192;
           HpAlloc = 0;
           _uaYjJ::I64 = CurrentNursery;
           _uaYjK::I64 = I64[_uaYjJ::I64 + 8];
           Hp = _uaYjK::I64 - 8;
           _uaYjL::I64 = I64[_uaYjJ::I64];
           HpLim = _uaYjL::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYjJ::I64 + 48]) << 12) - 1);
           I64[_uaYjH::P64 + 104] = I64[_uaYjH::P64 + 104] + (_uaYjK::I64 - _uaYjL::I64);
           R1 = _saWZz::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYjv() //  [R1]
         { info_tbl: [(caYjv,
                       label: block_caYjv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYjC; else goto caYjB;
       caYjC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYjB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZJ_entry() //  [R1]
         { info_tbl: [(caYjV,
                       label: sat_saWZJ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYjV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYk5; else goto caYk4;
       caYk5: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYk4: // global
           (_saWZH::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZH::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYk9,
                       label: GHC.IO.FD.$wwriteRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYk9: // global
           _saWYM::I64 = R6;
           _saWYL::I64 = R5;
           _saWYK::I64 = R4;
           _saWYJ::I64 = R3;
           _saWYI::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caYka; else goto caYkb;
       caYkb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYkd; else goto caYkc;
       caYkd: // global
           HpAlloc = 40;
           goto caYka;
       caYka: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYK::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caYkc: // global
           if (_saWYK::I64 == 0) goto caYk8; else goto caYk7;
       caYk8: // global
           (_saWZm::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWYJ::I64, 1, 0, 0);
           Hp = Hp - 40;
           _saWZK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWZm::I64));
           if (_saWZK::I64 != 0) goto uaYl3; else goto uaYl2;
       uaYl3: // global
           P64[Sp - 32] = _saWYI::P64;
           I64[Sp - 24] = _saWYJ::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call _caYjd() args: 0, res: 0, upd: 0;
       uaYl2: // global
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYL::I64;
           I64[Sp - 16] = _saWYM::I64;
           I64[Sp - 8] = _saWZK::I64;
           Sp = Sp - 40;
           call _caYkC() args: 0, res: 0, upd: 0;
       caYk7: // global
           I64[Hp - 32] = sat_saWZi_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWYJ::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWYI::P64;
           Sp = Sp - 16;
           call _caYhV() args: 0, res: 0, upd: 0;
     }
 },
 _caYkC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYkC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYkG; else goto caYkF;
       caYkG: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caYkA_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYkF: // global
           _saWYI::P64 = P64[Sp];
           _saWYJ::I64 = I64[Sp + 8];
           _saWYL::I64 = I64[Sp + 16];
           _saWYM::I64 = I64[Sp + 24];
           (_saWZO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZO::I64 == 0) goto caYkY; else goto caYkQ;
       caYkY: // global
           Hp = Hp - 16;
           I64[Sp] = block_caYjd_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           P64[Sp + 8] = _saWYI::P64;
           I64[Sp + 16] = _saWYJ::I64;
           I64[Sp + 24] = _saWYL::I64;
           I64[Sp + 32] = _saWYM::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caYkQ: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           I64[Sp - 8] = block_caYkO_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYkA() //  [R1]
         { info_tbl: [(caYkA,
                       label: block_caYkA_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYkA: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caYkC() args: 0, res: 0, upd: 0;
     }
 },
 _caYkO() //  []
         { info_tbl: [(caYkO,
                       label: block_caYkO_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYkO: // global
           _saWYJ::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _saWYL::I64 = I64[Sp + 24];
           I64[Sp + 24] = _saWYJ::I64;
           _saWYM::I64 = I64[Sp + 32];
           I64[Sp + 32] = _saWYL::I64;
           I64[Sp + 40] = _saWYM::I64;
           Sp = Sp + 8;
           call _caYjd() args: 0, res: 0, upd: 0;
     }
 },
 _caYjd() //  []
         { info_tbl: [(caYjd,
                       label: block_caYjd_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYjd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caYkm; else goto caYkl;
       caYkm: // global
           HpAlloc = 40;
           I64[Sp] = block_caYjd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caYkl: // global
           _saWYI::P64 = P64[Sp + 8];
           _saWYJ::I64 = I64[Sp + 16];
           _saWYL::I64 = I64[Sp + 24];
           _saWYM::I64 = I64[Sp + 32];
           _saWYN::I64 = I64[Sp + 40];
           (_saWZs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZs::I64 == 0) goto caYkp; else goto caYko;
       caYkp: // global
           I64[Hp - 32] = sat_saWZJ_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaYlb;
       caYko: // global
           I64[Hp - 32] = sat_saWZB_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaYlb;
       uaYlb: // global
           call _caYhV() args: 0, res: 0, upd: 0;
     }
 },
 _caYhV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhV: // global
           Hp = Hp + 16;
           _saWYQ::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caYkg; else goto caYkf;
       caYkg: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caYhU_info;
           R1 = _saWYQ::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYkf: // global
           I64[Hp - 8] = sat_saWZ2_info;
           I64[Hp] = I64[Sp];
           _saWYI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caYio_info;
           R5 = Hp - 7;
           R4 = _saWYQ::P64;
           R3 = _saWYI::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYhU() //  [R1]
         { info_tbl: [(caYhU,
                       label: block_caYhU_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYhU: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caYhV() args: 0, res: 0, upd: 0;
     }
 },
 _caYio() //  [R1]
         { info_tbl: [(caYio,
                       label: block_caYio_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYio: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYkj; else goto caYki;
       caYkj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYki: // global
           I64[Hp - 16] = sat_saWZ9_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.448702698 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYlo,
                       label: GHC.IO.FD.writeRawBufferPtr1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caYlC; else goto caYlD;
       caYlC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYlD: // global
           I64[Sp - 40] = block_caYll_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaYlN; else goto caYlm;
       uaYlN: // global
           call _caYll(R1) args: 0, res: 0, upd: 0;
       caYlm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYll() //  [R1]
         { info_tbl: [(caYll,
                       label: block_caYll_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYll: // global
           I64[Sp - 8] = block_caYlr_info;
           _saX04::I64 = I64[R1 + 7];
           _saX05::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saX05::I64;
           I64[Sp + 16] = _saX04::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYlM; else goto caYls;
       uaYlM: // global
           call _caYlr(R1) args: 0, res: 0, upd: 0;
       caYls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYlr() //  [R1]
         { info_tbl: [(caYlr,
                       label: block_caYlr_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlr: // global
           I64[Sp] = block_caYlw_info;
           _saX07::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saX07::I64;
           if (R1 & 7 != 0) goto uaYlO; else goto caYlx;
       uaYlO: // global
           call _caYlw(R1) args: 0, res: 0, upd: 0;
       caYlx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYlw() //  [R1]
         { info_tbl: [(caYlw,
                       label: block_caYlw_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlw: // global
           I64[Sp] = block_caYlB_info;
           _saX09::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saX09::I64;
           if (R1 & 7 != 0) goto uaYlP; else goto caYlH;
       uaYlP: // global
           call _caYlB(R1) args: 0, res: 0, upd: 0;
       caYlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYlB() //  [R1]
         { info_tbl: [(caYlB,
                       label: block_caYlB_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlB: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.451091824 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlR: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caYlX,
                       label: GHC.IO.FD.$wfdWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caYm2; else goto uaYml;
       caYm2: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       uaYml: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caYlS() args: 0, res: 0, upd: 0;
     }
 },
 _caYlS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlS: // global
           I64[Sp - 8] = block_caYlZ_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _caYlZ() //  [R1]
         { info_tbl: [(caYlZ,
                       label: block_caYlZ_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYlZ: // global
           I64[Sp] = block_caYm1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYmo; else goto caYm5;
       uaYmo: // global
           call _caYm1(R1) args: 0, res: 0, upd: 0;
       caYm5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYm1() //  [R1]
         { info_tbl: [(caYm1,
                       label: block_caYm1_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYm1: // global
           _saX0f::I64 = I64[Sp + 32];
           _saX0m::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_saX0m::I64,
                            _saX0f::I64)) goto caYmd; else goto caYme;
       caYmd: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYme: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _saX0m::I64;
           I64[Sp + 32] = _saX0f::I64 - _saX0m::I64;
           Sp = Sp + 8;
           call _caYlS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.453128498 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { info_tbl: [(caYmx,
                       label: GHC.IO.FD.$fRawIOFD2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYmx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYmG; else goto caYmH;
       caYmG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYmH: // global
           I64[Sp - 24] = block_caYmu_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYmQ; else goto caYmv;
       uaYmQ: // global
           call _caYmu(R1) args: 0, res: 0, upd: 0;
       caYmv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYmu() //  [R1]
         { info_tbl: [(caYmu,
                       label: block_caYmu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYmu: // global
           I64[Sp - 8] = block_caYmA_info;
           _saX0v::I64 = I64[R1 + 7];
           _saX0w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX0w::I64;
           I64[Sp + 8] = _saX0v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYmP; else goto caYmB;
       uaYmP: // global
           call _caYmA(R1) args: 0, res: 0, upd: 0;
       caYmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYmA() //  [R1]
         { info_tbl: [(caYmA,
                       label: block_caYmA_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYmA: // global
           I64[Sp] = block_caYmF_info;
           _saX0y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX0y::I64;
           if (R1 & 7 != 0) goto uaYmR; else goto caYmK;
       uaYmR: // global
           call _caYmF(R1) args: 0, res: 0, upd: 0;
       caYmK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYmF() //  [R1]
         { info_tbl: [(caYmF,
                       label: block_caYmF_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYmF: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.456881481 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYmT: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX0O_entry() //  [R1]
         { info_tbl: [(caYn6,
                       label: sat_saX0O_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYn6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYng; else goto caYnf;
       caYng: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYnf: // global
           (_saX0M::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX0M::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1e_entry() //  [R1]
         { info_tbl: [(caYnD,
                       label: sat_saX1e_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYnD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYnM; else goto caYnN;
       caYnM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYnN: // global
           I64[Sp - 8] = block_caYnJ_info;
           Sp = Sp - 8;
           _caYnG::I64 = I64[R1 + 7];
           _caYnH::I64 = I64[R1 + 15];
           _caYnI::I64 = I64[R1 + 23];
           _uaYnT::P64 = CurrentTSO;
           I64[I64[_uaYnT::P64 + 24] + 16] = Sp;
           _uaYnU::I64 = CurrentNursery;
           P64[_uaYnU::I64 + 8] = Hp + 8;
           I64[_uaYnT::P64 + 104] = I64[_uaYnT::P64 + 104] - ((Hp + 8) - I64[_uaYnU::I64]);
           (_uaYnR::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX1c::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caYnG::I64, _caYnH::I64, _caYnI::I64);
           (_uaYnS::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaYnR::I64);
           BaseReg = _uaYnS::I64;
           _uaYnV::P64 = CurrentTSO;
           _uaYnW::P64 = I64[_uaYnV::P64 + 24];
           Sp = I64[_uaYnW::P64 + 16];
           SpLim = _uaYnW::P64 + 192;
           HpAlloc = 0;
           _uaYnX::I64 = CurrentNursery;
           _uaYnY::I64 = I64[_uaYnX::I64 + 8];
           Hp = _uaYnY::I64 - 8;
           _uaYnZ::I64 = I64[_uaYnX::I64];
           HpLim = _uaYnZ::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYnX::I64 + 48]) << 12) - 1);
           I64[_uaYnV::P64 + 104] = I64[_uaYnV::P64 + 104] + (_uaYnY::I64 - _uaYnZ::I64);
           R1 = _saX1c::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYnJ() //  [R1]
         { info_tbl: [(caYnJ,
                       label: block_caYnJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYnJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYnQ; else goto caYnP;
       caYnQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYnP: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1u_entry() //  [R1]
         { info_tbl: [(caYo9,
                       label: sat_saX1u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYo9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYoj; else goto caYoi;
       caYoj: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYoi: // global
           (_saX1s::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX1s::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caYon,
                       label: GHC.IO.FD.$w$cwriteNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYon: // global
           _saX0E::I64 = R5;
           _saX0D::I64 = R4;
           _saX0C::I64 = R3;
           _saX0B::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto caYoo; else goto caYop;
       caYop: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caYor; else goto caYoq;
       caYor: // global
           HpAlloc = 32;
           goto caYoo;
       caYoo: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0C::I64;
           I64[Sp - 16] = _saX0D::I64;
           I64[Sp - 8] = _saX0E::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caYoq: // global
           if (_saX0C::I64 == 0) goto caYom; else goto caYol;
       caYom: // global
           (_saX10::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saX0B::I64, 1, 0, 0);
           Hp = Hp - 32;
           _saX11::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX10::I64));
           if (_saX11::I64 != 0) goto uaYpF; else goto caYpA;
       uaYpF: // global
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0D::I64;
           I64[Sp - 16] = _saX0E::I64;
           I64[Sp - 8] = _saX11::I64;
           Sp = Sp - 32;
           call _caYnr() args: 0, res: 0, upd: 0;
       caYpA: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYol: // global
           I64[Hp - 24] = sat_saX0O_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp - 8] = block_caYos_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYnr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYnr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caYoQ; else goto caYoP;
       caYoQ: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caYnq_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYoP: // global
           _saX0B::I64 = I64[Sp];
           _saX0D::I64 = I64[Sp + 8];
           _saX0E::I64 = I64[Sp + 16];
           (_saX15::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX15::I64 == 0) goto caYpg; else goto caYoV;
       caYpg: // global
           I64[Hp - 24] = sat_saX1u_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caYpd_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       caYoV: // global
           I64[Hp - 24] = sat_saX1e_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caYoR_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYnq() //  [R1]
         { info_tbl: [(caYnq,
                       label: block_caYnq_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYnq: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caYnr() args: 0, res: 0, upd: 0;
     }
 },
 _caYpd() //  [R1]
         { info_tbl: [(caYpd,
                       label: block_caYpd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYpd: // global
           I64[Sp] = block_caYpf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYpP; else goto caYpi;
       uaYpP: // global
           call _caYpf(R1) args: 0, res: 0, upd: 0;
       caYpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYpf() //  [R1]
         { info_tbl: [(caYpf,
                       label: block_caYpf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYpf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYpo; else goto caYpn;
       caYpo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYpn: // global
           _saX1A::I64 = I64[R1 + 7];
           if (_saX1A::I64 != (-1)) goto caYpw; else goto uaYpI;
       caYpw: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1A::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaYpI: // global
           Sp = Sp + 8;
           call _caYpx() args: 0, res: 0, upd: 0;
     }
 },
 _caYoR() //  [R1]
         { info_tbl: [(caYoR,
                       label: block_caYoR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYoR: // global
           I64[Sp] = block_caYoT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYpN; else goto caYoX;
       uaYpN: // global
           call _caYoT(R1) args: 0, res: 0, upd: 0;
       caYoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYoT() //  [R1]
         { info_tbl: [(caYoT,
                       label: block_caYoT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYoT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYp3; else goto caYp2;
       caYp3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYp2: // global
           _saX1k::I64 = I64[R1 + 7];
           if (_saX1k::I64 != (-1)) goto caYpb; else goto uaYpH;
       caYpb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1k::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaYpH: // global
           Sp = Sp + 8;
           call _caYpx() args: 0, res: 0, upd: 0;
     }
 },
 _caYos() //  [R1]
         { info_tbl: [(caYos,
                       label: block_caYos_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYos: // global
           I64[Sp] = block_caYou_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYpL; else goto caYow;
       uaYpL: // global
           call _caYou(R1) args: 0, res: 0, upd: 0;
       caYow: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYou() //  [R1]
         { info_tbl: [(caYou,
                       label: block_caYou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYoC; else goto caYoB;
       caYoC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYoB: // global
           _saX0U::I64 = I64[R1 + 7];
           if (_saX0U::I64 != (-1)) goto caYoK; else goto uaYpE;
       caYoK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX0U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaYpE: // global
           Sp = Sp + 8;
           call _caYpx() args: 0, res: 0, upd: 0;
     }
 },
 _caYpx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYpx: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.46234976 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { info_tbl: [(caYpY,
                       label: GHC.IO.FD.$fRawIOFD1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYpY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYq7; else goto caYq8;
       caYq7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYq8: // global
           I64[Sp - 24] = block_caYpV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYqh; else goto caYpW;
       uaYqh: // global
           call _caYpV(R1) args: 0, res: 0, upd: 0;
       caYpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYpV() //  [R1]
         { info_tbl: [(caYpV,
                       label: block_caYpV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYpV: // global
           I64[Sp - 8] = block_caYq1_info;
           _saX1I::I64 = I64[R1 + 7];
           _saX1J::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX1J::I64;
           I64[Sp + 8] = _saX1I::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYqg; else goto caYq2;
       uaYqg: // global
           call _caYq1(R1) args: 0, res: 0, upd: 0;
       caYq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYq1() //  [R1]
         { info_tbl: [(caYq1,
                       label: block_caYq1_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYq1: // global
           I64[Sp] = block_caYq6_info;
           _saX1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX1L::I64;
           if (R1 & 7 != 0) goto uaYqi; else goto caYqb;
       uaYqi: // global
           call _caYq6(R1) args: 0, res: 0, upd: 0;
       caYqb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYq6() //  [R1]
         { info_tbl: [(caYq6,
                       label: block_caYq6_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYq6: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.463855728 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.464998726 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { info_tbl: [(caYqq,
                       label: GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caYqI; else goto caYqJ;
       caYqI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYqJ: // global
           I64[Sp - 16] = block_caYqn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYqQ; else goto caYqo;
       uaYqQ: // global
           call _caYqn(R1) args: 0, res: 0, upd: 0;
       caYqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYqn() //  [R1]
         { info_tbl: [(caYqn,
                       label: block_caYqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqn: // global
           I64[Sp - 40] = block_caYqt_info;
           _saX1T::P64 = P64[R1 + 7];
           _saX1U::P64 = P64[R1 + 15];
           _saX1S::I64 = I64[R1 + 23];
           _saX1V::I64 = I64[R1 + 31];
           _saX1W::I64 = I64[R1 + 39];
           _saX1X::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _saX1U::P64;
           I64[Sp - 24] = _saX1V::I64;
           I64[Sp - 16] = _saX1W::I64;
           I64[Sp - 8] = _saX1X::I64;
           P64[Sp] = _saX1T::P64;
           I64[Sp + 8] = _saX1S::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaYqP; else goto caYqu;
       uaYqP: // global
           call _caYqt(R1) args: 0, res: 0, upd: 0;
       caYqu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYqt() //  [R1]
         { info_tbl: [(caYqt,
                       label: block_caYqt_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqt: // global
           I64[Sp] = block_caYqE_info;
           _saX1W::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _saX1W::I64;
           R4 = I64[Sp + 48] + _saX1W::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYqE() //  [R1]
         { info_tbl: [(caYqE,
                       label: block_caYqE_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caYqO; else goto caYqN;
       caYqO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYqN: // global
           _saX1S::I64 = I64[Sp + 48];
           _saX1T::P64 = P64[Sp + 40];
           _saX1U::P64 = P64[Sp + 8];
           _saX1V::I64 = I64[Sp + 16];
           call MO_Touch(_saX1T::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX1T::P64;
           P64[Hp - 32] = _saX1U::P64;
           I64[Hp - 24] = _saX1S::I64;
           I64[Hp - 16] = _saX1V::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.468399915 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { info_tbl: [(caYqY,
                       label: GHC.IO.FD.fdIsNonBlocking_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYr2; else goto caYr3;
       caYr2: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYr3: // global
           I64[Sp - 8] = block_caYqV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYr7; else goto caYqW;
       uaYr7: // global
           call _caYqV(R1) args: 0, res: 0, upd: 0;
       caYqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYqV() //  [R1]
         { info_tbl: [(caYqV,
                       label: block_caYqV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYqV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYr6; else goto caYr5;
       caYr6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYr5: // global
           _saX2b::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saX2b::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.469704622 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { info_tbl: [(caYrf,
                       label: GHC.IO.FD.fdFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYrj; else goto caYrk;
       caYrj: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYrk: // global
           I64[Sp - 8] = block_caYrc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYro; else goto caYrd;
       uaYro: // global
           call _caYrc(R1) args: 0, res: 0, upd: 0;
       caYrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYrc() //  [R1]
         { info_tbl: [(caYrc,
                       label: block_caYrc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYrn; else goto caYrm;
       caYrn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYrm: // global
           _saX2e::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2e::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.47108557 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { info_tbl: [(caYrw,
                       label: GHC.IO.FD.$fShowFD_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYrC; else goto caYrD;
       caYrC: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYrD: // global
           I64[Sp - 8] = block_caYrt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYrI; else goto caYru;
       uaYrI: // global
           call _caYrt(R1) args: 0, res: 0, upd: 0;
       caYru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYrt() //  [R1]
         { info_tbl: [(caYrt,
                       label: block_caYrt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrt: // global
           I64[Sp] = block_caYrz_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYrz() //  [R1, R2]
         { info_tbl: [(caYrz,
                       label: block_caYrz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYrH; else goto caYrG;
       caYrH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caYrG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.472614947 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { info_tbl: [(caYrU,
                       label: GHC.IO.FD.$fBufferedIOFD15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYrX; else goto caYrY;
       caYrX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYrY: // global
           I64[Sp - 16] = block_caYrN_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYrN() //  [R1]
         { info_tbl: [(caYrN,
                       label: block_caYrN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrN: // global
           I64[Sp - 8] = block_caYrP_info;
           _saX2s::P64 = R1;
           R1 = 8192;
           P64[Sp] = _saX2s::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYrP() //  [R1]
         { info_tbl: [(caYrP,
                       label: block_caYrP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYrP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caYs2; else goto caYs1;
       caYs2: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYs1: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.47432705 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_saX2E_entry() //  [R1]
         { info_tbl: [(caYse,
                       label: sat_saX2E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYse: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYsi; else goto caYsj;
       caYsi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYsj: // global
           I64[Sp - 8] = block_caYsb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYsn; else goto caYsc;
       uaYsn: // global
           call _caYsb(R1) args: 0, res: 0, upd: 0;
       caYsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYsb() //  [R1]
         { info_tbl: [(caYsb,
                       label: block_caYsb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYsb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYsm; else goto caYsl;
       caYsm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYsl: // global
           _saX2C::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2C::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { info_tbl: [(caYso,
                       label: GHC.IO.FD.$fIODeviceFD12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYso: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYss; else goto caYsr;
       caYss: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYsr: // global
           I64[Hp - 16] = sat_saX2E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.476043771 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_saX2L_entry() //  [R1]
         { info_tbl: [(caYsE,
                       label: sat_saX2L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYsE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYsI; else goto caYsJ;
       caYsI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYsJ: // global
           I64[Sp - 8] = block_caYsB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYsN; else goto caYsC;
       uaYsN: // global
           call _caYsB(R1) args: 0, res: 0, upd: 0;
       caYsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYsB() //  [R1]
         { info_tbl: [(caYsB,
                       label: block_caYsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYsB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYsM; else goto caYsL;
       caYsM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYsL: // global
           _saX2J::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2J::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { info_tbl: [(caYsO,
                       label: GHC.IO.FD.$fIODeviceFD9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYsO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYsS; else goto caYsR;
       caYsS: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYsR: // global
           I64[Hp - 16] = sat_saX2L_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.477941528 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_saX2R_entry() //  [R1]
         { info_tbl: [(caYt4,
                       label: sat_saX2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYt4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYt8; else goto caYt9;
       caYt8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYt9: // global
           I64[Sp - 8] = block_caYt1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYtd; else goto caYt2;
       uaYtd: // global
           call _caYt1(R1) args: 0, res: 0, upd: 0;
       caYt2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYt1() //  [R1]
         { info_tbl: [(caYt1,
                       label: block_caYt1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYt1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYtc; else goto caYtb;
       caYtc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYtb: // global
           _saX2P::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2P::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { info_tbl: [(caYte,
                       label: GHC.IO.FD.$fIODeviceFD8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYte: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYti; else goto caYth;
       caYti: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYth: // global
           I64[Hp - 16] = sat_saX2R_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.479905494 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_saX30_entry() //  [R1]
         { info_tbl: [(caYty,
                       label: sat_saX30_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYty: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYtz; else goto caYtA;
       caYtz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYtA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caYtr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYtH; else goto caYts;
       uaYtH: // global
           call _caYtr(R1) args: 0, res: 0, upd: 0;
       caYts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYtr() //  [R1]
         { info_tbl: [(caYtr,
                       label: block_caYtr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYtr: // global
           if (R1 & 7 == 1) goto caYtv; else goto caYtw;
       caYtv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYtw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saX2Y_entry() //  [R1]
         { info_tbl: [(caYtP,
                       label: sat_saX2Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYtP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYtT; else goto caYtU;
       caYtT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYtU: // global
           I64[Sp - 8] = block_caYtM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYtY; else goto caYtN;
       uaYtY: // global
           call _caYtM(R1) args: 0, res: 0, upd: 0;
       caYtN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYtM() //  [R1]
         { info_tbl: [(caYtM,
                       label: block_caYtM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYtX; else goto caYtW;
       caYtX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYtW: // global
           _saX2W::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2W::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { info_tbl: [(caYtZ,
                       label: GHC.IO.FD.$fIODeviceFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYtZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caYu3; else goto caYu2;
       caYu3: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYu2: // global
           I64[Hp - 40] = sat_saX30_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_saX2Y_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.481716644 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.482254491 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.48285374 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.483357383 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.483901271 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.484464689 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.485057285 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.485737278 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.48628615 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.486895933 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.487586569 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.488219997 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.488857392 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.489644548 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.490196826 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.49076703 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.492919955 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caYub,
                       label: GHC.IO.FD.$fShowFD_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYub: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYuh; else goto caYui;
       caYuh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYui: // global
           I64[Sp - 16] = block_caYu8_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYun; else goto caYu9;
       uaYun: // global
           call _caYu8(R1) args: 0, res: 0, upd: 0;
       caYu9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYu8() //  [R1]
         { info_tbl: [(caYu8,
                       label: block_caYu8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYu8: // global
           I64[Sp] = block_caYue_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYue() //  [R1, R2]
         { info_tbl: [(caYue,
                       label: block_caYue_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYue: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYum; else goto caYul;
       caYum: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caYul: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.49454793 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(caYuv,
                       label: GHC.IO.FD.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYuv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYuw; else goto caYux;
       caYuw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYux: // global
           I64[Sp - 16] = block_caYus_info;
           R4 = GHC.Types.[]_closure+1;
           _saX3c::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _saX3c::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYus() //  [R1, R2]
         { info_tbl: [(caYus,
                       label: block_caYus_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYus: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYuA; else goto caYuz;
       caYuA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caYuz: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.495907889 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { info_tbl: [(caYuI,
                       label: GHC.IO.FD.$fShowFD1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYuI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYuJ; else goto caYuK;
       caYuJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYuK: // global
           I64[Sp - 16] = block_caYuF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYuO; else goto caYuG;
       uaYuO: // global
           call _caYuF(R1) args: 0, res: 0, upd: 0;
       caYuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYuF() //  [R1]
         { info_tbl: [(caYuF,
                       label: block_caYuF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYuF: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.49698856 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caYuT,
                       label: GHC.IO.FD.$fShowFD_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYuT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.497721185 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.498555101 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { info_tbl: [(caYv6,
                       label: output_flags_raWV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYv6: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caYvo; else goto caYvp;
       caYvp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYvr; else goto caYvq;
       caYvr: // global
           HpAlloc = 16;
           goto caYvo;
       caYvo: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYvq: // global
           (_caYuZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_caYuZ::I64 == 0) goto caYv1; else goto caYv0;
       caYv1: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       caYv0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYuZ::I64;
           (_saX3r::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX3v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3r::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3v::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.499969908 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { info_tbl: [(caYvB,
                       label: write_flags_raWV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYvB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYvV; else goto caYvW;
       caYvV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYvW: // global
           (_caYvv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYvv::I64 == 0) goto caYvx; else goto caYvw;
       caYvx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYvw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYvv::I64;
           I64[Sp - 24] = block_caYvy_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYw0; else goto caYvz;
       uaYw0: // global
           call _caYvy(R1) args: 0, res: 0, upd: 0;
       caYvz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYvy() //  [R1]
         { info_tbl: [(caYvy,
                       label: block_caYvy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYvy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYvZ; else goto caYvY;
       caYvZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYvY: // global
           _saX3D::I64 = I64[R1 + 7];
           (_saX3H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3D::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3H::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.501557585 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { info_tbl: [(caYwa,
                       label: append_flags_raWV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYwa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYwu; else goto caYwv;
       caYwu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYwv: // global
           (_caYw4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYw4::I64 == 0) goto caYw6; else goto caYw5;
       caYw6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYw5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYw4::I64;
           I64[Sp - 24] = block_caYw7_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYwz; else goto caYw8;
       uaYwz: // global
           call _caYw7(R1) args: 0, res: 0, upd: 0;
       caYw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYw7() //  [R1]
         { info_tbl: [(caYw7,
                       label: block_caYw7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYw7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYwy; else goto caYwx;
       caYwy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYwx: // global
           _saX3O::I64 = I64[R1 + 7];
           (_saX3S::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3O::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3S::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.503108638 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { info_tbl: [(caYwJ,
                       label: rw_flags_raWV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYwJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYx3; else goto caYx4;
       caYx3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYx4: // global
           (_caYwD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYwD::I64 == 0) goto caYwF; else goto caYwE;
       caYwF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYwE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYwD::I64;
           I64[Sp - 24] = block_caYwG_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYx8; else goto caYwH;
       uaYx8: // global
           call _caYwG(R1) args: 0, res: 0, upd: 0;
       caYwH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYwG() //  [R1]
         { info_tbl: [(caYwG,
                       label: block_caYwG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYwG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYx7; else goto caYx6;
       caYx7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYx6: // global
           _saX3Z::I64 = I64[R1 + 7];
           (_saX43::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3Z::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX43::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.504602481 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { info_tbl: [(caYxj,
                       label: read_flags_raWV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYxj: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caYxB; else goto caYxC;
       caYxC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYxE; else goto caYxD;
       caYxE: // global
           HpAlloc = 16;
           goto caYxB;
       caYxB: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYxD: // global
           (_caYxc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_caYxc::I64 == 0) goto caYxe; else goto caYxd;
       caYxe: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       caYxd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYxc::I64;
           (_saX4c::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX4g::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4c::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4g::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.50592441 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { info_tbl: [(caYxM,
                       label: GHC.IO.FD.$fIODeviceFD16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYxM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYxN; else goto caYxO;
       caYxN: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYxO: // global
           I64[Sp - 8] = block_caYxJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYxW; else goto caYxK;
       uaYxW: // global
           call _caYxJ(R1) args: 0, res: 0, upd: 0;
       caYxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYxJ() //  [R1]
         { info_tbl: [(caYxJ,
                       label: block_caYxJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYxJ: // global
           if (I64[R1 + 7] == (-1)) goto caYxV; else goto caYxU;
       caYxV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYxU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.506988453 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.507740883 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { info_tbl: [(caYy3,
                       label: GHC.IO.FD.$fIODeviceFD14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYy3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYy4; else goto caYy5;
       caYy4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYy5: // global
           (_caYy0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYy0::I64 == 0) goto caYy2; else goto caYy1;
       caYy2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYy1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYy0::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.509762392 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_saX4E_entry() //  [R1]
         { info_tbl: [(caYyi,
                       label: sat_saX4E_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYys; else goto caYyr;
       caYys: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYyr: // global
           (_saX4C::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4C::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX4I_entry() //  [R1]
         { info_tbl: [(caYyz,
                       label: sat_saX4I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYyA; else goto caYyB;
       caYyA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYyB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { info_tbl: [(caYyC,
                       label: GHC.IO.FD.$w$ctell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyC: // global
           _saX4r::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caYyD; else goto caYyE;
       caYyE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYyG; else goto caYyF;
       caYyG: // global
           HpAlloc = 24;
           goto caYyD;
       caYyD: // global
           R2 = _saX4r::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYyF: // global
           (_saX4w::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_saX4E_info;
           I64[Hp - 8] = _saX4r::I64;
           I64[Hp] = _saX4w::I64;
           I64[Sp - 8] = block_caYyt_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYyt() //  [R1]
         { info_tbl: [(caYyt,
                       label: block_caYyt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYyJ; else goto caYyI;
       caYyJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYyI: // global
           I64[Hp - 16] = sat_saX4I_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.511685759 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { info_tbl: [(caYyR,
                       label: GHC.IO.FD.$fIODeviceFD13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYyS; else goto caYyT;
       caYyS: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYyT: // global
           I64[Sp - 8] = block_caYyO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYyX; else goto caYyP;
       uaYyX: // global
           call _caYyO(R1) args: 0, res: 0, upd: 0;
       caYyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYyO() //  [R1]
         { info_tbl: [(caYyO,
                       label: block_caYyO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYyO: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.512666851 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.513470988 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { info_tbl: [(caYz4,
                       label: GHC.IO.FD.$fIODeviceFD18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYz4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYz5; else goto caYz6;
       caYz5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYz6: // global
           (_caYz1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYz1::I64 == 0) goto caYz3; else goto caYz2;
       caYz3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYz2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYz1::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.515271671 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_saX51_entry() //  [R1]
         { info_tbl: [(caYzu,
                       label: sat_saX51_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYzy; else goto caYzx;
       caYzy: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYzx: // global
           (_saX4Z::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4Z::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { info_tbl: [(caYzz,
                       label: GHC.IO.FD.$w$cseek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYzA; else goto caYzB;
       caYzA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYzB: // global
           I64[Sp - 24] = block_caYzb_info;
           _saX4O::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _saX4O::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYzb() //  [R1]
         { info_tbl: [(caYzb,
                       label: block_caYzb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzb: // global
           I64[Sp] = block_caYzC_info;
           _saX4S::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX4S::I64;
           if (R1 & 7 != 0) goto uaYAb; else goto caYzK;
       uaYAb: // global
           call _caYzC(R1) args: 0, res: 0, upd: 0;
       caYzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYzC() //  [R1]
         { info_tbl: [(caYzC,
                       label: block_caYzC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzC: // global
           _caYA2::P64 = R1 & 7;
           if (_caYA2::P64 < 3) goto uaYA6; else goto caYzY;
       uaYA6: // global
           if (_caYA2::P64 < 2) goto caYzQ; else goto caYzU;
       caYzQ: // global
           (_saX59::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX59::I64));
           goto uaYAf;
       caYzU: // global
           (_saX5e::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5e::I64));
           goto uaYAf;
       caYzY: // global
           (_saX5j::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5j::I64));
           goto uaYAf;
       uaYAf: // global
           call _caYzi() args: 0, res: 0, upd: 0;
     }
 },
 _caYzi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzi: // global
           Hp = Hp + 32;
           _saX4U::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caYzH; else goto caYzG;
       caYzH: // global
           HpAlloc = 32;
           I64[Sp] = block_caYzh_info;
           R1 = _saX4U::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYzG: // global
           I64[Hp - 24] = sat_saX51_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX4U::I64;
           I64[Sp + 16] = block_caYzE_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYzh() //  [R1]
         { info_tbl: [(caYzh,
                       label: block_caYzh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzh: // global
           I64[Sp] = R1;
           call _caYzi() args: 0, res: 0, upd: 0;
     }
 },
 _caYzE() //  []
         { info_tbl: [(caYzE,
                       label: block_caYzE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYzE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.517876699 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { info_tbl: [(caYAn,
                       label: GHC.IO.FD.$fIODeviceFD17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYAo; else goto caYAp;
       caYAo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYAp: // global
           I64[Sp - 24] = block_caYAk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYAt; else goto caYAl;
       uaYAt: // global
           call _caYAk(R1) args: 0, res: 0, upd: 0;
       caYAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYAk() //  [R1]
         { info_tbl: [(caYAk,
                       label: block_caYAk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAk: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.51991517 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.520449355 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.521062949 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.521872734 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.522578698 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { info_tbl: [(caYAA,
                       label: lvl4_raWVa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYAB; else goto caYAC;
       caYAB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYAC: // global
           (_caYAx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYAx::I64 == 0) goto caYAz; else goto caYAy;
       caYAz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYAy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYAx::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.523617773 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { info_tbl: [(caYAJ,
                       label: GHC.IO.FD.$fIODeviceFD11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAJ: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.524656206 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { info_tbl: [(caYAS,
                       label: GHC.IO.FD.$wsetSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYAT; else goto caYAU;
       caYAT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYAU: // global
           I64[Sp - 16] = block_caYAQ_info;
           _saX5v::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _saX5v::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYAQ() //  [R1]
         { info_tbl: [(caYAQ,
                       label: block_caYAQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYAQ: // global
           (_saX5C::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_saX5C::I64) == 0 :: W32) goto caYBc; else goto caYB6;
       caYBc: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYB6: // global
           (_saX5H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX5H::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.52602329 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { info_tbl: [(caYBo,
                       label: GHC.IO.FD.$fIODeviceFD10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYBp; else goto caYBq;
       caYBp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYBq: // global
           I64[Sp - 16] = block_caYBl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYBu; else goto caYBm;
       uaYBu: // global
           call _caYBl(R1) args: 0, res: 0, upd: 0;
       caYBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYBl() //  [R1]
         { info_tbl: [(caYBl,
                       label: block_caYBl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBl: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.527187987 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYBz,
                       label: GHC.IO.FD.writeRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.528115802 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYBG,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBG: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.529070097 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYBN,
                       label: GHC.IO.FD.readRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.53061575 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBR: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYBX,
                       label: GHC.IO.FD.$w$cfillReadBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYBX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caYC8; else goto caYC9;
       caYC8: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caYC9: // global
           I64[Sp - 32] = block_caYC5_info;
           _saX5T::P64 = R6;
           R6 = 0;
           _saX5S::P64 = R5;
           _saX5W::I64 = I64[Sp + 16];
           R5 = R4 + _saX5W::I64;
           _saX5R::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _saX5W::I64;
           I64[Sp - 24] = _saX5R::I64;
           P64[Sp - 16] = _saX5S::P64;
           P64[Sp - 8] = _saX5T::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caYC5() //  [R1]
         { info_tbl: [(caYC5,
                       label: block_caYC5_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYC5: // global
           I64[Sp] = block_caYC7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYCy; else goto caYCb;
       uaYCy: // global
           call _caYC7(R1) args: 0, res: 0, upd: 0;
       caYCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYC7() //  [R1]
         { info_tbl: [(caYC7,
                       label: block_caYC7_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYC7: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caYCh; else goto caYCg;
       caYCh: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYCg: // global
           _saX5R::I64 = I64[Sp + 8];
           _saX5S::P64 = P64[Sp + 16];
           _saX5T::P64 = P64[Sp + 24];
           _saX5U::I64 = I64[Sp + 32];
           _saX5V::I64 = I64[Sp + 40];
           _saX5W::I64 = I64[Sp + 48];
           _saX66::I64 = I64[R1 + 7];
           if (_saX66::I64 == (-1)) goto caYCx; else goto caYCs;
       caYCx: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _caYCw::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _caYCw::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYCs: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64 + _saX66::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.533039762 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { info_tbl: [(caYCG,
                       label: GHC.IO.FD.$fBufferedIOFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYCG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYCK; else goto caYCL;
       caYCK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYCL: // global
           I64[Sp - 16] = block_caYCD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYCT; else goto caYCE;
       uaYCT: // global
           call _caYCD(R1) args: 0, res: 0, upd: 0;
       caYCE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYCD() //  [R1]
         { info_tbl: [(caYCD,
                       label: block_caYCD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYCD: // global
           I64[Sp - 8] = block_caYCJ_info;
           _saX6j::I64 = I64[R1 + 7];
           _saX6k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6k::I64;
           I64[Sp + 8] = _saX6j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYCS; else goto caYCN;
       uaYCS: // global
           call _caYCJ(R1) args: 0, res: 0, upd: 0;
       caYCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYCJ() //  [R1]
         { info_tbl: [(caYCJ,
                       label: block_caYCJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYCJ: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.535498647 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYCV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saX6L_entry() //  [R1]
         { info_tbl: [(caYDf,
                       label: sat_saX6L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDf: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caYDg; else goto caYDh;
       caYDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYDh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caYDc_info;
           _saX6v::P64 = P64[R1 + 16];
           _saX6w::P64 = P64[R1 + 24];
           _saX6u::I64 = I64[R1 + 40];
           _saX6x::I64 = I64[R1 + 48];
           _saX6y::I64 = I64[R1 + 56];
           _saX6z::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saX6u::I64;
           P64[Sp - 56] = _saX6v::P64;
           P64[Sp - 48] = _saX6w::P64;
           I64[Sp - 40] = _saX6x::I64;
           I64[Sp - 32] = _saX6y::I64;
           I64[Sp - 24] = _saX6z::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaYDz; else goto caYDd;
       uaYDz: // global
           call _caYDc(R1) args: 0, res: 0, upd: 0;
       caYDd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYDc() //  [R1]
         { info_tbl: [(caYDc,
                       label: block_caYDc_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caYDm; else goto caYDl;
       caYDm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYDl: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6z::I64 = I64[Sp + 48];
           _saX6J::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_saX6J::I64 == _saX6z::I64) goto caYDy; else goto caYDv;
       caYDy: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYDv: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = _saX6J::I64;
           I64[Hp] = _saX6z::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYDA,
                       label: GHC.IO.FD.$w$cflushWriteBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYDC; else goto caYDD;
       caYDC: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caYDD: // global
           I64[Sp - 32] = block_caYD5_info;
           _saX6v::P64 = R5;
           _saX6y::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _saX6y::I64;
           _saX6u::I64 = R4;
           R4 = R4 + _saX6y::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _saX6u::I64;
           P64[Sp - 16] = _saX6v::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYD5() //  [R1]
         { info_tbl: [(caYD5,
                       label: block_caYD5_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYD5: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caYDG; else goto caYDF;
       caYDG: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYDF: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6y::I64 = I64[Sp + 40];
           _saX6z::I64 = I64[Sp + 48];
           call MO_Touch(_saX6v::P64);
           I64[Hp - 88] = sat_saX6L_info;
           P64[Hp - 72] = _saX6v::P64;
           P64[Hp - 64] = _saX6w::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saX6u::I64;
           I64[Hp - 40] = _saX6x::I64;
           I64[Hp - 32] = _saX6y::I64;
           I64[Hp - 24] = _saX6z::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.538455965 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { info_tbl: [(caYDO,
                       label: GHC.IO.FD.$fBufferedIOFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYDS; else goto caYDT;
       caYDS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYDT: // global
           I64[Sp - 16] = block_caYDL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYE1; else goto caYDM;
       uaYE1: // global
           call _caYDL(R1) args: 0, res: 0, upd: 0;
       caYDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYDL() //  [R1]
         { info_tbl: [(caYDL,
                       label: block_caYDL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDL: // global
           I64[Sp - 8] = block_caYDR_info;
           _saX6R::I64 = I64[R1 + 7];
           _saX6S::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6S::I64;
           I64[Sp + 8] = _saX6R::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYE0; else goto caYDV;
       uaYE0: // global
           call _caYDR(R1) args: 0, res: 0, upd: 0;
       caYDV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYDR() //  [R1]
         { info_tbl: [(caYDR,
                       label: block_caYDR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYDR: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.540273609 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_saX7a_entry() //  [R1]
         { info_tbl: [(caYEm,
                       label: sat_saX7a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYEm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYEn; else goto caYEy;
       caYEn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYEy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto caYEl; else goto caYEk;
       caYEl: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYEk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { info_tbl: [(caYEz,
                       label: GHC.IO.FD.$fIODeviceFD21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYEz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYEA; else goto caYEB;
       caYEA: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYEB: // global
           I64[Sp - 8] = block_caYE6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYEF; else goto caYE7;
       uaYEF: // global
           call _caYE6(R1) args: 0, res: 0, upd: 0;
       caYE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYE6() //  [R1]
         { info_tbl: [(caYE6,
                       label: block_caYE6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYE6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYEE; else goto caYED;
       caYEE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYED: // global
           (_saX78::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_saX7a_info;
           I64[Hp] = _saX78::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.541992408 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { info_tbl: [(caYEN,
                       label: GHC.IO.FD.$fIODeviceFD25_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYEN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYEO; else goto caYEP;
       caYEO: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYEP: // global
           I64[Sp - 8] = block_caYEK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYEX; else goto caYEL;
       uaYEX: // global
           call _caYEK(R1) args: 0, res: 0, upd: 0;
       caYEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYEK() //  [R1]
         { info_tbl: [(caYEK,
                       label: block_caYEK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYEK: // global
           if (I64[R1 + 7] == (-1)) goto caYEW; else goto caYEV;
       caYEW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYEV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.543094522 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.543805897 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { info_tbl: [(caYF4,
                       label: GHC.IO.FD.$fIODeviceFD28_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYF4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYF5; else goto caYF6;
       caYF5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYF6: // global
           (_caYF1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYF1::I64 == 0) goto caYF3; else goto caYF2;
       caYF3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYF2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYF1::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.547159385 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_saX7u_entry() //  [R1]
         { info_tbl: [(caYFn,
                       label: sat_saX7u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYFD; else goto caYFE;
       caYFD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYFE: // global
           I64[Sp - 8] = block_caYFx_info;
           Sp = Sp - 8;
           _caYFt::I64 = I64[R1 + 7];
           _caYFu::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _caYFv::I64 = I64[R1 + 15];
           _uaYFK::P64 = CurrentTSO;
           I64[I64[_uaYFK::P64 + 24] + 16] = Sp;
           _uaYFL::I64 = CurrentNursery;
           P64[_uaYFL::I64 + 8] = Hp + 8;
           I64[_uaYFK::P64 + 104] = I64[_uaYFK::P64 + 104] - ((Hp + 8) - I64[_uaYFL::I64]);
           (_uaYFI::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX7r::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_caYFt::I64, _caYFu::I64, _caYFv::I64, 0);
           (_uaYFJ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaYFI::I64);
           BaseReg = _uaYFJ::I64;
           _uaYFM::P64 = CurrentTSO;
           _uaYFN::P64 = I64[_uaYFM::P64 + 24];
           Sp = I64[_uaYFN::P64 + 16];
           SpLim = _uaYFN::P64 + 192;
           HpAlloc = 0;
           _uaYFO::I64 = CurrentNursery;
           _uaYFP::I64 = I64[_uaYFO::I64 + 8];
           Hp = _uaYFP::I64 - 8;
           _uaYFQ::I64 = I64[_uaYFO::I64];
           HpLim = _uaYFQ::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYFO::I64 + 48]) << 12) - 1);
           I64[_uaYFM::P64 + 104] = I64[_uaYFM::P64 + 104] + (_uaYFP::I64 - _uaYFQ::I64);
           R1 = _saX7r::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYFx() //  [R1]
         { info_tbl: [(caYFx,
                       label: block_caYFx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYFH; else goto caYFG;
       caYFH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYFG: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX7B_entry() //  [R1]
         { info_tbl: [(caYG1,
                       label: sat_saX7B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYG1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYG2; else goto caYG3;
       caYG2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYG3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caYFY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYGd; else goto caYFZ;
       uaYGd: // global
           call _caYFY(R1) args: 0, res: 0, upd: 0;
       caYFZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYFY() //  [R1]
         { info_tbl: [(caYFY,
                       label: block_caYFY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFY: // global
           _saX7A::I64 = I64[R1 + 7];
           if (_saX7A::I64 != 0) goto uaYGc; else goto caYGa;
       uaYGc: // global
           if (_saX7A::I64 != 1) goto caYG9; else goto caYGb;
       caYG9: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caYGb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYGa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { info_tbl: [(caYGl,
                       label: GHC.IO.FD.$w$cready_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 18} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYGl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYGm; else goto caYGn;
       caYGm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYGn: // global
           I64[Sp - 24] = block_caYGe_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYGG; else goto caYGf;
       uaYGG: // global
           call _caYGe(R1) args: 0, res: 0, upd: 0;
       caYGf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYGe() //  [R1]
         { info_tbl: [(caYGe,
                       label: block_caYGe_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYGe: // global
           if (R1 & 7 == 1) goto caYGi; else goto caYGj;
       caYGi: // global
           I64[Sp] = 0;
           goto uaYGF;
       caYGj: // global
           I64[Sp] = 1;
           goto uaYGF;
       uaYGF: // global
           call _caYFe() args: 0, res: 0, upd: 0;
     }
 },
 _caYFe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFe: // global
           Hp = Hp + 32;
           _saX7k::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caYGq; else goto caYGp;
       caYGq: // global
           HpAlloc = 32;
           I64[Sp] = block_caYFd_info;
           R1 = _saX7k::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYGp: // global
           I64[Hp - 24] = sat_saX7u_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX7k::I64;
           I64[Sp + 16] = block_caYFS_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYFd() //  [R1]
         { info_tbl: [(caYFd,
                       label: block_caYFd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFd: // global
           I64[Sp] = R1;
           call _caYFe() args: 0, res: 0, upd: 0;
     }
 },
 _caYFS() //  [R1]
         { info_tbl: [(caYFS,
                       label: block_caYFS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYFS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYGt; else goto caYGs;
       caYGt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYGs: // global
           I64[Hp - 16] = sat_saX7B_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.550467478 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { info_tbl: [(caYGO,
                       label: GHC.IO.FD.$fIODeviceFD27_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYGO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYGS; else goto caYGT;
       caYGS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYGT: // global
           I64[Sp - 24] = block_caYGL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYH1; else goto caYGM;
       uaYH1: // global
           call _caYGL(R1) args: 0, res: 0, upd: 0;
       caYGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYGL() //  [R1]
         { info_tbl: [(caYGL,
                       label: block_caYGL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYGL: // global
           I64[Sp] = block_caYGR_info;
           _saX7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX7I::I64;
           if (R1 & 7 != 0) goto uaYH0; else goto caYGV;
       uaYH0: // global
           call _caYGR(R1) args: 0, res: 0, upd: 0;
       caYGV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYGR() //  [R1]
         { info_tbl: [(caYGR,
                       label: block_caYGR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYGR: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.552423492 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_saX7W_entry() //  [R1]
         { info_tbl: [(caYHo,
                       label: sat_saX7W_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYHp; else goto caYHq;
       caYHp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYHq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caYHh_info;
           _saX7Q::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX7Q::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaYHD; else goto caYHi;
       uaYHD: // global
           call _caYHh(R1) args: 0, res: 0, upd: 0;
       caYHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYHh() //  [R1]
         { info_tbl: [(caYHh,
                       label: block_caYHh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHh: // global
           _saX7Q::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caYHl; else goto caYHm;
       caYHl: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYHC; else goto caYHv;
       caYHv: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYHm: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYHC; else goto caYHB;
       caYHC: // global
           HpAlloc = 24;
           R1 = _saX7V::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYHB: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { info_tbl: [(caYHE,
                       label: GHC.IO.FD.setNonBlockingMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYHF; else goto caYHG;
       caYHF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYHG: // global
           I64[Sp - 16] = block_caYH6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYHL; else goto caYH7;
       uaYHL: // global
           call _caYH6(R1) args: 0, res: 0, upd: 0;
       caYH7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYH6() //  [R1]
         { info_tbl: [(caYH6,
                       label: block_caYH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYH6: // global
           I64[Sp - 8] = block_caYHb_info;
           R3 = P64[Sp + 8];
           _saX7Q::I64 = I64[R1 + 7];
           R2 = _saX7Q::I64;
           I64[Sp] = _saX7Q::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYHb() //  [R1]
         { info_tbl: [(caYHb,
                       label: block_caYHb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caYHK; else goto caYHJ;
       caYHK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYHJ: // global
           I64[Hp - 24] = sat_saX7W_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.554576552 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { info_tbl: [(caYHQ,
                       label: GHC.IO.FD.setNonBlockingMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.55528369 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.556002401 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { info_tbl: [(caYHZ,
                       label: lvl6_raWVc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYHZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYI0; else goto caYI1;
       caYI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYI1: // global
           (_caYHW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYHW::I64 == 0) goto caYHY; else goto caYHX;
       caYHY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYHX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYHW::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.557021032 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { info_tbl: [(caYI8,
                       label: GHC.IO.FD.$fIODeviceFD2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYI8: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.558353181 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { info_tbl: [(caYIn,
                       label: GHC.IO.FD.$w$cdup2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYIo; else goto caYIp;
       caYIo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYIp: // global
           _saX82::I64 = R4;
           _saX81::I64 = R3;
           _caYIh::I64 = R4;
           (_saX87::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _caYIh::I64);
           _saX88::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX87::I64));
           if (_saX88::I64 != (-1)) goto uaYIE; else goto caYIm;
       uaYIE: // global
           I64[Sp - 24] = _saX81::I64;
           I64[Sp - 16] = _saX82::I64;
           I64[Sp - 8] = _saX88::I64;
           Sp = Sp - 24;
           call _caYIs() args: 0, res: 0, upd: 0;
       caYIm: // global
           (_saX8d::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX8d::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caYIs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYIx; else goto caYIw;
       caYIx: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caYIr_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYIw: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYIr() //  [R1]
         { info_tbl: [(caYIr,
                       label: block_caYIr_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIr: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caYIs() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.560031389 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { info_tbl: [(caYIP,
                       label: GHC.IO.FD.$fIODeviceFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYIT; else goto caYIU;
       caYIT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYIU: // global
           I64[Sp - 16] = block_caYIM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYJ2; else goto caYIN;
       uaYJ2: // global
           call _caYIM(R1) args: 0, res: 0, upd: 0;
       caYIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYIM() //  [R1]
         { info_tbl: [(caYIM,
                       label: block_caYIM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIM: // global
           I64[Sp - 8] = block_caYIS_info;
           _saX8j::I64 = I64[R1 + 7];
           _saX8k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX8k::I64;
           I64[Sp + 8] = _saX8j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYJ1; else goto caYIW;
       uaYJ1: // global
           call _caYIS(R1) args: 0, res: 0, upd: 0;
       caYIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYIS() //  [R1]
         { info_tbl: [(caYIS,
                       label: block_caYIS_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYIS: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.56123653 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.561970951 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { info_tbl: [(caYJ9,
                       label: GHC.IO.FD.$fIODeviceFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYJa; else goto caYJb;
       caYJa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYJb: // global
           (_caYJ6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYJ6::I64 == 0) goto caYJ8; else goto caYJ7;
       caYJ8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYJ7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYJ6::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.563666089 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_saX8C_entry() //  [R1]
         { info_tbl: [(caYJy,
                       label: sat_saX8C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYJC; else goto caYJD;
       caYJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caYJv_info;
           _saX8p::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX8p::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaYJH; else goto caYJw;
       uaYJH: // global
           call _caYJv(R1) args: 0, res: 0, upd: 0;
       caYJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYJv() //  [R1]
         { info_tbl: [(caYJv,
                       label: block_caYJv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYJG; else goto caYJF;
       caYJG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYJF: // global
           _saX8B::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8B::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { info_tbl: [(caYJL,
                       label: GHC.IO.FD.$w$cdup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYJM; else goto caYJN;
       caYJM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYJN: // global
           _saX8p::I64 = R3;
           (_saX8u::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _saX8v::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX8u::I64));
           if (_saX8v::I64 != (-1)) goto uaYJZ; else goto caYJK;
       uaYJZ: // global
           I64[Sp - 16] = _saX8p::I64;
           I64[Sp - 8] = _saX8v::I64;
           Sp = Sp - 16;
           call _caYJP() args: 0, res: 0, upd: 0;
       caYJK: // global
           I64[Sp - 16] = block_caYJp_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _saX8p::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYJP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJP: // global
           Hp = Hp + 24;
           _saX8v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caYJU; else goto caYJT;
       caYJU: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caYJO_info;
           R1 = _saX8v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYJT: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8v::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYJO() //  [R1]
         { info_tbl: [(caYJO,
                       label: block_caYJO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJO: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caYJP() args: 0, res: 0, upd: 0;
     }
 },
 _caYJp() //  [R1]
         { info_tbl: [(caYJp,
                       label: block_caYJp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYJp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caYJY; else goto caYJX;
       caYJY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYJX: // global
           I64[Hp - 24] = sat_saX8C_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.566053714 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { info_tbl: [(caYKa,
                       label: GHC.IO.FD.$fIODeviceFD3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYKb; else goto caYKc;
       caYKb: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYKc: // global
           I64[Sp - 8] = block_caYK7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYKg; else goto caYK8;
       uaYKg: // global
           call _caYK7(R1) args: 0, res: 0, upd: 0;
       caYK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYK7() //  [R1]
         { info_tbl: [(caYK7,
                       label: block_caYK7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYK7: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.567584166 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_saX8N_entry() //  [R1]
         { info_tbl: [(caYKs,
                       label: sat_saX8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYKw; else goto caYKx;
       caYKw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYKx: // global
           I64[Sp - 8] = block_caYKp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYKB; else goto caYKq;
       uaYKB: // global
           call _caYKp(R1) args: 0, res: 0, upd: 0;
       caYKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYKp() //  [R1]
         { info_tbl: [(caYKp,
                       label: block_caYKp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYKA; else goto caYKz;
       caYKA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYKz: // global
           _saX8L::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8L::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { info_tbl: [(caYKH,
                       label: GHC.IO.FD.$fIODeviceFD6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKH: // global
           _saX8I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caYKI; else goto caYKJ;
       caYKJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYKL; else goto caYKK;
       caYKL: // global
           HpAlloc = 24;
           goto caYKI;
       caYKI: // global
           R2 = _saX8I::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYKK: // global
           I64[Hp - 16] = sat_saX8N_info;
           P64[Hp] = _saX8I::P64;
           I64[Sp - 8] = block_caYKC_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYKC() //  [R1]
         { info_tbl: [(caYKC,
                       label: block_caYKC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKC: // global
           I64[Sp] = block_caYKE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYKQ; else goto caYKF;
       uaYKQ: // global
           call _caYKE(R1) args: 0, res: 0, upd: 0;
       caYKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYKE() //  [R1]
         { info_tbl: [(caYKE,
                       label: block_caYKE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKE: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.570367881 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_saX90_entry() //  [R1]
         { info_tbl: [(caYL2,
                       label: sat_saX90_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYL2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYL6; else goto caYL7;
       caYL6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYL7: // global
           I64[Sp - 8] = block_caYKZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYLb; else goto caYL0;
       uaYLb: // global
           call _caYKZ(R1) args: 0, res: 0, upd: 0;
       caYL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYKZ() //  [R1]
         { info_tbl: [(caYKZ,
                       label: block_caYKZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYKZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYLa; else goto caYL9;
       caYLa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYL9: // global
           _saX8Y::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8Y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX99_entry() //  [R1]
         { info_tbl: [(caYLv,
                       label: sat_saX99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYLw; else goto caYLx;
       caYLw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYLx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caYLn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYLI; else goto caYLo;
       uaYLI: // global
           call _caYLn(R1) args: 0, res: 0, upd: 0;
       caYLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYLn() //  [R1]
         { info_tbl: [(caYLn,
                       label: block_caYLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLn: // global
           _caYLu::P64 = R1 & 7;
           if (_caYLu::P64 == 3) goto caYLt; else goto uaYLH;
       uaYLH: // global
           if (_caYLu::P64 == 4) goto caYLt; else goto caYLr;
       caYLt: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYLr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { info_tbl: [(caYLJ,
                       label: GHC.IO.FD.$fIODeviceFD20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLJ: // global
           _saX8V::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caYLK; else goto caYLL;
       caYLL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYLN; else goto caYLM;
       caYLN: // global
           HpAlloc = 24;
           goto caYLK;
       caYLK: // global
           R2 = _saX8V::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYLM: // global
           I64[Hp - 16] = sat_saX90_info;
           P64[Hp] = _saX8V::P64;
           I64[Sp - 8] = block_caYLc_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYLc() //  [R1]
         { info_tbl: [(caYLc,
                       label: block_caYLc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLc: // global
           I64[Sp] = block_caYLe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYLS; else goto caYLf;
       uaYLS: // global
           call _caYLe(R1) args: 0, res: 0, upd: 0;
       caYLf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYLe() //  [R1]
         { info_tbl: [(caYLe,
                       label: block_caYLe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYLR; else goto caYLQ;
       caYLR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYLQ: // global
           _saX95::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_saX99_info;
           P64[Hp] = _saX95::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.574077151 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { info_tbl: [(caYM0,
                       label: GHC.IO.FD.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYM0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYM1; else goto caYM2;
       caYM1: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYM2: // global
           I64[Sp - 8] = block_caYLX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYM8; else goto caYLY;
       uaYM8: // global
           call _caYLX(R1) args: 0, res: 0, upd: 0;
       caYLY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYLX() //  [R1]
         { info_tbl: [(caYLX,
                       label: block_caYLX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYLX: // global
           (_saX9i::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.575201236 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { info_tbl: [(caYMd,
                       label: GHC.IO.FD.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMd: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.575923651 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.576663509 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { info_tbl: [(caYMm,
                       label: GHC.IO.FD.$fIODeviceFD23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYMn; else goto caYMo;
       caYMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYMo: // global
           (_caYMj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYMj::I64 == 0) goto caYMl; else goto caYMk;
       caYMl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYMk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYMj::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.578003422 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_saX9t_entry() //  [R1]
         { info_tbl: [(caYMA,
                       label: sat_saX9t_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYML; else goto caYMK;
       caYML: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYMK: // global
           (_saX9q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9q::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { info_tbl: [(caYMO,
                       label: GHC.IO.FD.$wclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMO: // global
           _saX9j::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caYMP; else goto caYMQ;
       caYMQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYMS; else goto caYMR;
       caYMS: // global
           HpAlloc = 16;
           goto caYMP;
       caYMP: // global
           R2 = _saX9j::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYMR: // global
           I64[Hp - 8] = sat_saX9t_info;
           I64[Hp] = _saX9j::I64;
           I64[Sp - 8] = block_caYMM_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caYMM() //  []
         { info_tbl: [(caYMM,
                       label: block_caYMM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.579558446 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { info_tbl: [(caYN1,
                       label: GHC.IO.FD.$fIODeviceFD26_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYN1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYN2; else goto caYN3;
       caYN2: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYN3: // global
           I64[Sp - 8] = block_caYMY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYN7; else goto caYMZ;
       uaYN7: // global
           call _caYMY(R1) args: 0, res: 0, upd: 0;
       caYMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYMY() //  [R1]
         { info_tbl: [(caYMY,
                       label: block_caYMY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYMY: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.581079244 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_saX9W_entry() //  [R1]
         { info_tbl: [(caYNp,
                       label: sat_saX9W_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYNp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYNA; else goto caYNz;
       caYNA: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYNz: // global
           (_saX9T::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9T::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { info_tbl: [(caYNE,
                       label: GHC.IO.FD.$w$cclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYNE: // global
           _saX9B::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caYNF; else goto caYNG;
       caYNG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYNI; else goto caYNH;
       caYNI: // global
           HpAlloc = 16;
           goto caYNF;
       caYNF: // global
           R2 = _saX9B::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYNH: // global
           (_saX9G::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_saX9B::I64);
           (_saX9K::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX9K::I64 == 0) goto caYND; else goto caYNC;
       caYND: // global
           I64[Hp - 8] = sat_saX9W_info;
           I64[Hp] = _saX9B::I64;
           I64[Sp - 8] = block_caYNN_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       caYNC: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9B::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _caYNN() //  []
         { info_tbl: [(caYNN,
                       label: block_caYNN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYNN: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.582840085 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { info_tbl: [(caYNX,
                       label: GHC.IO.FD.$fIODeviceFD22_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYNX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYNY; else goto caYNZ;
       caYNY: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYNZ: // global
           I64[Sp - 8] = block_caYNU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYO3; else goto caYNV;
       uaYO3: // global
           call _caYNU(R1) args: 0, res: 0, upd: 0;
       caYNV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYNU() //  [R1]
         { info_tbl: [(caYNU,
                       label: block_caYNU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYNU: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.583854994 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.584514571 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.585280156 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { info_tbl: [(caYOa,
                       label: GHC.IO.FD.mkFD6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYOb; else goto caYOc;
       caYOb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYOc: // global
           (_caYO7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYO7::I64 == 0) goto caYO9; else goto caYO8;
       caYO9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYO8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYO7::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.58619581 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.586894077 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { info_tbl: [(caYOj,
                       label: GHC.IO.FD.mkFD10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYOk; else goto caYOl;
       caYOk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYOl: // global
           (_caYOg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYOg::I64 == 0) goto caYOi; else goto caYOh;
       caYOi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYOh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYOg::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.587836608 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.588598854 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { info_tbl: [(caYOs,
                       label: GHC.IO.FD.mkFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYOt; else goto caYOu;
       caYOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYOu: // global
           (_caYOp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYOp::I64 == 0) goto caYOr; else goto caYOq;
       caYOr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYOq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYOp::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.58953179 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.590216493 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { info_tbl: [(caYOB,
                       label: GHC.IO.FD.mkFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYOC; else goto caYOD;
       caYOC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYOD: // global
           (_caYOy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYOy::I64 == 0) goto caYOA; else goto caYOz;
       caYOA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYOz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYOy::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.591142842 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.591960808 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { info_tbl: [(caYOK,
                       label: GHC.IO.FD.mkFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYOL; else goto caYOM;
       caYOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYOM: // global
           (_caYOH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caYOH::I64 == 0) goto caYOJ; else goto caYOI;
       caYOJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caYOI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caYOH::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.595771431 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_saXaj_entry() //  [R1]
         { info_tbl: [(caYP8,
                       label: sat_saXaj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYP8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYP9; else goto caYPa;
       caYP9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYPa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caYP5_info;
           _saXa8::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saXa8::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaYPy; else goto caYP6;
       uaYPy: // global
           call _caYP5(R1) args: 0, res: 0, upd: 0;
       caYP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYP5() //  [R1]
         { info_tbl: [(caYP5,
                       label: block_caYP5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYP5: // global
           I64[Sp] = block_caYPd_info;
           _saXah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saXah::I64;
           if (R1 & 7 != 0) goto uaYPx; else goto caYPf;
       uaYPx: // global
           call _caYPd(R1) args: 0, res: 0, upd: 0;
       caYPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYPd() //  [R1]
         { info_tbl: [(caYPd,
                       label: block_caYPd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYPd: // global
           _saXah::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caYPl; else goto caYPs;
       caYPl: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYPv; else goto caYPn;
       caYPn: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYPs: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYPv; else goto caYPu;
       caYPv: // global
           HpAlloc = 24;
           R1 = _saXai::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYPu: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saXaG_entry() //  [R1]
         { info_tbl: [(caYQy,
                       label: sat_saXaG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYQz; else goto caYQA;
       caYQz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYQA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caYQr_info;
           _saXan::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saXan::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaYQN; else goto caYQs;
       uaYQN: // global
           call _caYQr(R1) args: 0, res: 0, upd: 0;
       caYQs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYQr() //  [R1]
         { info_tbl: [(caYQr,
                       label: block_caYQr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQr: // global
           _saXan::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caYQv; else goto caYQw;
       caYQv: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYQM; else goto caYQF;
       caYQF: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caYQw: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caYQM; else goto caYQL;
       caYQM: // global
           HpAlloc = 24;
           R1 = _saXaF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYQL: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caYQV,
                       label: GHC.IO.FD.$wmkFD_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caYQW; else goto caYQX;
       caYQW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYQX: // global
           I64[Sp - 32] = block_caYQO_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaYSs; else goto caYQP;
       uaYSs: // global
           call _caYQO(R1) args: 0, res: 0, upd: 0;
       caYQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYQO() //  [R1]
         { info_tbl: [(caYQO,
                       label: block_caYQO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQO: // global
           if (R1 & 7 == 1) goto caYQS; else goto caYQT;
       caYQS: // global
           I64[Sp] = block_caYRQ_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       caYQT: // global
           I64[Sp] = block_caYS2_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaYSr; else goto caYS4;
       uaYSr: // global
           call _caYS2(R1) args: 0, res: 0, upd: 0;
       caYS4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYRQ() //  [R1]
         { info_tbl: [(caYRQ,
                       label: block_caYRQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYRQ: // global
           I64[Sp] = block_caYRS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaYSu; else goto caYRV;
       uaYSu: // global
           call _caYRS(R1) args: 0, res: 0, upd: 0;
       caYRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYRS() //  [R1]
         { info_tbl: [(caYRS,
                       label: block_caYRS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYRS: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _caYS2() //  [R1]
         { info_tbl: [(caYS2,
                       label: block_caYS2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYS2: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _saXaa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saXaa: // global
           I64[Sp - 8] = block_caYOW_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYSx; else goto caYOX;
       uaYSx: // global
           call _caYOW(R1) args: 0, res: 0, upd: 0;
       caYOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYOW() //  [R1]
         { info_tbl: [(caYOW,
                       label: block_caYOW_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYOW: // global
           _caYSf::P64 = R1 & 7;
           if (_caYSf::P64 == 1) goto caYR7; else goto uaYSh;
       caYR7: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaYSh: // global
           _saXa5::P64 = P64[Sp + 32];
           if (_caYSf::P64 == 3) goto caYR9; else goto caYR1;
       caYR9: // global
           I64[Sp] = block_caYPC_info;
           R1 = _saXa5::P64;
           if (R1 & 7 != 0) goto uaYSm; else goto caYPD;
       uaYSm: // global
           call _caYPC(R1) args: 0, res: 0, upd: 0;
       caYPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYR1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caYR4; else goto caYR3;
       caYR4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYR3: // global
           I64[Hp - 48] = sat_saXaj_info;
           P64[Hp - 32] = _saXa5::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYPC() //  [R1]
         { info_tbl: [(caYPC,
                       label: block_caYPC_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYPC: // global
           _saXad::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caYPH_info;
           _saXan::I64 = I64[R1 + 7];
           R1 = _saXad::P64;
           I64[Sp + 32] = _saXan::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaYSn; else goto caYPI;
       uaYSn: // global
           call _caYPH(R1) args: 0, res: 0, upd: 0;
       caYPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYPH() //  [R1]
         { info_tbl: [(caYPH,
                       label: block_caYPH_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYPH: // global
           _saXae::P64 = P64[Sp + 8];
           _saXap::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXap::I64, 0)) goto caYRM; else goto caYRN;
       caYRM: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       caYRN: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       saXar: // global
           I64[Sp + 8] = block_caYPU_info;
           R1 = _saXae::P64;
           I64[Sp + 16] = _saXas::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaYSo; else goto caYPV;
       uaYSo: // global
           call _caYPU(R1) args: 0, res: 0, upd: 0;
       caYPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYPU() //  [R1]
         { info_tbl: [(caYPU,
                       label: block_caYPU_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYPU: // global
           _saXa6::P64 = P64[Sp + 24];
           _saXau::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXau::I64, 0)) goto caYRH; else goto caYRI;
       caYRH: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       caYRI: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       saXaw: // global
           I64[Sp] = block_caYRe_info;
           R1 = _saXa6::P64;
           I64[Sp + 24] = _saXax::I64;
           if (R1 & 7 != 0) goto uaYSp; else goto caYRt;
       uaYSp: // global
           call _caYRe(R1) args: 0, res: 0, upd: 0;
       caYRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYRe() //  [R1]
         { info_tbl: [(caYRe,
                       label: block_caYRe_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYRe: // global
           _saXan::I64 = I64[Sp + 16];
           _saXas::I64 = I64[Sp + 8];
           _saXax::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto caYRD; else goto caYRz;
       caYRD: // global
           _saXaz::I64 = 0;
           goto saXay;
       caYRz: // global
           _saXaz::I64 = 1;
           goto saXay;
       saXay: // global
           (_saXaD::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_saXan::I64, _saXas::I64, _saXax::I64, _saXaz::I64);
           _saXaE::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXaD::I64));
           if (_saXaE::I64 != (-1)) goto uaYSk; else goto caYRp;
       uaYSk: // global
           I64[Sp + 24] = _saXaE::I64;
           Sp = Sp + 16;
           call _caYQl() args: 0, res: 0, upd: 0;
       caYRp: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYQl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caYRm; else goto caYRl;
       caYRm: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caYQk_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYRl: // global
           I64[Hp - 48] = sat_saXaG_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYQk() //  [R1]
         { info_tbl: [(caYQk,
                       label: block_caYQk_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYQk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caYQl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.602607847 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { info_tbl: [(caYSC,
                       label: GHC.IO.FD.mkFD1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYSC: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.603534117 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYSJ,
                       label: GHC.IO.FD.mkFD_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYSJ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.608355798 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_saXbr_entry() //  [R1]
         { info_tbl: [(caYTk,
                       label: sat_saXbr_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caYTn; else goto caYTo;
       caYTn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYTo: // global
           I64[Sp - 8] = block_caYTg_info;
           Sp = Sp - 8;
           _caYTd::I64 = I64[R1 + 7];
           _caYTe::I64 = I64[R1 + 15];
           _uaYTu::P64 = CurrentTSO;
           I64[I64[_uaYTu::P64 + 24] + 16] = Sp;
           _uaYTv::I64 = CurrentNursery;
           P64[_uaYTv::I64 + 8] = Hp + 8;
           I64[_uaYTu::P64 + 104] = I64[_uaYTu::P64 + 104] - ((Hp + 8) - I64[_uaYTv::I64]);
           (_uaYTs::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saXbo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_caYTd::I64, _caYTe::I64, 438);
           (_uaYTt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaYTs::I64);
           BaseReg = _uaYTt::I64;
           _uaYTw::P64 = CurrentTSO;
           _uaYTx::P64 = I64[_uaYTw::P64 + 24];
           Sp = I64[_uaYTx::P64 + 16];
           SpLim = _uaYTx::P64 + 192;
           HpAlloc = 0;
           _uaYTy::I64 = CurrentNursery;
           _uaYTz::I64 = I64[_uaYTy::I64 + 8];
           Hp = _uaYTz::I64 - 8;
           _uaYTA::I64 = I64[_uaYTy::I64];
           HpLim = _uaYTA::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaYTy::I64 + 48]) << 12) - 1);
           I64[_uaYTw::P64 + 104] = I64[_uaYTw::P64 + 104] + (_uaYTz::I64 - _uaYTA::I64);
           R1 = _saXbo::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYTg() //  [R1]
         { info_tbl: [(caYTg,
                       label: block_caYTg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caYTr; else goto caYTq;
       caYTr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYTq: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbI_entry() //  [R1]
         { info_tbl: [(caYTW,
                       label: sat_saXbI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caYTX; else goto caYTY;
       caYTX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYTY: // global
           I64[Sp - 24] = block_caYTT_info;
           _saXbz::P64 = P64[R1 + 15];
           _saXbA::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _saXbz::P64;
           P64[Sp - 8] = _saXbA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYU4; else goto caYTU;
       uaYU4: // global
           call _caYTT(R1) args: 0, res: 0, upd: 0;
       caYTU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYTT() //  [R1]
         { info_tbl: [(caYTT,
                       label: block_caYTT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTT: // global
           _saXbz::P64 = P64[Sp + 8];
           _saXbA::P64 = P64[Sp + 16];
           (_saXbH::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _saXbA::P64;
           R2 = _saXbz::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbJ_entry() //  [R1, R2]
         { info_tbl: [(caYU5,
                       label: sat_saXbJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYU5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYU6; else goto caYU7;
       caYU6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYU7: // global
           I64[Sp - 16] = block_caYTJ_info;
           _saXbu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _saXbu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYUb; else goto caYTK;
       uaYUb: // global
           call _caYTJ(R1) args: 0, res: 0, upd: 0;
       caYTK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYTJ() //  [R1]
         { info_tbl: [(caYTJ,
                       label: block_caYTJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caYUa; else goto caYU9;
       caYUa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYU9: // global
           _saXbz::P64 = P64[R1 + 7];
           _saXbA::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_saXbI_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _saXbz::P64;
           P64[Hp] = _saXbA::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbw_entry() //  [R1]
         { info_tbl: [(caYUh,
                       label: sat_saXbw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUh: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaYYU_srtd" {
     uaYYU_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_saXcZ_entry() //  [R1, R2]
         { info_tbl: [(caYUk,
                       label: sat_saXcZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYUl; else goto caYUm;
       caYUl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caYUm: // global
           I64[Sp - 24] = block_caYSX_info;
           _saXb8::P64 = P64[R1 + 6];
           _saXb9::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _saXb8::P64;
           P64[Sp - 8] = _saXb9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYYn; else goto caYSY;
       uaYYn: // global
           call _caYSX(R1) args: 0, res: 0, upd: 0;
       caYSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYYV_srtd" {
     uaYYV_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caYSX() //  [R1]
         { info_tbl: [(caYSX,
                       label: block_caYSX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYSX: // global
           I64[Sp - 8] = block_caYUn_info;
           _saXbh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saXbh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYYl; else goto caYVt;
       uaYYl: // global
           call _caYUn(R1) args: 0, res: 0, upd: 0;
       caYVt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYYW_srtd" {
     uaYYW_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caYUn() //  [R1]
         { info_tbl: [(caYUn,
                       label: block_caYUn_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUn: // global
           _saXb8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto caYVA; else goto caYWm;
       caYVA: // global
           I64[Sp] = block_caYVx_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto uaYYo; else goto caYVB;
       uaYYo: // global
           call _caYVx(R1) args: 0, res: 0, upd: 0;
       caYVB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYWm: // global
           I64[Sp] = block_caYWk_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto uaYYp; else goto caYWn;
       uaYYp: // global
           call _caYWk(R1) args: 0, res: 0, upd: 0;
       caYWn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYYX_srtd" {
     uaYYX_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caYVx() //  [R1]
         { info_tbl: [(caYVx,
                       label: block_caYVx_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYVx: // global
           _caYY0::P64 = R1 & 7;
           if (_caYY0::P64 < 3) goto uaYY4; else goto uaYY5;
       uaYY4: // global
           if (_caYY0::P64 < 2) goto caYVI; else goto caYVS;
       caYVI: // global
           I64[Sp] = block_caYVF_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto uaYYy; else goto caYVJ;
       uaYYy: // global
           call _caYVF(R1) args: 0, res: 0, upd: 0;
       caYVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYVS: // global
           I64[Sp] = block_caYVQ_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto uaYYz; else goto caYVT;
       uaYYz: // global
           call _caYVQ(R1) args: 0, res: 0, upd: 0;
       caYVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaYY5: // global
           if (_caYY0::P64 < 4) goto caYW2; else goto caYWc;
       caYW2: // global
           I64[Sp] = block_caYW0_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto uaYYA; else goto caYW3;
       uaYYA: // global
           call _caYW0(R1) args: 0, res: 0, upd: 0;
       caYW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYWc: // global
           I64[Sp] = block_caYWa_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto uaYYB; else goto caYWd;
       uaYYB: // global
           call _caYWa(R1) args: 0, res: 0, upd: 0;
       caYWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYYY_srtd" {
     uaYYY_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYVF() //  [R1]
         { info_tbl: [(caYVF,
                       label: block_caYVF_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYVF: // global
           I64[Sp] = I64[R1 + 7];
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYYZ_srtd" {
     uaYYZ_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYVQ() //  [R1]
         { info_tbl: [(caYVQ,
                       label: block_caYVQ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYVQ: // global
           I64[Sp] = I64[R1 + 7];
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ0_srtd" {
     uaYZ0_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYW0() //  [R1]
         { info_tbl: [(caYW0,
                       label: block_caYW0_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYW0: // global
           I64[Sp] = I64[R1 + 7];
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ1_srtd" {
     uaYZ1_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYWa() //  [R1]
         { info_tbl: [(caYWa,
                       label: block_caYWa_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWa: // global
           I64[Sp] = I64[R1 + 7];
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ2_srtd" {
     uaYZ2_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _caYWk() //  [R1]
         { info_tbl: [(caYWk,
                       label: block_caYWk_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWk: // global
           _caYX5::P64 = R1 & 7;
           if (_caYX5::P64 < 3) goto uaYY6; else goto uaYY7;
       uaYY6: // global
           if (_caYX5::P64 < 2) goto caYWu; else goto caYWE;
       caYWu: // global
           I64[Sp] = block_caYWr_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto uaYYG; else goto caYWv;
       uaYYG: // global
           call _caYWr(R1) args: 0, res: 0, upd: 0;
       caYWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYWE: // global
           I64[Sp] = block_caYWC_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto uaYYH; else goto caYWF;
       uaYYH: // global
           call _caYWC(R1) args: 0, res: 0, upd: 0;
       caYWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaYY7: // global
           if (_caYX5::P64 < 4) goto caYWO; else goto caYWY;
       caYWO: // global
           I64[Sp] = block_caYWM_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto uaYYI; else goto caYWP;
       uaYYI: // global
           call _caYWM(R1) args: 0, res: 0, upd: 0;
       caYWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caYWY: // global
           I64[Sp] = block_caYWW_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto uaYYJ; else goto caYWZ;
       uaYYJ: // global
           call _caYWW(R1) args: 0, res: 0, upd: 0;
       caYWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYZ3_srtd" {
     uaYZ3_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYWr() //  [R1]
         { info_tbl: [(caYWr,
                       label: block_caYWr_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWr: // global
           _saXci::I64 = I64[R1 + 7];
           (_saXcm::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXci::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcm::I64));
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ4_srtd" {
     uaYZ4_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYWC() //  [R1]
         { info_tbl: [(caYWC,
                       label: block_caYWC_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWC: // global
           _saXct::I64 = I64[R1 + 7];
           (_saXcx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXct::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcx::I64));
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ5_srtd" {
     uaYZ5_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYWM() //  [R1]
         { info_tbl: [(caYWM,
                       label: block_caYWM_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWM: // global
           _saXcE::I64 = I64[R1 + 7];
           (_saXcI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcE::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcI::I64));
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ6_srtd" {
     uaYZ6_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYWW() //  [R1]
         { info_tbl: [(caYWW,
                       label: block_caYWW_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYWW: // global
           _saXcP::I64 = I64[R1 + 7];
           (_saXcT::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcP::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcT::I64));
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 _caYT5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYT5: // global
           Hp = Hp + 24;
           _saXbj::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caYUu; else goto caYUt;
       caYUu: // global
           HpAlloc = 24;
           I64[Sp] = block_caYT4_info;
           R1 = _saXbj::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYUt: // global
           I64[Hp - 16] = sat_saXbr_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saXbj::I64;
           I64[Sp + 8] = block_caYTC_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYZ7_srtd" {
     uaYZ7_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _caYT4() //  [R1]
         { info_tbl: [(caYT4,
                       label: block_caYT4_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYT4: // global
           I64[Sp] = R1;
           call _caYT5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uaYZ8_srtd" {
     uaYZ8_srtd:
         const SaXeV_srt+352;
         const 39;
         const 274877906945;
 },
 _caYTC() //  [R1]
         { info_tbl: [(caYTC,
                       label: block_caYTC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYTC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caYUx; else goto caYUw;
       caYUx: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYUw: // global
           I64[Hp - 40] = sat_saXbJ_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saXbw_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_caYUp_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYUp() //  [R1]
         { info_tbl: [(caYUp,
                       label: block_caYUp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUp: // global
           I64[Sp] = block_caYUr_info;
           _saXbM::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _saXbM::P64;
           if (R1 & 7 != 0) goto uaYYq; else goto caYUz;
       uaYYq: // global
           call _caYUr(R1) args: 0, res: 0, upd: 0;
       caYUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYUr() //  [R1]
         { info_tbl: [(caYUr,
                       label: block_caYUr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUr: // global
           I64[Sp - 8] = block_caYUD_info;
           _saXbO::P64 = P64[R1 + 7];
           _saXbP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _saXbP::P64;
           P64[Sp + 8] = _saXbO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaYYr; else goto caYUF;
       uaYYr: // global
           call _caYUD(R1) args: 0, res: 0, upd: 0;
       caYUF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYUD() //  [R1]
         { info_tbl: [(caYUD,
                       label: block_caYUD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUD: // global
           if (R1 & 7 == 2) goto caYUQ; else goto uaYYh;
       caYUQ: // global
           _saXbP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caYUO_info;
           R1 = _saXbP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaYYs; else goto caYUR;
       uaYYs: // global
           call _caYUO(R1) args: 0, res: 0, upd: 0;
       caYUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaYYh: // global
           Sp = Sp + 24;
           call _caYUX() args: 0, res: 0, upd: 0;
     }
 },
 _caYUO() //  [R1]
         { info_tbl: [(caYUO,
                       label: block_caYUO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUO: // global
           if (R1 & 7 == 3) goto caYV2; else goto uaYYi;
       caYV2: // global
           I64[Sp + 16] = block_caYV0_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaYYu; else goto caYV3;
       uaYYu: // global
           call _caYV0(R1) args: 0, res: 0, upd: 0;
       caYV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaYYi: // global
           Sp = Sp + 16;
           call _caYUX() args: 0, res: 0, upd: 0;
     }
 },
 _caYV0() //  [R1]
         { info_tbl: [(caYV0,
                       label: block_caYV0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYV0: // global
           (_saXbY::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _saXbZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXbY::I64));
           if (_saXbZ::I64 == 0) goto uaYYj; else goto caYVg;
       uaYYj: // global
           I64[Sp - 8] = _saXbZ::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _caYVm() args: 0, res: 0, upd: 0;
       caYVg: // global
           (_saXc3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saXc3::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caYVm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYVm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYVs; else goto caYVr;
       caYVs: // global
           HpAlloc = 24;
           _saXbZ::I64 = I64[Sp];
           I64[Sp] = block_caYVl_info;
           R1 = _saXbZ::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caYVr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caYVl() //  [R1]
         { info_tbl: [(caYVl,
                       label: block_caYVl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYVl: // global
           I64[Sp] = R1;
           call _caYVm() args: 0, res: 0, upd: 0;
     }
 },
 _caYUX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYUX: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaYZ9_srtd" {
     uaYZ9_srtd:
         const SaXeV_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(caYYO,
                       label: GHC.IO.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYYO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caYYP; else goto caYYQ;
       caYYP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caYYQ: // global
           I64[Sp - 32] = block_caYSQ_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaYZa_srtd" {
     uaYZa_srtd:
         const SaXeV_srt+264;
         const 58;
         const 279788325873647617;
 },
 _caYSQ() //  [R1]
         { info_tbl: [(caYSQ,
                       label: block_caYSQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caYYT; else goto caYYS;
       caYYT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYYS: // global
           I64[Hp - 16] = sat_saXcZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.619363669 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { info_tbl: [(caYZf,
                       label: GHC.IO.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.621414633 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saXdj_entry() //  [R1]
         { info_tbl: [(caYZG,
                       label: sat_saXdj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZG: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caYZN; else goto caYZO;
       caYZN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYZO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caYZD_info;
           _saXd3::P64 = P64[R1 + 16];
           _saXd4::P64 = P64[R1 + 24];
           _saXd2::I64 = I64[R1 + 40];
           _saXd5::I64 = I64[R1 + 48];
           _saXd6::I64 = I64[R1 + 56];
           _saXd7::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saXd2::I64;
           P64[Sp - 56] = _saXd3::P64;
           P64[Sp - 48] = _saXd4::P64;
           I64[Sp - 40] = _saXd5::I64;
           I64[Sp - 32] = _saXd6::I64;
           I64[Sp - 24] = _saXd7::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaYZS; else goto caYZE;
       uaYZS: // global
           call _caYZD(R1) args: 0, res: 0, upd: 0;
       caYZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caYZD() //  [R1]
         { info_tbl: [(caYZD,
                       label: block_caYZD_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caYZR; else goto caYZQ;
       caYZR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caYZQ: // global
           _saXdi::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _saXdi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caYZT,
                       label: GHC.IO.FD.$w$cfillReadBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caYZV; else goto caYZW;
       caYZV: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caYZW: // global
           I64[Sp - 32] = block_caYZw_info;
           _saXd4::P64 = R6;
           R6 = 0;
           _saXd3::P64 = R5;
           _saXd7::I64 = I64[Sp + 16];
           R5 = R4 + _saXd7::I64;
           _saXd2::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _saXd7::I64;
           I64[Sp - 24] = _saXd2::I64;
           P64[Sp - 16] = _saXd3::P64;
           P64[Sp - 8] = _saXd4::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _caYZw() //  [R1]
         { info_tbl: [(caYZw,
                       label: block_caYZw_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYZw: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caYZZ; else goto caYZY;
       caYZZ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYZY: // global
           _saXd2::I64 = I64[Sp + 8];
           _saXd3::P64 = P64[Sp + 16];
           _saXd4::P64 = P64[Sp + 24];
           _saXd5::I64 = I64[Sp + 32];
           _saXd6::I64 = I64[Sp + 40];
           _saXd7::I64 = I64[Sp + 48];
           call MO_Touch(_saXd3::P64);
           I64[Hp - 88] = sat_saXdj_info;
           P64[Hp - 72] = _saXd3::P64;
           P64[Hp - 64] = _saXd4::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saXd2::I64;
           I64[Hp - 40] = _saXd5::I64;
           I64[Hp - 32] = _saXd6::I64;
           I64[Hp - 24] = _saXd7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.624714319 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { info_tbl: [(caZ07,
                       label: GHC.IO.FD.$fBufferedIOFD11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ07: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZ0b; else goto caZ0c;
       caZ0b: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ0c: // global
           I64[Sp - 16] = block_caZ04_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZ0k; else goto caZ05;
       uaZ0k: // global
           call _caZ04(R1) args: 0, res: 0, upd: 0;
       caZ05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ04() //  [R1]
         { info_tbl: [(caZ04,
                       label: block_caZ04_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ04: // global
           I64[Sp - 8] = block_caZ0a_info;
           _saXdp::I64 = I64[R1 + 7];
           _saXdq::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saXdq::I64;
           I64[Sp + 8] = _saXdp::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ0j; else goto caZ0e;
       uaZ0j: // global
           call _caZ0a(R1) args: 0, res: 0, upd: 0;
       caZ0e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ0a() //  [R1]
         { info_tbl: [(caZ0a,
                       label: block_caZ0a_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0a: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.628380156 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_saXdI_entry() //  [R1]
         { info_tbl: [(caZ0w,
                       label: sat_saXdI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZ0A; else goto caZ0B;
       caZ0A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ0B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZ0t_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZ0F; else goto caZ0u;
       uaZ0F: // global
           call _caZ0t(R1) args: 0, res: 0, upd: 0;
       caZ0u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZ0t() //  [R1]
         { info_tbl: [(caZ0t,
                       label: block_caZ0t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0t: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caZ0E; else goto caZ0D;
       caZ0E: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZ0D: // global
           _saXdD::P64 = P64[R1 + 7];
           _saXdC::I64 = I64[R1 + 23];
           _saXdF::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saXdD::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _saXdC::I64;
           I64[Hp - 16] = _saXdF::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { info_tbl: [(caZ0G,
                       label: GHC.IO.FD.$fBufferedIOFD6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZ0K; else goto caZ0J;
       caZ0K: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ0J: // global
           I64[Hp - 16] = sat_saXdI_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.629965833 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.63083725 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { info_tbl: [(caZ0Q,
                       label: GHC.IO.FD.FD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZ0U; else goto caZ0T;
       caZ0U: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ0T: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.631739801 UTC

[GHC.IO.FD.FD_con_entry() //  [R1]
         { info_tbl: [(caZ0V,
                       label: GHC.IO.FD.FD_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ0V: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.63249186 UTC

[section ""relreadonly" . SaXeV_srt" {
     SaXeV_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.634006117 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:55.635678817 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { info_tbl: [(caZ14,
                       label: GHC.IO.FD.$WFD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ1d; else goto caZ1e;
       caZ1d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ1e: // global
           I64[Sp - 16] = block_caZ11_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZ1k; else goto caZ12;
       uaZ1k: // global
           call _caZ11(R1) args: 0, res: 0, upd: 0;
       caZ12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ11() //  [R1]
         { info_tbl: [(caZ11,
                       label: block_caZ11_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ11: // global
           I64[Sp] = block_caZ17_info;
           _saWVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saWVh::I64;
           if (R1 & 7 != 0) goto uaZ1j; else goto caZ18;
       uaZ1j: // global
           call _caZ17(R1) args: 0, res: 0, upd: 0;
       caZ18: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ17() //  [R1]
         { info_tbl: [(caZ17,
                       label: block_caZ17_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ17: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZ1i; else goto caZ1h;
       caZ1i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ1h: // global
           _saWVj::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saWVj::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.644462915 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { info_tbl: [(caZ1J,
                       label: GHC.IO.FD.$fBufferedIOFD5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ1J: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caZ1K; else goto uaZ2j;
       caZ1K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uaZ2j: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _caZ1B() args: 0, res: 0, upd: 0;
     }
 },
 _caZ1B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ1B: // global
           I64[Sp - 8] = block_caZ1E_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ1E() //  [R1]
         { info_tbl: [(caZ1E,
                       label: block_caZ1E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ1E: // global
           I64[Sp - 8] = block_caZ1G_info;
           _saWVq::P64 = R1;
           R1 = R1;
           P64[Sp] = _saWVq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ2l; else goto caZ1H;
       uaZ2l: // global
           call _caZ1G(R1) args: 0, res: 0, upd: 0;
       caZ1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ1G() //  [R1]
         { info_tbl: [(caZ1G,
                       label: block_caZ1G_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ1G: // global
           if (I64[R1 + 7] == (-1)) goto caZ2h; else goto caZ1S;
       caZ2h: // global
           _saWVk::P64 = P64[Sp + 16];
           _saWVl::P64 = P64[Sp + 24];
           _saWVm::P64 = P64[Sp + 32];
           (_saWVx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _saWVy::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWVx::I64));
           if (_saWVy::I64 != 4) goto uaZ2i; else goto caZ27;
       uaZ2i: // global
           if (_saWVy::I64 != 11) goto caZ21; else goto caZ2d;
       caZ21: // global
           R2 = _saWVk::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       caZ2d: // global
           R1 = _saWVm::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       caZ27: // global
           P64[Sp + 16] = _saWVk::P64;
           P64[Sp + 24] = _saWVl::P64;
           P64[Sp + 32] = _saWVm::P64;
           Sp = Sp + 16;
           call _caZ1B() args: 0, res: 0, upd: 0;
       caZ1S: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.655907539 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.658655691 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { info_tbl: [(caZ2K,
                       label: lvl1_raWUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ2L; else goto caZ2M;
       caZ2L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ2M: // global
           (_caZ2H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ2H::I64 == 0) goto caZ2J; else goto caZ2I;
       caZ2J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ2I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ2H::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.663911603 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.666412327 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { info_tbl: [(caZ31,
                       label: GHC.IO.FD.$fBufferedIOFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ31: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ32; else goto caZ33;
       caZ32: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ33: // global
           (_caZ2Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ2Y::I64 == 0) goto caZ30; else goto caZ2Z;
       caZ30: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ2Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ2Y::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.671628445 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.674042231 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { info_tbl: [(caZ3g,
                       label: GHC.IO.FD.$fBufferedIOFD3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ3g: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.677836488 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.679753673 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.684135767 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ3r: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWVZ_entry() //  [R1]
         { info_tbl: [(caZ3G,
                       label: sat_saWVZ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ3G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ3Q; else goto caZ3P;
       caZ3Q: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZ3P: // global
           (_saWVX::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWVX::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWWc_entry() //  [R1]
         { info_tbl: [(caZ4a,
                       label: sat_saWWc_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ4a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZ4j; else goto caZ4k;
       caZ4j: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZ4k: // global
           I64[Sp - 8] = block_caZ4g_info;
           Sp = Sp - 8;
           _caZ4d::I64 = I64[R1 + 7];
           _caZ4e::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZ4f::I64 = I64[R1 + 31];
           _uaZ4q::P64 = CurrentTSO;
           I64[I64[_uaZ4q::P64 + 24] + 16] = Sp;
           _uaZ4r::I64 = CurrentNursery;
           P64[_uaZ4r::I64 + 8] = Hp + 8;
           I64[_uaZ4q::P64 + 104] = I64[_uaZ4q::P64 + 104] - ((Hp + 8) - I64[_uaZ4r::I64]);
           (_uaZ4o::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWWa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caZ4d::I64, _caZ4e::I64, _caZ4f::I64);
           (_uaZ4p::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZ4o::I64);
           BaseReg = _uaZ4p::I64;
           _uaZ4s::P64 = CurrentTSO;
           _uaZ4t::P64 = I64[_uaZ4s::P64 + 24];
           Sp = I64[_uaZ4t::P64 + 16];
           SpLim = _uaZ4t::P64 + 192;
           HpAlloc = 0;
           _uaZ4u::I64 = CurrentNursery;
           _uaZ4v::I64 = I64[_uaZ4u::I64 + 8];
           Hp = _uaZ4v::I64 - 8;
           _uaZ4w::I64 = I64[_uaZ4u::I64];
           HpLim = _uaZ4w::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZ4u::I64 + 48]) << 12) - 1);
           I64[_uaZ4s::P64 + 104] = I64[_uaZ4s::P64 + 104] + (_uaZ4v::I64 - _uaZ4w::I64);
           R1 = _saWWa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ4g() //  [R1]
         { info_tbl: [(caZ4g,
                       label: block_caZ4g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ4g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ4n; else goto caZ4m;
       caZ4n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZ4m: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(caZ4B,
                       label: GHC.IO.FD.$wreadRawBufferPtrNoBlock_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ4B: // global
           _saWVE::I64 = R6;
           _saWVD::I64 = R5;
           _saWVC::I64 = R4;
           _saWVB::I64 = R3;
           _saWVA::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZ4C; else goto caZ4D;
       caZ4D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZ4F; else goto caZ4E;
       caZ4F: // global
           HpAlloc = 40;
           goto caZ4C;
       caZ4C: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVC::I64;
           I64[Sp - 16] = _saWVD::I64;
           I64[Sp - 8] = _saWVE::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZ4E: // global
           if (_saWVC::I64 == 0) goto caZ4A; else goto caZ4z;
       caZ4A: // global
           (_saWW3::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWVB::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWW4::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWW3::I64));
           if (_saWW4::I64 != 0) goto uaZ5f; else goto caZ59;
       uaZ5f: // global
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVD::I64;
           I64[Sp - 16] = _saWVE::I64;
           I64[Sp - 8] = _saWW4::I64;
           Sp = Sp - 40;
           call _caZ41() args: 0, res: 0, upd: 0;
       caZ59: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ4z: // global
           I64[Hp - 32] = sat_saWVZ_info;
           I64[Hp - 24] = _saWVB::I64;
           I64[Hp - 16] = _saWVD::I64;
           I64[Hp - 8] = _saWVE::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWVA::P64;
           Sp = Sp - 8;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caZ41() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ41: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZ56; else goto caZ55;
       caZ56: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caZ40_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZ55: // global
           I64[Hp - 32] = sat_saWWc_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caZ40() //  [R1]
         { info_tbl: [(caZ40,
                       label: block_caZ40_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ40: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZ41() args: 0, res: 0, upd: 0;
     }
 },
 _saWVH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saWVH: // global
           _saWVA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caZ4J_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _saWVA::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZ4J() //  [R1]
         { info_tbl: [(caZ4J,
                       label: block_caZ4J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ4J: // global
           I64[Sp] = block_caZ4L_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZ5m; else goto caZ4O;
       uaZ5m: // global
           call _caZ4L(R1) args: 0, res: 0, upd: 0;
       caZ4O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ4L() //  [R1]
         { info_tbl: [(caZ4L,
                       label: block_caZ4L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ4L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ4U; else goto caZ4T;
       caZ4U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ4T: // global
           _saWVP::I64 = I64[R1 + 7];
           if (_saWVP::I64 != (-1)) goto uaZ5d; else goto caZ50;
       uaZ5d: // global
           if (_saWVP::I64 != 0) goto caZ4Z; else goto caZ51;
       caZ4Z: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ51: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ50: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.706762254 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZ6y,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ6y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZ6M; else goto caZ6N;
       caZ6M: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ6N: // global
           I64[Sp - 40] = block_caZ6v_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZ6X; else goto caZ6w;
       uaZ6X: // global
           call _caZ6v(R1) args: 0, res: 0, upd: 0;
       caZ6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ6v() //  [R1]
         { info_tbl: [(caZ6v,
                       label: block_caZ6v_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ6v: // global
           I64[Sp - 8] = block_caZ6B_info;
           _saWWk::I64 = I64[R1 + 7];
           _saWWl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWWl::I64;
           I64[Sp + 16] = _saWWk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ6W; else goto caZ6C;
       uaZ6W: // global
           call _caZ6B(R1) args: 0, res: 0, upd: 0;
       caZ6C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ6B() //  [R1]
         { info_tbl: [(caZ6B,
                       label: block_caZ6B_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ6B: // global
           I64[Sp] = block_caZ6G_info;
           _saWWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWWn::I64;
           if (R1 & 7 != 0) goto uaZ6Y; else goto caZ6H;
       uaZ6Y: // global
           call _caZ6G(R1) args: 0, res: 0, upd: 0;
       caZ6H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ6G() //  [R1]
         { info_tbl: [(caZ6G,
                       label: block_caZ6G_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ6G: // global
           I64[Sp] = block_caZ6L_info;
           _saWWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWWp::I64;
           if (R1 & 7 != 0) goto uaZ6Z; else goto caZ6R;
       uaZ6Z: // global
           call _caZ6L(R1) args: 0, res: 0, upd: 0;
       caZ6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ6L() //  [R1]
         { info_tbl: [(caZ6L,
                       label: block_caZ6L_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ6L: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.718786664 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ7n: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caZ7t,
                       label: GHC.IO.FD.$w$creadNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ7y; else goto caZ7z;
       caZ7y: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caZ7z: // global
           I64[Sp - 8] = block_caZ7v_info;
           R6 = 0;
           _saWWx::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _saWWx::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caZ7v() //  [R1]
         { info_tbl: [(caZ7v,
                       label: block_caZ7v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ7v: // global
           I64[Sp] = block_caZ7x_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZ7O; else goto caZ7B;
       uaZ7O: // global
           call _caZ7x(R1) args: 0, res: 0, upd: 0;
       caZ7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ7x() //  [R1]
         { info_tbl: [(caZ7x,
                       label: block_caZ7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ7x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ7H; else goto caZ7G;
       caZ7H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ7G: // global
           if (I64[R1 + 7] == (-1)) goto caZ7N; else goto caZ7M;
       caZ7N: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ7M: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.728043196 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { info_tbl: [(caZ8c,
                       label: GHC.IO.FD.$fRawIOFD3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ8c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZ8l; else goto caZ8m;
       caZ8l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ8m: // global
           I64[Sp - 24] = block_caZ89_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZ8v; else goto caZ8a;
       uaZ8v: // global
           call _caZ89(R1) args: 0, res: 0, upd: 0;
       caZ8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ89() //  [R1]
         { info_tbl: [(caZ89,
                       label: block_caZ89_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ89: // global
           I64[Sp - 8] = block_caZ8f_info;
           _saWWK::I64 = I64[R1 + 7];
           _saWWL::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWWL::I64;
           I64[Sp + 8] = _saWWK::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ8u; else goto caZ8g;
       uaZ8u: // global
           call _caZ8f(R1) args: 0, res: 0, upd: 0;
       caZ8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ8f() //  [R1]
         { info_tbl: [(caZ8f,
                       label: block_caZ8f_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ8f: // global
           I64[Sp] = block_caZ8k_info;
           _saWWN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWWN::I64;
           if (R1 & 7 != 0) goto uaZ8w; else goto caZ8p;
       uaZ8w: // global
           call _caZ8k(R1) args: 0, res: 0, upd: 0;
       caZ8p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ8k() //  [R1]
         { info_tbl: [(caZ8k,
                       label: block_caZ8k_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ8k: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.737805265 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.739826333 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { info_tbl: [(caZ8V,
                       label: GHC.IO.FD.$fBufferedIOFD_loc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ8W; else goto caZ8X;
       caZ8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ8X: // global
           (_caZ8S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ8S::I64 == 0) goto caZ8U; else goto caZ8T;
       caZ8U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ8T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ8S::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.744058761 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { info_tbl: [(caZ9c,
                       label: GHC.IO.FD.$fBufferedIOFD14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ9c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZ9d; else goto caZ9e;
       caZ9d: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZ9e: // global
           I64[Sp - 8] = block_caZ99_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ9m; else goto caZ9a;
       uaZ9m: // global
           call _caZ99(R1) args: 0, res: 0, upd: 0;
       caZ9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ99() //  [R1]
         { info_tbl: [(caZ99,
                       label: block_caZ99_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ99: // global
           if (I64[R1 + 7] == (-1)) goto caZ9l; else goto caZ9k;
       caZ9l: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ9k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.749814932 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.751796499 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { info_tbl: [(caZ9F,
                       label: GHC.IO.FD.$fBufferedIOFD12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ9F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ9G; else goto caZ9H;
       caZ9G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ9H: // global
           (_caZ9C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ9C::I64 == 0) goto caZ9E; else goto caZ9D;
       caZ9E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ9D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ9C::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.759652987 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ9Q: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWXe_entry() //  [R1]
         { info_tbl: [(caZa9,
                       label: sat_saWXe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZa9: // global
           _saWXe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caZaa; else goto caZab;
       caZab: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZad; else goto caZac;
       caZad: // global
           HpAlloc = 16;
           goto caZaa;
       caZaa: // global
           R1 = _saWXe::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZac: // global
           _saWWV::I64 = I64[_saWXe::P64 + 7];
           (_saWX8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWX8::I64 == 0) goto caZa8; else goto caZa7;
       caZa8: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZan_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caZa7: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caZan() //  []
         { info_tbl: [(caZan,
                       label: block_caZan_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZan: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXk_entry() //  [R1]
         { info_tbl: [(caZaz,
                       label: sat_saWXk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZaz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZaD; else goto caZaE;
       caZaD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZaE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZaw_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZaI; else goto caZax;
       uaZaI: // global
           call _caZaw(R1) args: 0, res: 0, upd: 0;
       caZax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZaw() //  [R1]
         { info_tbl: [(caZaw,
                       label: block_caZaw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZaw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZaH; else goto caZaG;
       caZaH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZaG: // global
           _saWXj::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWXj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWXt_entry() //  [R1]
         { info_tbl: [(caZaS,
                       label: sat_saWXt_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZaS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZb2; else goto caZb1;
       caZb2: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZb1: // global
           (_saWXr::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXr::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXP_entry() //  [R1]
         { info_tbl: [(caZbt,
                       label: sat_saWXP_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZbC; else goto caZbD;
       caZbC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZbD: // global
           I64[Sp - 8] = block_caZbz_info;
           Sp = Sp - 8;
           _caZbw::I64 = I64[R1 + 7];
           _caZbx::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZby::I64 = I64[R1 + 31];
           _uaZbJ::P64 = CurrentTSO;
           I64[I64[_uaZbJ::P64 + 24] + 16] = Sp;
           _uaZbK::I64 = CurrentNursery;
           P64[_uaZbK::I64 + 8] = Hp + 8;
           I64[_uaZbJ::P64 + 104] = I64[_uaZbJ::P64 + 104] - ((Hp + 8) - I64[_uaZbK::I64]);
           (_uaZbH::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWXN::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caZbw::I64, _caZbx::I64, _caZby::I64);
           (_uaZbI::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZbH::I64);
           BaseReg = _uaZbI::I64;
           _uaZbL::P64 = CurrentTSO;
           _uaZbM::P64 = I64[_uaZbL::P64 + 24];
           Sp = I64[_uaZbM::P64 + 16];
           SpLim = _uaZbM::P64 + 192;
           HpAlloc = 0;
           _uaZbN::I64 = CurrentNursery;
           _uaZbO::I64 = I64[_uaZbN::I64 + 8];
           Hp = _uaZbO::I64 - 8;
           _uaZbP::I64 = I64[_uaZbN::I64];
           HpLim = _uaZbP::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZbN::I64 + 48]) << 12) - 1);
           I64[_uaZbL::P64 + 104] = I64[_uaZbL::P64 + 104] + (_uaZbO::I64 - _uaZbP::I64);
           R1 = _saWXN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZbz() //  [R1]
         { info_tbl: [(caZbz,
                       label: block_caZbz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZbG; else goto caZbF;
       caZbG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZbF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWXX_entry() //  [R1]
         { info_tbl: [(caZbZ,
                       label: sat_saWXX_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZc9; else goto caZc8;
       caZc9: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZc8: // global
           (_saWXV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXV::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZcd,
                       label: GHC.IO.FD.$wreadRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZcd: // global
           _saWWY::I64 = R6;
           _saWWX::I64 = R5;
           _saWWW::I64 = R4;
           _saWWV::I64 = R3;
           _saWWU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZce; else goto caZcf;
       caZcf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZch; else goto caZcg;
       caZch: // global
           HpAlloc = 40;
           goto caZce;
       caZce: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWW::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZcg: // global
           if (_saWWW::I64 == 0) goto caZcc; else goto caZcb;
       caZcc: // global
           (_saWXx::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWWV::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWYb::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWXx::I64));
           if (_saWYb::I64 != (-1)) goto caZd2; else goto caZdd;
       caZd2: // global
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWX::I64;
           I64[Sp - 16] = _saWWY::I64;
           I64[Sp - 8] = _saWYb::I64;
           Sp = Sp - 40;
           call _caZbc() args: 0, res: 0, upd: 0;
       caZdd: // global
           I64[Sp - 40] = block_caZda_info;
           R2 = _saWWU::P64;
           P64[Sp - 32] = _saWWU::P64;
           I64[Sp - 24] = _saWWV::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caZcb: // global
           I64[Hp - 32] = sat_saWXt_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWWV::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWWU::P64;
           Sp = Sp - 16;
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 _caZda() //  [R1]
         { info_tbl: [(caZda,
                       label: block_caZda_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZda: // global
           I64[Sp] = block_caZdc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZdB; else goto caZdg;
       uaZdB: // global
           call _caZdc(R1) args: 0, res: 0, upd: 0;
       caZdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZdc() //  [R1]
         { info_tbl: [(caZdc,
                       label: block_caZdc_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZdc: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _caZbc() args: 0, res: 0, upd: 0;
     }
 },
 _caZbc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbc: // global
           Hp = Hp + 16;
           _saWXA::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caZcq; else goto caZcp;
       caZcq: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZbb_info;
           R1 = _saWXA::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZcp: // global
           if (_saWXA::I64 == 0) goto caZcW; else goto caZcz;
       caZcW: // global
           _saWWV::I64 = I64[Sp + 8];
           (_saWY2::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWY2::I64 == 0) goto caZcT; else goto caZcL;
       caZcT: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZbh_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caZcL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           I64[Sp - 8] = block_caZcJ_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       caZcz: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _caZbh() args: 0, res: 0, upd: 0;
     }
 },
 _caZbb() //  [R1]
         { info_tbl: [(caZbb,
                       label: block_caZbb_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbb: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZbc() args: 0, res: 0, upd: 0;
     }
 },
 _caZcJ() //  []
         { info_tbl: [(caZcJ,
                       label: block_caZcJ_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZcJ: // global
           call _caZbh() args: 0, res: 0, upd: 0;
     }
 },
 _caZbh() //  []
         { info_tbl: [(caZbh,
                       label: block_caZbh_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZbh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZct; else goto caZcs;
       caZct: // global
           HpAlloc = 40;
           I64[Sp] = block_caZbh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caZcs: // global
           _saWWU::P64 = P64[Sp + 8];
           _saWWV::I64 = I64[Sp + 16];
           _saWWX::I64 = I64[Sp + 24];
           _saWWY::I64 = I64[Sp + 32];
           _saWWZ::I64 = I64[Sp + 48];
           (_saWXG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWXG::I64 == 0) goto caZcw; else goto caZcv;
       caZcw: // global
           I64[Hp - 32] = sat_saWXX_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaZdx;
       caZcv: // global
           I64[Hp - 32] = sat_saWXP_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaZdx;
       uaZdx: // global
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 _caZ9X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ9X: // global
           Hp = Hp + 16;
           _saWX2::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZck; else goto caZcj;
       caZck: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZ9W_info;
           R1 = _saWX2::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZcj: // global
           I64[Hp - 8] = sat_saWXe_info;
           I64[Hp] = I64[Sp];
           _saWWU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caZaq_info;
           R5 = Hp - 7;
           R4 = _saWX2::P64;
           R3 = _saWWU::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZ9W() //  [R1]
         { info_tbl: [(caZ9W,
                       label: block_caZ9W_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ9W: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 _caZaq() //  [R1]
         { info_tbl: [(caZaq,
                       label: block_caZaq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZaq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZcn; else goto caZcm;
       caZcn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZcm: // global
           I64[Hp - 16] = sat_saWXk_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.800475062 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZfo,
                       label: GHC.IO.FD.$fRawIOFD5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZfo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZfC; else goto caZfD;
       caZfC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZfD: // global
           I64[Sp - 40] = block_caZfl_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZfN; else goto caZfm;
       uaZfN: // global
           call _caZfl(R1) args: 0, res: 0, upd: 0;
       caZfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZfl() //  [R1]
         { info_tbl: [(caZfl,
                       label: block_caZfl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZfl: // global
           I64[Sp - 8] = block_caZfr_info;
           _saWYo::I64 = I64[R1 + 7];
           _saWYp::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWYp::I64;
           I64[Sp + 16] = _saWYo::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZfM; else goto caZfs;
       uaZfM: // global
           call _caZfr(R1) args: 0, res: 0, upd: 0;
       caZfs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZfr() //  [R1]
         { info_tbl: [(caZfr,
                       label: block_caZfr_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZfr: // global
           I64[Sp] = block_caZfw_info;
           _saWYr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWYr::I64;
           if (R1 & 7 != 0) goto uaZfO; else goto caZfx;
       uaZfO: // global
           call _caZfw(R1) args: 0, res: 0, upd: 0;
       caZfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZfw() //  [R1]
         { info_tbl: [(caZfw,
                       label: block_caZfw_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZfw: // global
           I64[Sp] = block_caZfB_info;
           _saWYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWYt::I64;
           if (R1 & 7 != 0) goto uaZfP; else goto caZfH;
       uaZfP: // global
           call _caZfB(R1) args: 0, res: 0, upd: 0;
       caZfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZfB() //  [R1]
         { info_tbl: [(caZfB,
                       label: block_caZfB_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZfB: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.812741011 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { info_tbl: [(caZgj,
                       label: GHC.IO.FD.$fRawIOFD4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZgj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZgs; else goto caZgt;
       caZgs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZgt: // global
           I64[Sp - 24] = block_caZgg_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZgD; else goto caZgh;
       uaZgD: // global
           call _caZgg(R1) args: 0, res: 0, upd: 0;
       caZgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZgg() //  [R1]
         { info_tbl: [(caZgg,
                       label: block_caZgg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZgg: // global
           I64[Sp - 8] = block_caZgm_info;
           _saWYB::I64 = I64[R1 + 7];
           _saWYC::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWYC::I64;
           I64[Sp + 8] = _saWYB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZgC; else goto caZgn;
       uaZgC: // global
           call _caZgm(R1) args: 0, res: 0, upd: 0;
       caZgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZgm() //  [R1]
         { info_tbl: [(caZgm,
                       label: block_caZgm_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZgm: // global
           I64[Sp] = block_caZgr_info;
           _saWYE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWYE::I64;
           if (R1 & 7 != 0) goto uaZgE; else goto caZgw;
       uaZgE: // global
           call _caZgr(R1) args: 0, res: 0, upd: 0;
       caZgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZgr() //  [R1]
         { info_tbl: [(caZgr,
                       label: block_caZgr_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZgr: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.825466374 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZgY: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWZ2_entry() //  [R1]
         { info_tbl: [(caZhh,
                       label: sat_saWZ2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZhh: // global
           _saWZ2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caZhi; else goto caZhj;
       caZhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZhl; else goto caZhk;
       caZhl: // global
           HpAlloc = 16;
           goto caZhi;
       caZhi: // global
           R1 = _saWZ2::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZhk: // global
           _saWYJ::I64 = I64[_saWZ2::P64 + 7];
           (_saWYW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWYW::I64 == 0) goto caZhg; else goto caZhf;
       caZhg: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZhv_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caZhf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caZhv() //  []
         { info_tbl: [(caZhv,
                       label: block_caZhv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZhv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZ9_entry() //  [R1]
         { info_tbl: [(caZhH,
                       label: sat_saWZ9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZhH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZhO; else goto caZhP;
       caZhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZhE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZhT; else goto caZhF;
       uaZhT: // global
           call _caZhE(R1) args: 0, res: 0, upd: 0;
       caZhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZhE() //  [R1]
         { info_tbl: [(caZhE,
                       label: block_caZhE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZhE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZhS; else goto caZhR;
       caZhS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZhR: // global
           _saWZ8::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saWZ8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saWZi_entry() //  [R1]
         { info_tbl: [(caZi3,
                       label: sat_saWZi_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZi3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZid; else goto caZic;
       caZid: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZic: // global
           (_saWZg::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZg::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZB_entry() //  [R1]
         { info_tbl: [(caZiz,
                       label: sat_saWZB_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZiz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZiI; else goto caZiJ;
       caZiI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZiJ: // global
           I64[Sp - 8] = block_caZiF_info;
           Sp = Sp - 8;
           _caZiC::I64 = I64[R1 + 7];
           _caZiD::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZiE::I64 = I64[R1 + 31];
           _uaZiP::P64 = CurrentTSO;
           I64[I64[_uaZiP::P64 + 24] + 16] = Sp;
           _uaZiQ::I64 = CurrentNursery;
           P64[_uaZiQ::I64 + 8] = Hp + 8;
           I64[_uaZiP::P64 + 104] = I64[_uaZiP::P64 + 104] - ((Hp + 8) - I64[_uaZiQ::I64]);
           (_uaZiN::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWZz::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caZiC::I64, _caZiD::I64, _caZiE::I64);
           (_uaZiO::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZiN::I64);
           BaseReg = _uaZiO::I64;
           _uaZiR::P64 = CurrentTSO;
           _uaZiS::P64 = I64[_uaZiR::P64 + 24];
           Sp = I64[_uaZiS::P64 + 16];
           SpLim = _uaZiS::P64 + 192;
           HpAlloc = 0;
           _uaZiT::I64 = CurrentNursery;
           _uaZiU::I64 = I64[_uaZiT::I64 + 8];
           Hp = _uaZiU::I64 - 8;
           _uaZiV::I64 = I64[_uaZiT::I64];
           HpLim = _uaZiV::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZiT::I64 + 48]) << 12) - 1);
           I64[_uaZiR::P64 + 104] = I64[_uaZiR::P64 + 104] + (_uaZiU::I64 - _uaZiV::I64);
           R1 = _saWZz::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZiF() //  [R1]
         { info_tbl: [(caZiF,
                       label: block_caZiF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZiF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZiM; else goto caZiL;
       caZiM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZiL: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saWZJ_entry() //  [R1]
         { info_tbl: [(caZj5,
                       label: sat_saWZJ_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZj5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZjf; else goto caZje;
       caZjf: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZje: // global
           (_saWZH::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZH::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZjj,
                       label: GHC.IO.FD.$wwriteRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZjj: // global
           _saWYM::I64 = R6;
           _saWYL::I64 = R5;
           _saWYK::I64 = R4;
           _saWYJ::I64 = R3;
           _saWYI::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZjk; else goto caZjl;
       caZjl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZjn; else goto caZjm;
       caZjn: // global
           HpAlloc = 40;
           goto caZjk;
       caZjk: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYK::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZjm: // global
           if (_saWYK::I64 == 0) goto caZji; else goto caZjh;
       caZji: // global
           (_saWZm::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWYJ::I64, 1, 0, 0);
           Hp = Hp - 40;
           _saWZK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWZm::I64));
           if (_saWZK::I64 != 0) goto uaZkd; else goto uaZkc;
       uaZkd: // global
           P64[Sp - 32] = _saWYI::P64;
           I64[Sp - 24] = _saWYJ::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call _caZin() args: 0, res: 0, upd: 0;
       uaZkc: // global
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYL::I64;
           I64[Sp - 16] = _saWYM::I64;
           I64[Sp - 8] = _saWZK::I64;
           Sp = Sp - 40;
           call _caZjM() args: 0, res: 0, upd: 0;
       caZjh: // global
           I64[Hp - 32] = sat_saWZi_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWYJ::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWYI::P64;
           Sp = Sp - 16;
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 _caZjM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZjQ; else goto caZjP;
       caZjQ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZjK_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZjP: // global
           _saWYI::P64 = P64[Sp];
           _saWYJ::I64 = I64[Sp + 8];
           _saWYL::I64 = I64[Sp + 16];
           _saWYM::I64 = I64[Sp + 24];
           (_saWZO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZO::I64 == 0) goto caZk8; else goto caZk0;
       caZk8: // global
           Hp = Hp - 16;
           I64[Sp] = block_caZin_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           P64[Sp + 8] = _saWYI::P64;
           I64[Sp + 16] = _saWYJ::I64;
           I64[Sp + 24] = _saWYL::I64;
           I64[Sp + 32] = _saWYM::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caZk0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           I64[Sp - 8] = block_caZjY_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZjK() //  [R1]
         { info_tbl: [(caZjK,
                       label: block_caZjK_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZjK: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZjM() args: 0, res: 0, upd: 0;
     }
 },
 _caZjY() //  []
         { info_tbl: [(caZjY,
                       label: block_caZjY_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZjY: // global
           _saWYJ::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _saWYL::I64 = I64[Sp + 24];
           I64[Sp + 24] = _saWYJ::I64;
           _saWYM::I64 = I64[Sp + 32];
           I64[Sp + 32] = _saWYL::I64;
           I64[Sp + 40] = _saWYM::I64;
           Sp = Sp + 8;
           call _caZin() args: 0, res: 0, upd: 0;
     }
 },
 _caZin() //  []
         { info_tbl: [(caZin,
                       label: block_caZin_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZin: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZjw; else goto caZjv;
       caZjw: // global
           HpAlloc = 40;
           I64[Sp] = block_caZin_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caZjv: // global
           _saWYI::P64 = P64[Sp + 8];
           _saWYJ::I64 = I64[Sp + 16];
           _saWYL::I64 = I64[Sp + 24];
           _saWYM::I64 = I64[Sp + 32];
           _saWYN::I64 = I64[Sp + 40];
           (_saWZs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZs::I64 == 0) goto caZjz; else goto caZjy;
       caZjz: // global
           I64[Hp - 32] = sat_saWZJ_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaZkl;
       caZjy: // global
           I64[Hp - 32] = sat_saWZB_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaZkl;
       uaZkl: // global
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 _caZh5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZh5: // global
           Hp = Hp + 16;
           _saWYQ::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZjq; else goto caZjp;
       caZjq: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZh4_info;
           R1 = _saWYQ::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZjp: // global
           I64[Hp - 8] = sat_saWZ2_info;
           I64[Hp] = I64[Sp];
           _saWYI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caZhy_info;
           R5 = Hp - 7;
           R4 = _saWYQ::P64;
           R3 = _saWYI::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZh4() //  [R1]
         { info_tbl: [(caZh4,
                       label: block_caZh4_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZh4: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 _caZhy() //  [R1]
         { info_tbl: [(caZhy,
                       label: block_caZhy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZhy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZjt; else goto caZjs;
       caZjt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZjs: // global
           I64[Hp - 16] = sat_saWZ9_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.864062435 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZm2,
                       label: GHC.IO.FD.writeRawBufferPtr1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZm2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZmg; else goto caZmh;
       caZmg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZmh: // global
           I64[Sp - 40] = block_caZlZ_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZmr; else goto caZm0;
       uaZmr: // global
           call _caZlZ(R1) args: 0, res: 0, upd: 0;
       caZm0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZlZ() //  [R1]
         { info_tbl: [(caZlZ,
                       label: block_caZlZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZlZ: // global
           I64[Sp - 8] = block_caZm5_info;
           _saX04::I64 = I64[R1 + 7];
           _saX05::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saX05::I64;
           I64[Sp + 16] = _saX04::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZmq; else goto caZm6;
       uaZmq: // global
           call _caZm5(R1) args: 0, res: 0, upd: 0;
       caZm6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZm5() //  [R1]
         { info_tbl: [(caZm5,
                       label: block_caZm5_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZm5: // global
           I64[Sp] = block_caZma_info;
           _saX07::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saX07::I64;
           if (R1 & 7 != 0) goto uaZms; else goto caZmb;
       uaZms: // global
           call _caZma(R1) args: 0, res: 0, upd: 0;
       caZmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZma() //  [R1]
         { info_tbl: [(caZma,
                       label: block_caZma_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZma: // global
           I64[Sp] = block_caZmf_info;
           _saX09::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saX09::I64;
           if (R1 & 7 != 0) goto uaZmt; else goto caZml;
       uaZmt: // global
           call _caZmf(R1) args: 0, res: 0, upd: 0;
       caZml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZmf() //  [R1]
         { info_tbl: [(caZmf,
                       label: block_caZmf_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZmf: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.876473946 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZmR: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caZmX,
                       label: GHC.IO.FD.$wfdWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZmX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZn2; else goto uaZnl;
       caZn2: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       uaZnl: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caZmS() args: 0, res: 0, upd: 0;
     }
 },
 _caZmS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZmS: // global
           I64[Sp - 8] = block_caZmZ_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _caZmZ() //  [R1]
         { info_tbl: [(caZmZ,
                       label: block_caZmZ_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZmZ: // global
           I64[Sp] = block_caZn1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZno; else goto caZn5;
       uaZno: // global
           call _caZn1(R1) args: 0, res: 0, upd: 0;
       caZn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZn1() //  [R1]
         { info_tbl: [(caZn1,
                       label: block_caZn1_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZn1: // global
           _saX0f::I64 = I64[Sp + 32];
           _saX0m::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_saX0m::I64,
                            _saX0f::I64)) goto caZnd; else goto caZne;
       caZnd: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZne: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _saX0m::I64;
           I64[Sp + 32] = _saX0f::I64 - _saX0m::I64;
           Sp = Sp + 8;
           call _caZmS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.887285535 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { info_tbl: [(caZnV,
                       label: GHC.IO.FD.$fRawIOFD2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZnV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZo4; else goto caZo5;
       caZo4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZo5: // global
           I64[Sp - 24] = block_caZnS_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZoe; else goto caZnT;
       uaZoe: // global
           call _caZnS(R1) args: 0, res: 0, upd: 0;
       caZnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZnS() //  [R1]
         { info_tbl: [(caZnS,
                       label: block_caZnS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZnS: // global
           I64[Sp - 8] = block_caZnY_info;
           _saX0v::I64 = I64[R1 + 7];
           _saX0w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX0w::I64;
           I64[Sp + 8] = _saX0v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZod; else goto caZnZ;
       uaZod: // global
           call _caZnY(R1) args: 0, res: 0, upd: 0;
       caZnZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZnY() //  [R1]
         { info_tbl: [(caZnY,
                       label: block_caZnY_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZnY: // global
           I64[Sp] = block_caZo3_info;
           _saX0y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX0y::I64;
           if (R1 & 7 != 0) goto uaZof; else goto caZo8;
       uaZof: // global
           call _caZo3(R1) args: 0, res: 0, upd: 0;
       caZo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZo3() //  [R1]
         { info_tbl: [(caZo3,
                       label: block_caZo3_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZo3: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.898713295 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZoy: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX0O_entry() //  [R1]
         { info_tbl: [(caZoL,
                       label: sat_saX0O_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZoL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZoV; else goto caZoU;
       caZoV: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZoU: // global
           (_saX0M::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX0M::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1e_entry() //  [R1]
         { info_tbl: [(caZpi,
                       label: sat_saX1e_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZpi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZpr; else goto caZps;
       caZpr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZps: // global
           I64[Sp - 8] = block_caZpo_info;
           Sp = Sp - 8;
           _caZpl::I64 = I64[R1 + 7];
           _caZpm::I64 = I64[R1 + 15];
           _caZpn::I64 = I64[R1 + 23];
           _uaZpy::P64 = CurrentTSO;
           I64[I64[_uaZpy::P64 + 24] + 16] = Sp;
           _uaZpz::I64 = CurrentNursery;
           P64[_uaZpz::I64 + 8] = Hp + 8;
           I64[_uaZpy::P64 + 104] = I64[_uaZpy::P64 + 104] - ((Hp + 8) - I64[_uaZpz::I64]);
           (_uaZpw::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX1c::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caZpl::I64, _caZpm::I64, _caZpn::I64);
           (_uaZpx::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZpw::I64);
           BaseReg = _uaZpx::I64;
           _uaZpA::P64 = CurrentTSO;
           _uaZpB::P64 = I64[_uaZpA::P64 + 24];
           Sp = I64[_uaZpB::P64 + 16];
           SpLim = _uaZpB::P64 + 192;
           HpAlloc = 0;
           _uaZpC::I64 = CurrentNursery;
           _uaZpD::I64 = I64[_uaZpC::I64 + 8];
           Hp = _uaZpD::I64 - 8;
           _uaZpE::I64 = I64[_uaZpC::I64];
           HpLim = _uaZpE::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZpC::I64 + 48]) << 12) - 1);
           I64[_uaZpA::P64 + 104] = I64[_uaZpA::P64 + 104] + (_uaZpD::I64 - _uaZpE::I64);
           R1 = _saX1c::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZpo() //  [R1]
         { info_tbl: [(caZpo,
                       label: block_caZpo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZpo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZpv; else goto caZpu;
       caZpv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZpu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX1u_entry() //  [R1]
         { info_tbl: [(caZpO,
                       label: sat_saX1u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZpO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZpY; else goto caZpX;
       caZpY: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZpX: // global
           (_saX1s::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX1s::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caZq2,
                       label: GHC.IO.FD.$w$cwriteNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZq2: // global
           _saX0E::I64 = R5;
           _saX0D::I64 = R4;
           _saX0C::I64 = R3;
           _saX0B::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto caZq3; else goto caZq4;
       caZq4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZq6; else goto caZq5;
       caZq6: // global
           HpAlloc = 32;
           goto caZq3;
       caZq3: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0C::I64;
           I64[Sp - 16] = _saX0D::I64;
           I64[Sp - 8] = _saX0E::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caZq5: // global
           if (_saX0C::I64 == 0) goto caZq1; else goto caZq0;
       caZq1: // global
           (_saX10::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saX0B::I64, 1, 0, 0);
           Hp = Hp - 32;
           _saX11::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX10::I64));
           if (_saX11::I64 != 0) goto uaZrk; else goto caZrf;
       uaZrk: // global
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0D::I64;
           I64[Sp - 16] = _saX0E::I64;
           I64[Sp - 8] = _saX11::I64;
           Sp = Sp - 32;
           call _caZp6() args: 0, res: 0, upd: 0;
       caZrf: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZq0: // global
           I64[Hp - 24] = sat_saX0O_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp - 8] = block_caZq7_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZp6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZp6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZqv; else goto caZqu;
       caZqv: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caZp5_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZqu: // global
           _saX0B::I64 = I64[Sp];
           _saX0D::I64 = I64[Sp + 8];
           _saX0E::I64 = I64[Sp + 16];
           (_saX15::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX15::I64 == 0) goto caZqV; else goto caZqA;
       caZqV: // global
           I64[Hp - 24] = sat_saX1u_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caZqS_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       caZqA: // global
           I64[Hp - 24] = sat_saX1e_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caZqw_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZp5() //  [R1]
         { info_tbl: [(caZp5,
                       label: block_caZp5_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZp5: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caZp6() args: 0, res: 0, upd: 0;
     }
 },
 _caZqS() //  [R1]
         { info_tbl: [(caZqS,
                       label: block_caZqS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZqS: // global
           I64[Sp] = block_caZqU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZru; else goto caZqX;
       uaZru: // global
           call _caZqU(R1) args: 0, res: 0, upd: 0;
       caZqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZqU() //  [R1]
         { info_tbl: [(caZqU,
                       label: block_caZqU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZqU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZr3; else goto caZr2;
       caZr3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZr2: // global
           _saX1A::I64 = I64[R1 + 7];
           if (_saX1A::I64 != (-1)) goto caZrb; else goto uaZrn;
       caZrb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1A::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrn: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 _caZqw() //  [R1]
         { info_tbl: [(caZqw,
                       label: block_caZqw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZqw: // global
           I64[Sp] = block_caZqy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZrs; else goto caZqC;
       uaZrs: // global
           call _caZqy(R1) args: 0, res: 0, upd: 0;
       caZqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZqy() //  [R1]
         { info_tbl: [(caZqy,
                       label: block_caZqy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZqy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZqI; else goto caZqH;
       caZqI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZqH: // global
           _saX1k::I64 = I64[R1 + 7];
           if (_saX1k::I64 != (-1)) goto caZqQ; else goto uaZrm;
       caZqQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1k::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrm: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 _caZq7() //  [R1]
         { info_tbl: [(caZq7,
                       label: block_caZq7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZq7: // global
           I64[Sp] = block_caZq9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZrq; else goto caZqb;
       uaZrq: // global
           call _caZq9(R1) args: 0, res: 0, upd: 0;
       caZqb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZq9() //  [R1]
         { info_tbl: [(caZq9,
                       label: block_caZq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZqh; else goto caZqg;
       caZqh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZqg: // global
           _saX0U::I64 = I64[R1 + 7];
           if (_saX0U::I64 != (-1)) goto caZqp; else goto uaZrj;
       caZqp: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX0U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrj: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 _caZrc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZrc: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.931810577 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { info_tbl: [(caZsR,
                       label: GHC.IO.FD.$fRawIOFD1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZsR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZt0; else goto caZt1;
       caZt0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZt1: // global
           I64[Sp - 24] = block_caZsO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZta; else goto caZsP;
       uaZta: // global
           call _caZsO(R1) args: 0, res: 0, upd: 0;
       caZsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZsO() //  [R1]
         { info_tbl: [(caZsO,
                       label: block_caZsO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZsO: // global
           I64[Sp - 8] = block_caZsU_info;
           _saX1I::I64 = I64[R1 + 7];
           _saX1J::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX1J::I64;
           I64[Sp + 8] = _saX1I::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZt9; else goto caZsV;
       uaZt9: // global
           call _caZsU(R1) args: 0, res: 0, upd: 0;
       caZsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZsU() //  [R1]
         { info_tbl: [(caZsU,
                       label: block_caZsU_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZsU: // global
           I64[Sp] = block_caZsZ_info;
           _saX1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX1L::I64;
           if (R1 & 7 != 0) goto uaZtb; else goto caZt4;
       uaZtb: // global
           call _caZsZ(R1) args: 0, res: 0, upd: 0;
       caZt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZsZ() //  [R1]
         { info_tbl: [(caZsZ,
                       label: block_caZsZ_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZsZ: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.941274519 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.943867282 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { info_tbl: [(caZtB,
                       label: GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZtB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caZtT; else goto caZtU;
       caZtT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZtU: // global
           I64[Sp - 16] = block_caZty_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZu1; else goto caZtz;
       uaZu1: // global
           call _caZty(R1) args: 0, res: 0, upd: 0;
       caZtz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZty() //  [R1]
         { info_tbl: [(caZty,
                       label: block_caZty_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZty: // global
           I64[Sp - 40] = block_caZtE_info;
           _saX1T::P64 = P64[R1 + 7];
           _saX1U::P64 = P64[R1 + 15];
           _saX1S::I64 = I64[R1 + 23];
           _saX1V::I64 = I64[R1 + 31];
           _saX1W::I64 = I64[R1 + 39];
           _saX1X::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _saX1U::P64;
           I64[Sp - 24] = _saX1V::I64;
           I64[Sp - 16] = _saX1W::I64;
           I64[Sp - 8] = _saX1X::I64;
           P64[Sp] = _saX1T::P64;
           I64[Sp + 8] = _saX1S::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZu0; else goto caZtF;
       uaZu0: // global
           call _caZtE(R1) args: 0, res: 0, upd: 0;
       caZtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZtE() //  [R1]
         { info_tbl: [(caZtE,
                       label: block_caZtE_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZtE: // global
           I64[Sp] = block_caZtP_info;
           _saX1W::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _saX1W::I64;
           R4 = I64[Sp + 48] + _saX1W::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZtP() //  [R1]
         { info_tbl: [(caZtP,
                       label: block_caZtP_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZtP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caZtZ; else goto caZtY;
       caZtZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZtY: // global
           _saX1S::I64 = I64[Sp + 48];
           _saX1T::P64 = P64[Sp + 40];
           _saX1U::P64 = P64[Sp + 8];
           _saX1V::I64 = I64[Sp + 16];
           call MO_Touch(_saX1T::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX1T::P64;
           P64[Hp - 32] = _saX1U::P64;
           I64[Hp - 24] = _saX1S::I64;
           I64[Hp - 16] = _saX1V::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.954994211 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { info_tbl: [(caZus,
                       label: GHC.IO.FD.fdIsNonBlocking_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZus: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZuw; else goto caZux;
       caZuw: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZux: // global
           I64[Sp - 8] = block_caZup_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZuB; else goto caZuq;
       uaZuB: // global
           call _caZup(R1) args: 0, res: 0, upd: 0;
       caZuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZup() //  [R1]
         { info_tbl: [(caZup,
                       label: block_caZup_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZuA; else goto caZuz;
       caZuA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZuz: // global
           _saX2b::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saX2b::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.960739806 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { info_tbl: [(caZuT,
                       label: GHC.IO.FD.fdFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZuT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZuX; else goto caZuY;
       caZuX: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZuY: // global
           I64[Sp - 8] = block_caZuQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZv2; else goto caZuR;
       uaZv2: // global
           call _caZuQ(R1) args: 0, res: 0, upd: 0;
       caZuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZuQ() //  [R1]
         { info_tbl: [(caZuQ,
                       label: block_caZuQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZuQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZv1; else goto caZv0;
       caZv1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZv0: // global
           _saX2e::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2e::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.966991734 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { info_tbl: [(caZvk,
                       label: GHC.IO.FD.$fShowFD_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZvq; else goto caZvr;
       caZvq: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZvr: // global
           I64[Sp - 8] = block_caZvh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZvw; else goto caZvi;
       uaZvw: // global
           call _caZvh(R1) args: 0, res: 0, upd: 0;
       caZvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZvh() //  [R1]
         { info_tbl: [(caZvh,
                       label: block_caZvh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvh: // global
           I64[Sp] = block_caZvn_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZvn() //  [R1, R2]
         { info_tbl: [(caZvn,
                       label: block_caZvn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZvv; else goto caZvu;
       caZvv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZvu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.975464523 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { info_tbl: [(caZvV,
                       label: GHC.IO.FD.$fBufferedIOFD15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZvY; else goto caZvZ;
       caZvY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZvZ: // global
           I64[Sp - 16] = block_caZvO_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZvO() //  [R1]
         { info_tbl: [(caZvO,
                       label: block_caZvO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvO: // global
           I64[Sp - 8] = block_caZvQ_info;
           _saX2s::P64 = R1;
           R1 = 8192;
           P64[Sp] = _saX2s::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZvQ() //  [R1]
         { info_tbl: [(caZvQ,
                       label: block_caZvQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZvQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caZw3; else goto caZw2;
       caZw3: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZw2: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.983047051 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_saX2E_entry() //  [R1]
         { info_tbl: [(caZwv,
                       label: sat_saX2E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZwv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZwz; else goto caZwA;
       caZwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZwA: // global
           I64[Sp - 8] = block_caZws_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZwE; else goto caZwt;
       uaZwE: // global
           call _caZws(R1) args: 0, res: 0, upd: 0;
       caZwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZws() //  [R1]
         { info_tbl: [(caZws,
                       label: block_caZws_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZws: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZwD; else goto caZwC;
       caZwD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZwC: // global
           _saX2C::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2C::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { info_tbl: [(caZwF,
                       label: GHC.IO.FD.$fIODeviceFD12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZwF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZwJ; else goto caZwI;
       caZwJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZwI: // global
           I64[Hp - 16] = sat_saX2E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.990716042 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_saX2L_entry() //  [R1]
         { info_tbl: [(caZx8,
                       label: sat_saX2L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZx8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZxc; else goto caZxd;
       caZxc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZxd: // global
           I64[Sp - 8] = block_caZx5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZxh; else goto caZx6;
       uaZxh: // global
           call _caZx5(R1) args: 0, res: 0, upd: 0;
       caZx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZx5() //  [R1]
         { info_tbl: [(caZx5,
                       label: block_caZx5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZx5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZxg; else goto caZxf;
       caZxg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZxf: // global
           _saX2J::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2J::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { info_tbl: [(caZxi,
                       label: GHC.IO.FD.$fIODeviceFD9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZxi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZxm; else goto caZxl;
       caZxm: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZxl: // global
           I64[Hp - 16] = sat_saX2L_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:55.999092085 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_saX2R_entry() //  [R1]
         { info_tbl: [(caZxL,
                       label: sat_saX2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZxL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZxP; else goto caZxQ;
       caZxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZxQ: // global
           I64[Sp - 8] = block_caZxI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZxU; else goto caZxJ;
       uaZxU: // global
           call _caZxI(R1) args: 0, res: 0, upd: 0;
       caZxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZxI() //  [R1]
         { info_tbl: [(caZxI,
                       label: block_caZxI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZxI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZxT; else goto caZxS;
       caZxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZxS: // global
           _saX2P::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2P::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { info_tbl: [(caZxV,
                       label: GHC.IO.FD.$fIODeviceFD8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZxV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZxZ; else goto caZxY;
       caZxZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZxY: // global
           I64[Hp - 16] = sat_saX2R_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.007424444 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_saX30_entry() //  [R1]
         { info_tbl: [(caZys,
                       label: sat_saX30_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZys: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZyt; else goto caZyu;
       caZyt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZyu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZyl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZyB; else goto caZym;
       uaZyB: // global
           call _caZyl(R1) args: 0, res: 0, upd: 0;
       caZym: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZyl() //  [R1]
         { info_tbl: [(caZyl,
                       label: block_caZyl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZyl: // global
           if (R1 & 7 == 1) goto caZyp; else goto caZyq;
       caZyp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZyq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saX2Y_entry() //  [R1]
         { info_tbl: [(caZyJ,
                       label: sat_saX2Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZyJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZyN; else goto caZyO;
       caZyN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZyO: // global
           I64[Sp - 8] = block_caZyG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZyS; else goto caZyH;
       uaZyS: // global
           call _caZyG(R1) args: 0, res: 0, upd: 0;
       caZyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZyG() //  [R1]
         { info_tbl: [(caZyG,
                       label: block_caZyG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZyG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZyR; else goto caZyQ;
       caZyR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZyQ: // global
           _saX2W::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2W::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { info_tbl: [(caZyT,
                       label: GHC.IO.FD.$fIODeviceFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZyT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caZyX; else goto caZyW;
       caZyX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZyW: // global
           I64[Hp - 40] = sat_saX30_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_saX2Y_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.018817564 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.020518069 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.022330197 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.024513693 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.026181355 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.027882799 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.029861292 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.031543102 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.033187152 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.034832418 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.036690978 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.038387246 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.040085823 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.042329369 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.044058663 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.045858007 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.048694527 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caZzK,
                       label: GHC.IO.FD.$fShowFD_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZzQ; else goto caZzR;
       caZzQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZzR: // global
           I64[Sp - 16] = block_caZzH_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZzW; else goto caZzI;
       uaZzW: // global
           call _caZzH(R1) args: 0, res: 0, upd: 0;
       caZzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZzH() //  [R1]
         { info_tbl: [(caZzH,
                       label: block_caZzH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZzH: // global
           I64[Sp] = block_caZzN_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZzN() //  [R1, R2]
         { info_tbl: [(caZzN,
                       label: block_caZzN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZzV; else goto caZzU;
       caZzV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZzU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.05675084 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(caZAg,
                       label: GHC.IO.FD.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZAg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZAh; else goto caZAi;
       caZAh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZAi: // global
           I64[Sp - 16] = block_caZAd_info;
           R4 = GHC.Types.[]_closure+1;
           _saX3c::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _saX3c::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZAd() //  [R1, R2]
         { info_tbl: [(caZAd,
                       label: block_caZAd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZAd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZAl; else goto caZAk;
       caZAl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZAk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.0626571 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { info_tbl: [(caZAB,
                       label: GHC.IO.FD.$fShowFD1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZAB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZAC; else goto caZAD;
       caZAC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZAD: // global
           I64[Sp - 16] = block_caZAy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZAH; else goto caZAz;
       uaZAH: // global
           call _caZAy(R1) args: 0, res: 0, upd: 0;
       caZAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZAy() //  [R1]
         { info_tbl: [(caZAy,
                       label: block_caZAy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZAy: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.068453729 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caZAV,
                       label: GHC.IO.FD.$fShowFD_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZAV: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.072343663 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.074469913 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { info_tbl: [(caZBd,
                       label: output_flags_raWV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZBd: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caZBv; else goto caZBw;
       caZBw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZBy; else goto caZBx;
       caZBy: // global
           HpAlloc = 16;
           goto caZBv;
       caZBv: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZBx: // global
           (_caZB6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_caZB6::I64 == 0) goto caZB8; else goto caZB7;
       caZB8: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       caZB7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZB6::I64;
           (_saX3r::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX3v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3r::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3v::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.079468526 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { info_tbl: [(caZBT,
                       label: write_flags_raWV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZBT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZCd; else goto caZCe;
       caZCd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZCe: // global
           (_caZBN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZBN::I64 == 0) goto caZBP; else goto caZBO;
       caZBP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZBO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZBN::I64;
           I64[Sp - 24] = block_caZBQ_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZCi; else goto caZBR;
       uaZCi: // global
           call _caZBQ(R1) args: 0, res: 0, upd: 0;
       caZBR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZBQ() //  [R1]
         { info_tbl: [(caZBQ,
                       label: block_caZBQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZBQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZCh; else goto caZCg;
       caZCh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZCg: // global
           _saX3D::I64 = I64[R1 + 7];
           (_saX3H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3D::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3H::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.086026471 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { info_tbl: [(caZCH,
                       label: append_flags_raWV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZCH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZD1; else goto caZD2;
       caZD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZD2: // global
           (_caZCB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZCB::I64 == 0) goto caZCD; else goto caZCC;
       caZCD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZCC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZCB::I64;
           I64[Sp - 24] = block_caZCE_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZD6; else goto caZCF;
       uaZD6: // global
           call _caZCE(R1) args: 0, res: 0, upd: 0;
       caZCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZCE() //  [R1]
         { info_tbl: [(caZCE,
                       label: block_caZCE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZCE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZD5; else goto caZD4;
       caZD5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZD4: // global
           _saX3O::I64 = I64[R1 + 7];
           (_saX3S::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3O::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3S::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.092526493 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { info_tbl: [(caZDv,
                       label: rw_flags_raWV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZDv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZDP; else goto caZDQ;
       caZDP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZDQ: // global
           (_caZDp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZDp::I64 == 0) goto caZDr; else goto caZDq;
       caZDr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZDq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZDp::I64;
           I64[Sp - 24] = block_caZDs_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZDU; else goto caZDt;
       uaZDU: // global
           call _caZDs(R1) args: 0, res: 0, upd: 0;
       caZDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZDs() //  [R1]
         { info_tbl: [(caZDs,
                       label: block_caZDs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZDT; else goto caZDS;
       caZDT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZDS: // global
           _saX3Z::I64 = I64[R1 + 7];
           (_saX43::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3Z::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX43::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.099753982 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { info_tbl: [(caZEk,
                       label: read_flags_raWV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZEk: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caZEC; else goto caZED;
       caZED: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZEF; else goto caZEE;
       caZEF: // global
           HpAlloc = 16;
           goto caZEC;
       caZEC: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZEE: // global
           (_caZEd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_caZEd::I64 == 0) goto caZEf; else goto caZEe;
       caZEf: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       caZEe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZEd::I64;
           (_saX4c::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX4g::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4c::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4g::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.104482814 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { info_tbl: [(caZEY,
                       label: GHC.IO.FD.$fIODeviceFD16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZEY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZEZ; else goto caZF0;
       caZEZ: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZF0: // global
           I64[Sp - 8] = block_caZEV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZF8; else goto caZEW;
       uaZF8: // global
           call _caZEV(R1) args: 0, res: 0, upd: 0;
       caZEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZEV() //  [R1]
         { info_tbl: [(caZEV,
                       label: block_caZEV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZEV: // global
           if (I64[R1 + 7] == (-1)) goto caZF7; else goto caZF6;
       caZF7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZF6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.110212897 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.112082289 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { info_tbl: [(caZFr,
                       label: GHC.IO.FD.$fIODeviceFD14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZFr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZFs; else goto caZFt;
       caZFs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZFt: // global
           (_caZFo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZFo::I64 == 0) goto caZFq; else goto caZFp;
       caZFq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZFp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZFo::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.116819702 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_saX4E_entry() //  [R1]
         { info_tbl: [(caZFN,
                       label: sat_saX4E_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZFN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZFX; else goto caZFW;
       caZFX: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZFW: // global
           (_saX4C::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4C::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX4I_entry() //  [R1]
         { info_tbl: [(caZG4,
                       label: sat_saX4I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZG4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZG5; else goto caZG6;
       caZG5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { info_tbl: [(caZG7,
                       label: GHC.IO.FD.$w$ctell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZG7: // global
           _saX4r::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caZG8; else goto caZG9;
       caZG9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZGb; else goto caZGa;
       caZGb: // global
           HpAlloc = 24;
           goto caZG8;
       caZG8: // global
           R2 = _saX4r::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZGa: // global
           (_saX4w::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_saX4E_info;
           I64[Hp - 8] = _saX4r::I64;
           I64[Hp] = _saX4w::I64;
           I64[Sp - 8] = block_caZFY_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZFY() //  [R1]
         { info_tbl: [(caZFY,
                       label: block_caZFY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZFY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZGe; else goto caZGd;
       caZGe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZGd: // global
           I64[Hp - 16] = sat_saX4I_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.12765716 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { info_tbl: [(caZGE,
                       label: GHC.IO.FD.$fIODeviceFD13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZGE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZGF; else goto caZGG;
       caZGF: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZGG: // global
           I64[Sp - 8] = block_caZGB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZGK; else goto caZGC;
       uaZGK: // global
           call _caZGB(R1) args: 0, res: 0, upd: 0;
       caZGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZGB() //  [R1]
         { info_tbl: [(caZGB,
                       label: block_caZGB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZGB: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.132861766 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.134777337 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { info_tbl: [(caZH1,
                       label: GHC.IO.FD.$fIODeviceFD18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZH1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZH2; else goto caZH3;
       caZH2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZH3: // global
           (_caZGY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZGY::I64 == 0) goto caZH0; else goto caZGZ;
       caZH0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZGZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZGY::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.139676349 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_saX51_entry() //  [R1]
         { info_tbl: [(caZHy,
                       label: sat_saX51_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZHC; else goto caZHB;
       caZHC: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZHB: // global
           (_saX4Z::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4Z::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { info_tbl: [(caZHD,
                       label: GHC.IO.FD.$w$cseek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZHE; else goto caZHF;
       caZHE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZHF: // global
           I64[Sp - 24] = block_caZHf_info;
           _saX4O::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _saX4O::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZHf() //  [R1]
         { info_tbl: [(caZHf,
                       label: block_caZHf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHf: // global
           I64[Sp] = block_caZHG_info;
           _saX4S::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX4S::I64;
           if (R1 & 7 != 0) goto uaZIf; else goto caZHO;
       uaZIf: // global
           call _caZHG(R1) args: 0, res: 0, upd: 0;
       caZHO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZHG() //  [R1]
         { info_tbl: [(caZHG,
                       label: block_caZHG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHG: // global
           _caZI6::P64 = R1 & 7;
           if (_caZI6::P64 < 3) goto uaZIa; else goto caZI2;
       uaZIa: // global
           if (_caZI6::P64 < 2) goto caZHU; else goto caZHY;
       caZHU: // global
           (_saX59::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX59::I64));
           goto uaZIj;
       caZHY: // global
           (_saX5e::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5e::I64));
           goto uaZIj;
       caZI2: // global
           (_saX5j::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5j::I64));
           goto uaZIj;
       uaZIj: // global
           call _caZHm() args: 0, res: 0, upd: 0;
     }
 },
 _caZHm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHm: // global
           Hp = Hp + 32;
           _saX4U::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caZHL; else goto caZHK;
       caZHL: // global
           HpAlloc = 32;
           I64[Sp] = block_caZHl_info;
           R1 = _saX4U::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZHK: // global
           I64[Hp - 24] = sat_saX51_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX4U::I64;
           I64[Sp + 16] = block_caZHI_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZHl() //  [R1]
         { info_tbl: [(caZHl,
                       label: block_caZHl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHl: // global
           I64[Sp] = R1;
           call _caZHm() args: 0, res: 0, upd: 0;
     }
 },
 _caZHI() //  []
         { info_tbl: [(caZHI,
                       label: block_caZHI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZHI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.155101755 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { info_tbl: [(caZIW,
                       label: GHC.IO.FD.$fIODeviceFD17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZIW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZIX; else goto caZIY;
       caZIX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZIY: // global
           I64[Sp - 24] = block_caZIT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZJ2; else goto caZIU;
       uaZJ2: // global
           call _caZIT(R1) args: 0, res: 0, upd: 0;
       caZIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZIT() //  [R1]
         { info_tbl: [(caZIT,
                       label: block_caZIT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZIT: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.160666279 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.16254793 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.164352561 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.166111876 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.168520879 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { info_tbl: [(caZJm,
                       label: lvl4_raWVa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZJn; else goto caZJo;
       caZJn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZJo: // global
           (_caZJj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZJj::I64 == 0) goto caZJl; else goto caZJk;
       caZJl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZJk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZJj::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.173138773 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { info_tbl: [(caZJC,
                       label: GHC.IO.FD.$fIODeviceFD11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZJC: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.176827684 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { info_tbl: [(caZJP,
                       label: GHC.IO.FD.$wsetSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZJQ; else goto caZJR;
       caZJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZJR: // global
           I64[Sp - 16] = block_caZJN_info;
           _saX5v::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _saX5v::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZJN() //  [R1]
         { info_tbl: [(caZJN,
                       label: block_caZJN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZJN: // global
           (_saX5C::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_saX5C::I64) == 0 :: W32) goto caZK9; else goto caZK3;
       caZK9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZK3: // global
           (_saX5H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX5H::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.183249758 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { info_tbl: [(caZKu,
                       label: GHC.IO.FD.$fIODeviceFD10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZKu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZKv; else goto caZKw;
       caZKv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZKw: // global
           I64[Sp - 16] = block_caZKr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZKA; else goto caZKs;
       uaZKA: // global
           call _caZKr(R1) args: 0, res: 0, upd: 0;
       caZKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZKr() //  [R1]
         { info_tbl: [(caZKr,
                       label: block_caZKr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZKr: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.188733885 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZKO,
                       label: GHC.IO.FD.writeRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZKO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.192771064 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZKZ,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZKZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.19628726 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZLa,
                       label: GHC.IO.FD.readRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZLa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.200381302 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZLi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZLo,
                       label: GHC.IO.FD.$w$cfillReadBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZLo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caZLz; else goto caZLA;
       caZLz: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caZLA: // global
           I64[Sp - 32] = block_caZLw_info;
           _saX5T::P64 = R6;
           R6 = 0;
           _saX5S::P64 = R5;
           _saX5W::I64 = I64[Sp + 16];
           R5 = R4 + _saX5W::I64;
           _saX5R::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _saX5W::I64;
           I64[Sp - 24] = _saX5R::I64;
           P64[Sp - 16] = _saX5S::P64;
           P64[Sp - 8] = _saX5T::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _caZLw() //  [R1]
         { info_tbl: [(caZLw,
                       label: block_caZLw_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZLw: // global
           I64[Sp] = block_caZLy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZLZ; else goto caZLC;
       uaZLZ: // global
           call _caZLy(R1) args: 0, res: 0, upd: 0;
       caZLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZLy() //  [R1]
         { info_tbl: [(caZLy,
                       label: block_caZLy_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZLy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caZLI; else goto caZLH;
       caZLI: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZLH: // global
           _saX5R::I64 = I64[Sp + 8];
           _saX5S::P64 = P64[Sp + 16];
           _saX5T::P64 = P64[Sp + 24];
           _saX5U::I64 = I64[Sp + 32];
           _saX5V::I64 = I64[Sp + 40];
           _saX5W::I64 = I64[Sp + 48];
           _saX66::I64 = I64[R1 + 7];
           if (_saX66::I64 == (-1)) goto caZLY; else goto caZLT;
       caZLY: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _caZLX::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _caZLX::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZLT: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64 + _saX66::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.211454034 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { info_tbl: [(caZMv,
                       label: GHC.IO.FD.$fBufferedIOFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZMv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZMz; else goto caZMA;
       caZMz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZMA: // global
           I64[Sp - 16] = block_caZMs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZMI; else goto caZMt;
       uaZMI: // global
           call _caZMs(R1) args: 0, res: 0, upd: 0;
       caZMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZMs() //  [R1]
         { info_tbl: [(caZMs,
                       label: block_caZMs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZMs: // global
           I64[Sp - 8] = block_caZMy_info;
           _saX6j::I64 = I64[R1 + 7];
           _saX6k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6k::I64;
           I64[Sp + 8] = _saX6j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZMH; else goto caZMC;
       uaZMH: // global
           call _caZMy(R1) args: 0, res: 0, upd: 0;
       caZMC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZMy() //  [R1]
         { info_tbl: [(caZMy,
                       label: block_caZMy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZMy: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.220769866 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZN0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saX6L_entry() //  [R1]
         { info_tbl: [(caZNk,
                       label: sat_saX6L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZNk: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caZNl; else goto caZNm;
       caZNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZNm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caZNh_info;
           _saX6v::P64 = P64[R1 + 16];
           _saX6w::P64 = P64[R1 + 24];
           _saX6u::I64 = I64[R1 + 40];
           _saX6x::I64 = I64[R1 + 48];
           _saX6y::I64 = I64[R1 + 56];
           _saX6z::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saX6u::I64;
           P64[Sp - 56] = _saX6v::P64;
           P64[Sp - 48] = _saX6w::P64;
           I64[Sp - 40] = _saX6x::I64;
           I64[Sp - 32] = _saX6y::I64;
           I64[Sp - 24] = _saX6z::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaZNE; else goto caZNi;
       uaZNE: // global
           call _caZNh(R1) args: 0, res: 0, upd: 0;
       caZNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZNh() //  [R1]
         { info_tbl: [(caZNh,
                       label: block_caZNh_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZNh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caZNr; else goto caZNq;
       caZNr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZNq: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6z::I64 = I64[Sp + 48];
           _saX6J::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_saX6J::I64 == _saX6z::I64) goto caZND; else goto caZNA;
       caZND: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZNA: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = _saX6J::I64;
           I64[Hp] = _saX6z::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caZNF,
                       label: GHC.IO.FD.$w$cflushWriteBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZNF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZNH; else goto caZNI;
       caZNH: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caZNI: // global
           I64[Sp - 32] = block_caZNa_info;
           _saX6v::P64 = R5;
           _saX6y::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _saX6y::I64;
           _saX6u::I64 = R4;
           R4 = R4 + _saX6y::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _saX6u::I64;
           P64[Sp - 16] = _saX6v::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZNa() //  [R1]
         { info_tbl: [(caZNa,
                       label: block_caZNa_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZNa: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caZNL; else goto caZNK;
       caZNL: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZNK: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6y::I64 = I64[Sp + 40];
           _saX6z::I64 = I64[Sp + 48];
           call MO_Touch(_saX6v::P64);
           I64[Hp - 88] = sat_saX6L_info;
           P64[Hp - 72] = _saX6v::P64;
           P64[Hp - 64] = _saX6w::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saX6u::I64;
           I64[Hp - 40] = _saX6x::I64;
           I64[Hp - 32] = _saX6y::I64;
           I64[Hp - 24] = _saX6z::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.233945684 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { info_tbl: [(caZOj,
                       label: GHC.IO.FD.$fBufferedIOFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZOj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZOn; else goto caZOo;
       caZOn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZOo: // global
           I64[Sp - 16] = block_caZOg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZOw; else goto caZOh;
       uaZOw: // global
           call _caZOg(R1) args: 0, res: 0, upd: 0;
       caZOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZOg() //  [R1]
         { info_tbl: [(caZOg,
                       label: block_caZOg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZOg: // global
           I64[Sp - 8] = block_caZOm_info;
           _saX6R::I64 = I64[R1 + 7];
           _saX6S::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6S::I64;
           I64[Sp + 8] = _saX6R::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZOv; else goto caZOq;
       uaZOv: // global
           call _caZOm(R1) args: 0, res: 0, upd: 0;
       caZOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZOm() //  [R1]
         { info_tbl: [(caZOm,
                       label: block_caZOm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZOm: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.242684172 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_saX7a_entry() //  [R1]
         { info_tbl: [(caZP7,
                       label: sat_saX7a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZP7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZP8; else goto caZPj;
       caZP8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZPj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto caZP6; else goto caZP5;
       caZP6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZP5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { info_tbl: [(caZPk,
                       label: GHC.IO.FD.$fIODeviceFD21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZPk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZPl; else goto caZPm;
       caZPl: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZPm: // global
           I64[Sp - 8] = block_caZOR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZPq; else goto caZOS;
       uaZPq: // global
           call _caZOR(R1) args: 0, res: 0, upd: 0;
       caZOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZOR() //  [R1]
         { info_tbl: [(caZOR,
                       label: block_caZOR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZOR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZPp; else goto caZPo;
       caZPp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZPo: // global
           (_saX78::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_saX7a_info;
           I64[Hp] = _saX78::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.250396969 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { info_tbl: [(caZPP,
                       label: GHC.IO.FD.$fIODeviceFD25_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZPP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZPQ; else goto caZPR;
       caZPQ: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZPR: // global
           I64[Sp - 8] = block_caZPM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZPZ; else goto caZPN;
       uaZPZ: // global
           call _caZPM(R1) args: 0, res: 0, upd: 0;
       caZPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZPM() //  [R1]
         { info_tbl: [(caZPM,
                       label: block_caZPM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZPM: // global
           if (I64[R1 + 7] == (-1)) goto caZPY; else goto caZPX;
       caZPY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZPX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.255846549 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.257809722 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { info_tbl: [(caZQi,
                       label: GHC.IO.FD.$fIODeviceFD28_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZQi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZQj; else goto caZQk;
       caZQj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZQk: // global
           (_caZQf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZQf::I64 == 0) goto caZQh; else goto caZQg;
       caZQh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZQg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZQf::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.263295137 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_saX7u_entry() //  [R1]
         { info_tbl: [(caZQI,
                       label: sat_saX7u_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZQI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZQY; else goto caZQZ;
       caZQY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZQZ: // global
           I64[Sp - 8] = block_caZQS_info;
           Sp = Sp - 8;
           _caZQO::I64 = I64[R1 + 7];
           _caZQP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _caZQQ::I64 = I64[R1 + 15];
           _uaZR5::P64 = CurrentTSO;
           I64[I64[_uaZR5::P64 + 24] + 16] = Sp;
           _uaZR6::I64 = CurrentNursery;
           P64[_uaZR6::I64 + 8] = Hp + 8;
           I64[_uaZR5::P64 + 104] = I64[_uaZR5::P64 + 104] - ((Hp + 8) - I64[_uaZR6::I64]);
           (_uaZR3::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX7r::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_caZQO::I64, _caZQP::I64, _caZQQ::I64, 0);
           (_uaZR4::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZR3::I64);
           BaseReg = _uaZR4::I64;
           _uaZR7::P64 = CurrentTSO;
           _uaZR8::P64 = I64[_uaZR7::P64 + 24];
           Sp = I64[_uaZR8::P64 + 16];
           SpLim = _uaZR8::P64 + 192;
           HpAlloc = 0;
           _uaZR9::I64 = CurrentNursery;
           _uaZRa::I64 = I64[_uaZR9::I64 + 8];
           Hp = _uaZRa::I64 - 8;
           _uaZRb::I64 = I64[_uaZR9::I64];
           HpLim = _uaZRb::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZR9::I64 + 48]) << 12) - 1);
           I64[_uaZR7::P64 + 104] = I64[_uaZR7::P64 + 104] + (_uaZRa::I64 - _uaZRb::I64);
           R1 = _saX7r::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZQS() //  [R1]
         { info_tbl: [(caZQS,
                       label: block_caZQS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZQS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZR2; else goto caZR1;
       caZR2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZR1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX7B_entry() //  [R1]
         { info_tbl: [(caZRm,
                       label: sat_saX7B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZRn; else goto caZRo;
       caZRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZRj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZRy; else goto caZRk;
       uaZRy: // global
           call _caZRj(R1) args: 0, res: 0, upd: 0;
       caZRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZRj() //  [R1]
         { info_tbl: [(caZRj,
                       label: block_caZRj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZRj: // global
           _saX7A::I64 = I64[R1 + 7];
           if (_saX7A::I64 != 0) goto uaZRx; else goto caZRv;
       uaZRx: // global
           if (_saX7A::I64 != 1) goto caZRu; else goto caZRw;
       caZRu: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caZRw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZRv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { info_tbl: [(caZRG,
                       label: GHC.IO.FD.$w$cready_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 18} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZRG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZRH; else goto caZRI;
       caZRH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZRI: // global
           I64[Sp - 24] = block_caZRz_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZS1; else goto caZRA;
       uaZS1: // global
           call _caZRz(R1) args: 0, res: 0, upd: 0;
       caZRA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZRz() //  [R1]
         { info_tbl: [(caZRz,
                       label: block_caZRz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZRz: // global
           if (R1 & 7 == 1) goto caZRD; else goto caZRE;
       caZRD: // global
           I64[Sp] = 0;
           goto uaZS0;
       caZRE: // global
           I64[Sp] = 1;
           goto uaZS0;
       uaZS0: // global
           call _caZQz() args: 0, res: 0, upd: 0;
     }
 },
 _caZQz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZQz: // global
           Hp = Hp + 32;
           _saX7k::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caZRL; else goto caZRK;
       caZRL: // global
           HpAlloc = 32;
           I64[Sp] = block_caZQy_info;
           R1 = _saX7k::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZRK: // global
           I64[Hp - 24] = sat_saX7u_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX7k::I64;
           I64[Sp + 16] = block_caZRd_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZQy() //  [R1]
         { info_tbl: [(caZQy,
                       label: block_caZQy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZQy: // global
           I64[Sp] = R1;
           call _caZQz() args: 0, res: 0, upd: 0;
     }
 },
 _caZRd() //  [R1]
         { info_tbl: [(caZRd,
                       label: block_caZRd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZRd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZRO; else goto caZRN;
       caZRO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZRN: // global
           I64[Hp - 16] = sat_saX7B_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.284051249 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { info_tbl: [(caZT7,
                       label: GHC.IO.FD.$fIODeviceFD27_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZT7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZTb; else goto caZTc;
       caZTb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZTc: // global
           I64[Sp - 24] = block_caZT4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZTk; else goto caZT5;
       uaZTk: // global
           call _caZT4(R1) args: 0, res: 0, upd: 0;
       caZT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZT4() //  [R1]
         { info_tbl: [(caZT4,
                       label: block_caZT4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZT4: // global
           I64[Sp] = block_caZTa_info;
           _saX7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX7I::I64;
           if (R1 & 7 != 0) goto uaZTj; else goto caZTe;
       uaZTj: // global
           call _caZTa(R1) args: 0, res: 0, upd: 0;
       caZTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZTa() //  [R1]
         { info_tbl: [(caZTa,
                       label: block_caZTa_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZTa: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.292742172 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_saX7W_entry() //  [R1]
         { info_tbl: [(caZTU,
                       label: sat_saX7W_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZTU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZTV; else goto caZTW;
       caZTV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZTW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caZTN_info;
           _saX7Q::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX7Q::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaZU9; else goto caZTO;
       uaZU9: // global
           call _caZTN(R1) args: 0, res: 0, upd: 0;
       caZTO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZTN() //  [R1]
         { info_tbl: [(caZTN,
                       label: block_caZTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZTN: // global
           _saX7Q::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caZTR; else goto caZTS;
       caZTR: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caZU8; else goto caZU1;
       caZU1: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZTS: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caZU8; else goto caZU7;
       caZU8: // global
           HpAlloc = 24;
           R1 = _saX7V::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZU7: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { info_tbl: [(caZUa,
                       label: GHC.IO.FD.setNonBlockingMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZUa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZUb; else goto caZUc;
       caZUb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZUc: // global
           I64[Sp - 16] = block_caZTC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZUh; else goto caZTD;
       uaZUh: // global
           call _caZTC(R1) args: 0, res: 0, upd: 0;
       caZTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZTC() //  [R1]
         { info_tbl: [(caZTC,
                       label: block_caZTC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZTC: // global
           I64[Sp - 8] = block_caZTH_info;
           R3 = P64[Sp + 8];
           _saX7Q::I64 = I64[R1 + 7];
           R2 = _saX7Q::I64;
           I64[Sp] = _saX7Q::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZTH() //  [R1]
         { info_tbl: [(caZTH,
                       label: block_caZTH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZTH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZUg; else goto caZUf;
       caZUg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZUf: // global
           I64[Hp - 24] = sat_saX7W_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.304659617 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { info_tbl: [(caZUN,
                       label: GHC.IO.FD.setNonBlockingMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZUN: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.308035365 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.309858913 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { info_tbl: [(caZV1,
                       label: lvl6_raWVc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZV1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZV2; else goto caZV3;
       caZV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZV3: // global
           (_caZUY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZUY::I64 == 0) goto caZV0; else goto caZUZ;
       caZV0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZUZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZUY::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.314912809 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { info_tbl: [(caZVh,
                       label: GHC.IO.FD.$fIODeviceFD2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZVh: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.3186931 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { info_tbl: [(caZVA,
                       label: GHC.IO.FD.$w$cdup2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZVA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZVB; else goto caZVC;
       caZVB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZVC: // global
           _saX82::I64 = R4;
           _saX81::I64 = R3;
           _caZVu::I64 = R4;
           (_saX87::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _caZVu::I64);
           _saX88::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX87::I64));
           if (_saX88::I64 != (-1)) goto uaZVR; else goto caZVz;
       uaZVR: // global
           I64[Sp - 24] = _saX81::I64;
           I64[Sp - 16] = _saX82::I64;
           I64[Sp - 8] = _saX88::I64;
           Sp = Sp - 24;
           call _caZVF() args: 0, res: 0, upd: 0;
       caZVz: // global
           (_saX8d::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX8d::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caZVF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZVF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZVK; else goto caZVJ;
       caZVK: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caZVE_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZVJ: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caZVE() //  [R1]
         { info_tbl: [(caZVE,
                       label: block_caZVE_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZVE: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caZVF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.326130072 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { info_tbl: [(caZWg,
                       label: GHC.IO.FD.$fIODeviceFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZWg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZWk; else goto caZWl;
       caZWk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZWl: // global
           I64[Sp - 16] = block_caZWd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZWt; else goto caZWe;
       uaZWt: // global
           call _caZWd(R1) args: 0, res: 0, upd: 0;
       caZWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZWd() //  [R1]
         { info_tbl: [(caZWd,
                       label: block_caZWd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZWd: // global
           I64[Sp - 8] = block_caZWj_info;
           _saX8j::I64 = I64[R1 + 7];
           _saX8k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX8k::I64;
           I64[Sp + 8] = _saX8j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZWs; else goto caZWn;
       uaZWs: // global
           call _caZWj(R1) args: 0, res: 0, upd: 0;
       caZWn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZWj() //  [R1]
         { info_tbl: [(caZWj,
                       label: block_caZWj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZWj: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.333731829 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.33565883 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { info_tbl: [(caZWO,
                       label: GHC.IO.FD.$fIODeviceFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZWO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZWP; else goto caZWQ;
       caZWP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZWQ: // global
           (_caZWL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZWL::I64 == 0) goto caZWN; else goto caZWM;
       caZWN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZWM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZWL::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.340905445 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_saX8C_entry() //  [R1]
         { info_tbl: [(caZXk,
                       label: sat_saX8C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZXo; else goto caZXp;
       caZXo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZXp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caZXh_info;
           _saX8p::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX8p::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaZXt; else goto caZXi;
       uaZXt: // global
           call _caZXh(R1) args: 0, res: 0, upd: 0;
       caZXi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caZXh() //  [R1]
         { info_tbl: [(caZXh,
                       label: block_caZXh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZXs; else goto caZXr;
       caZXs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZXr: // global
           _saX8B::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8B::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { info_tbl: [(caZXx,
                       label: GHC.IO.FD.$w$cdup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZXy; else goto caZXz;
       caZXy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZXz: // global
           _saX8p::I64 = R3;
           (_saX8u::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _saX8v::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX8u::I64));
           if (_saX8v::I64 != (-1)) goto uaZXL; else goto caZXw;
       uaZXL: // global
           I64[Sp - 16] = _saX8p::I64;
           I64[Sp - 8] = _saX8v::I64;
           Sp = Sp - 16;
           call _caZXB() args: 0, res: 0, upd: 0;
       caZXw: // global
           I64[Sp - 16] = block_caZXb_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _saX8p::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZXB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXB: // global
           Hp = Hp + 24;
           _saX8v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZXG; else goto caZXF;
       caZXG: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caZXA_info;
           R1 = _saX8v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZXF: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8v::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caZXA() //  [R1]
         { info_tbl: [(caZXA,
                       label: block_caZXA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZXB() args: 0, res: 0, upd: 0;
     }
 },
 _caZXb() //  [R1]
         { info_tbl: [(caZXb,
                       label: block_caZXb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZXb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZXK; else goto caZXJ;
       caZXK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZXJ: // global
           I64[Hp - 24] = sat_saX8C_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.354197225 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { info_tbl: [(caZYn,
                       label: GHC.IO.FD.$fIODeviceFD3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZYn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZYo; else goto caZYp;
       caZYo: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZYp: // global
           I64[Sp - 8] = block_caZYk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZYt; else goto caZYl;
       uaZYt: // global
           call _caZYk(R1) args: 0, res: 0, upd: 0;
       caZYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZYk() //  [R1]
         { info_tbl: [(caZYk,
                       label: block_caZYk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZYk: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.360229245 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_saX8N_entry() //  [R1]
         { info_tbl: [(caZYO,
                       label: sat_saX8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZYO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZYS; else goto caZYT;
       caZYS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZYT: // global
           I64[Sp - 8] = block_caZYL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZYX; else goto caZYM;
       uaZYX: // global
           call _caZYL(R1) args: 0, res: 0, upd: 0;
       caZYM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZYL() //  [R1]
         { info_tbl: [(caZYL,
                       label: block_caZYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZYL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZYW; else goto caZYV;
       caZYW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZYV: // global
           _saX8L::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8L::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { info_tbl: [(caZZ3,
                       label: GHC.IO.FD.$fIODeviceFD6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZ3: // global
           _saX8I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caZZ4; else goto caZZ5;
       caZZ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZZ7; else goto caZZ6;
       caZZ7: // global
           HpAlloc = 24;
           goto caZZ4;
       caZZ4: // global
           R2 = _saX8I::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZZ6: // global
           I64[Hp - 16] = sat_saX8N_info;
           P64[Hp] = _saX8I::P64;
           I64[Sp - 8] = block_caZYY_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZYY() //  [R1]
         { info_tbl: [(caZYY,
                       label: block_caZYY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZYY: // global
           I64[Sp] = block_caZZ0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZZc; else goto caZZ1;
       uaZZc: // global
           call _caZZ0(R1) args: 0, res: 0, upd: 0;
       caZZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZZ0() //  [R1]
         { info_tbl: [(caZZ0,
                       label: block_caZZ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZ0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.372452855 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_saX90_entry() //  [R1]
         { info_tbl: [(caZZK,
                       label: sat_saX90_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZZO; else goto caZZP;
       caZZO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZZP: // global
           I64[Sp - 8] = block_caZZH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZZT; else goto caZZI;
       uaZZT: // global
           call _caZZH(R1) args: 0, res: 0, upd: 0;
       caZZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZZH() //  [R1]
         { info_tbl: [(caZZH,
                       label: block_caZZH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZZS; else goto caZZR;
       caZZS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZZR: // global
           _saX8Y::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8Y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX99_entry() //  [R1]
         { info_tbl: [(cb00d,
                       label: sat_saX99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb00d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb00e; else goto cb00f;
       cb00e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb00f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb005_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub00q; else goto cb006;
       ub00q: // global
           call _cb005(R1) args: 0, res: 0, upd: 0;
       cb006: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb005() //  [R1]
         { info_tbl: [(cb005,
                       label: block_cb005_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb005: // global
           _cb00c::P64 = R1 & 7;
           if (_cb00c::P64 == 3) goto cb00b; else goto ub00p;
       ub00p: // global
           if (_cb00c::P64 == 4) goto cb00b; else goto cb009;
       cb00b: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb009: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { info_tbl: [(cb00r,
                       label: GHC.IO.FD.$fIODeviceFD20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb00r: // global
           _saX8V::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb00s; else goto cb00t;
       cb00t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb00v; else goto cb00u;
       cb00v: // global
           HpAlloc = 24;
           goto cb00s;
       cb00s: // global
           R2 = _saX8V::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb00u: // global
           I64[Hp - 16] = sat_saX90_info;
           P64[Hp] = _saX8V::P64;
           I64[Sp - 8] = block_caZZU_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZZU() //  [R1]
         { info_tbl: [(caZZU,
                       label: block_caZZU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZU: // global
           I64[Sp] = block_caZZW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub00A; else goto caZZX;
       ub00A: // global
           call _caZZW(R1) args: 0, res: 0, upd: 0;
       caZZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZZW() //  [R1]
         { info_tbl: [(caZZW,
                       label: block_caZZW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb00z; else goto cb00y;
       cb00z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb00y: // global
           _saX95::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_saX99_info;
           P64[Hp] = _saX95::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.389067376 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { info_tbl: [(cb01f,
                       label: GHC.IO.FD.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb01f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb01g; else goto cb01h;
       cb01g: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb01h: // global
           I64[Sp - 8] = block_cb01c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub01n; else goto cb01d;
       ub01n: // global
           call _cb01c(R1) args: 0, res: 0, upd: 0;
       cb01d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb01c() //  [R1]
         { info_tbl: [(cb01c,
                       label: block_cb01c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb01c: // global
           (_saX9i::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.394621725 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { info_tbl: [(cb01C,
                       label: GHC.IO.FD.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb01C: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.397871084 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.399749962 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { info_tbl: [(cb01Q,
                       label: GHC.IO.FD.$fIODeviceFD23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb01Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb01R; else goto cb01S;
       cb01R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb01S: // global
           (_cb01N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb01N::I64 == 0) goto cb01P; else goto cb01O;
       cb01P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb01O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb01N::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.404153224 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_saX9t_entry() //  [R1]
         { info_tbl: [(cb02b,
                       label: sat_saX9t_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb02m; else goto cb02l;
       cb02m: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb02l: // global
           (_saX9q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9q::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { info_tbl: [(cb02p,
                       label: GHC.IO.FD.$wclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02p: // global
           _saX9j::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb02q; else goto cb02r;
       cb02r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb02t; else goto cb02s;
       cb02t: // global
           HpAlloc = 16;
           goto cb02q;
       cb02q: // global
           R2 = _saX9j::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb02s: // global
           I64[Hp - 8] = sat_saX9t_info;
           I64[Hp] = _saX9j::I64;
           I64[Sp - 8] = block_cb02n_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb02n() //  []
         { info_tbl: [(cb02n,
                       label: block_cb02n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02n: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.412691438 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { info_tbl: [(cb02R,
                       label: GHC.IO.FD.$fIODeviceFD26_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb02S; else goto cb02T;
       cb02S: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb02T: // global
           I64[Sp - 8] = block_cb02O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub02X; else goto cb02P;
       ub02X: // global
           call _cb02O(R1) args: 0, res: 0, upd: 0;
       cb02P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb02O() //  [R1]
         { info_tbl: [(cb02O,
                       label: block_cb02O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02O: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.419022947 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_saX9W_entry() //  [R1]
         { info_tbl: [(cb03o,
                       label: sat_saX9W_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb03o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb03z; else goto cb03y;
       cb03z: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb03y: // global
           (_saX9T::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9T::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { info_tbl: [(cb03D,
                       label: GHC.IO.FD.$w$cclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb03D: // global
           _saX9B::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb03E; else goto cb03F;
       cb03F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb03H; else goto cb03G;
       cb03H: // global
           HpAlloc = 16;
           goto cb03E;
       cb03E: // global
           R2 = _saX9B::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb03G: // global
           (_saX9G::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_saX9B::I64);
           (_saX9K::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX9K::I64 == 0) goto cb03C; else goto cb03B;
       cb03C: // global
           I64[Hp - 8] = sat_saX9W_info;
           I64[Hp] = _saX9B::I64;
           I64[Sp - 8] = block_cb03M_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       cb03B: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9B::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb03M() //  []
         { info_tbl: [(cb03M,
                       label: block_cb03M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb03M: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.42758787 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { info_tbl: [(cb04c,
                       label: GHC.IO.FD.$fIODeviceFD22_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb04c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb04d; else goto cb04e;
       cb04d: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb04e: // global
           I64[Sp - 8] = block_cb049_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub04i; else goto cb04a;
       ub04i: // global
           call _cb049(R1) args: 0, res: 0, upd: 0;
       cb04a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb049() //  [R1]
         { info_tbl: [(cb049,
                       label: block_cb049_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb049: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.433561025 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.435479191 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.43735331 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { info_tbl: [(cb04A,
                       label: GHC.IO.FD.mkFD6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb04A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb04B; else goto cb04C;
       cb04B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb04C: // global
           (_cb04x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb04x::I64 == 0) goto cb04z; else goto cb04y;
       cb04z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb04y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb04x::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.441185779 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.443179446 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { info_tbl: [(cb04R,
                       label: GHC.IO.FD.mkFD10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb04R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb04S; else goto cb04T;
       cb04S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb04T: // global
           (_cb04O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb04O::I64 == 0) goto cb04Q; else goto cb04P;
       cb04Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb04P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb04O::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.447042609 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.449043352 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { info_tbl: [(cb058,
                       label: GHC.IO.FD.mkFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb058: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb059; else goto cb05a;
       cb059: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05a: // global
           (_cb055::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb055::I64 == 0) goto cb057; else goto cb056;
       cb057: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb056: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb055::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.453100213 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.455809239 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { info_tbl: [(cb05p,
                       label: GHC.IO.FD.mkFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb05p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb05q; else goto cb05r;
       cb05q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05r: // global
           (_cb05m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb05m::I64 == 0) goto cb05o; else goto cb05n;
       cb05o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb05n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb05m::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.459585748 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.461623432 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { info_tbl: [(cb05G,
                       label: GHC.IO.FD.mkFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb05G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb05H; else goto cb05I;
       cb05H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05I: // global
           (_cb05D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb05D::I64 == 0) goto cb05F; else goto cb05E;
       cb05F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb05E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb05D::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.468493599 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_saXaj_entry() //  [R1]
         { info_tbl: [(cb06b,
                       label: sat_saXaj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb06b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb06c; else goto cb06d;
       cb06c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb06d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb068_info;
           _saXa8::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saXa8::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub06B; else goto cb069;
       ub06B: // global
           call _cb068(R1) args: 0, res: 0, upd: 0;
       cb069: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb068() //  [R1]
         { info_tbl: [(cb068,
                       label: block_cb068_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb068: // global
           I64[Sp] = block_cb06g_info;
           _saXah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saXah::I64;
           if (R1 & 7 != 0) goto ub06A; else goto cb06i;
       ub06A: // global
           call _cb06g(R1) args: 0, res: 0, upd: 0;
       cb06i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb06g() //  [R1]
         { info_tbl: [(cb06g,
                       label: block_cb06g_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb06g: // global
           _saXah::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb06o; else goto cb06v;
       cb06o: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb06y; else goto cb06q;
       cb06q: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb06v: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb06y; else goto cb06x;
       cb06y: // global
           HpAlloc = 24;
           R1 = _saXai::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb06x: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saXaG_entry() //  [R1]
         { info_tbl: [(cb07B,
                       label: sat_saXaG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07B: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb07C; else goto cb07D;
       cb07C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb07D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb07u_info;
           _saXan::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saXan::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub07Q; else goto cb07v;
       ub07Q: // global
           call _cb07u(R1) args: 0, res: 0, upd: 0;
       cb07v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb07u() //  [R1]
         { info_tbl: [(cb07u,
                       label: block_cb07u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07u: // global
           _saXan::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb07y; else goto cb07z;
       cb07y: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb07P; else goto cb07I;
       cb07I: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb07z: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb07P; else goto cb07O;
       cb07P: // global
           HpAlloc = 24;
           R1 = _saXaF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb07O: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb07Y,
                       label: GHC.IO.FD.$wmkFD_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07Y: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb07Z; else goto cb080;
       cb07Z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb080: // global
           I64[Sp - 32] = block_cb07R_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub09v; else goto cb07S;
       ub09v: // global
           call _cb07R(R1) args: 0, res: 0, upd: 0;
       cb07S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb07R() //  [R1]
         { info_tbl: [(cb07R,
                       label: block_cb07R_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07R: // global
           if (R1 & 7 == 1) goto cb07V; else goto cb07W;
       cb07V: // global
           I64[Sp] = block_cb08T_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       cb07W: // global
           I64[Sp] = block_cb095_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub09u; else goto cb097;
       ub09u: // global
           call _cb095(R1) args: 0, res: 0, upd: 0;
       cb097: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb08T() //  [R1]
         { info_tbl: [(cb08T,
                       label: block_cb08T_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb08T: // global
           I64[Sp] = block_cb08V_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub09x; else goto cb08Y;
       ub09x: // global
           call _cb08V(R1) args: 0, res: 0, upd: 0;
       cb08Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb08V() //  [R1]
         { info_tbl: [(cb08V,
                       label: block_cb08V_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb08V: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _cb095() //  [R1]
         { info_tbl: [(cb095,
                       label: block_cb095_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb095: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 _saXaa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saXaa: // global
           I64[Sp - 8] = block_cb05Z_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub09A; else goto cb060;
       ub09A: // global
           call _cb05Z(R1) args: 0, res: 0, upd: 0;
       cb060: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb05Z() //  [R1]
         { info_tbl: [(cb05Z,
                       label: block_cb05Z_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb05Z: // global
           _cb09i::P64 = R1 & 7;
           if (_cb09i::P64 == 1) goto cb08a; else goto ub09k;
       cb08a: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ub09k: // global
           _saXa5::P64 = P64[Sp + 32];
           if (_cb09i::P64 == 3) goto cb08c; else goto cb084;
       cb08c: // global
           I64[Sp] = block_cb06F_info;
           R1 = _saXa5::P64;
           if (R1 & 7 != 0) goto ub09p; else goto cb06G;
       ub09p: // global
           call _cb06F(R1) args: 0, res: 0, upd: 0;
       cb06G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb084: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb087; else goto cb086;
       cb087: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb086: // global
           I64[Hp - 48] = sat_saXaj_info;
           P64[Hp - 32] = _saXa5::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb06F() //  [R1]
         { info_tbl: [(cb06F,
                       label: block_cb06F_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb06F: // global
           _saXad::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb06K_info;
           _saXan::I64 = I64[R1 + 7];
           R1 = _saXad::P64;
           I64[Sp + 32] = _saXan::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub09q; else goto cb06L;
       ub09q: // global
           call _cb06K(R1) args: 0, res: 0, upd: 0;
       cb06L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb06K() //  [R1]
         { info_tbl: [(cb06K,
                       label: block_cb06K_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb06K: // global
           _saXae::P64 = P64[Sp + 8];
           _saXap::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXap::I64, 0)) goto cb08P; else goto cb08Q;
       cb08P: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       cb08Q: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       saXar: // global
           I64[Sp + 8] = block_cb06X_info;
           R1 = _saXae::P64;
           I64[Sp + 16] = _saXas::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub09r; else goto cb06Y;
       ub09r: // global
           call _cb06X(R1) args: 0, res: 0, upd: 0;
       cb06Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb06X() //  [R1]
         { info_tbl: [(cb06X,
                       label: block_cb06X_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb06X: // global
           _saXa6::P64 = P64[Sp + 24];
           _saXau::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXau::I64, 0)) goto cb08K; else goto cb08L;
       cb08K: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       cb08L: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       saXaw: // global
           I64[Sp] = block_cb08h_info;
           R1 = _saXa6::P64;
           I64[Sp + 24] = _saXax::I64;
           if (R1 & 7 != 0) goto ub09s; else goto cb08w;
       ub09s: // global
           call _cb08h(R1) args: 0, res: 0, upd: 0;
       cb08w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb08h() //  [R1]
         { info_tbl: [(cb08h,
                       label: block_cb08h_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb08h: // global
           _saXan::I64 = I64[Sp + 16];
           _saXas::I64 = I64[Sp + 8];
           _saXax::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb08G; else goto cb08C;
       cb08G: // global
           _saXaz::I64 = 0;
           goto saXay;
       cb08C: // global
           _saXaz::I64 = 1;
           goto saXay;
       saXay: // global
           (_saXaD::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_saXan::I64, _saXas::I64, _saXax::I64, _saXaz::I64);
           _saXaE::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXaD::I64));
           if (_saXaE::I64 != (-1)) goto ub09n; else goto cb08s;
       ub09n: // global
           I64[Sp + 24] = _saXaE::I64;
           Sp = Sp + 16;
           call _cb07o() args: 0, res: 0, upd: 0;
       cb08s: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb07o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb08p; else goto cb08o;
       cb08p: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb07n_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb08o: // global
           I64[Hp - 48] = sat_saXaG_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb07n() //  [R1]
         { info_tbl: [(cb07n,
                       label: block_cb07n_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb07n: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb07o() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.505980505 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { info_tbl: [(cb0bd,
                       label: GHC.IO.FD.mkFD1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bd: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.509339726 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0bo,
                       label: GHC.IO.FD.mkFD_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.516878816 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_saXbr_entry() //  [R1]
         { info_tbl: [(cb0c3,
                       label: sat_saXbr_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0c3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0c6; else goto cb0c7;
       cb0c6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0c7: // global
           I64[Sp - 8] = block_cb0bZ_info;
           Sp = Sp - 8;
           _cb0bW::I64 = I64[R1 + 7];
           _cb0bX::I64 = I64[R1 + 15];
           _ub0cd::P64 = CurrentTSO;
           I64[I64[_ub0cd::P64 + 24] + 16] = Sp;
           _ub0ce::I64 = CurrentNursery;
           P64[_ub0ce::I64 + 8] = Hp + 8;
           I64[_ub0cd::P64 + 104] = I64[_ub0cd::P64 + 104] - ((Hp + 8) - I64[_ub0ce::I64]);
           (_ub0cb::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saXbo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_cb0bW::I64, _cb0bX::I64, 438);
           (_ub0cc::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0cb::I64);
           BaseReg = _ub0cc::I64;
           _ub0cf::P64 = CurrentTSO;
           _ub0cg::P64 = I64[_ub0cf::P64 + 24];
           Sp = I64[_ub0cg::P64 + 16];
           SpLim = _ub0cg::P64 + 192;
           HpAlloc = 0;
           _ub0ch::I64 = CurrentNursery;
           _ub0ci::I64 = I64[_ub0ch::I64 + 8];
           Hp = _ub0ci::I64 - 8;
           _ub0cj::I64 = I64[_ub0ch::I64];
           HpLim = _ub0cj::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0ch::I64 + 48]) << 12) - 1);
           I64[_ub0cf::P64 + 104] = I64[_ub0cf::P64 + 104] + (_ub0ci::I64 - _ub0cj::I64);
           R1 = _saXbo::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0bZ() //  [R1]
         { info_tbl: [(cb0bZ,
                       label: block_cb0bZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0ca; else goto cb0c9;
       cb0ca: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0c9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbI_entry() //  [R1]
         { info_tbl: [(cb0cF,
                       label: sat_saXbI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0cF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0cG; else goto cb0cH;
       cb0cG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0cH: // global
           I64[Sp - 24] = block_cb0cC_info;
           _saXbz::P64 = P64[R1 + 15];
           _saXbA::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _saXbz::P64;
           P64[Sp - 8] = _saXbA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0cN; else goto cb0cD;
       ub0cN: // global
           call _cb0cC(R1) args: 0, res: 0, upd: 0;
       cb0cD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0cC() //  [R1]
         { info_tbl: [(cb0cC,
                       label: block_cb0cC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0cC: // global
           _saXbz::P64 = P64[Sp + 8];
           _saXbA::P64 = P64[Sp + 16];
           (_saXbH::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _saXbA::P64;
           R2 = _saXbz::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbJ_entry() //  [R1, R2]
         { info_tbl: [(cb0cO,
                       label: sat_saXbJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0cO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0cP; else goto cb0cQ;
       cb0cP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0cQ: // global
           I64[Sp - 16] = block_cb0cs_info;
           _saXbu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _saXbu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0cU; else goto cb0ct;
       ub0cU: // global
           call _cb0cs(R1) args: 0, res: 0, upd: 0;
       cb0ct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0cs() //  [R1]
         { info_tbl: [(cb0cs,
                       label: block_cb0cs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0cs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb0cT; else goto cb0cS;
       cb0cT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0cS: // global
           _saXbz::P64 = P64[R1 + 7];
           _saXbA::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_saXbI_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _saXbz::P64;
           P64[Hp] = _saXbA::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saXbw_entry() //  [R1]
         { info_tbl: [(cb0d0,
                       label: sat_saXbw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0d0: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub0hD_srtd" {
     ub0hD_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_saXcZ_entry() //  [R1, R2]
         { info_tbl: [(cb0d3,
                       label: sat_saXcZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0d3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0d4; else goto cb0d5;
       cb0d4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0d5: // global
           I64[Sp - 24] = block_cb0bG_info;
           _saXb8::P64 = P64[R1 + 6];
           _saXb9::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _saXb8::P64;
           P64[Sp - 8] = _saXb9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0h6; else goto cb0bH;
       ub0h6: // global
           call _cb0bG(R1) args: 0, res: 0, upd: 0;
       cb0bH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hE_srtd" {
     ub0hE_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0bG() //  [R1]
         { info_tbl: [(cb0bG,
                       label: block_cb0bG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bG: // global
           I64[Sp - 8] = block_cb0d6_info;
           _saXbh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saXbh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0h4; else goto cb0ec;
       ub0h4: // global
           call _cb0d6(R1) args: 0, res: 0, upd: 0;
       cb0ec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hF_srtd" {
     ub0hF_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0d6() //  [R1]
         { info_tbl: [(cb0d6,
                       label: block_cb0d6_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0d6: // global
           _saXb8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cb0ej; else goto cb0f5;
       cb0ej: // global
           I64[Sp] = block_cb0eg_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto ub0h7; else goto cb0ek;
       ub0h7: // global
           call _cb0eg(R1) args: 0, res: 0, upd: 0;
       cb0ek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0f5: // global
           I64[Sp] = block_cb0f3_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto ub0h8; else goto cb0f6;
       ub0h8: // global
           call _cb0f3(R1) args: 0, res: 0, upd: 0;
       cb0f6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hG_srtd" {
     ub0hG_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0eg() //  [R1]
         { info_tbl: [(cb0eg,
                       label: block_cb0eg_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0eg: // global
           _cb0gJ::P64 = R1 & 7;
           if (_cb0gJ::P64 < 3) goto ub0gN; else goto ub0gO;
       ub0gN: // global
           if (_cb0gJ::P64 < 2) goto cb0er; else goto cb0eB;
       cb0er: // global
           I64[Sp] = block_cb0eo_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub0hh; else goto cb0es;
       ub0hh: // global
           call _cb0eo(R1) args: 0, res: 0, upd: 0;
       cb0es: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0eB: // global
           I64[Sp] = block_cb0ez_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub0hi; else goto cb0eC;
       ub0hi: // global
           call _cb0ez(R1) args: 0, res: 0, upd: 0;
       cb0eC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0gO: // global
           if (_cb0gJ::P64 < 4) goto cb0eL; else goto cb0eV;
       cb0eL: // global
           I64[Sp] = block_cb0eJ_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub0hj; else goto cb0eM;
       ub0hj: // global
           call _cb0eJ(R1) args: 0, res: 0, upd: 0;
       cb0eM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0eV: // global
           I64[Sp] = block_cb0eT_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub0hk; else goto cb0eW;
       ub0hk: // global
           call _cb0eT(R1) args: 0, res: 0, upd: 0;
       cb0eW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hH_srtd" {
     ub0hH_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eo() //  [R1]
         { info_tbl: [(cb0eo,
                       label: block_cb0eo_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0eo: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hI_srtd" {
     ub0hI_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0ez() //  [R1]
         { info_tbl: [(cb0ez,
                       label: block_cb0ez_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0ez: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hJ_srtd" {
     ub0hJ_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eJ() //  [R1]
         { info_tbl: [(cb0eJ,
                       label: block_cb0eJ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0eJ: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hK_srtd" {
     ub0hK_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eT() //  [R1]
         { info_tbl: [(cb0eT,
                       label: block_cb0eT_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0eT: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hL_srtd" {
     ub0hL_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0f3() //  [R1]
         { info_tbl: [(cb0f3,
                       label: block_cb0f3_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0f3: // global
           _cb0fO::P64 = R1 & 7;
           if (_cb0fO::P64 < 3) goto ub0gP; else goto ub0gQ;
       ub0gP: // global
           if (_cb0fO::P64 < 2) goto cb0fd; else goto cb0fn;
       cb0fd: // global
           I64[Sp] = block_cb0fa_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub0hp; else goto cb0fe;
       ub0hp: // global
           call _cb0fa(R1) args: 0, res: 0, upd: 0;
       cb0fe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0fn: // global
           I64[Sp] = block_cb0fl_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub0hq; else goto cb0fo;
       ub0hq: // global
           call _cb0fl(R1) args: 0, res: 0, upd: 0;
       cb0fo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0gQ: // global
           if (_cb0fO::P64 < 4) goto cb0fx; else goto cb0fH;
       cb0fx: // global
           I64[Sp] = block_cb0fv_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub0hr; else goto cb0fy;
       ub0hr: // global
           call _cb0fv(R1) args: 0, res: 0, upd: 0;
       cb0fy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0fH: // global
           I64[Sp] = block_cb0fF_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub0hs; else goto cb0fI;
       ub0hs: // global
           call _cb0fF(R1) args: 0, res: 0, upd: 0;
       cb0fI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hM_srtd" {
     ub0hM_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fa() //  [R1]
         { info_tbl: [(cb0fa,
                       label: block_cb0fa_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0fa: // global
           _saXci::I64 = I64[R1 + 7];
           (_saXcm::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXci::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcm::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hN_srtd" {
     ub0hN_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fl() //  [R1]
         { info_tbl: [(cb0fl,
                       label: block_cb0fl_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0fl: // global
           _saXct::I64 = I64[R1 + 7];
           (_saXcx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXct::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcx::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hO_srtd" {
     ub0hO_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fv() //  [R1]
         { info_tbl: [(cb0fv,
                       label: block_cb0fv_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0fv: // global
           _saXcE::I64 = I64[R1 + 7];
           (_saXcI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcE::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcI::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hP_srtd" {
     ub0hP_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fF() //  [R1]
         { info_tbl: [(cb0fF,
                       label: block_cb0fF_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0fF: // global
           _saXcP::I64 = I64[R1 + 7];
           (_saXcT::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcP::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcT::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 _cb0bO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bO: // global
           Hp = Hp + 24;
           _saXbj::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb0dd; else goto cb0dc;
       cb0dd: // global
           HpAlloc = 24;
           I64[Sp] = block_cb0bN_info;
           R1 = _saXbj::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0dc: // global
           I64[Hp - 16] = sat_saXbr_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saXbj::I64;
           I64[Sp + 8] = block_cb0cl_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hQ_srtd" {
     ub0hQ_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0bN() //  [R1]
         { info_tbl: [(cb0bN,
                       label: block_cb0bN_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bN: // global
           I64[Sp] = R1;
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub0hR_srtd" {
     ub0hR_srtd:
         const SaXeV_srt+352;
         const 39;
         const 274877906945;
 },
 _cb0cl() //  [R1]
         { info_tbl: [(cb0cl,
                       label: block_cb0cl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0cl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb0dg; else goto cb0df;
       cb0dg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0df: // global
           I64[Hp - 40] = sat_saXbJ_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saXbw_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cb0d8_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0d8() //  [R1]
         { info_tbl: [(cb0d8,
                       label: block_cb0d8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0d8: // global
           I64[Sp] = block_cb0da_info;
           _saXbM::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _saXbM::P64;
           if (R1 & 7 != 0) goto ub0h9; else goto cb0di;
       ub0h9: // global
           call _cb0da(R1) args: 0, res: 0, upd: 0;
       cb0di: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0da() //  [R1]
         { info_tbl: [(cb0da,
                       label: block_cb0da_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0da: // global
           I64[Sp - 8] = block_cb0dm_info;
           _saXbO::P64 = P64[R1 + 7];
           _saXbP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _saXbP::P64;
           P64[Sp + 8] = _saXbO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0ha; else goto cb0do;
       ub0ha: // global
           call _cb0dm(R1) args: 0, res: 0, upd: 0;
       cb0do: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0dm() //  [R1]
         { info_tbl: [(cb0dm,
                       label: block_cb0dm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0dm: // global
           if (R1 & 7 == 2) goto cb0dz; else goto ub0h0;
       cb0dz: // global
           _saXbP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb0dx_info;
           R1 = _saXbP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub0hb; else goto cb0dA;
       ub0hb: // global
           call _cb0dx(R1) args: 0, res: 0, upd: 0;
       cb0dA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0h0: // global
           Sp = Sp + 24;
           call _cb0dG() args: 0, res: 0, upd: 0;
     }
 },
 _cb0dx() //  [R1]
         { info_tbl: [(cb0dx,
                       label: block_cb0dx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0dx: // global
           if (R1 & 7 == 3) goto cb0dL; else goto ub0h1;
       cb0dL: // global
           I64[Sp + 16] = block_cb0dJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub0hd; else goto cb0dM;
       ub0hd: // global
           call _cb0dJ(R1) args: 0, res: 0, upd: 0;
       cb0dM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0h1: // global
           Sp = Sp + 16;
           call _cb0dG() args: 0, res: 0, upd: 0;
     }
 },
 _cb0dJ() //  [R1]
         { info_tbl: [(cb0dJ,
                       label: block_cb0dJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0dJ: // global
           (_saXbY::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _saXbZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXbY::I64));
           if (_saXbZ::I64 == 0) goto ub0h2; else goto cb0dZ;
       ub0h2: // global
           I64[Sp - 8] = _saXbZ::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _cb0e5() args: 0, res: 0, upd: 0;
       cb0dZ: // global
           (_saXc3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saXc3::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb0e5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0e5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0eb; else goto cb0ea;
       cb0eb: // global
           HpAlloc = 24;
           _saXbZ::I64 = I64[Sp];
           I64[Sp] = block_cb0e4_info;
           R1 = _saXbZ::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0ea: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb0e4() //  [R1]
         { info_tbl: [(cb0e4,
                       label: block_cb0e4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0e4: // global
           I64[Sp] = R1;
           call _cb0e5() args: 0, res: 0, upd: 0;
     }
 },
 _cb0dG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0dG: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub0hS_srtd" {
     ub0hS_srtd:
         const SaXeV_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb0hx,
                       label: GHC.IO.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0hx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0hy; else goto cb0hz;
       cb0hy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0hz: // global
           I64[Sp - 32] = block_cb0bz_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hT_srtd" {
     ub0hT_srtd:
         const SaXeV_srt+264;
         const 58;
         const 279788325873647617;
 },
 _cb0bz() //  [R1]
         { info_tbl: [(cb0bz,
                       label: block_cb0bz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0bz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0hC; else goto cb0hB;
       cb0hC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0hB: // global
           I64[Hp - 16] = sat_saXcZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.593799354 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cb0l1,
                       label: GHC.IO.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0l1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.598920785 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0l9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saXdj_entry() //  [R1]
         { info_tbl: [(cb0lw,
                       label: sat_saXdj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0lw: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb0lD; else goto cb0lE;
       cb0lD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0lE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb0lt_info;
           _saXd3::P64 = P64[R1 + 16];
           _saXd4::P64 = P64[R1 + 24];
           _saXd2::I64 = I64[R1 + 40];
           _saXd5::I64 = I64[R1 + 48];
           _saXd6::I64 = I64[R1 + 56];
           _saXd7::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saXd2::I64;
           P64[Sp - 56] = _saXd3::P64;
           P64[Sp - 48] = _saXd4::P64;
           I64[Sp - 40] = _saXd5::I64;
           I64[Sp - 32] = _saXd6::I64;
           I64[Sp - 24] = _saXd7::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub0lI; else goto cb0lu;
       ub0lI: // global
           call _cb0lt(R1) args: 0, res: 0, upd: 0;
       cb0lu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb0lt() //  [R1]
         { info_tbl: [(cb0lt,
                       label: block_cb0lt_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0lt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb0lH; else goto cb0lG;
       cb0lH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0lG: // global
           _saXdi::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _saXdi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0lJ,
                       label: GHC.IO.FD.$w$cfillReadBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0lJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb0lL; else goto cb0lM;
       cb0lL: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb0lM: // global
           I64[Sp - 32] = block_cb0lm_info;
           _saXd4::P64 = R6;
           R6 = 0;
           _saXd3::P64 = R5;
           _saXd7::I64 = I64[Sp + 16];
           R5 = R4 + _saXd7::I64;
           _saXd2::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _saXd7::I64;
           I64[Sp - 24] = _saXd2::I64;
           P64[Sp - 16] = _saXd3::P64;
           P64[Sp - 8] = _saXd4::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb0lm() //  [R1]
         { info_tbl: [(cb0lm,
                       label: block_cb0lm_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0lm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb0lP; else goto cb0lO;
       cb0lP: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0lO: // global
           _saXd2::I64 = I64[Sp + 8];
           _saXd3::P64 = P64[Sp + 16];
           _saXd4::P64 = P64[Sp + 24];
           _saXd5::I64 = I64[Sp + 32];
           _saXd6::I64 = I64[Sp + 40];
           _saXd7::I64 = I64[Sp + 48];
           call MO_Touch(_saXd3::P64);
           I64[Hp - 88] = sat_saXdj_info;
           P64[Hp - 72] = _saXd3::P64;
           P64[Hp - 64] = _saXd4::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saXd2::I64;
           I64[Hp - 40] = _saXd5::I64;
           I64[Hp - 32] = _saXd6::I64;
           I64[Hp - 24] = _saXd7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.611683423 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { info_tbl: [(cb0ms,
                       label: GHC.IO.FD.$fBufferedIOFD11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0ms: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0mw; else goto cb0mx;
       cb0mw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0mx: // global
           I64[Sp - 16] = block_cb0mp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0mF; else goto cb0mq;
       ub0mF: // global
           call _cb0mp(R1) args: 0, res: 0, upd: 0;
       cb0mq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0mp() //  [R1]
         { info_tbl: [(cb0mp,
                       label: block_cb0mp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0mp: // global
           I64[Sp - 8] = block_cb0mv_info;
           _saXdp::I64 = I64[R1 + 7];
           _saXdq::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saXdq::I64;
           I64[Sp + 8] = _saXdp::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0mE; else goto cb0mz;
       ub0mE: // global
           call _cb0mv(R1) args: 0, res: 0, upd: 0;
       cb0mz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0mv() //  [R1]
         { info_tbl: [(cb0mv,
                       label: block_cb0mv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0mv: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.62030565 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_saXdI_entry() //  [R1]
         { info_tbl: [(cb0n7,
                       label: sat_saXdI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0n7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0nb; else goto cb0nc;
       cb0nb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0nc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0n4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0ng; else goto cb0n5;
       ub0ng: // global
           call _cb0n4(R1) args: 0, res: 0, upd: 0;
       cb0n5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb0n4() //  [R1]
         { info_tbl: [(cb0n4,
                       label: block_cb0n4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0n4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb0nf; else goto cb0ne;
       cb0nf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0ne: // global
           _saXdD::P64 = P64[R1 + 7];
           _saXdC::I64 = I64[R1 + 23];
           _saXdF::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saXdD::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _saXdC::I64;
           I64[Hp - 16] = _saXdF::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { info_tbl: [(cb0nh,
                       label: GHC.IO.FD.$fBufferedIOFD6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0nh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0nl; else goto cb0nk;
       cb0nl: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0nk: // global
           I64[Hp - 16] = sat_saXdI_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.628712128 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.630850054 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { info_tbl: [(cb0nG,
                       label: GHC.IO.FD.FD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0nG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0nK; else goto cb0nJ;
       cb0nK: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0nJ: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.635025356 UTC

[GHC.IO.FD.FD_con_entry() //  [R1]
         { info_tbl: [(cb0nQ,
                       label: GHC.IO.FD.FD_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0nQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:56.638215774 UTC

[section ""relreadonly" . SaXeV_srt" {
     SaXeV_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.328244616 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:00.329833884 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { info_tbl: [(cb0Gz,
                       label: GHC.IO.FD.$WFD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Gz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0GI; else goto cb0GJ;
       cb0GI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0GJ: // global
           I64[Sp - 16] = block_cb0Gw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0GP; else goto cb0Gx;
       ub0GP: // global
           call _cb0Gw(R1) args: 0, res: 0, upd: 0;
       cb0Gx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Gw() //  [R1]
         { info_tbl: [(cb0Gw,
                       label: block_cb0Gw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Gw: // global
           I64[Sp] = block_cb0GC_info;
           _sb0o0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb0o0::I64;
           if (R1 & 7 != 0) goto ub0GO; else goto cb0GD;
       ub0GO: // global
           call _cb0GC(R1) args: 0, res: 0, upd: 0;
       cb0GD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0GC() //  [R1]
         { info_tbl: [(cb0GC,
                       label: block_cb0GC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0GC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0GN; else goto cb0GM;
       cb0GN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0GM: // global
           _sb0o2::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sb0o2::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.337751482 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { info_tbl: [(cb0Hh,
                       label: GHC.IO.FD.$fBufferedIOFD5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Hh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb0Hi; else goto ub0HR;
       cb0Hi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ub0HR: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cb0H9() args: 0, res: 0, upd: 0;
     }
 },
 _cb0H9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0H9: // global
           I64[Sp - 8] = block_cb0Hc_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Hc() //  [R1]
         { info_tbl: [(cb0Hc,
                       label: block_cb0Hc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Hc: // global
           I64[Sp - 8] = block_cb0He_info;
           _sb0o9::P64 = R1;
           R1 = R1;
           P64[Sp] = _sb0o9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0HT; else goto cb0Hf;
       ub0HT: // global
           call _cb0He(R1) args: 0, res: 0, upd: 0;
       cb0Hf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0He() //  [R1]
         { info_tbl: [(cb0He,
                       label: block_cb0He_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0He: // global
           if (I64[R1 + 7] == (-1)) goto cb0HP; else goto cb0Hq;
       cb0HP: // global
           _sb0o3::P64 = P64[Sp + 16];
           _sb0o4::P64 = P64[Sp + 24];
           _sb0o5::P64 = P64[Sp + 32];
           (_sb0og::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _sb0oh::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0og::I64));
           if (_sb0oh::I64 != 4) goto ub0HQ; else goto cb0HF;
       ub0HQ: // global
           if (_sb0oh::I64 != 11) goto cb0Hz; else goto cb0HL;
       cb0Hz: // global
           R2 = _sb0o3::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       cb0HL: // global
           R1 = _sb0o5::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cb0HF: // global
           P64[Sp + 16] = _sb0o3::P64;
           P64[Sp + 24] = _sb0o4::P64;
           P64[Sp + 32] = _sb0o5::P64;
           Sp = Sp + 16;
           call _cb0H9() args: 0, res: 0, upd: 0;
       cb0Hq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.348227683 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.35035176 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { info_tbl: [(cb0Il,
                       label: lvl1_raWUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Il: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0Im; else goto cb0In;
       cb0Im: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0In: // global
           (_cb0Ii::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0Ii::I64 == 0) goto cb0Ik; else goto cb0Ij;
       cb0Ik: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0Ij: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0Ii::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.354572569 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.356385937 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { info_tbl: [(cb0ID,
                       label: GHC.IO.FD.$fBufferedIOFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0ID: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0IE; else goto cb0IF;
       cb0IE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0IF: // global
           (_cb0IA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0IA::I64 == 0) goto cb0IC; else goto cb0IB;
       cb0IC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0IB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0IA::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.360243686 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.36208908 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { info_tbl: [(cb0IT,
                       label: GHC.IO.FD.$fBufferedIOFD3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0IT: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.366079897 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.367754 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.370998552 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0J4: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0oI_entry() //  [R1]
         { info_tbl: [(cb0Jj,
                       label: sat_sb0oI_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Jj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Jt; else goto cb0Js;
       cb0Jt: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Js: // global
           (_sb0oG::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0oG::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0oV_entry() //  [R1]
         { info_tbl: [(cb0JN,
                       label: sat_sb0oV_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0JN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0JW; else goto cb0JX;
       cb0JW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0JX: // global
           I64[Sp - 8] = block_cb0JT_info;
           Sp = Sp - 8;
           _cb0JQ::I64 = I64[R1 + 7];
           _cb0JR::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0JS::I64 = I64[R1 + 31];
           _ub0K3::P64 = CurrentTSO;
           I64[I64[_ub0K3::P64 + 24] + 16] = Sp;
           _ub0K4::I64 = CurrentNursery;
           P64[_ub0K4::I64 + 8] = Hp + 8;
           I64[_ub0K3::P64 + 104] = I64[_ub0K3::P64 + 104] - ((Hp + 8) - I64[_ub0K4::I64]);
           (_ub0K1::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0oT::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_cb0JQ::I64, _cb0JR::I64, _cb0JS::I64);
           (_ub0K2::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0K1::I64);
           BaseReg = _ub0K2::I64;
           _ub0K5::P64 = CurrentTSO;
           _ub0K6::P64 = I64[_ub0K5::P64 + 24];
           Sp = I64[_ub0K6::P64 + 16];
           SpLim = _ub0K6::P64 + 192;
           HpAlloc = 0;
           _ub0K7::I64 = CurrentNursery;
           _ub0K8::I64 = I64[_ub0K7::I64 + 8];
           Hp = _ub0K8::I64 - 8;
           _ub0K9::I64 = I64[_ub0K7::I64];
           HpLim = _ub0K9::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0K7::I64 + 48]) << 12) - 1);
           I64[_ub0K5::P64 + 104] = I64[_ub0K5::P64 + 104] + (_ub0K8::I64 - _ub0K9::I64);
           R1 = _sb0oT::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0JT() //  [R1]
         { info_tbl: [(cb0JT,
                       label: block_cb0JT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0JT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0K0; else goto cb0JZ;
       cb0K0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0JZ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cb0Ke,
                       label: GHC.IO.FD.$wreadRawBufferPtrNoBlock_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Ke: // global
           _sb0on::I64 = R6;
           _sb0om::I64 = R5;
           _sb0ol::I64 = R4;
           _sb0ok::I64 = R3;
           _sb0oj::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0Kf; else goto cb0Kg;
       cb0Kg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Ki; else goto cb0Kh;
       cb0Ki: // global
           HpAlloc = 40;
           goto cb0Kf;
       cb0Kf: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _sb0oj::P64;
           I64[Sp - 32] = _sb0ok::I64;
           I64[Sp - 24] = _sb0ol::I64;
           I64[Sp - 16] = _sb0om::I64;
           I64[Sp - 8] = _sb0on::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0Kh: // global
           if (_sb0ol::I64 == 0) goto cb0Kd; else goto cb0Kc;
       cb0Kd: // global
           (_sb0oM::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0ok::I64, 0, 0, 0);
           Hp = Hp - 40;
           _sb0oN::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0oM::I64));
           if (_sb0oN::I64 != 0) goto ub0KS; else goto cb0KM;
       ub0KS: // global
           P64[Sp - 40] = _sb0oj::P64;
           I64[Sp - 32] = _sb0ok::I64;
           I64[Sp - 24] = _sb0om::I64;
           I64[Sp - 16] = _sb0on::I64;
           I64[Sp - 8] = _sb0oN::I64;
           Sp = Sp - 40;
           call _cb0JE() args: 0, res: 0, upd: 0;
       cb0KM: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0Kc: // global
           I64[Hp - 32] = sat_sb0oI_info;
           I64[Hp - 24] = _sb0ok::I64;
           I64[Hp - 16] = _sb0om::I64;
           I64[Hp - 8] = _sb0on::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0oj::P64;
           Sp = Sp - 8;
           call _sb0oq() args: 0, res: 0, upd: 0;
     }
 },
 _cb0JE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0JE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0KJ; else goto cb0KI;
       cb0KJ: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_cb0JD_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0KI: // global
           I64[Hp - 32] = sat_sb0oV_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _sb0oq() args: 0, res: 0, upd: 0;
     }
 },
 _cb0JD() //  [R1]
         { info_tbl: [(cb0JD,
                       label: block_cb0JD_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0JD: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb0JE() args: 0, res: 0, upd: 0;
     }
 },
 _sb0oq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb0oq: // global
           _sb0oj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb0Km_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _sb0oj::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Km() //  [R1]
         { info_tbl: [(cb0Km,
                       label: block_cb0Km_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Km: // global
           I64[Sp] = block_cb0Ko_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0KZ; else goto cb0Kr;
       ub0KZ: // global
           call _cb0Ko(R1) args: 0, res: 0, upd: 0;
       cb0Kr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Ko() //  [R1]
         { info_tbl: [(cb0Ko,
                       label: block_cb0Ko_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Ko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Kx; else goto cb0Kw;
       cb0Kx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Kw: // global
           _sb0oy::I64 = I64[R1 + 7];
           if (_sb0oy::I64 != (-1)) goto ub0KQ; else goto cb0KD;
       ub0KQ: // global
           if (_sb0oy::I64 != 0) goto cb0KC; else goto cb0KE;
       cb0KC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0oy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0KE: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0KD: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.39422207 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0Mk,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Mk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb0My; else goto cb0Mz;
       cb0My: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0Mz: // global
           I64[Sp - 40] = block_cb0Mh_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub0MJ; else goto cb0Mi;
       ub0MJ: // global
           call _cb0Mh(R1) args: 0, res: 0, upd: 0;
       cb0Mi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Mh() //  [R1]
         { info_tbl: [(cb0Mh,
                       label: block_cb0Mh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Mh: // global
           I64[Sp - 8] = block_cb0Mn_info;
           _sb0p3::I64 = I64[R1 + 7];
           _sb0p4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0p4::I64;
           I64[Sp + 16] = _sb0p3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0MI; else goto cb0Mo;
       ub0MI: // global
           call _cb0Mn(R1) args: 0, res: 0, upd: 0;
       cb0Mo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Mn() //  [R1]
         { info_tbl: [(cb0Mn,
                       label: block_cb0Mn_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Mn: // global
           I64[Sp] = block_cb0Ms_info;
           _sb0p6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0p6::I64;
           if (R1 & 7 != 0) goto ub0MK; else goto cb0Mt;
       ub0MK: // global
           call _cb0Ms(R1) args: 0, res: 0, upd: 0;
       cb0Mt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Ms() //  [R1]
         { info_tbl: [(cb0Ms,
                       label: block_cb0Ms_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Ms: // global
           I64[Sp] = block_cb0Mx_info;
           _sb0p8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0p8::I64;
           if (R1 & 7 != 0) goto ub0ML; else goto cb0MD;
       ub0ML: // global
           call _cb0Mx(R1) args: 0, res: 0, upd: 0;
       cb0MD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Mx() //  [R1]
         { info_tbl: [(cb0Mx,
                       label: block_cb0Mx_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Mx: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.406260639 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Nd: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb0Nj,
                       label: GHC.IO.FD.$w$creadNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Nj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0No; else goto cb0Np;
       cb0No: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb0Np: // global
           I64[Sp - 8] = block_cb0Nl_info;
           R6 = 0;
           _sb0pg::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _sb0pg::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb0Nl() //  [R1]
         { info_tbl: [(cb0Nl,
                       label: block_cb0Nl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Nl: // global
           I64[Sp] = block_cb0Nn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0NE; else goto cb0Nr;
       ub0NE: // global
           call _cb0Nn(R1) args: 0, res: 0, upd: 0;
       cb0Nr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Nn() //  [R1]
         { info_tbl: [(cb0Nn,
                       label: block_cb0Nn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Nn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Nx; else goto cb0Nw;
       cb0Nx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Nw: // global
           if (I64[R1 + 7] == (-1)) goto cb0ND; else goto cb0NC;
       cb0ND: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0NC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.41530414 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { info_tbl: [(cb0O6,
                       label: GHC.IO.FD.$fRawIOFD3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0O6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0Of; else goto cb0Og;
       cb0Of: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0Og: // global
           I64[Sp - 24] = block_cb0O3_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0Op; else goto cb0O4;
       ub0Op: // global
           call _cb0O3(R1) args: 0, res: 0, upd: 0;
       cb0O4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0O3() //  [R1]
         { info_tbl: [(cb0O3,
                       label: block_cb0O3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0O3: // global
           I64[Sp - 8] = block_cb0O9_info;
           _sb0pt::I64 = I64[R1 + 7];
           _sb0pu::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0pu::I64;
           I64[Sp + 8] = _sb0pt::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Oo; else goto cb0Oa;
       ub0Oo: // global
           call _cb0O9(R1) args: 0, res: 0, upd: 0;
       cb0Oa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0O9() //  [R1]
         { info_tbl: [(cb0O9,
                       label: block_cb0O9_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0O9: // global
           I64[Sp] = block_cb0Oe_info;
           _sb0pw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0pw::I64;
           if (R1 & 7 != 0) goto ub0Oq; else goto cb0Oj;
       ub0Oq: // global
           call _cb0Oe(R1) args: 0, res: 0, upd: 0;
       cb0Oj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Oe() //  [R1]
         { info_tbl: [(cb0Oe,
                       label: block_cb0Oe_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Oe: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.424745237 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.426710411 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { info_tbl: [(cb0OS,
                       label: GHC.IO.FD.$fBufferedIOFD_loc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0OS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0OT; else goto cb0OU;
       cb0OT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0OU: // global
           (_cb0OP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0OP::I64 == 0) goto cb0OR; else goto cb0OQ;
       cb0OR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0OQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0OP::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.431456799 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { info_tbl: [(cb0Pa,
                       label: GHC.IO.FD.$fBufferedIOFD14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Pa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Pb; else goto cb0Pc;
       cb0Pb: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0Pc: // global
           I64[Sp - 8] = block_cb0P7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Pk; else goto cb0P8;
       ub0Pk: // global
           call _cb0P7(R1) args: 0, res: 0, upd: 0;
       cb0P8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0P7() //  [R1]
         { info_tbl: [(cb0P7,
                       label: block_cb0P7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0P7: // global
           if (I64[R1 + 7] == (-1)) goto cb0Pj; else goto cb0Pi;
       cb0Pj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0Pi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.43767068 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.439469188 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { info_tbl: [(cb0PG,
                       label: GHC.IO.FD.$fBufferedIOFD12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0PG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0PH; else goto cb0PI;
       cb0PH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0PI: // global
           (_cb0PD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0PD::I64 == 0) goto cb0PF; else goto cb0PE;
       cb0PF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0PE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0PD::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.446385813 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0PS: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0pX_entry() //  [R1]
         { info_tbl: [(cb0Qb,
                       label: sat_sb0pX_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Qb: // global
           _sb0pX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Qc; else goto cb0Qd;
       cb0Qd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Qf; else goto cb0Qe;
       cb0Qf: // global
           HpAlloc = 16;
           goto cb0Qc;
       cb0Qc: // global
           R1 = _sb0pX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Qe: // global
           _sb0pE::I64 = I64[_sb0pX::P64 + 7];
           (_sb0pR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0pR::I64 == 0) goto cb0Qa; else goto cb0Q9;
       cb0Qa: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Qp_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       cb0Q9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb0Qp() //  []
         { info_tbl: [(cb0Qp,
                       label: block_cb0Qp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Qp: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0q3_entry() //  [R1]
         { info_tbl: [(cb0QB,
                       label: sat_sb0q3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0QB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0QF; else goto cb0QG;
       cb0QF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0QG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0Qy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0QK; else goto cb0Qz;
       ub0QK: // global
           call _cb0Qy(R1) args: 0, res: 0, upd: 0;
       cb0Qz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb0Qy() //  [R1]
         { info_tbl: [(cb0Qy,
                       label: block_cb0Qy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Qy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0QJ; else goto cb0QI;
       cb0QJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0QI: // global
           _sb0q2::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0q2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb0qc_entry() //  [R1]
         { info_tbl: [(cb0QU,
                       label: sat_sb0qc_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0QU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0R4; else goto cb0R3;
       cb0R4: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0R3: // global
           (_sb0qa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0qa::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0qy_entry() //  [R1]
         { info_tbl: [(cb0Rv,
                       label: sat_sb0qy_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Rv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0RE; else goto cb0RF;
       cb0RE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0RF: // global
           I64[Sp - 8] = block_cb0RB_info;
           Sp = Sp - 8;
           _cb0Ry::I64 = I64[R1 + 7];
           _cb0Rz::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0RA::I64 = I64[R1 + 31];
           _ub0RL::P64 = CurrentTSO;
           I64[I64[_ub0RL::P64 + 24] + 16] = Sp;
           _ub0RM::I64 = CurrentNursery;
           P64[_ub0RM::I64 + 8] = Hp + 8;
           I64[_ub0RL::P64 + 104] = I64[_ub0RL::P64 + 104] - ((Hp + 8) - I64[_ub0RM::I64]);
           (_ub0RJ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0qw::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_cb0Ry::I64, _cb0Rz::I64, _cb0RA::I64);
           (_ub0RK::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0RJ::I64);
           BaseReg = _ub0RK::I64;
           _ub0RN::P64 = CurrentTSO;
           _ub0RO::P64 = I64[_ub0RN::P64 + 24];
           Sp = I64[_ub0RO::P64 + 16];
           SpLim = _ub0RO::P64 + 192;
           HpAlloc = 0;
           _ub0RP::I64 = CurrentNursery;
           _ub0RQ::I64 = I64[_ub0RP::I64 + 8];
           Hp = _ub0RQ::I64 - 8;
           _ub0RR::I64 = I64[_ub0RP::I64];
           HpLim = _ub0RR::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0RP::I64 + 48]) << 12) - 1);
           I64[_ub0RN::P64 + 104] = I64[_ub0RN::P64 + 104] + (_ub0RQ::I64 - _ub0RR::I64);
           R1 = _sb0qw::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0RB() //  [R1]
         { info_tbl: [(cb0RB,
                       label: block_cb0RB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0RB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0RI; else goto cb0RH;
       cb0RI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0RH: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0qG_entry() //  [R1]
         { info_tbl: [(cb0S1,
                       label: sat_sb0qG_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0S1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Sb; else goto cb0Sa;
       cb0Sb: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Sa: // global
           (_sb0qE::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0qE::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0Sf,
                       label: GHC.IO.FD.$wreadRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Sf: // global
           _sb0pH::I64 = R6;
           _sb0pG::I64 = R5;
           _sb0pF::I64 = R4;
           _sb0pE::I64 = R3;
           _sb0pD::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0Sg; else goto cb0Sh;
       cb0Sh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Sj; else goto cb0Si;
       cb0Sj: // global
           HpAlloc = 40;
           goto cb0Sg;
       cb0Sg: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _sb0pD::P64;
           I64[Sp - 32] = _sb0pE::I64;
           I64[Sp - 24] = _sb0pF::I64;
           I64[Sp - 16] = _sb0pG::I64;
           I64[Sp - 8] = _sb0pH::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0Si: // global
           if (_sb0pF::I64 == 0) goto cb0Se; else goto cb0Sd;
       cb0Se: // global
           (_sb0qg::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0pE::I64, 0, 0, 0);
           Hp = Hp - 40;
           _sb0qU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0qg::I64));
           if (_sb0qU::I64 != (-1)) goto cb0T4; else goto cb0Tf;
       cb0T4: // global
           P64[Sp - 40] = _sb0pD::P64;
           I64[Sp - 32] = _sb0pE::I64;
           I64[Sp - 24] = _sb0pG::I64;
           I64[Sp - 16] = _sb0pH::I64;
           I64[Sp - 8] = _sb0qU::I64;
           Sp = Sp - 40;
           call _cb0Re() args: 0, res: 0, upd: 0;
       cb0Tf: // global
           I64[Sp - 40] = block_cb0Tc_info;
           R2 = _sb0pD::P64;
           P64[Sp - 32] = _sb0pD::P64;
           I64[Sp - 24] = _sb0pE::I64;
           I64[Sp - 16] = _sb0pG::I64;
           I64[Sp - 8] = _sb0pH::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       cb0Sd: // global
           I64[Hp - 32] = sat_sb0qc_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _sb0pE::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0pD::P64;
           Sp = Sp - 16;
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Tc() //  [R1]
         { info_tbl: [(cb0Tc,
                       label: block_cb0Tc_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Tc: // global
           I64[Sp] = block_cb0Te_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0TD; else goto cb0Ti;
       ub0TD: // global
           call _cb0Te(R1) args: 0, res: 0, upd: 0;
       cb0Ti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Te() //  [R1]
         { info_tbl: [(cb0Te,
                       label: block_cb0Te_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Te: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _cb0Re() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Re() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Re: // global
           Hp = Hp + 16;
           _sb0qj::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cb0Ss; else goto cb0Sr;
       cb0Ss: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0Rd_info;
           R1 = _sb0qj::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0Sr: // global
           if (_sb0qj::I64 == 0) goto cb0SY; else goto cb0SB;
       cb0SY: // global
           _sb0pE::I64 = I64[Sp + 8];
           (_sb0qL::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0qL::I64 == 0) goto cb0SV; else goto cb0SN;
       cb0SV: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Rj_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       cb0SN: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           I64[Sp - 8] = block_cb0SL_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cb0SB: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _cb0Rj() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Rd() //  [R1]
         { info_tbl: [(cb0Rd,
                       label: block_cb0Rd_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Rd: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb0Re() args: 0, res: 0, upd: 0;
     }
 },
 _cb0SL() //  []
         { info_tbl: [(cb0SL,
                       label: block_cb0SL_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0SL: // global
           call _cb0Rj() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Rj() //  []
         { info_tbl: [(cb0Rj,
                       label: block_cb0Rj_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Rj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Sv; else goto cb0Su;
       cb0Sv: // global
           HpAlloc = 40;
           I64[Sp] = block_cb0Rj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb0Su: // global
           _sb0pD::P64 = P64[Sp + 8];
           _sb0pE::I64 = I64[Sp + 16];
           _sb0pG::I64 = I64[Sp + 24];
           _sb0pH::I64 = I64[Sp + 32];
           _sb0pI::I64 = I64[Sp + 48];
           (_sb0qp::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0qp::I64 == 0) goto cb0Sy; else goto cb0Sx;
       cb0Sy: // global
           I64[Hp - 32] = sat_sb0qG_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = _sb0pI::I64;
           P64[Sp + 48] = _sb0pD::P64;
           I64[Sp + 32] = _sb0pE::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto ub0Tz;
       cb0Sx: // global
           I64[Hp - 32] = sat_sb0qy_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = _sb0pI::I64;
           P64[Sp + 48] = _sb0pD::P64;
           I64[Sp + 32] = _sb0pE::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto ub0Tz;
       ub0Tz: // global
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 _cb0PZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0PZ: // global
           Hp = Hp + 16;
           _sb0pL::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb0Sm; else goto cb0Sl;
       cb0Sm: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0PY_info;
           R1 = _sb0pL::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Sl: // global
           I64[Hp - 8] = sat_sb0pX_info;
           I64[Hp] = I64[Sp];
           _sb0pD::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb0Qs_info;
           R5 = Hp - 7;
           R4 = _sb0pL::P64;
           R3 = _sb0pD::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0PY() //  [R1]
         { info_tbl: [(cb0PY,
                       label: block_cb0PY_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0PY: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Qs() //  [R1]
         { info_tbl: [(cb0Qs,
                       label: block_cb0Qs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Qs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0Sp; else goto cb0So;
       cb0Sp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0So: // global
           I64[Hp - 16] = sat_sb0q3_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.487991975 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0VO,
                       label: GHC.IO.FD.$fRawIOFD5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0VO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb0W2; else goto cb0W3;
       cb0W2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0W3: // global
           I64[Sp - 40] = block_cb0VL_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub0Wd; else goto cb0VM;
       ub0Wd: // global
           call _cb0VL(R1) args: 0, res: 0, upd: 0;
       cb0VM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0VL() //  [R1]
         { info_tbl: [(cb0VL,
                       label: block_cb0VL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0VL: // global
           I64[Sp - 8] = block_cb0VR_info;
           _sb0r7::I64 = I64[R1 + 7];
           _sb0r8::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0r8::I64;
           I64[Sp + 16] = _sb0r7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Wc; else goto cb0VS;
       ub0Wc: // global
           call _cb0VR(R1) args: 0, res: 0, upd: 0;
       cb0VS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0VR() //  [R1]
         { info_tbl: [(cb0VR,
                       label: block_cb0VR_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0VR: // global
           I64[Sp] = block_cb0VW_info;
           _sb0ra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0ra::I64;
           if (R1 & 7 != 0) goto ub0We; else goto cb0VX;
       ub0We: // global
           call _cb0VW(R1) args: 0, res: 0, upd: 0;
       cb0VX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0VW() //  [R1]
         { info_tbl: [(cb0VW,
                       label: block_cb0VW_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0VW: // global
           I64[Sp] = block_cb0W1_info;
           _sb0rc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0rc::I64;
           if (R1 & 7 != 0) goto ub0Wf; else goto cb0W7;
       ub0Wf: // global
           call _cb0W1(R1) args: 0, res: 0, upd: 0;
       cb0W7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0W1() //  [R1]
         { info_tbl: [(cb0W1,
                       label: block_cb0W1_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0W1: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.500251054 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { info_tbl: [(cb0WN,
                       label: GHC.IO.FD.$fRawIOFD4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0WN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0WW; else goto cb0WX;
       cb0WW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0WX: // global
           I64[Sp - 24] = block_cb0WK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0X7; else goto cb0WL;
       ub0X7: // global
           call _cb0WK(R1) args: 0, res: 0, upd: 0;
       cb0WL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0WK() //  [R1]
         { info_tbl: [(cb0WK,
                       label: block_cb0WK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0WK: // global
           I64[Sp - 8] = block_cb0WQ_info;
           _sb0rk::I64 = I64[R1 + 7];
           _sb0rl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0rl::I64;
           I64[Sp + 8] = _sb0rk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0X6; else goto cb0WR;
       ub0X6: // global
           call _cb0WQ(R1) args: 0, res: 0, upd: 0;
       cb0WR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0WQ() //  [R1]
         { info_tbl: [(cb0WQ,
                       label: block_cb0WQ_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0WQ: // global
           I64[Sp] = block_cb0WV_info;
           _sb0rn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0rn::I64;
           if (R1 & 7 != 0) goto ub0X8; else goto cb0X0;
       ub0X8: // global
           call _cb0WV(R1) args: 0, res: 0, upd: 0;
       cb0X0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0WV() //  [R1]
         { info_tbl: [(cb0WV,
                       label: block_cb0WV_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0WV: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.512097091 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Xv: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0rL_entry() //  [R1]
         { info_tbl: [(cb0XO,
                       label: sat_sb0rL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0XO: // global
           _sb0rL::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cb0XP; else goto cb0XQ;
       cb0XQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0XS; else goto cb0XR;
       cb0XS: // global
           HpAlloc = 16;
           goto cb0XP;
       cb0XP: // global
           R1 = _sb0rL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0XR: // global
           _sb0rs::I64 = I64[_sb0rL::P64 + 7];
           (_sb0rF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0rF::I64 == 0) goto cb0XN; else goto cb0XM;
       cb0XN: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Y2_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       cb0XM: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb0Y2() //  []
         { info_tbl: [(cb0Y2,
                       label: block_cb0Y2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Y2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0rS_entry() //  [R1]
         { info_tbl: [(cb0Ye,
                       label: sat_sb0rS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Ye: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0Yl; else goto cb0Ym;
       cb0Yl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0Ym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0Yb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0Yq; else goto cb0Yc;
       ub0Yq: // global
           call _cb0Yb(R1) args: 0, res: 0, upd: 0;
       cb0Yc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb0Yb() //  [R1]
         { info_tbl: [(cb0Yb,
                       label: block_cb0Yb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Yb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Yp; else goto cb0Yo;
       cb0Yp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0Yo: // global
           _sb0rR::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0rR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb0s1_entry() //  [R1]
         { info_tbl: [(cb0YA,
                       label: sat_sb0s1_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0YA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0YK; else goto cb0YJ;
       cb0YK: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0YJ: // global
           (_sb0rZ::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0rZ::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0sk_entry() //  [R1]
         { info_tbl: [(cb0Z6,
                       label: sat_sb0sk_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Z6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Zf; else goto cb0Zg;
       cb0Zf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Zg: // global
           I64[Sp - 8] = block_cb0Zc_info;
           Sp = Sp - 8;
           _cb0Z9::I64 = I64[R1 + 7];
           _cb0Za::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0Zb::I64 = I64[R1 + 31];
           _ub0Zm::P64 = CurrentTSO;
           I64[I64[_ub0Zm::P64 + 24] + 16] = Sp;
           _ub0Zn::I64 = CurrentNursery;
           P64[_ub0Zn::I64 + 8] = Hp + 8;
           I64[_ub0Zm::P64 + 104] = I64[_ub0Zm::P64 + 104] - ((Hp + 8) - I64[_ub0Zn::I64]);
           (_ub0Zk::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0si::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_cb0Z9::I64, _cb0Za::I64, _cb0Zb::I64);
           (_ub0Zl::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0Zk::I64);
           BaseReg = _ub0Zl::I64;
           _ub0Zo::P64 = CurrentTSO;
           _ub0Zp::P64 = I64[_ub0Zo::P64 + 24];
           Sp = I64[_ub0Zp::P64 + 16];
           SpLim = _ub0Zp::P64 + 192;
           HpAlloc = 0;
           _ub0Zq::I64 = CurrentNursery;
           _ub0Zr::I64 = I64[_ub0Zq::I64 + 8];
           Hp = _ub0Zr::I64 - 8;
           _ub0Zs::I64 = I64[_ub0Zq::I64];
           HpLim = _ub0Zs::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0Zq::I64 + 48]) << 12) - 1);
           I64[_ub0Zo::P64 + 104] = I64[_ub0Zo::P64 + 104] + (_ub0Zr::I64 - _ub0Zs::I64);
           R1 = _sb0si::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Zc() //  [R1]
         { info_tbl: [(cb0Zc,
                       label: block_cb0Zc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Zc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Zj; else goto cb0Zi;
       cb0Zj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0Zi: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0ss_entry() //  [R1]
         { info_tbl: [(cb0ZC,
                       label: sat_sb0ss_info
                       rep:HeapRep 4 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0ZC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0ZM; else goto cb0ZL;
       cb0ZM: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0ZL: // global
           (_sb0sq::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0sq::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb0ZQ,
                       label: GHC.IO.FD.$wwriteRawBufferPtr_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0ZQ: // global
           _sb0rv::I64 = R6;
           _sb0ru::I64 = R5;
           _sb0rt::I64 = R4;
           _sb0rs::I64 = R3;
           _sb0rr::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0ZR; else goto cb0ZS;
       cb0ZS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0ZU; else goto cb0ZT;
       cb0ZU: // global
           HpAlloc = 40;
           goto cb0ZR;
       cb0ZR: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _sb0rr::P64;
           I64[Sp - 32] = _sb0rs::I64;
           I64[Sp - 24] = _sb0rt::I64;
           I64[Sp - 16] = _sb0ru::I64;
           I64[Sp - 8] = _sb0rv::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0ZT: // global
           if (_sb0rt::I64 == 0) goto cb0ZP; else goto cb0ZO;
       cb0ZP: // global
           (_sb0s5::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0rs::I64, 1, 0, 0);
           Hp = Hp - 40;
           _sb0st::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0s5::I64));
           if (_sb0st::I64 != 0) goto ub10K; else goto ub10J;
       ub10K: // global
           P64[Sp - 32] = _sb0rr::P64;
           I64[Sp - 24] = _sb0rs::I64;
           I64[Sp - 16] = _sb0ru::I64;
           I64[Sp - 8] = _sb0rv::I64;
           Sp = Sp - 40;
           call _cb0YU() args: 0, res: 0, upd: 0;
       ub10J: // global
           P64[Sp - 40] = _sb0rr::P64;
           I64[Sp - 32] = _sb0rs::I64;
           I64[Sp - 24] = _sb0ru::I64;
           I64[Sp - 16] = _sb0rv::I64;
           I64[Sp - 8] = _sb0st::I64;
           Sp = Sp - 40;
           call _cb10j() args: 0, res: 0, upd: 0;
       cb0ZO: // global
           I64[Hp - 32] = sat_sb0s1_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _sb0rs::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0rr::P64;
           Sp = Sp - 16;
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 _cb10j() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb10j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb10n; else goto cb10m;
       cb10n: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb10h_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb10m: // global
           _sb0rr::P64 = P64[Sp];
           _sb0rs::I64 = I64[Sp + 8];
           _sb0ru::I64 = I64[Sp + 16];
           _sb0rv::I64 = I64[Sp + 24];
           (_sb0sx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0sx::I64 == 0) goto cb10F; else goto cb10x;
       cb10F: // global
           Hp = Hp - 16;
           I64[Sp] = block_cb0YU_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           P64[Sp + 8] = _sb0rr::P64;
           I64[Sp + 16] = _sb0rs::I64;
           I64[Sp + 24] = _sb0ru::I64;
           I64[Sp + 32] = _sb0rv::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       cb10x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           I64[Sp - 8] = block_cb10v_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb10h() //  [R1]
         { info_tbl: [(cb10h,
                       label: block_cb10h_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb10h: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb10j() args: 0, res: 0, upd: 0;
     }
 },
 _cb10v() //  []
         { info_tbl: [(cb10v,
                       label: block_cb10v_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb10v: // global
           _sb0rs::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _sb0ru::I64 = I64[Sp + 24];
           I64[Sp + 24] = _sb0rs::I64;
           _sb0rv::I64 = I64[Sp + 32];
           I64[Sp + 32] = _sb0ru::I64;
           I64[Sp + 40] = _sb0rv::I64;
           Sp = Sp + 8;
           call _cb0YU() args: 0, res: 0, upd: 0;
     }
 },
 _cb0YU() //  []
         { info_tbl: [(cb0YU,
                       label: block_cb0YU_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0YU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb103; else goto cb102;
       cb103: // global
           HpAlloc = 40;
           I64[Sp] = block_cb0YU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb102: // global
           _sb0rr::P64 = P64[Sp + 8];
           _sb0rs::I64 = I64[Sp + 16];
           _sb0ru::I64 = I64[Sp + 24];
           _sb0rv::I64 = I64[Sp + 32];
           _sb0rw::I64 = I64[Sp + 40];
           (_sb0sb::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0sb::I64 == 0) goto cb106; else goto cb105;
       cb106: // global
           I64[Hp - 32] = sat_sb0ss_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = _sb0rw::I64;
           P64[Sp + 40] = _sb0rr::P64;
           I64[Sp + 24] = _sb0rs::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto ub10S;
       cb105: // global
           I64[Hp - 32] = sat_sb0sk_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = _sb0rw::I64;
           P64[Sp + 40] = _sb0rr::P64;
           I64[Sp + 24] = _sb0rs::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto ub10S;
       ub10S: // global
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 _cb0XC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0XC: // global
           Hp = Hp + 16;
           _sb0rz::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb0ZX; else goto cb0ZW;
       cb0ZX: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0XB_info;
           R1 = _sb0rz::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0ZW: // global
           I64[Hp - 8] = sat_sb0rL_info;
           I64[Hp] = I64[Sp];
           _sb0rr::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb0Y5_info;
           R5 = Hp - 7;
           R4 = _sb0rz::P64;
           R3 = _sb0rr::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0XB() //  [R1]
         { info_tbl: [(cb0XB,
                       label: block_cb0XB_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0XB: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Y5() //  [R1]
         { info_tbl: [(cb0Y5,
                       label: block_cb0Y5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb100; else goto cb0ZZ;
       cb100: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0ZZ: // global
           I64[Hp - 16] = sat_sb0rS_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.549998075 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb12V,
                       label: GHC.IO.FD.writeRawBufferPtr1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb12V: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb139; else goto cb13a;
       cb139: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb13a: // global
           I64[Sp - 40] = block_cb12S_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub13k; else goto cb12T;
       ub13k: // global
           call _cb12S(R1) args: 0, res: 0, upd: 0;
       cb12T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb12S() //  [R1]
         { info_tbl: [(cb12S,
                       label: block_cb12S_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb12S: // global
           I64[Sp - 8] = block_cb12Y_info;
           _sb0sN::I64 = I64[R1 + 7];
           _sb0sO::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0sO::I64;
           I64[Sp + 16] = _sb0sN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub13j; else goto cb12Z;
       ub13j: // global
           call _cb12Y(R1) args: 0, res: 0, upd: 0;
       cb12Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb12Y() //  [R1]
         { info_tbl: [(cb12Y,
                       label: block_cb12Y_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb12Y: // global
           I64[Sp] = block_cb133_info;
           _sb0sQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0sQ::I64;
           if (R1 & 7 != 0) goto ub13l; else goto cb134;
       ub13l: // global
           call _cb133(R1) args: 0, res: 0, upd: 0;
       cb134: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb133() //  [R1]
         { info_tbl: [(cb133,
                       label: block_cb133_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb133: // global
           I64[Sp] = block_cb138_info;
           _sb0sS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0sS::I64;
           if (R1 & 7 != 0) goto ub13m; else goto cb13e;
       ub13m: // global
           call _cb138(R1) args: 0, res: 0, upd: 0;
       cb13e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb138() //  [R1]
         { info_tbl: [(cb138,
                       label: block_cb138_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb138: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.562323385 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13O: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb13U,
                       label: GHC.IO.FD.$wfdWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13U: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb13Z; else goto ub14i;
       cb13Z: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ub14i: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cb13P() args: 0, res: 0, upd: 0;
     }
 },
 _cb13P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13P: // global
           I64[Sp - 8] = block_cb13W_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb13W() //  [R1]
         { info_tbl: [(cb13W,
                       label: block_cb13W_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13W: // global
           I64[Sp] = block_cb13Y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub14l; else goto cb142;
       ub14l: // global
           call _cb13Y(R1) args: 0, res: 0, upd: 0;
       cb142: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb13Y() //  [R1]
         { info_tbl: [(cb13Y,
                       label: block_cb13Y_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13Y: // global
           _sb0sY::I64 = I64[Sp + 32];
           _sb0t5::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_sb0t5::I64,
                            _sb0sY::I64)) goto cb14a; else goto cb14b;
       cb14a: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb14b: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _sb0t5::I64;
           I64[Sp + 32] = _sb0sY::I64 - _sb0t5::I64;
           Sp = Sp + 8;
           call _cb13P() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.572633439 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { info_tbl: [(cb14V,
                       label: GHC.IO.FD.$fRawIOFD2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb14V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb154; else goto cb155;
       cb154: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb155: // global
           I64[Sp - 24] = block_cb14S_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub15e; else goto cb14T;
       ub15e: // global
           call _cb14S(R1) args: 0, res: 0, upd: 0;
       cb14T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb14S() //  [R1]
         { info_tbl: [(cb14S,
                       label: block_cb14S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb14S: // global
           I64[Sp - 8] = block_cb14Y_info;
           _sb0te::I64 = I64[R1 + 7];
           _sb0tf::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0tf::I64;
           I64[Sp + 8] = _sb0te::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub15d; else goto cb14Z;
       ub15d: // global
           call _cb14Y(R1) args: 0, res: 0, upd: 0;
       cb14Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb14Y() //  [R1]
         { info_tbl: [(cb14Y,
                       label: block_cb14Y_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb14Y: // global
           I64[Sp] = block_cb153_info;
           _sb0th::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0th::I64;
           if (R1 & 7 != 0) goto ub15f; else goto cb158;
       ub15f: // global
           call _cb153(R1) args: 0, res: 0, upd: 0;
       cb158: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb153() //  [R1]
         { info_tbl: [(cb153,
                       label: block_cb153_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb153: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.584624459 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb15B: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0tx_entry() //  [R1]
         { info_tbl: [(cb15O,
                       label: sat_sb0tx_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb15O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb15Y; else goto cb15X;
       cb15Y: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb15X: // global
           (_sb0tv::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0tv::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0tX_entry() //  [R1]
         { info_tbl: [(cb16l,
                       label: sat_sb0tX_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb16l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb16u; else goto cb16v;
       cb16u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb16v: // global
           I64[Sp - 8] = block_cb16r_info;
           Sp = Sp - 8;
           _cb16o::I64 = I64[R1 + 7];
           _cb16p::I64 = I64[R1 + 15];
           _cb16q::I64 = I64[R1 + 23];
           _ub16B::P64 = CurrentTSO;
           I64[I64[_ub16B::P64 + 24] + 16] = Sp;
           _ub16C::I64 = CurrentNursery;
           P64[_ub16C::I64 + 8] = Hp + 8;
           I64[_ub16B::P64 + 104] = I64[_ub16B::P64 + 104] - ((Hp + 8) - I64[_ub16C::I64]);
           (_ub16z::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0tV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_cb16o::I64, _cb16p::I64, _cb16q::I64);
           (_ub16A::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub16z::I64);
           BaseReg = _ub16A::I64;
           _ub16D::P64 = CurrentTSO;
           _ub16E::P64 = I64[_ub16D::P64 + 24];
           Sp = I64[_ub16E::P64 + 16];
           SpLim = _ub16E::P64 + 192;
           HpAlloc = 0;
           _ub16F::I64 = CurrentNursery;
           _ub16G::I64 = I64[_ub16F::I64 + 8];
           Hp = _ub16G::I64 - 8;
           _ub16H::I64 = I64[_ub16F::I64];
           HpLim = _ub16H::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub16F::I64 + 48]) << 12) - 1);
           I64[_ub16D::P64 + 104] = I64[_ub16D::P64 + 104] + (_ub16G::I64 - _ub16H::I64);
           R1 = _sb0tV::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb16r() //  [R1]
         { info_tbl: [(cb16r,
                       label: block_cb16r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb16r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb16y; else goto cb16x;
       cb16y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb16x: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0ud_entry() //  [R1]
         { info_tbl: [(cb16R,
                       label: sat_sb0ud_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb16R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb171; else goto cb170;
       cb171: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb170: // global
           (_sb0ub::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0ub::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb175,
                       label: GHC.IO.FD.$w$cwriteNonBlocking_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb175: // global
           _sb0tn::I64 = R5;
           _sb0tm::I64 = R4;
           _sb0tl::I64 = R3;
           _sb0tk::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cb176; else goto cb177;
       cb177: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb179; else goto cb178;
       cb179: // global
           HpAlloc = 32;
           goto cb176;
       cb176: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _sb0tk::I64;
           I64[Sp - 24] = _sb0tl::I64;
           I64[Sp - 16] = _sb0tm::I64;
           I64[Sp - 8] = _sb0tn::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb178: // global
           if (_sb0tl::I64 == 0) goto cb174; else goto cb173;
       cb174: // global
           (_sb0tJ::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0tk::I64, 1, 0, 0);
           Hp = Hp - 32;
           _sb0tK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0tJ::I64));
           if (_sb0tK::I64 != 0) goto ub18n; else goto cb18i;
       ub18n: // global
           I64[Sp - 32] = _sb0tk::I64;
           I64[Sp - 24] = _sb0tm::I64;
           I64[Sp - 16] = _sb0tn::I64;
           I64[Sp - 8] = _sb0tK::I64;
           Sp = Sp - 32;
           call _cb169() args: 0, res: 0, upd: 0;
       cb18i: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb173: // global
           I64[Hp - 24] = sat_sb0tx_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp - 8] = block_cb17a_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb169() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb169: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb17y; else goto cb17x;
       cb17y: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb168_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb17x: // global
           _sb0tk::I64 = I64[Sp];
           _sb0tm::I64 = I64[Sp + 8];
           _sb0tn::I64 = I64[Sp + 16];
           (_sb0tO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0tO::I64 == 0) goto cb17Y; else goto cb17D;
       cb17Y: // global
           I64[Hp - 24] = sat_sb0ud_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp + 24] = block_cb17V_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       cb17D: // global
           I64[Hp - 24] = sat_sb0tX_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp + 24] = block_cb17z_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb168() //  [R1]
         { info_tbl: [(cb168,
                       label: block_cb168_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb168: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cb169() args: 0, res: 0, upd: 0;
     }
 },
 _cb17V() //  [R1]
         { info_tbl: [(cb17V,
                       label: block_cb17V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17V: // global
           I64[Sp] = block_cb17X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18x; else goto cb180;
       ub18x: // global
           call _cb17X(R1) args: 0, res: 0, upd: 0;
       cb180: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb17X() //  [R1]
         { info_tbl: [(cb17X,
                       label: block_cb17X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb186; else goto cb185;
       cb186: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb185: // global
           _sb0uj::I64 = I64[R1 + 7];
           if (_sb0uj::I64 != (-1)) goto cb18e; else goto ub18q;
       cb18e: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0uj::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18q: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 _cb17z() //  [R1]
         { info_tbl: [(cb17z,
                       label: block_cb17z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17z: // global
           I64[Sp] = block_cb17B_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18v; else goto cb17F;
       ub18v: // global
           call _cb17B(R1) args: 0, res: 0, upd: 0;
       cb17F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb17B() //  [R1]
         { info_tbl: [(cb17B,
                       label: block_cb17B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb17L; else goto cb17K;
       cb17L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb17K: // global
           _sb0u3::I64 = I64[R1 + 7];
           if (_sb0u3::I64 != (-1)) goto cb17T; else goto ub18p;
       cb17T: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0u3::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18p: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 _cb17a() //  [R1]
         { info_tbl: [(cb17a,
                       label: block_cb17a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17a: // global
           I64[Sp] = block_cb17c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18t; else goto cb17e;
       ub18t: // global
           call _cb17c(R1) args: 0, res: 0, upd: 0;
       cb17e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb17c() //  [R1]
         { info_tbl: [(cb17c,
                       label: block_cb17c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb17c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb17k; else goto cb17j;
       cb17k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb17j: // global
           _sb0tD::I64 = I64[R1 + 7];
           if (_sb0tD::I64 != (-1)) goto cb17s; else goto ub18m;
       cb17s: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0tD::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18m: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 _cb18f() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb18f: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.617556025 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1ab,
                       label: GHC.IO.FD.$fRawIOFD1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1ak; else goto cb1al;
       cb1ak: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1al: // global
           I64[Sp - 24] = block_cb1a8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1au; else goto cb1a9;
       ub1au: // global
           call _cb1a8(R1) args: 0, res: 0, upd: 0;
       cb1a9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1a8() //  [R1]
         { info_tbl: [(cb1a8,
                       label: block_cb1a8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1a8: // global
           I64[Sp - 8] = block_cb1ae_info;
           _sb0ur::I64 = I64[R1 + 7];
           _sb0us::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0us::I64;
           I64[Sp + 8] = _sb0ur::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1at; else goto cb1af;
       ub1at: // global
           call _cb1ae(R1) args: 0, res: 0, upd: 0;
       cb1af: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1ae() //  [R1]
         { info_tbl: [(cb1ae,
                       label: block_cb1ae_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ae: // global
           I64[Sp] = block_cb1aj_info;
           _sb0uu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0uu::I64;
           if (R1 & 7 != 0) goto ub1av; else goto cb1ao;
       ub1av: // global
           call _cb1aj(R1) args: 0, res: 0, upd: 0;
       cb1ao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1aj() //  [R1]
         { info_tbl: [(cb1aj,
                       label: block_cb1aj_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1aj: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.626574861 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.629011769 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { info_tbl: [(cb1aY,
                       label: GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1aY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb1bg; else goto cb1bh;
       cb1bg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1bh: // global
           I64[Sp - 16] = block_cb1aV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1bo; else goto cb1aW;
       ub1bo: // global
           call _cb1aV(R1) args: 0, res: 0, upd: 0;
       cb1aW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1aV() //  [R1]
         { info_tbl: [(cb1aV,
                       label: block_cb1aV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1aV: // global
           I64[Sp - 40] = block_cb1b1_info;
           _sb0uC::P64 = P64[R1 + 7];
           _sb0uD::P64 = P64[R1 + 15];
           _sb0uB::I64 = I64[R1 + 23];
           _sb0uE::I64 = I64[R1 + 31];
           _sb0uF::I64 = I64[R1 + 39];
           _sb0uG::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _sb0uD::P64;
           I64[Sp - 24] = _sb0uE::I64;
           I64[Sp - 16] = _sb0uF::I64;
           I64[Sp - 8] = _sb0uG::I64;
           P64[Sp] = _sb0uC::P64;
           I64[Sp + 8] = _sb0uB::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub1bn; else goto cb1b2;
       ub1bn: // global
           call _cb1b1(R1) args: 0, res: 0, upd: 0;
       cb1b2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1b1() //  [R1]
         { info_tbl: [(cb1b1,
                       label: block_cb1b1_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1b1: // global
           I64[Sp] = block_cb1bc_info;
           _sb0uF::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _sb0uF::I64;
           R4 = I64[Sp + 48] + _sb0uF::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1bc() //  [R1]
         { info_tbl: [(cb1bc,
                       label: block_cb1bc_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1bc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1bm; else goto cb1bl;
       cb1bm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1bl: // global
           _sb0uB::I64 = I64[Sp + 48];
           _sb0uC::P64 = P64[Sp + 40];
           _sb0uD::P64 = P64[Sp + 8];
           _sb0uE::I64 = I64[Sp + 16];
           call MO_Touch(_sb0uC::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0uC::P64;
           P64[Hp - 32] = _sb0uD::P64;
           I64[Hp - 24] = _sb0uB::I64;
           I64[Hp - 16] = _sb0uE::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.639674568 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { info_tbl: [(cb1bT,
                       label: GHC.IO.FD.fdIsNonBlocking_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1bT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1bX; else goto cb1bY;
       cb1bX: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1bY: // global
           I64[Sp - 8] = block_cb1bQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1c2; else goto cb1bR;
       ub1c2: // global
           call _cb1bQ(R1) args: 0, res: 0, upd: 0;
       cb1bR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1bQ() //  [R1]
         { info_tbl: [(cb1bQ,
                       label: block_cb1bQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1bQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1c1; else goto cb1c0;
       cb1c1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1c0: // global
           _sb0uU::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0uU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.645709514 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { info_tbl: [(cb1cm,
                       label: GHC.IO.FD.fdFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1cm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1cq; else goto cb1cr;
       cb1cq: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1cr: // global
           I64[Sp - 8] = block_cb1cj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1cv; else goto cb1ck;
       ub1cv: // global
           call _cb1cj(R1) args: 0, res: 0, upd: 0;
       cb1ck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1cj() //  [R1]
         { info_tbl: [(cb1cj,
                       label: block_cb1cj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1cj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1cu; else goto cb1ct;
       cb1cu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ct: // global
           _sb0uX::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0uX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.651480599 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { info_tbl: [(cb1cP,
                       label: GHC.IO.FD.$fShowFD_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1cP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1cV; else goto cb1cW;
       cb1cV: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1cW: // global
           I64[Sp - 8] = block_cb1cM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1d1; else goto cb1cN;
       ub1d1: // global
           call _cb1cM(R1) args: 0, res: 0, upd: 0;
       cb1cN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1cM() //  [R1]
         { info_tbl: [(cb1cM,
                       label: block_cb1cM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1cM: // global
           I64[Sp] = block_cb1cS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1cS() //  [R1, R2]
         { info_tbl: [(cb1cS,
                       label: block_cb1cS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1cS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1d0; else goto cb1cZ;
       cb1d0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1cZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.659664392 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { info_tbl: [(cb1du,
                       label: GHC.IO.FD.$fBufferedIOFD15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1du: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1dx; else goto cb1dy;
       cb1dx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1dy: // global
           I64[Sp - 16] = block_cb1dn_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1dn() //  [R1]
         { info_tbl: [(cb1dn,
                       label: block_cb1dn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1dn: // global
           I64[Sp - 8] = block_cb1dp_info;
           _sb0vb::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sb0vb::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1dp() //  [R1]
         { info_tbl: [(cb1dp,
                       label: block_cb1dp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1dp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb1dC; else goto cb1dB;
       cb1dC: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1dB: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.667356746 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_sb0vn_entry() //  [R1]
         { info_tbl: [(cb1e9,
                       label: sat_sb0vn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1e9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ed; else goto cb1ee;
       cb1ed: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1ee: // global
           I64[Sp - 8] = block_cb1e6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1ei; else goto cb1e7;
       ub1ei: // global
           call _cb1e6(R1) args: 0, res: 0, upd: 0;
       cb1e7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1e6() //  [R1]
         { info_tbl: [(cb1e6,
                       label: block_cb1e6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1e6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1eh; else goto cb1eg;
       cb1eh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1eg: // global
           _sb0vl::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { info_tbl: [(cb1ej,
                       label: GHC.IO.FD.$fIODeviceFD12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ej: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1en; else goto cb1em;
       cb1en: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1em: // global
           I64[Hp - 16] = sat_sb0vn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.675845442 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_sb0vu_entry() //  [R1]
         { info_tbl: [(cb1eP,
                       label: sat_sb0vu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1eP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1eT; else goto cb1eU;
       cb1eT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1eU: // global
           I64[Sp - 8] = block_cb1eM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1eY; else goto cb1eN;
       ub1eY: // global
           call _cb1eM(R1) args: 0, res: 0, upd: 0;
       cb1eN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1eM() //  [R1]
         { info_tbl: [(cb1eM,
                       label: block_cb1eM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1eM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1eX; else goto cb1eW;
       cb1eX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1eW: // global
           _sb0vs::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { info_tbl: [(cb1eZ,
                       label: GHC.IO.FD.$fIODeviceFD9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1eZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1f3; else goto cb1f2;
       cb1f3: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1f2: // global
           I64[Hp - 16] = sat_sb0vu_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.684065744 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_sb0vA_entry() //  [R1]
         { info_tbl: [(cb1fv,
                       label: sat_sb0vA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1fv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1fz; else goto cb1fA;
       cb1fz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1fA: // global
           I64[Sp - 8] = block_cb1fs_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1fE; else goto cb1ft;
       ub1fE: // global
           call _cb1fs(R1) args: 0, res: 0, upd: 0;
       cb1ft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1fs() //  [R1]
         { info_tbl: [(cb1fs,
                       label: block_cb1fs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1fs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1fD; else goto cb1fC;
       cb1fD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1fC: // global
           _sb0vy::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { info_tbl: [(cb1fF,
                       label: GHC.IO.FD.$fIODeviceFD8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1fF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1fJ; else goto cb1fI;
       cb1fJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1fI: // global
           I64[Hp - 16] = sat_sb0vA_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.692002781 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_sb0vJ_entry() //  [R1]
         { info_tbl: [(cb1gg,
                       label: sat_sb0vJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1gg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1gh; else goto cb1gi;
       cb1gh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1gi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1g9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1gp; else goto cb1ga;
       ub1gp: // global
           call _cb1g9(R1) args: 0, res: 0, upd: 0;
       cb1ga: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1g9() //  [R1]
         { info_tbl: [(cb1g9,
                       label: block_cb1g9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1g9: // global
           if (R1 & 7 == 1) goto cb1gd; else goto cb1ge;
       cb1gd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1ge: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb0vH_entry() //  [R1]
         { info_tbl: [(cb1gx,
                       label: sat_sb0vH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1gx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1gB; else goto cb1gC;
       cb1gB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1gC: // global
           I64[Sp - 8] = block_cb1gu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1gG; else goto cb1gv;
       ub1gG: // global
           call _cb1gu(R1) args: 0, res: 0, upd: 0;
       cb1gv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1gu() //  [R1]
         { info_tbl: [(cb1gu,
                       label: block_cb1gu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1gu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1gF; else goto cb1gE;
       cb1gF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1gE: // global
           _sb0vF::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { info_tbl: [(cb1gH,
                       label: GHC.IO.FD.$fIODeviceFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1gH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb1gL; else goto cb1gK;
       cb1gL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1gK: // global
           I64[Hp - 40] = sat_sb0vJ_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sb0vH_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.704428459 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.706174338 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.708238458 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.710101775 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.711755545 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.71399023 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.71586181 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.717784017 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.720017091 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.721819178 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.723657964 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.725508769 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.72743931 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.729332944 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.73173037 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.734282716 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.736608172 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1hG,
                       label: GHC.IO.FD.$fShowFD_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1hG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1hM; else goto cb1hN;
       cb1hM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1hN: // global
           I64[Sp - 16] = block_cb1hD_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1hS; else goto cb1hE;
       ub1hS: // global
           call _cb1hD(R1) args: 0, res: 0, upd: 0;
       cb1hE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1hD() //  [R1]
         { info_tbl: [(cb1hD,
                       label: block_cb1hD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1hD: // global
           I64[Sp] = block_cb1hJ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1hJ() //  [R1, R2]
         { info_tbl: [(cb1hJ,
                       label: block_cb1hJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1hJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1hR; else goto cb1hQ;
       cb1hR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1hQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.744223523 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(cb1ig,
                       label: GHC.IO.FD.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ig: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1ih; else goto cb1ii;
       cb1ih: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1ii: // global
           I64[Sp - 16] = block_cb1id_info;
           R4 = GHC.Types.[]_closure+1;
           _sb0vV::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _sb0vV::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1id() //  [R1, R2]
         { info_tbl: [(cb1id,
                       label: block_cb1id_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1id: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1il; else goto cb1ik;
       cb1il: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1ik: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.750315118 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { info_tbl: [(cb1iE,
                       label: GHC.IO.FD.$fShowFD1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1iE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1iF; else goto cb1iG;
       cb1iF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1iG: // global
           I64[Sp - 16] = block_cb1iB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1iK; else goto cb1iC;
       ub1iK: // global
           call _cb1iB(R1) args: 0, res: 0, upd: 0;
       cb1iC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1iB() //  [R1]
         { info_tbl: [(cb1iB,
                       label: block_cb1iB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1iB: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.755680841 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cb1iZ,
                       label: GHC.IO.FD.$fShowFD_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1iZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.75929876 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.761325304 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { info_tbl: [(cb1jh,
                       label: output_flags_raWV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1jh: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb1jz; else goto cb1jA;
       cb1jA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1jC; else goto cb1jB;
       cb1jC: // global
           HpAlloc = 16;
           goto cb1jz;
       cb1jz: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1jB: // global
           (_cb1ja::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_cb1ja::I64 == 0) goto cb1jc; else goto cb1jb;
       cb1jc: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       cb1jb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1ja::I64;
           (_sb0wa::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_sb0we::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wa::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0we::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.766749406 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { info_tbl: [(cb1jZ,
                       label: write_flags_raWV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1jZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1kj; else goto cb1kk;
       cb1kj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1kk: // global
           (_cb1jT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1jT::I64 == 0) goto cb1jV; else goto cb1jU;
       cb1jV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1jU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1jT::I64;
           I64[Sp - 24] = block_cb1jW_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1ko; else goto cb1jX;
       ub1ko: // global
           call _cb1jW(R1) args: 0, res: 0, upd: 0;
       cb1jX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1jW() //  [R1]
         { info_tbl: [(cb1jW,
                       label: block_cb1jW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1jW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1kn; else goto cb1km;
       cb1kn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1km: // global
           _sb0wm::I64 = I64[R1 + 7];
           (_sb0wq::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wm::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wq::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.773543886 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { info_tbl: [(cb1kQ,
                       label: append_flags_raWV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1kQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1la; else goto cb1lb;
       cb1la: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1lb: // global
           (_cb1kK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1kK::I64 == 0) goto cb1kM; else goto cb1kL;
       cb1kM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1kL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1kK::I64;
           I64[Sp - 24] = block_cb1kN_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1lf; else goto cb1kO;
       ub1lf: // global
           call _cb1kN(R1) args: 0, res: 0, upd: 0;
       cb1kO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1kN() //  [R1]
         { info_tbl: [(cb1kN,
                       label: block_cb1kN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1kN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1le; else goto cb1ld;
       cb1le: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1ld: // global
           _sb0wx::I64 = I64[R1 + 7];
           (_sb0wB::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wx::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wB::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.780090837 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { info_tbl: [(cb1lH,
                       label: rw_flags_raWV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1lH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1m1; else goto cb1m2;
       cb1m1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1m2: // global
           (_cb1lB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1lB::I64 == 0) goto cb1lD; else goto cb1lC;
       cb1lD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1lC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1lB::I64;
           I64[Sp - 24] = block_cb1lE_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1m6; else goto cb1lF;
       ub1m6: // global
           call _cb1lE(R1) args: 0, res: 0, upd: 0;
       cb1lF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1lE() //  [R1]
         { info_tbl: [(cb1lE,
                       label: block_cb1lE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1lE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1m5; else goto cb1m4;
       cb1m5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1m4: // global
           _sb0wI::I64 = I64[R1 + 7];
           (_sb0wM::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wI::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.786796167 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { info_tbl: [(cb1mz,
                       label: read_flags_raWV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1mz: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb1mR; else goto cb1mS;
       cb1mS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1mU; else goto cb1mT;
       cb1mU: // global
           HpAlloc = 16;
           goto cb1mR;
       cb1mR: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1mT: // global
           (_cb1ms::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_cb1ms::I64 == 0) goto cb1mu; else goto cb1mt;
       cb1mu: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       cb1mt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1ms::I64;
           (_sb0wV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_sb0wZ::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wV::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wZ::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.791527079 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { info_tbl: [(cb1nf,
                       label: GHC.IO.FD.$fIODeviceFD16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1nf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ng; else goto cb1nh;
       cb1ng: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1nh: // global
           I64[Sp - 8] = block_cb1nc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1np; else goto cb1nd;
       ub1np: // global
           call _cb1nc(R1) args: 0, res: 0, upd: 0;
       cb1nd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1nc() //  [R1]
         { info_tbl: [(cb1nc,
                       label: block_cb1nc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1nc: // global
           if (I64[R1 + 7] == (-1)) goto cb1no; else goto cb1nn;
       cb1no: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1nn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.797038304 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.799493443 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { info_tbl: [(cb1nL,
                       label: GHC.IO.FD.$fIODeviceFD14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1nL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1nM; else goto cb1nN;
       cb1nM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1nN: // global
           (_cb1nI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1nI::I64 == 0) goto cb1nK; else goto cb1nJ;
       cb1nK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1nJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1nI::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.803853354 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_sb0xn_entry() //  [R1]
         { info_tbl: [(cb1o8,
                       label: sat_sb0xn_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1o8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1oi; else goto cb1oh;
       cb1oi: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1oh: // global
           (_sb0xl::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0xl::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0xr_entry() //  [R1]
         { info_tbl: [(cb1op,
                       label: sat_sb0xr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1op: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1oq; else goto cb1or;
       cb1oq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1or: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { info_tbl: [(cb1os,
                       label: GHC.IO.FD.$w$ctell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1os: // global
           _sb0xa::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ot; else goto cb1ou;
       cb1ou: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1ow; else goto cb1ov;
       cb1ow: // global
           HpAlloc = 24;
           goto cb1ot;
       cb1ot: // global
           R2 = _sb0xa::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1ov: // global
           (_sb0xf::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_sb0xn_info;
           I64[Hp - 8] = _sb0xa::I64;
           I64[Hp] = _sb0xf::I64;
           I64[Sp - 8] = block_cb1oj_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1oj() //  [R1]
         { info_tbl: [(cb1oj,
                       label: block_cb1oj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1oj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1oz; else goto cb1oy;
       cb1oz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1oy: // global
           I64[Hp - 16] = sat_sb0xr_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.814468903 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { info_tbl: [(cb1p4,
                       label: GHC.IO.FD.$fIODeviceFD13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1p4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1p5; else goto cb1p6;
       cb1p5: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1p6: // global
           I64[Sp - 8] = block_cb1p1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1pa; else goto cb1p2;
       ub1pa: // global
           call _cb1p1(R1) args: 0, res: 0, upd: 0;
       cb1p2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1p1() //  [R1]
         { info_tbl: [(cb1p1,
                       label: block_cb1p1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1p1: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.819491068 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.821454259 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { info_tbl: [(cb1ps,
                       label: GHC.IO.FD.$fIODeviceFD18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ps: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1pt; else goto cb1pu;
       cb1pt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1pu: // global
           (_cb1pp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1pp::I64 == 0) goto cb1pr; else goto cb1pq;
       cb1pr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1pq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1pp::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.826689623 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_sb0xK_entry() //  [R1]
         { info_tbl: [(cb1q0,
                       label: sat_sb0xK_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1q0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1q4; else goto cb1q3;
       cb1q4: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1q3: // global
           (_sb0xI::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0xI::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1q5,
                       label: GHC.IO.FD.$w$cseek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1q5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1q6; else goto cb1q7;
       cb1q6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1q7: // global
           I64[Sp - 24] = block_cb1pH_info;
           _sb0xx::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _sb0xx::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1pH() //  [R1]
         { info_tbl: [(cb1pH,
                       label: block_cb1pH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1pH: // global
           I64[Sp] = block_cb1q8_info;
           _sb0xB::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb0xB::I64;
           if (R1 & 7 != 0) goto ub1qH; else goto cb1qg;
       ub1qH: // global
           call _cb1q8(R1) args: 0, res: 0, upd: 0;
       cb1qg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1q8() //  [R1]
         { info_tbl: [(cb1q8,
                       label: block_cb1q8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1q8: // global
           _cb1qy::P64 = R1 & 7;
           if (_cb1qy::P64 < 3) goto ub1qC; else goto cb1qu;
       ub1qC: // global
           if (_cb1qy::P64 < 2) goto cb1qm; else goto cb1qq;
       cb1qm: // global
           (_sb0xS::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0xS::I64));
           goto ub1qL;
       cb1qq: // global
           (_sb0xX::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0xX::I64));
           goto ub1qL;
       cb1qu: // global
           (_sb0y2::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0y2::I64));
           goto ub1qL;
       ub1qL: // global
           call _cb1pO() args: 0, res: 0, upd: 0;
     }
 },
 _cb1pO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1pO: // global
           Hp = Hp + 32;
           _sb0xD::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1qd; else goto cb1qc;
       cb1qd: // global
           HpAlloc = 32;
           I64[Sp] = block_cb1pN_info;
           R1 = _sb0xD::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1qc: // global
           I64[Hp - 24] = sat_sb0xK_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sb0xD::I64;
           I64[Sp + 16] = block_cb1qa_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1pN() //  [R1]
         { info_tbl: [(cb1pN,
                       label: block_cb1pN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1pN: // global
           I64[Sp] = R1;
           call _cb1pO() args: 0, res: 0, upd: 0;
     }
 },
 _cb1qa() //  []
         { info_tbl: [(cb1qa,
                       label: block_cb1qa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1qa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.841520195 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1rv,
                       label: GHC.IO.FD.$fIODeviceFD17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1rv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1rw; else goto cb1rx;
       cb1rw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1rx: // global
           I64[Sp - 24] = block_cb1rs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1rB; else goto cb1rt;
       ub1rB: // global
           call _cb1rs(R1) args: 0, res: 0, upd: 0;
       cb1rt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1rs() //  [R1]
         { info_tbl: [(cb1rs,
                       label: block_cb1rs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1rs: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.846881921 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.848611034 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.850931893 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.852583227 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.85440285 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { info_tbl: [(cb1rW,
                       label: lvl4_raWVa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1rW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1rX; else goto cb1rY;
       cb1rX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1rY: // global
           (_cb1rT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1rT::I64 == 0) goto cb1rV; else goto cb1rU;
       cb1rV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1rU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1rT::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.858728734 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { info_tbl: [(cb1sd,
                       label: GHC.IO.FD.$fIODeviceFD11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1sd: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.862758818 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { info_tbl: [(cb1sq,
                       label: GHC.IO.FD.$wsetSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1sq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1sr; else goto cb1ss;
       cb1sr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1ss: // global
           I64[Sp - 16] = block_cb1so_info;
           _sb0ye::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _sb0ye::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1so() //  [R1]
         { info_tbl: [(cb1so,
                       label: block_cb1so_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1so: // global
           (_sb0yl::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_sb0yl::I64) == 0 :: W32) goto cb1sK; else goto cb1sE;
       cb1sK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1sE: // global
           (_sb0yq::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0yq::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.868821732 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { info_tbl: [(cb1t7,
                       label: GHC.IO.FD.$fIODeviceFD10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1t7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1t8; else goto cb1t9;
       cb1t8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1t9: // global
           I64[Sp - 16] = block_cb1t4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1td; else goto cb1t5;
       ub1td: // global
           call _cb1t4(R1) args: 0, res: 0, upd: 0;
       cb1t5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1t4() //  [R1]
         { info_tbl: [(cb1t4,
                       label: block_cb1t4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1t4: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.874444882 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1ts,
                       label: GHC.IO.FD.writeRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ts: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.878406033 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1tD,
                       label: GHC.IO.FD.readRawBufferPtrNoBlock_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1tD: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.881718747 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1tO,
                       label: GHC.IO.FD.readRawBufferPtr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1tO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.885854901 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1tW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1u2,
                       label: GHC.IO.FD.$w$cfillReadBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1u2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb1ud; else goto cb1ue;
       cb1ud: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb1ue: // global
           I64[Sp - 32] = block_cb1ua_info;
           _sb0yC::P64 = R6;
           R6 = 0;
           _sb0yB::P64 = R5;
           _sb0yF::I64 = I64[Sp + 16];
           R5 = R4 + _sb0yF::I64;
           _sb0yA::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _sb0yF::I64;
           I64[Sp - 24] = _sb0yA::I64;
           P64[Sp - 16] = _sb0yB::P64;
           P64[Sp - 8] = _sb0yC::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb1ua() //  [R1]
         { info_tbl: [(cb1ua,
                       label: block_cb1ua_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ua: // global
           I64[Sp] = block_cb1uc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1uD; else goto cb1ug;
       ub1uD: // global
           call _cb1uc(R1) args: 0, res: 0, upd: 0;
       cb1ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1uc() //  [R1]
         { info_tbl: [(cb1uc,
                       label: block_cb1uc_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1uc: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb1um; else goto cb1ul;
       cb1um: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ul: // global
           _sb0yA::I64 = I64[Sp + 8];
           _sb0yB::P64 = P64[Sp + 16];
           _sb0yC::P64 = P64[Sp + 24];
           _sb0yD::I64 = I64[Sp + 32];
           _sb0yE::I64 = I64[Sp + 40];
           _sb0yF::I64 = I64[Sp + 48];
           _sb0yP::I64 = I64[R1 + 7];
           if (_sb0yP::I64 == (-1)) goto cb1uC; else goto cb1ux;
       cb1uC: // global
           call MO_Touch(_sb0yB::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _sb0yB::P64;
           P64[Hp - 72] = _sb0yC::P64;
           I64[Hp - 64] = _sb0yA::I64;
           I64[Hp - 56] = _sb0yD::I64;
           I64[Hp - 48] = _sb0yE::I64;
           I64[Hp - 40] = _sb0yF::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _cb1uB::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cb1uB::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1ux: // global
           call MO_Touch(_sb0yB::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _sb0yB::P64;
           P64[Hp - 72] = _sb0yC::P64;
           I64[Hp - 64] = _sb0yA::I64;
           I64[Hp - 56] = _sb0yD::I64;
           I64[Hp - 48] = _sb0yE::I64;
           I64[Hp - 40] = _sb0yF::I64 + _sb0yP::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.897036454 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { info_tbl: [(cb1vi,
                       label: GHC.IO.FD.$fBufferedIOFD7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1vi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1vm; else goto cb1vn;
       cb1vm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1vn: // global
           I64[Sp - 16] = block_cb1vf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1vv; else goto cb1vg;
       ub1vv: // global
           call _cb1vf(R1) args: 0, res: 0, upd: 0;
       cb1vg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1vf() //  [R1]
         { info_tbl: [(cb1vf,
                       label: block_cb1vf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1vf: // global
           I64[Sp - 8] = block_cb1vl_info;
           _sb0z2::I64 = I64[R1 + 7];
           _sb0z3::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0z3::I64;
           I64[Sp + 8] = _sb0z2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1vu; else goto cb1vp;
       ub1vu: // global
           call _cb1vl(R1) args: 0, res: 0, upd: 0;
       cb1vp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1vl() //  [R1]
         { info_tbl: [(cb1vl,
                       label: block_cb1vl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1vl: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.906212375 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1vP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb0zu_entry() //  [R1]
         { info_tbl: [(cb1w9,
                       label: sat_sb0zu_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1w9: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb1wa; else goto cb1wb;
       cb1wa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1wb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb1w6_info;
           _sb0ze::P64 = P64[R1 + 16];
           _sb0zf::P64 = P64[R1 + 24];
           _sb0zd::I64 = I64[R1 + 40];
           _sb0zg::I64 = I64[R1 + 48];
           _sb0zh::I64 = I64[R1 + 56];
           _sb0zi::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _sb0zd::I64;
           P64[Sp - 56] = _sb0ze::P64;
           P64[Sp - 48] = _sb0zf::P64;
           I64[Sp - 40] = _sb0zg::I64;
           I64[Sp - 32] = _sb0zh::I64;
           I64[Sp - 24] = _sb0zi::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub1wt; else goto cb1w7;
       ub1wt: // global
           call _cb1w6(R1) args: 0, res: 0, upd: 0;
       cb1w7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1w6() //  [R1]
         { info_tbl: [(cb1w6,
                       label: block_cb1w6_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1w6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1wg; else goto cb1wf;
       cb1wg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1wf: // global
           _sb0zd::I64 = I64[Sp + 8];
           _sb0ze::P64 = P64[Sp + 16];
           _sb0zf::P64 = P64[Sp + 24];
           _sb0zg::I64 = I64[Sp + 32];
           _sb0zi::I64 = I64[Sp + 48];
           _sb0zs::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_sb0zs::I64 == _sb0zi::I64) goto cb1ws; else goto cb1wp;
       cb1ws: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0ze::P64;
           P64[Hp - 32] = _sb0zf::P64;
           I64[Hp - 24] = _sb0zd::I64;
           I64[Hp - 16] = _sb0zg::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1wp: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0ze::P64;
           P64[Hp - 32] = _sb0zf::P64;
           I64[Hp - 24] = _sb0zd::I64;
           I64[Hp - 16] = _sb0zg::I64;
           I64[Hp - 8] = _sb0zs::I64;
           I64[Hp] = _sb0zi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1wu,
                       label: GHC.IO.FD.$w$cflushWriteBuffer0_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1wu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1ww; else goto cb1wx;
       cb1ww: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb1wx: // global
           I64[Sp - 32] = block_cb1vZ_info;
           _sb0ze::P64 = R5;
           _sb0zh::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _sb0zh::I64;
           _sb0zd::I64 = R4;
           R4 = R4 + _sb0zh::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _sb0zd::I64;
           P64[Sp - 16] = _sb0ze::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1vZ() //  [R1]
         { info_tbl: [(cb1vZ,
                       label: block_cb1vZ_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1vZ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb1wA; else goto cb1wz;
       cb1wA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1wz: // global
           _sb0zd::I64 = I64[Sp + 8];
           _sb0ze::P64 = P64[Sp + 16];
           _sb0zf::P64 = P64[Sp + 24];
           _sb0zg::I64 = I64[Sp + 32];
           _sb0zh::I64 = I64[Sp + 40];
           _sb0zi::I64 = I64[Sp + 48];
           call MO_Touch(_sb0ze::P64);
           I64[Hp - 88] = sat_sb0zu_info;
           P64[Hp - 72] = _sb0ze::P64;
           P64[Hp - 64] = _sb0zf::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sb0zd::I64;
           I64[Hp - 40] = _sb0zg::I64;
           I64[Hp - 32] = _sb0zh::I64;
           I64[Hp - 24] = _sb0zi::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.919594994 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { info_tbl: [(cb1xf,
                       label: GHC.IO.FD.$fBufferedIOFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1xf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1xj; else goto cb1xk;
       cb1xj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1xk: // global
           I64[Sp - 16] = block_cb1xc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1xs; else goto cb1xd;
       ub1xs: // global
           call _cb1xc(R1) args: 0, res: 0, upd: 0;
       cb1xd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1xc() //  [R1]
         { info_tbl: [(cb1xc,
                       label: block_cb1xc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1xc: // global
           I64[Sp - 8] = block_cb1xi_info;
           _sb0zA::I64 = I64[R1 + 7];
           _sb0zB::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0zB::I64;
           I64[Sp + 8] = _sb0zA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1xr; else goto cb1xm;
       ub1xr: // global
           call _cb1xi(R1) args: 0, res: 0, upd: 0;
       cb1xm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1xi() //  [R1]
         { info_tbl: [(cb1xi,
                       label: block_cb1xi_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1xi: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.927852839 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_sb0zT_entry() //  [R1]
         { info_tbl: [(cb1y5,
                       label: sat_sb0zT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1y5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1y6; else goto cb1yh;
       cb1y6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1yh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto cb1y4; else goto cb1y3;
       cb1y4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1y3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { info_tbl: [(cb1yi,
                       label: GHC.IO.FD.$fIODeviceFD21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1yi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1yj; else goto cb1yk;
       cb1yj: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1yk: // global
           I64[Sp - 8] = block_cb1xP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1yo; else goto cb1xQ;
       ub1yo: // global
           call _cb1xP(R1) args: 0, res: 0, upd: 0;
       cb1xQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1xP() //  [R1]
         { info_tbl: [(cb1xP,
                       label: block_cb1xP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1xP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1yn; else goto cb1ym;
       cb1yn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ym: // global
           (_sb0zR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_sb0zT_info;
           I64[Hp] = _sb0zR::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.935901297 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { info_tbl: [(cb1yS,
                       label: GHC.IO.FD.$fIODeviceFD25_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1yS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1yT; else goto cb1yU;
       cb1yT: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1yU: // global
           I64[Sp - 8] = block_cb1yP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1z2; else goto cb1yQ;
       ub1z2: // global
           call _cb1yP(R1) args: 0, res: 0, upd: 0;
       cb1yQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1yP() //  [R1]
         { info_tbl: [(cb1yP,
                       label: block_cb1yP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1yP: // global
           if (I64[R1 + 7] == (-1)) goto cb1z1; else goto cb1z0;
       cb1z1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1z0: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.942010953 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.943875292 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { info_tbl: [(cb1zo,
                       label: GHC.IO.FD.$fIODeviceFD28_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1zo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1zp; else goto cb1zq;
       cb1zp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1zq: // global
           (_cb1zl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1zl::I64 == 0) goto cb1zn; else goto cb1zm;
       cb1zn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1zm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1zl::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.949011609 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_sb0Ad_entry() //  [R1]
         { info_tbl: [(cb1zP,
                       label: sat_sb0Ad_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1zP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1A5; else goto cb1A6;
       cb1A5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1A6: // global
           I64[Sp - 8] = block_cb1zZ_info;
           Sp = Sp - 8;
           _cb1zV::I64 = I64[R1 + 7];
           _cb1zW::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _cb1zX::I64 = I64[R1 + 15];
           _ub1Ac::P64 = CurrentTSO;
           I64[I64[_ub1Ac::P64 + 24] + 16] = Sp;
           _ub1Ad::I64 = CurrentNursery;
           P64[_ub1Ad::I64 + 8] = Hp + 8;
           I64[_ub1Ac::P64 + 104] = I64[_ub1Ac::P64 + 104] - ((Hp + 8) - I64[_ub1Ad::I64]);
           (_ub1Aa::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0Aa::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_cb1zV::I64, _cb1zW::I64, _cb1zX::I64, 0);
           (_ub1Ab::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub1Aa::I64);
           BaseReg = _ub1Ab::I64;
           _ub1Ae::P64 = CurrentTSO;
           _ub1Af::P64 = I64[_ub1Ae::P64 + 24];
           Sp = I64[_ub1Af::P64 + 16];
           SpLim = _ub1Af::P64 + 192;
           HpAlloc = 0;
           _ub1Ag::I64 = CurrentNursery;
           _ub1Ah::I64 = I64[_ub1Ag::I64 + 8];
           Hp = _ub1Ah::I64 - 8;
           _ub1Ai::I64 = I64[_ub1Ag::I64];
           HpLim = _ub1Ai::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub1Ag::I64 + 48]) << 12) - 1);
           I64[_ub1Ae::P64 + 104] = I64[_ub1Ae::P64 + 104] + (_ub1Ah::I64 - _ub1Ai::I64);
           R1 = _sb0Aa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1zZ() //  [R1]
         { info_tbl: [(cb1zZ,
                       label: block_cb1zZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1zZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1A9; else goto cb1A8;
       cb1A9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1A8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0Ak_entry() //  [R1]
         { info_tbl: [(cb1At,
                       label: sat_sb0Ak_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1At: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Au; else goto cb1Av;
       cb1Au: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Av: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1Aq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1AF; else goto cb1Ar;
       ub1AF: // global
           call _cb1Aq(R1) args: 0, res: 0, upd: 0;
       cb1Ar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1Aq() //  [R1]
         { info_tbl: [(cb1Aq,
                       label: block_cb1Aq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Aq: // global
           _sb0Aj::I64 = I64[R1 + 7];
           if (_sb0Aj::I64 != 0) goto ub1AE; else goto cb1AC;
       ub1AE: // global
           if (_sb0Aj::I64 != 1) goto cb1AB; else goto cb1AD;
       cb1AB: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cb1AD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1AC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1AN,
                       label: GHC.IO.FD.$w$cready_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 18} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1AN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1AO; else goto cb1AP;
       cb1AO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1AP: // global
           I64[Sp - 24] = block_cb1AG_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1B8; else goto cb1AH;
       ub1B8: // global
           call _cb1AG(R1) args: 0, res: 0, upd: 0;
       cb1AH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1AG() //  [R1]
         { info_tbl: [(cb1AG,
                       label: block_cb1AG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1AG: // global
           if (R1 & 7 == 1) goto cb1AK; else goto cb1AL;
       cb1AK: // global
           I64[Sp] = 0;
           goto ub1B7;
       cb1AL: // global
           I64[Sp] = 1;
           goto ub1B7;
       ub1B7: // global
           call _cb1zG() args: 0, res: 0, upd: 0;
     }
 },
 _cb1zG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1zG: // global
           Hp = Hp + 32;
           _sb0A3::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1AS; else goto cb1AR;
       cb1AS: // global
           HpAlloc = 32;
           I64[Sp] = block_cb1zF_info;
           R1 = _sb0A3::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1AR: // global
           I64[Hp - 24] = sat_sb0Ad_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sb0A3::I64;
           I64[Sp + 16] = block_cb1Ak_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1zF() //  [R1]
         { info_tbl: [(cb1zF,
                       label: block_cb1zF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1zF: // global
           I64[Sp] = R1;
           call _cb1zG() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Ak() //  [R1]
         { info_tbl: [(cb1Ak,
                       label: block_cb1Ak_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ak: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1AV; else goto cb1AU;
       cb1AV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1AU: // global
           I64[Hp - 16] = sat_sb0Ak_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.969574139 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1Cp,
                       label: GHC.IO.FD.$fIODeviceFD27_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Cp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Ct; else goto cb1Cu;
       cb1Ct: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Cu: // global
           I64[Sp - 24] = block_cb1Cm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1CC; else goto cb1Cn;
       ub1CC: // global
           call _cb1Cm(R1) args: 0, res: 0, upd: 0;
       cb1Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Cm() //  [R1]
         { info_tbl: [(cb1Cm,
                       label: block_cb1Cm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Cm: // global
           I64[Sp] = block_cb1Cs_info;
           _sb0Ar::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb0Ar::I64;
           if (R1 & 7 != 0) goto ub1CB; else goto cb1Cw;
       ub1CB: // global
           call _cb1Cs(R1) args: 0, res: 0, upd: 0;
       cb1Cw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Cs() //  [R1]
         { info_tbl: [(cb1Cs,
                       label: block_cb1Cs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Cs: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.97742432 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_sb0AF_entry() //  [R1]
         { info_tbl: [(cb1De,
                       label: sat_sb0AF_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1De: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1Df; else goto cb1Dg;
       cb1Df: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Dg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1D7_info;
           _sb0Az::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0Az::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1Dt; else goto cb1D8;
       ub1Dt: // global
           call _cb1D7(R1) args: 0, res: 0, upd: 0;
       cb1D8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1D7() //  [R1]
         { info_tbl: [(cb1D7,
                       label: block_cb1D7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1D7: // global
           _sb0Az::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1Db; else goto cb1Dc;
       cb1Db: // global
           Hp = Hp + 24;
           _sb0AE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1Ds; else goto cb1Dl;
       cb1Dl: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Az::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1Dc: // global
           Hp = Hp + 24;
           _sb0AE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1Ds; else goto cb1Dr;
       cb1Ds: // global
           HpAlloc = 24;
           R1 = _sb0AE::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1Dr: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Az::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { info_tbl: [(cb1Du,
                       label: GHC.IO.FD.setNonBlockingMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Du: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Dv; else goto cb1Dw;
       cb1Dv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Dw: // global
           I64[Sp - 16] = block_cb1CW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1DB; else goto cb1CX;
       ub1DB: // global
           call _cb1CW(R1) args: 0, res: 0, upd: 0;
       cb1CX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1CW() //  [R1]
         { info_tbl: [(cb1CW,
                       label: block_cb1CW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1CW: // global
           I64[Sp - 8] = block_cb1D1_info;
           R3 = P64[Sp + 8];
           _sb0Az::I64 = I64[R1 + 7];
           R2 = _sb0Az::I64;
           I64[Sp] = _sb0Az::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1D1() //  [R1]
         { info_tbl: [(cb1D1,
                       label: block_cb1D1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1D1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1DA; else goto cb1Dz;
       cb1DA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Dz: // global
           I64[Hp - 24] = sat_sb0AF_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.989974881 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { info_tbl: [(cb1Ee,
                       label: GHC.IO.FD.setNonBlockingMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ee: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.993434723 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.995150602 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { info_tbl: [(cb1Es,
                       label: lvl6_raWVc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Es: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Et; else goto cb1Eu;
       cb1Et: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Eu: // global
           (_cb1Ep::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Ep::I64 == 0) goto cb1Er; else goto cb1Eq;
       cb1Er: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Eq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Ep::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:00.998994607 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { info_tbl: [(cb1EJ,
                       label: GHC.IO.FD.$fIODeviceFD2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1EJ: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.002813605 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { info_tbl: [(cb1F2,
                       label: GHC.IO.FD.$w$cdup2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1F2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1F3; else goto cb1F4;
       cb1F3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1F4: // global
           _sb0AL::I64 = R4;
           _sb0AK::I64 = R3;
           _cb1EW::I64 = R4;
           (_sb0AQ::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _cb1EW::I64);
           _sb0AR::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0AQ::I64));
           if (_sb0AR::I64 != (-1)) goto ub1Fj; else goto cb1F1;
       ub1Fj: // global
           I64[Sp - 24] = _sb0AK::I64;
           I64[Sp - 16] = _sb0AL::I64;
           I64[Sp - 8] = _sb0AR::I64;
           Sp = Sp - 24;
           call _cb1F7() args: 0, res: 0, upd: 0;
       cb1F1: // global
           (_sb0AW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0AW::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb1F7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1F7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Fc; else goto cb1Fb;
       cb1Fc: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cb1F6_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1Fb: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1F6() //  [R1]
         { info_tbl: [(cb1F6,
                       label: block_cb1F6_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1F6: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cb1F7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.010099684 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { info_tbl: [(cb1FK,
                       label: GHC.IO.FD.$fIODeviceFD1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1FK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1FO; else goto cb1FP;
       cb1FO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1FP: // global
           I64[Sp - 16] = block_cb1FH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1FX; else goto cb1FI;
       ub1FX: // global
           call _cb1FH(R1) args: 0, res: 0, upd: 0;
       cb1FI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1FH() //  [R1]
         { info_tbl: [(cb1FH,
                       label: block_cb1FH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1FH: // global
           I64[Sp - 8] = block_cb1FN_info;
           _sb0B2::I64 = I64[R1 + 7];
           _sb0B3::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0B3::I64;
           I64[Sp + 8] = _sb0B2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1FW; else goto cb1FR;
       ub1FW: // global
           call _cb1FN(R1) args: 0, res: 0, upd: 0;
       cb1FR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1FN() //  [R1]
         { info_tbl: [(cb1FN,
                       label: block_cb1FN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1FN: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.017791776 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.019625463 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { info_tbl: [(cb1Gk,
                       label: GHC.IO.FD.$fIODeviceFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Gk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Gl; else goto cb1Gm;
       cb1Gl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Gm: // global
           (_cb1Gh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Gh::I64 == 0) goto cb1Gj; else goto cb1Gi;
       cb1Gj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Gi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Gh::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.024235963 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_sb0Bl_entry() //  [R1]
         { info_tbl: [(cb1GR,
                       label: sat_sb0Bl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1GR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1GV; else goto cb1GW;
       cb1GV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1GW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1GO_info;
           _sb0B8::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0B8::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1H0; else goto cb1GP;
       ub1H0: // global
           call _cb1GO(R1) args: 0, res: 0, upd: 0;
       cb1GP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1GO() //  [R1]
         { info_tbl: [(cb1GO,
                       label: block_cb1GO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1GO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1GZ; else goto cb1GY;
       cb1GZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1GY: // global
           _sb0Bk::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Bk::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { info_tbl: [(cb1H4,
                       label: GHC.IO.FD.$w$cdup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1H4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1H5; else goto cb1H6;
       cb1H5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1H6: // global
           _sb0B8::I64 = R3;
           (_sb0Bd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _sb0Be::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Bd::I64));
           if (_sb0Be::I64 != (-1)) goto ub1Hi; else goto cb1H3;
       ub1Hi: // global
           I64[Sp - 16] = _sb0B8::I64;
           I64[Sp - 8] = _sb0Be::I64;
           Sp = Sp - 16;
           call _cb1H8() args: 0, res: 0, upd: 0;
       cb1H3: // global
           I64[Sp - 16] = block_cb1GI_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _sb0B8::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1H8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1H8: // global
           Hp = Hp + 24;
           _sb0Be::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb1Hd; else goto cb1Hc;
       cb1Hd: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cb1H7_info;
           R1 = _sb0Be::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1Hc: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Be::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1H7() //  [R1]
         { info_tbl: [(cb1H7,
                       label: block_cb1H7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1H7: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb1H8() args: 0, res: 0, upd: 0;
     }
 },
 _cb1GI() //  [R1]
         { info_tbl: [(cb1GI,
                       label: block_cb1GI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1GI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1Hh; else goto cb1Hg;
       cb1Hh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Hg: // global
           I64[Hp - 24] = sat_sb0Bl_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.037996973 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { info_tbl: [(cb1I1,
                       label: GHC.IO.FD.$fIODeviceFD3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1I1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1I2; else goto cb1I3;
       cb1I2: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1I3: // global
           I64[Sp - 8] = block_cb1HY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1I7; else goto cb1HZ;
       ub1I7: // global
           call _cb1HY(R1) args: 0, res: 0, upd: 0;
       cb1HZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1HY() //  [R1]
         { info_tbl: [(cb1HY,
                       label: block_cb1HY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1HY: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.043851898 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_sb0Bw_entry() //  [R1]
         { info_tbl: [(cb1It,
                       label: sat_sb0Bw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1It: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Ix; else goto cb1Iy;
       cb1Ix: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Iy: // global
           I64[Sp - 8] = block_cb1Iq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1IC; else goto cb1Ir;
       ub1IC: // global
           call _cb1Iq(R1) args: 0, res: 0, upd: 0;
       cb1Ir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Iq() //  [R1]
         { info_tbl: [(cb1Iq,
                       label: block_cb1Iq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Iq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1IB; else goto cb1IA;
       cb1IB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1IA: // global
           _sb0Bu::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0Bu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { info_tbl: [(cb1II,
                       label: GHC.IO.FD.$fIODeviceFD6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1II: // global
           _sb0Br::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1IJ; else goto cb1IK;
       cb1IK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1IM; else goto cb1IL;
       cb1IM: // global
           HpAlloc = 24;
           goto cb1IJ;
       cb1IJ: // global
           R2 = _sb0Br::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1IL: // global
           I64[Hp - 16] = sat_sb0Bw_info;
           P64[Hp] = _sb0Br::P64;
           I64[Sp - 8] = block_cb1ID_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1ID() //  [R1]
         { info_tbl: [(cb1ID,
                       label: block_cb1ID_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ID: // global
           I64[Sp] = block_cb1IF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1IR; else goto cb1IG;
       ub1IR: // global
           call _cb1IF(R1) args: 0, res: 0, upd: 0;
       cb1IG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1IF() //  [R1]
         { info_tbl: [(cb1IF,
                       label: block_cb1IF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1IF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.055722668 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_sb0BJ_entry() //  [R1]
         { info_tbl: [(cb1Ju,
                       label: sat_sb0BJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ju: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Jy; else goto cb1Jz;
       cb1Jy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Jz: // global
           I64[Sp - 8] = block_cb1Jr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1JD; else goto cb1Js;
       ub1JD: // global
           call _cb1Jr(R1) args: 0, res: 0, upd: 0;
       cb1Js: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Jr() //  [R1]
         { info_tbl: [(cb1Jr,
                       label: block_cb1Jr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Jr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1JC; else goto cb1JB;
       cb1JC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1JB: // global
           _sb0BH::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0BH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0BS_entry() //  [R1]
         { info_tbl: [(cb1JX,
                       label: sat_sb0BS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1JX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1JY; else goto cb1JZ;
       cb1JY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1JZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1JP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1Ka; else goto cb1JQ;
       ub1Ka: // global
           call _cb1JP(R1) args: 0, res: 0, upd: 0;
       cb1JQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1JP() //  [R1]
         { info_tbl: [(cb1JP,
                       label: block_cb1JP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1JP: // global
           _cb1JW::P64 = R1 & 7;
           if (_cb1JW::P64 == 3) goto cb1JV; else goto ub1K9;
       ub1K9: // global
           if (_cb1JW::P64 == 4) goto cb1JV; else goto cb1JT;
       cb1JV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1JT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { info_tbl: [(cb1Kb,
                       label: GHC.IO.FD.$fIODeviceFD20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Kb: // global
           _sb0BE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Kc; else goto cb1Kd;
       cb1Kd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Kf; else goto cb1Ke;
       cb1Kf: // global
           HpAlloc = 24;
           goto cb1Kc;
       cb1Kc: // global
           R2 = _sb0BE::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Ke: // global
           I64[Hp - 16] = sat_sb0BJ_info;
           P64[Hp] = _sb0BE::P64;
           I64[Sp - 8] = block_cb1JE_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1JE() //  [R1]
         { info_tbl: [(cb1JE,
                       label: block_cb1JE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1JE: // global
           I64[Sp] = block_cb1JG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1Kk; else goto cb1JH;
       ub1Kk: // global
           call _cb1JG(R1) args: 0, res: 0, upd: 0;
       cb1JH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1JG() //  [R1]
         { info_tbl: [(cb1JG,
                       label: block_cb1JG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1JG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Kj; else goto cb1Ki;
       cb1Kj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Ki: // global
           _sb0BO::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sb0BS_info;
           P64[Hp] = _sb0BO::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.072090582 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { info_tbl: [(cb1L9,
                       label: GHC.IO.FD.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1L9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1La; else goto cb1Lb;
       cb1La: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Lb: // global
           I64[Sp - 8] = block_cb1L6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1Lh; else goto cb1L7;
       ub1Lh: // global
           call _cb1L6(R1) args: 0, res: 0, upd: 0;
       cb1L7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1L6() //  [R1]
         { info_tbl: [(cb1L6,
                       label: block_cb1L6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1L6: // global
           (_sb0C1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.077558623 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { info_tbl: [(cb1Ly,
                       label: GHC.IO.FD.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ly: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.080764134 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.082646152 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { info_tbl: [(cb1LM,
                       label: GHC.IO.FD.$fIODeviceFD23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1LM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1LN; else goto cb1LO;
       cb1LN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1LO: // global
           (_cb1LJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1LJ::I64 == 0) goto cb1LL; else goto cb1LK;
       cb1LL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1LK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1LJ::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.087300026 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_sb0Cc_entry() //  [R1]
         { info_tbl: [(cb1M8,
                       label: sat_sb0Cc_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1M8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1Mj; else goto cb1Mi;
       cb1Mj: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1Mi: // global
           (_sb0C9::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0C9::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { info_tbl: [(cb1Mm,
                       label: GHC.IO.FD.$wclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Mm: // global
           _sb0C2::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Mn; else goto cb1Mo;
       cb1Mo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1Mq; else goto cb1Mp;
       cb1Mq: // global
           HpAlloc = 16;
           goto cb1Mn;
       cb1Mn: // global
           R2 = _sb0C2::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Mp: // global
           I64[Hp - 8] = sat_sb0Cc_info;
           I64[Hp] = _sb0C2::I64;
           I64[Sp - 8] = block_cb1Mk_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Mk() //  []
         { info_tbl: [(cb1Mk,
                       label: block_cb1Mk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Mk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.095052545 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { info_tbl: [(cb1MS,
                       label: GHC.IO.FD.$fIODeviceFD26_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1MS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1MT; else goto cb1MU;
       cb1MT: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1MU: // global
           I64[Sp - 8] = block_cb1MP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1MY; else goto cb1MQ;
       ub1MY: // global
           call _cb1MP(R1) args: 0, res: 0, upd: 0;
       cb1MQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1MP() //  [R1]
         { info_tbl: [(cb1MP,
                       label: block_cb1MP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1MP: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.101048372 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_sb0CF_entry() //  [R1]
         { info_tbl: [(cb1Nq,
                       label: sat_sb0CF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Nq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1NB; else goto cb1NA;
       cb1NB: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1NA: // global
           (_sb0CC::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0CC::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { info_tbl: [(cb1NF,
                       label: GHC.IO.FD.$w$cclose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1NF: // global
           _sb0Ck::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1NG; else goto cb1NH;
       cb1NH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1NJ; else goto cb1NI;
       cb1NJ: // global
           HpAlloc = 16;
           goto cb1NG;
       cb1NG: // global
           R2 = _sb0Ck::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1NI: // global
           (_sb0Cp::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_sb0Ck::I64);
           (_sb0Ct::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0Ct::I64 == 0) goto cb1NE; else goto cb1ND;
       cb1NE: // global
           I64[Hp - 8] = sat_sb0CF_info;
           I64[Hp] = _sb0Ck::I64;
           I64[Sp - 8] = block_cb1NO_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       cb1ND: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Ck::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb1NO() //  []
         { info_tbl: [(cb1NO,
                       label: block_cb1NO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1NO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.109935592 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { info_tbl: [(cb1Oj,
                       label: GHC.IO.FD.$fIODeviceFD22_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Oj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Ok; else goto cb1Ol;
       cb1Ok: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Ol: // global
           I64[Sp - 8] = block_cb1Og_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1Op; else goto cb1Oh;
       ub1Op: // global
           call _cb1Og(R1) args: 0, res: 0, upd: 0;
       cb1Oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Og() //  [R1]
         { info_tbl: [(cb1Og,
                       label: block_cb1Og_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Og: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.115281078 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.117208751 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.119100659 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { info_tbl: [(cb1OI,
                       label: GHC.IO.FD.mkFD6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1OI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1OJ; else goto cb1OK;
       cb1OJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1OK: // global
           (_cb1OF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1OF::I64 == 0) goto cb1OH; else goto cb1OG;
       cb1OH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1OG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1OF::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.12322429 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.124970961 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { info_tbl: [(cb1P0,
                       label: GHC.IO.FD.mkFD10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1P0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1P1; else goto cb1P2;
       cb1P1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1P2: // global
           (_cb1OX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1OX::I64 == 0) goto cb1OZ; else goto cb1OY;
       cb1OZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1OY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1OX::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.128821451 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.130866354 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { info_tbl: [(cb1Pi,
                       label: GHC.IO.FD.mkFD8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Pi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Pj; else goto cb1Pk;
       cb1Pj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Pk: // global
           (_cb1Pf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Pf::I64 == 0) goto cb1Ph; else goto cb1Pg;
       cb1Ph: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Pg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Pf::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.135248206 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.137411707 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { info_tbl: [(cb1PA,
                       label: GHC.IO.FD.mkFD4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1PA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1PB; else goto cb1PC;
       cb1PB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1PC: // global
           (_cb1Px::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Px::I64 == 0) goto cb1Pz; else goto cb1Py;
       cb1Pz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Py: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Px::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.14111397 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.143366632 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { info_tbl: [(cb1PS,
                       label: GHC.IO.FD.mkFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1PS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1PT; else goto cb1PU;
       cb1PT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1PU: // global
           (_cb1PP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1PP::I64 == 0) goto cb1PR; else goto cb1PQ;
       cb1PR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1PQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1PP::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.150536246 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_sb0D2_entry() //  [R1]
         { info_tbl: [(cb1Qo,
                       label: sat_sb0D2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Qo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1Qp; else goto cb1Qq;
       cb1Qp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Qq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1Ql_info;
           _sb0CR::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sb0CR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1QO; else goto cb1Qm;
       ub1QO: // global
           call _cb1Ql(R1) args: 0, res: 0, upd: 0;
       cb1Qm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1Ql() //  [R1]
         { info_tbl: [(cb1Ql,
                       label: block_cb1Ql_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ql: // global
           I64[Sp] = block_cb1Qt_info;
           _sb0D0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb0D0::I64;
           if (R1 & 7 != 0) goto ub1QN; else goto cb1Qv;
       ub1QN: // global
           call _cb1Qt(R1) args: 0, res: 0, upd: 0;
       cb1Qv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1Qt() //  [R1]
         { info_tbl: [(cb1Qt,
                       label: block_cb1Qt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Qt: // global
           _sb0D0::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1QB; else goto cb1QI;
       cb1QB: // global
           Hp = Hp + 24;
           _sb0D1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1QL; else goto cb1QD;
       cb1QD: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D0::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1QI: // global
           Hp = Hp + 24;
           _sb0D1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1QL; else goto cb1QK;
       cb1QL: // global
           HpAlloc = 24;
           R1 = _sb0D1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1QK: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D0::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb0Dp_entry() //  [R1]
         { info_tbl: [(cb1RO,
                       label: sat_sb0Dp_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1RO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1RP; else goto cb1RQ;
       cb1RP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1RQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1RH_info;
           _sb0D6::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0D6::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1S3; else goto cb1RI;
       ub1S3: // global
           call _cb1RH(R1) args: 0, res: 0, upd: 0;
       cb1RI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb1RH() //  [R1]
         { info_tbl: [(cb1RH,
                       label: block_cb1RH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1RH: // global
           _sb0D6::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1RL; else goto cb1RM;
       cb1RL: // global
           Hp = Hp + 24;
           _sb0Do::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1S2; else goto cb1RV;
       cb1RV: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D6::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1RM: // global
           Hp = Hp + 24;
           _sb0Do::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1S2; else goto cb1S1;
       cb1S2: // global
           HpAlloc = 24;
           R1 = _sb0Do::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1S1: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D6::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb1Sb,
                       label: GHC.IO.FD.$wmkFD_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Sb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb1Sc; else goto cb1Sd;
       cb1Sc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Sd: // global
           I64[Sp - 32] = block_cb1S4_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1TI; else goto cb1S5;
       ub1TI: // global
           call _cb1S4(R1) args: 0, res: 0, upd: 0;
       cb1S5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1S4() //  [R1]
         { info_tbl: [(cb1S4,
                       label: block_cb1S4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1S4: // global
           if (R1 & 7 == 1) goto cb1S8; else goto cb1S9;
       cb1S8: // global
           I64[Sp] = block_cb1T6_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       cb1S9: // global
           I64[Sp] = block_cb1Ti_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub1TH; else goto cb1Tk;
       ub1TH: // global
           call _cb1Ti(R1) args: 0, res: 0, upd: 0;
       cb1Tk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1T6() //  [R1]
         { info_tbl: [(cb1T6,
                       label: block_cb1T6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1T6: // global
           I64[Sp] = block_cb1T8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1TK; else goto cb1Tb;
       ub1TK: // global
           call _cb1T8(R1) args: 0, res: 0, upd: 0;
       cb1Tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1T8() //  [R1]
         { info_tbl: [(cb1T8,
                       label: block_cb1T8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1T8: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _sb0CT() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Ti() //  [R1]
         { info_tbl: [(cb1Ti,
                       label: block_cb1Ti_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ti: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _sb0CT() args: 0, res: 0, upd: 0;
     }
 },
 _sb0CT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb0CT: // global
           I64[Sp - 8] = block_cb1Qc_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1TN; else goto cb1Qd;
       ub1TN: // global
           call _cb1Qc(R1) args: 0, res: 0, upd: 0;
       cb1Qd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Qc() //  [R1]
         { info_tbl: [(cb1Qc,
                       label: block_cb1Qc_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Qc: // global
           _cb1Tv::P64 = R1 & 7;
           if (_cb1Tv::P64 == 1) goto cb1Sn; else goto ub1Tx;
       cb1Sn: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ub1Tx: // global
           _sb0CO::P64 = P64[Sp + 32];
           if (_cb1Tv::P64 == 3) goto cb1Sp; else goto cb1Sh;
       cb1Sp: // global
           I64[Sp] = block_cb1QS_info;
           R1 = _sb0CO::P64;
           if (R1 & 7 != 0) goto ub1TC; else goto cb1QT;
       ub1TC: // global
           call _cb1QS(R1) args: 0, res: 0, upd: 0;
       cb1QT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Sh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1Sk; else goto cb1Sj;
       cb1Sk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Sj: // global
           I64[Hp - 48] = sat_sb0D2_info;
           P64[Hp - 32] = _sb0CO::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1QS() //  [R1]
         { info_tbl: [(cb1QS,
                       label: block_cb1QS_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1QS: // global
           _sb0CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb1QX_info;
           _sb0D6::I64 = I64[R1 + 7];
           R1 = _sb0CW::P64;
           I64[Sp + 32] = _sb0D6::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub1TD; else goto cb1QY;
       ub1TD: // global
           call _cb1QX(R1) args: 0, res: 0, upd: 0;
       cb1QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1QX() //  [R1]
         { info_tbl: [(cb1QX,
                       label: block_cb1QX_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1QX: // global
           _sb0CX::P64 = P64[Sp + 8];
           _sb0D8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sb0D8::I64, 0)) goto cb1T2; else goto cb1T3;
       cb1T2: // global
           _sb0Db::I64 = _sb0D8::I64;
           goto sb0Da;
       cb1T3: // global
           _sb0Db::I64 = _sb0D8::I64;
           goto sb0Da;
       sb0Da: // global
           I64[Sp + 8] = block_cb1Ra_info;
           R1 = _sb0CX::P64;
           I64[Sp + 16] = _sb0Db::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub1TE; else goto cb1Rb;
       ub1TE: // global
           call _cb1Ra(R1) args: 0, res: 0, upd: 0;
       cb1Rb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Ra() //  [R1]
         { info_tbl: [(cb1Ra,
                       label: block_cb1Ra_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Ra: // global
           _sb0CP::P64 = P64[Sp + 24];
           _sb0Dd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sb0Dd::I64, 0)) goto cb1SX; else goto cb1SY;
       cb1SX: // global
           _sb0Dg::I64 = _sb0Dd::I64;
           goto sb0Df;
       cb1SY: // global
           _sb0Dg::I64 = _sb0Dd::I64;
           goto sb0Df;
       sb0Df: // global
           I64[Sp] = block_cb1Su_info;
           R1 = _sb0CP::P64;
           I64[Sp + 24] = _sb0Dg::I64;
           if (R1 & 7 != 0) goto ub1TF; else goto cb1SJ;
       ub1TF: // global
           call _cb1Su(R1) args: 0, res: 0, upd: 0;
       cb1SJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Su() //  [R1]
         { info_tbl: [(cb1Su,
                       label: block_cb1Su_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Su: // global
           _sb0D6::I64 = I64[Sp + 16];
           _sb0Db::I64 = I64[Sp + 8];
           _sb0Dg::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb1ST; else goto cb1SP;
       cb1ST: // global
           _sb0Di::I64 = 0;
           goto sb0Dh;
       cb1SP: // global
           _sb0Di::I64 = 1;
           goto sb0Dh;
       sb0Dh: // global
           (_sb0Dm::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_sb0D6::I64, _sb0Db::I64, _sb0Dg::I64, _sb0Di::I64);
           _sb0Dn::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Dm::I64));
           if (_sb0Dn::I64 != (-1)) goto ub1TA; else goto cb1SF;
       ub1TA: // global
           I64[Sp + 24] = _sb0Dn::I64;
           Sp = Sp + 16;
           call _cb1RB() args: 0, res: 0, upd: 0;
       cb1SF: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1RB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1RB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1SC; else goto cb1SB;
       cb1SC: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb1RA_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1SB: // global
           I64[Hp - 48] = sat_sb0Dp_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1RA() //  [R1]
         { info_tbl: [(cb1RA,
                       label: block_cb1RA_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1RA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb1RB() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.187902505 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { info_tbl: [(cb1VP,
                       label: GHC.IO.FD.mkFD1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1VP: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.19129286 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb1W0,
                       label: GHC.IO.FD.mkFD_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1W0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.198962719 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_sb0Ea_entry() //  [R1]
         { info_tbl: [(cb1WF,
                       label: sat_sb0Ea_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1WF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1WI; else goto cb1WJ;
       cb1WI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1WJ: // global
           I64[Sp - 8] = block_cb1WB_info;
           Sp = Sp - 8;
           _cb1Wy::I64 = I64[R1 + 7];
           _cb1Wz::I64 = I64[R1 + 15];
           _ub1WP::P64 = CurrentTSO;
           I64[I64[_ub1WP::P64 + 24] + 16] = Sp;
           _ub1WQ::I64 = CurrentNursery;
           P64[_ub1WQ::I64 + 8] = Hp + 8;
           I64[_ub1WP::P64 + 104] = I64[_ub1WP::P64 + 104] - ((Hp + 8) - I64[_ub1WQ::I64]);
           (_ub1WN::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0E7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_cb1Wy::I64, _cb1Wz::I64, 438);
           (_ub1WO::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub1WN::I64);
           BaseReg = _ub1WO::I64;
           _ub1WR::P64 = CurrentTSO;
           _ub1WS::P64 = I64[_ub1WR::P64 + 24];
           Sp = I64[_ub1WS::P64 + 16];
           SpLim = _ub1WS::P64 + 192;
           HpAlloc = 0;
           _ub1WT::I64 = CurrentNursery;
           _ub1WU::I64 = I64[_ub1WT::I64 + 8];
           Hp = _ub1WU::I64 - 8;
           _ub1WV::I64 = I64[_ub1WT::I64];
           HpLim = _ub1WV::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub1WT::I64 + 48]) << 12) - 1);
           I64[_ub1WR::P64 + 104] = I64[_ub1WR::P64 + 104] + (_ub1WU::I64 - _ub1WV::I64);
           R1 = _sb0E7::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1WB() //  [R1]
         { info_tbl: [(cb1WB,
                       label: block_cb1WB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1WB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1WM; else goto cb1WL;
       cb1WM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1WL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0Er_entry() //  [R1]
         { info_tbl: [(cb1Xh,
                       label: sat_sb0Er_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Xh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Xi; else goto cb1Xj;
       cb1Xi: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1Xj: // global
           I64[Sp - 24] = block_cb1Xe_info;
           _sb0Ei::P64 = P64[R1 + 15];
           _sb0Ej::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sb0Ei::P64;
           P64[Sp - 8] = _sb0Ej::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1Xp; else goto cb1Xf;
       ub1Xp: // global
           call _cb1Xe(R1) args: 0, res: 0, upd: 0;
       cb1Xf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Xe() //  [R1]
         { info_tbl: [(cb1Xe,
                       label: block_cb1Xe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Xe: // global
           _sb0Ei::P64 = P64[Sp + 8];
           _sb0Ej::P64 = P64[Sp + 16];
           (_sb0Eq::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _sb0Ej::P64;
           R2 = _sb0Ei::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0Es_entry() //  [R1, R2]
         { info_tbl: [(cb1Xq,
                       label: sat_sb0Es_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Xq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Xr; else goto cb1Xs;
       cb1Xr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Xs: // global
           I64[Sp - 16] = block_cb1X4_info;
           _sb0Ed::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sb0Ed::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1Xw; else goto cb1X5;
       ub1Xw: // global
           call _cb1X4(R1) args: 0, res: 0, upd: 0;
       cb1X5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1X4() //  [R1]
         { info_tbl: [(cb1X4,
                       label: block_cb1X4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1X4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1Xv; else goto cb1Xu;
       cb1Xv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Xu: // global
           _sb0Ei::P64 = P64[R1 + 7];
           _sb0Ej::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sb0Er_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sb0Ei::P64;
           P64[Hp] = _sb0Ej::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0Ef_entry() //  [R1]
         { info_tbl: [(cb1XC,
                       label: sat_sb0Ef_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XC: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub22f_srtd" {
     ub22f_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_sb0FI_entry() //  [R1, R2]
         { info_tbl: [(cb1XF,
                       label: sat_sb0FI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1XG; else goto cb1XH;
       cb1XG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1XH: // global
           I64[Sp - 24] = block_cb1Wi_info;
           _sb0DR::P64 = P64[R1 + 6];
           _sb0DS::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb0DR::P64;
           P64[Sp - 8] = _sb0DS::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub21I; else goto cb1Wj;
       ub21I: // global
           call _cb1Wi(R1) args: 0, res: 0, upd: 0;
       cb1Wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22g_srtd" {
     ub22g_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1Wi() //  [R1]
         { info_tbl: [(cb1Wi,
                       label: block_cb1Wi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Wi: // global
           I64[Sp - 8] = block_cb1XI_info;
           _sb0E0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0E0::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub21G; else goto cb1YO;
       ub21G: // global
           call _cb1XI(R1) args: 0, res: 0, upd: 0;
       cb1YO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22h_srtd" {
     ub22h_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1XI() //  [R1]
         { info_tbl: [(cb1XI,
                       label: block_cb1XI_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XI: // global
           _sb0DR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cb1YV; else goto cb1ZH;
       cb1YV: // global
           I64[Sp] = block_cb1YS_info;
           R1 = _sb0DR::P64;
           if (R1 & 7 != 0) goto ub21J; else goto cb1YW;
       ub21J: // global
           call _cb1YS(R1) args: 0, res: 0, upd: 0;
       cb1YW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1ZH: // global
           I64[Sp] = block_cb1ZF_info;
           R1 = _sb0DR::P64;
           if (R1 & 7 != 0) goto ub21K; else goto cb1ZI;
       ub21K: // global
           call _cb1ZF(R1) args: 0, res: 0, upd: 0;
       cb1ZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22i_srtd" {
     ub22i_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1YS() //  [R1]
         { info_tbl: [(cb1YS,
                       label: block_cb1YS_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1YS: // global
           _cb21l::P64 = R1 & 7;
           if (_cb21l::P64 < 3) goto ub21p; else goto ub21q;
       ub21p: // global
           if (_cb21l::P64 < 2) goto cb1Z3; else goto cb1Zd;
       cb1Z3: // global
           I64[Sp] = block_cb1Z0_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub21T; else goto cb1Z4;
       ub21T: // global
           call _cb1Z0(R1) args: 0, res: 0, upd: 0;
       cb1Z4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Zd: // global
           I64[Sp] = block_cb1Zb_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub21U; else goto cb1Ze;
       ub21U: // global
           call _cb1Zb(R1) args: 0, res: 0, upd: 0;
       cb1Ze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21q: // global
           if (_cb21l::P64 < 4) goto cb1Zn; else goto cb1Zx;
       cb1Zn: // global
           I64[Sp] = block_cb1Zl_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub21V; else goto cb1Zo;
       ub21V: // global
           call _cb1Zl(R1) args: 0, res: 0, upd: 0;
       cb1Zo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Zx: // global
           I64[Sp] = block_cb1Zv_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub21W; else goto cb1Zy;
       ub21W: // global
           call _cb1Zv(R1) args: 0, res: 0, upd: 0;
       cb1Zy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22j_srtd" {
     ub22j_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Z0() //  [R1]
         { info_tbl: [(cb1Z0,
                       label: block_cb1Z0_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Z0: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22k_srtd" {
     ub22k_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zb() //  [R1]
         { info_tbl: [(cb1Zb,
                       label: block_cb1Zb_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Zb: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22l_srtd" {
     ub22l_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zl() //  [R1]
         { info_tbl: [(cb1Zl,
                       label: block_cb1Zl_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Zl: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22m_srtd" {
     ub22m_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zv() //  [R1]
         { info_tbl: [(cb1Zv,
                       label: block_cb1Zv_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Zv: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22n_srtd" {
     ub22n_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1ZF() //  [R1]
         { info_tbl: [(cb1ZF,
                       label: block_cb1ZF_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ZF: // global
           _cb20q::P64 = R1 & 7;
           if (_cb20q::P64 < 3) goto ub21r; else goto ub21s;
       ub21r: // global
           if (_cb20q::P64 < 2) goto cb1ZP; else goto cb1ZZ;
       cb1ZP: // global
           I64[Sp] = block_cb1ZM_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub221; else goto cb1ZQ;
       ub221: // global
           call _cb1ZM(R1) args: 0, res: 0, upd: 0;
       cb1ZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1ZZ: // global
           I64[Sp] = block_cb1ZX_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub222; else goto cb200;
       ub222: // global
           call _cb1ZX(R1) args: 0, res: 0, upd: 0;
       cb200: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21s: // global
           if (_cb20q::P64 < 4) goto cb209; else goto cb20j;
       cb209: // global
           I64[Sp] = block_cb207_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub223; else goto cb20a;
       ub223: // global
           call _cb207(R1) args: 0, res: 0, upd: 0;
       cb20a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb20j: // global
           I64[Sp] = block_cb20h_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub224; else goto cb20k;
       ub224: // global
           call _cb20h(R1) args: 0, res: 0, upd: 0;
       cb20k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22o_srtd" {
     ub22o_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1ZM() //  [R1]
         { info_tbl: [(cb1ZM,
                       label: block_cb1ZM_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ZM: // global
           _sb0F1::I64 = I64[R1 + 7];
           (_sb0F5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0F1::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0F5::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22p_srtd" {
     ub22p_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1ZX() //  [R1]
         { info_tbl: [(cb1ZX,
                       label: block_cb1ZX_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1ZX: // global
           _sb0Fc::I64 = I64[R1 + 7];
           (_sb0Fg::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fc::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Fg::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22q_srtd" {
     ub22q_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb207() //  [R1]
         { info_tbl: [(cb207,
                       label: block_cb207_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb207: // global
           _sb0Fn::I64 = I64[R1 + 7];
           (_sb0Fr::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fn::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Fr::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22r_srtd" {
     ub22r_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb20h() //  [R1]
         { info_tbl: [(cb20h,
                       label: block_cb20h_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb20h: // global
           _sb0Fy::I64 = I64[R1 + 7];
           (_sb0FC::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fy::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0FC::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Wq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Wq: // global
           Hp = Hp + 24;
           _sb0E2::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1XP; else goto cb1XO;
       cb1XP: // global
           HpAlloc = 24;
           I64[Sp] = block_cb1Wp_info;
           R1 = _sb0E2::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1XO: // global
           I64[Hp - 16] = sat_sb0Ea_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sb0E2::I64;
           I64[Sp + 8] = block_cb1WX_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22s_srtd" {
     ub22s_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Wp() //  [R1]
         { info_tbl: [(cb1Wp,
                       label: block_cb1Wp_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Wp: // global
           I64[Sp] = R1;
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub22t_srtd" {
     ub22t_srtd:
         const Sb0HW_srt+352;
         const 39;
         const 274877906945;
 },
 _cb1WX() //  [R1]
         { info_tbl: [(cb1WX,
                       label: block_cb1WX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1WX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb1XS; else goto cb1XR;
       cb1XS: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1XR: // global
           I64[Hp - 40] = sat_sb0Es_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sb0Ef_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cb1XK_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1XK() //  [R1]
         { info_tbl: [(cb1XK,
                       label: block_cb1XK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XK: // global
           I64[Sp] = block_cb1XM_info;
           _sb0Ev::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sb0Ev::P64;
           if (R1 & 7 != 0) goto ub21L; else goto cb1XU;
       ub21L: // global
           call _cb1XM(R1) args: 0, res: 0, upd: 0;
       cb1XU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1XM() //  [R1]
         { info_tbl: [(cb1XM,
                       label: block_cb1XM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XM: // global
           I64[Sp - 8] = block_cb1XY_info;
           _sb0Ex::P64 = P64[R1 + 7];
           _sb0Ey::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb0Ey::P64;
           P64[Sp + 8] = _sb0Ex::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub21M; else goto cb1Y0;
       ub21M: // global
           call _cb1XY(R1) args: 0, res: 0, upd: 0;
       cb1Y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1XY() //  [R1]
         { info_tbl: [(cb1XY,
                       label: block_cb1XY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1XY: // global
           if (R1 & 7 == 2) goto cb1Yb; else goto ub21C;
       cb1Yb: // global
           _sb0Ey::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb1Y9_info;
           R1 = _sb0Ey::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub21N; else goto cb1Yc;
       ub21N: // global
           call _cb1Y9(R1) args: 0, res: 0, upd: 0;
       cb1Yc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21C: // global
           Sp = Sp + 24;
           call _cb1Yi() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Y9() //  [R1]
         { info_tbl: [(cb1Y9,
                       label: block_cb1Y9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Y9: // global
           if (R1 & 7 == 3) goto cb1Yn; else goto ub21D;
       cb1Yn: // global
           I64[Sp + 16] = block_cb1Yl_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub21P; else goto cb1Yo;
       ub21P: // global
           call _cb1Yl(R1) args: 0, res: 0, upd: 0;
       cb1Yo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21D: // global
           Sp = Sp + 16;
           call _cb1Yi() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Yl() //  [R1]
         { info_tbl: [(cb1Yl,
                       label: block_cb1Yl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Yl: // global
           (_sb0EH::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _sb0EI::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0EH::I64));
           if (_sb0EI::I64 == 0) goto ub21E; else goto cb1YB;
       ub21E: // global
           I64[Sp - 8] = _sb0EI::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _cb1YH() args: 0, res: 0, upd: 0;
       cb1YB: // global
           (_sb0EM::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0EM::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb1YH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1YH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1YN; else goto cb1YM;
       cb1YN: // global
           HpAlloc = 24;
           _sb0EI::I64 = I64[Sp];
           I64[Sp] = block_cb1YG_info;
           R1 = _sb0EI::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1YM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1YG() //  [R1]
         { info_tbl: [(cb1YG,
                       label: block_cb1YG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1YG: // global
           I64[Sp] = R1;
           call _cb1YH() args: 0, res: 0, upd: 0;
     }
 },
 _cb1Yi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Yi: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub22u_srtd" {
     ub22u_srtd:
         const Sb0HW_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb229,
                       label: GHC.IO.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb229: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb22a; else goto cb22b;
       cb22a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb22b: // global
           I64[Sp - 32] = block_cb1Wb_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22v_srtd" {
     ub22v_srtd:
         const Sb0HW_srt+264;
         const 58;
         const 279788325873647617;
 },
 _cb1Wb() //  [R1]
         { info_tbl: [(cb1Wb,
                       label: block_cb1Wb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1Wb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb22e; else goto cb22d;
       cb22e: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb22d: // global
           I64[Hp - 16] = sat_sb0FI_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.275060312 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cb26b,
                       label: GHC.IO.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.27970316 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26j: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb0G2_entry() //  [R1]
         { info_tbl: [(cb26G,
                       label: sat_sb0G2_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26G: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb26N; else goto cb26O;
       cb26N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb26O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb26D_info;
           _sb0FM::P64 = P64[R1 + 16];
           _sb0FN::P64 = P64[R1 + 24];
           _sb0FL::I64 = I64[R1 + 40];
           _sb0FO::I64 = I64[R1 + 48];
           _sb0FP::I64 = I64[R1 + 56];
           _sb0FQ::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _sb0FL::I64;
           P64[Sp - 56] = _sb0FM::P64;
           P64[Sp - 48] = _sb0FN::P64;
           I64[Sp - 40] = _sb0FO::I64;
           I64[Sp - 32] = _sb0FP::I64;
           I64[Sp - 24] = _sb0FQ::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub26S; else goto cb26E;
       ub26S: // global
           call _cb26D(R1) args: 0, res: 0, upd: 0;
       cb26E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb26D() //  [R1]
         { info_tbl: [(cb26D,
                       label: block_cb26D_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26D: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb26R; else goto cb26Q;
       cb26R: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb26Q: // global
           _sb0G1::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sb0G1::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb26T,
                       label: GHC.IO.FD.$w$cfillReadBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [True, True, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb26V; else goto cb26W;
       cb26V: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb26W: // global
           I64[Sp - 32] = block_cb26w_info;
           _sb0FN::P64 = R6;
           R6 = 0;
           _sb0FM::P64 = R5;
           _sb0FQ::I64 = I64[Sp + 16];
           R5 = R4 + _sb0FQ::I64;
           _sb0FL::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _sb0FQ::I64;
           I64[Sp - 24] = _sb0FL::I64;
           P64[Sp - 16] = _sb0FM::P64;
           P64[Sp - 8] = _sb0FN::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb26w() //  [R1]
         { info_tbl: [(cb26w,
                       label: block_cb26w_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb26w: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb26Z; else goto cb26Y;
       cb26Z: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb26Y: // global
           _sb0FL::I64 = I64[Sp + 8];
           _sb0FM::P64 = P64[Sp + 16];
           _sb0FN::P64 = P64[Sp + 24];
           _sb0FO::I64 = I64[Sp + 32];
           _sb0FP::I64 = I64[Sp + 40];
           _sb0FQ::I64 = I64[Sp + 48];
           call MO_Touch(_sb0FM::P64);
           I64[Hp - 88] = sat_sb0G2_info;
           P64[Hp - 72] = _sb0FM::P64;
           P64[Hp - 64] = _sb0FN::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sb0FL::I64;
           I64[Hp - 40] = _sb0FO::I64;
           I64[Hp - 32] = _sb0FP::I64;
           I64[Hp - 24] = _sb0FQ::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.293088466 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { info_tbl: [(cb27I,
                       label: GHC.IO.FD.$fBufferedIOFD11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb27I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb27M; else goto cb27N;
       cb27M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb27N: // global
           I64[Sp - 16] = block_cb27F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub27V; else goto cb27G;
       ub27V: // global
           call _cb27F(R1) args: 0, res: 0, upd: 0;
       cb27G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb27F() //  [R1]
         { info_tbl: [(cb27F,
                       label: block_cb27F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb27F: // global
           I64[Sp - 8] = block_cb27L_info;
           _sb0G8::I64 = I64[R1 + 7];
           _sb0G9::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0G9::I64;
           I64[Sp + 8] = _sb0G8::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub27U; else goto cb27P;
       ub27U: // global
           call _cb27L(R1) args: 0, res: 0, upd: 0;
       cb27P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb27L() //  [R1]
         { info_tbl: [(cb27L,
                       label: block_cb27L_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb27L: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.301326541 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_sb0Gr_entry() //  [R1]
         { info_tbl: [(cb28p,
                       label: sat_sb0Gr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb28p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb28t; else goto cb28u;
       cb28t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb28u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb28m_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub28y; else goto cb28n;
       ub28y: // global
           call _cb28m(R1) args: 0, res: 0, upd: 0;
       cb28n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb28m() //  [R1]
         { info_tbl: [(cb28m,
                       label: block_cb28m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb28m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb28x; else goto cb28w;
       cb28x: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb28w: // global
           _sb0Gm::P64 = P64[R1 + 7];
           _sb0Gl::I64 = I64[R1 + 23];
           _sb0Go::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0Gm::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb0Gl::I64;
           I64[Hp - 16] = _sb0Go::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { info_tbl: [(cb28z,
                       label: GHC.IO.FD.$fBufferedIOFD6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb28z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb28D; else goto cb28C;
       cb28D: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb28C: // global
           I64[Hp - 16] = sat_sb0Gr_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.309572119 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.311706505 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { info_tbl: [(cb294,
                       label: GHC.IO.FD.FD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb294: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb298; else goto cb297;
       cb298: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb297: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.316064974 UTC

[GHC.IO.FD.FD_con_entry() //  [R1]
         { info_tbl: [(cb29f,
                       label: GHC.IO.FD.FD_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb29f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:01.319433335 UTC

[section ""relreadonly" . Sb0HW_srt" {
     Sb0HW_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]

