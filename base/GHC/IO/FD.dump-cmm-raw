
==================== Raw Cmm ====================
2018-03-16 16:05:55.634578739 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:55.637095708 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { []
         }
     {offset
       caZ14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ1d; else goto caZ1e;
       caZ1d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ1e: // global
           I64[Sp - 16] = block_caZ11_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZ1k; else goto caZ12;
       uaZ1k: // global
           call _caZ11(R1) args: 0, res: 0, upd: 0;
       caZ12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$WFD_info" {
     GHC.IO.FD.$WFD_info:
         const GHC.IO.FD.$WFD_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _caZ11() //  [R1]
         { []
         }
     {offset
       caZ11: // global
           I64[Sp] = block_caZ17_info;
           _saWVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saWVh::I64;
           if (R1 & 7 != 0) goto uaZ1j; else goto caZ18;
       uaZ1j: // global
           call _caZ17(R1) args: 0, res: 0, upd: 0;
       caZ18: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ11_info" {
     block_caZ11_info:
         const _caZ11;
         const 1;
         const 30;
 },
 _caZ17() //  [R1]
         { []
         }
     {offset
       caZ17: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZ1i; else goto caZ1h;
       caZ1i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ1h: // global
           _saWVj::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saWVj::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ17_info" {
     block_caZ17_info:
         const _caZ17;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.646250915 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZ1J: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caZ1K; else goto uaZ2j;
       caZ1K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uaZ2j: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _caZ1B() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD5_info" {
     GHC.IO.FD.$fBufferedIOFD5_info:
         const GHC.IO.FD.$fBufferedIOFD5_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const SaXeV_srt;
 },
 _caZ1B() //  []
         { []
         }
     {offset
       caZ1B: // global
           I64[Sp - 8] = block_caZ1E_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ1E() //  [R1]
         { []
         }
     {offset
       caZ1E: // global
           I64[Sp - 8] = block_caZ1G_info;
           _saWVq::P64 = R1;
           R1 = R1;
           P64[Sp] = _saWVq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ2l; else goto caZ1H;
       uaZ2l: // global
           call _caZ1G(R1) args: 0, res: 0, upd: 0;
       caZ1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ1E_info" {
     block_caZ1E_info:
         const _caZ1E;
         const 3;
         const 4294967326;
         const SaXeV_srt;
 },
 _caZ1G() //  [R1]
         { []
         }
     {offset
       caZ1G: // global
           if (I64[R1 + 7] == (-1)) goto caZ2h; else goto caZ1S;
       caZ2h: // global
           _saWVk::P64 = P64[Sp + 16];
           _saWVl::P64 = P64[Sp + 24];
           _saWVm::P64 = P64[Sp + 32];
           (_saWVx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _saWVy::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWVx::I64));
           if (_saWVy::I64 != 4) goto uaZ2i; else goto caZ27;
       uaZ2i: // global
           if (_saWVy::I64 != 11) goto caZ21; else goto caZ2d;
       caZ21: // global
           R2 = _saWVk::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       caZ2d: // global
           R1 = _saWVm::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       caZ27: // global
           P64[Sp + 16] = _saWVk::P64;
           P64[Sp + 24] = _saWVl::P64;
           P64[Sp + 32] = _saWVm::P64;
           Sp = Sp + 16;
           call _caZ1B() args: 0, res: 0, upd: 0;
       caZ1S: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ1G_info" {
     block_caZ1G_info:
         const _caZ1G;
         const 4;
         const 4294967326;
         const SaXeV_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.656773625 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.659878874 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { []
         }
     {offset
       caZ2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ2L; else goto caZ2M;
       caZ2L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ2M: // global
           (_caZ2H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ2H::I64 == 0) goto caZ2J; else goto caZ2I;
       caZ2J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ2I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ2H::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_raWUY_info" {
     lvl1_raWUY_info:
         const lvl1_raWUY_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.664687976 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.667605657 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { []
         }
     {offset
       caZ31: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ32; else goto caZ33;
       caZ32: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ33: // global
           (_caZ2Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ2Y::I64 == 0) goto caZ30; else goto caZ2Z;
       caZ30: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ2Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ2Y::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD8_info" {
     GHC.IO.FD.$fBufferedIOFD8_info:
         const GHC.IO.FD.$fBufferedIOFD8_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.672444518 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.674870718 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { []
         }
     {offset
       caZ3g: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD3_info" {
     GHC.IO.FD.$fBufferedIOFD3_info:
         const GHC.IO.FD.$fBufferedIOFD3_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.678467579 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.680371684 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.688149612 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { []
         }
     {offset
       caZ3r: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWVZ_entry() //  [R1]
         { []
         }
     {offset
       caZ3G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ3Q; else goto caZ3P;
       caZ3Q: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZ3P: // global
           (_saWVX::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWVX::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWVZ_info" {
     sat_saWVZ_info:
         const sat_saWVZ_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_saWWc_entry() //  [R1]
         { []
         }
     {offset
       caZ4a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZ4j; else goto caZ4k;
       caZ4j: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZ4k: // global
           I64[Sp - 8] = block_caZ4g_info;
           Sp = Sp - 8;
           _caZ4d::I64 = I64[R1 + 7];
           _caZ4e::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZ4f::I64 = I64[R1 + 31];
           _uaZ4q::P64 = CurrentTSO;
           I64[I64[_uaZ4q::P64 + 24] + 16] = Sp;
           _uaZ4r::I64 = CurrentNursery;
           P64[_uaZ4r::I64 + 8] = Hp + 8;
           I64[_uaZ4q::P64 + 104] = I64[_uaZ4q::P64 + 104] - ((Hp + 8) - I64[_uaZ4r::I64]);
           (_uaZ4o::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWWa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caZ4d::I64, _caZ4e::I64, _caZ4f::I64);
           (_uaZ4p::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZ4o::I64);
           BaseReg = _uaZ4p::I64;
           _uaZ4s::P64 = CurrentTSO;
           _uaZ4t::P64 = I64[_uaZ4s::P64 + 24];
           Sp = I64[_uaZ4t::P64 + 16];
           SpLim = _uaZ4t::P64 + 192;
           HpAlloc = 0;
           _uaZ4u::I64 = CurrentNursery;
           _uaZ4v::I64 = I64[_uaZ4u::I64 + 8];
           Hp = _uaZ4v::I64 - 8;
           _uaZ4w::I64 = I64[_uaZ4u::I64];
           HpLim = _uaZ4w::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZ4u::I64 + 48]) << 12) - 1);
           I64[_uaZ4s::P64 + 104] = I64[_uaZ4s::P64 + 104] + (_uaZ4v::I64 - _uaZ4w::I64);
           R1 = _saWWa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWWc_info" {
     sat_saWWc_info:
         const sat_saWWc_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _caZ4g() //  [R1]
         { []
         }
     {offset
       caZ4g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ4n; else goto caZ4m;
       caZ4n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZ4m: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ4g_info" {
     block_caZ4g_info:
         const _caZ4g;
         const 0;
         const 30;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { []
         }
     {offset
       caZ4B: // global
           _saWVE::I64 = R6;
           _saWVD::I64 = R5;
           _saWVC::I64 = R4;
           _saWVB::I64 = R3;
           _saWVA::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZ4C; else goto caZ4D;
       caZ4D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZ4F; else goto caZ4E;
       caZ4F: // global
           HpAlloc = 40;
           goto caZ4C;
       caZ4C: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVC::I64;
           I64[Sp - 16] = _saWVD::I64;
           I64[Sp - 8] = _saWVE::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZ4E: // global
           if (_saWVC::I64 == 0) goto caZ4A; else goto caZ4z;
       caZ4A: // global
           (_saWW3::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWVB::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWW4::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWW3::I64));
           if (_saWW4::I64 != 0) goto uaZ5f; else goto caZ59;
       uaZ5f: // global
           P64[Sp - 40] = _saWVA::P64;
           I64[Sp - 32] = _saWVB::I64;
           I64[Sp - 24] = _saWVD::I64;
           I64[Sp - 16] = _saWVE::I64;
           I64[Sp - 8] = _saWW4::I64;
           Sp = Sp - 40;
           call _caZ41() args: 0, res: 0, upd: 0;
       caZ59: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ4z: // global
           I64[Hp - 32] = sat_saWVZ_info;
           I64[Hp - 24] = _saWVB::I64;
           I64[Hp - 16] = _saWVD::I64;
           I64[Hp - 8] = _saWVE::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWVA::P64;
           Sp = Sp - 8;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_info" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_info:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry;
         const 0;
         const 12884901902;
         const 30064771072;
         const SaXeV_srt+8;
         const 3974;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow;
 },
 _caZ41() //  []
         { []
         }
     {offset
       caZ41: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZ56; else goto caZ55;
       caZ56: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caZ40_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZ55: // global
           I64[Hp - 32] = sat_saWWc_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _saWVH() args: 0, res: 0, upd: 0;
     }
 },
 _caZ40() //  [R1]
         { []
         }
     {offset
       caZ40: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZ41() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZ40_info" {
     block_caZ40_info:
         const _caZ40;
         const 3974;
         const 4294967326;
         const SaXeV_srt+8;
 },
 _saWVH() //  []
         { []
         }
     {offset
       saWVH: // global
           _saWVA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caZ4J_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _saWVA::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZ4J() //  [R1]
         { []
         }
     {offset
       caZ4J: // global
           I64[Sp] = block_caZ4L_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZ5m; else goto caZ4O;
       uaZ5m: // global
           call _caZ4L(R1) args: 0, res: 0, upd: 0;
       caZ4O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ4J_info" {
     block_caZ4J_info:
         const _caZ4J;
         const 0;
         const 30;
 },
 _caZ4L() //  [R1]
         { []
         }
     {offset
       caZ4L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ4U; else goto caZ4T;
       caZ4U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ4T: // global
           _saWVP::I64 = I64[R1 + 7];
           if (_saWVP::I64 != (-1)) goto uaZ5d; else goto caZ50;
       uaZ5d: // global
           if (_saWVP::I64 != 0) goto caZ4Z; else goto caZ51;
       caZ4Z: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ51: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ50: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ4L_info" {
     block_caZ4L_info:
         const _caZ4L;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.70913755 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZ6y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZ6M; else goto caZ6N;
       caZ6M: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ6N: // global
           I64[Sp - 40] = block_caZ6v_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZ6X; else goto caZ6w;
       uaZ6X: // global
           call _caZ6v(R1) args: 0, res: 0, upd: 0;
       caZ6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtrNoBlock1_info" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_info:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const SaXeV_srt+16;
 },
 _caZ6v() //  [R1]
         { []
         }
     {offset
       caZ6v: // global
           I64[Sp - 8] = block_caZ6B_info;
           _saWWk::I64 = I64[R1 + 7];
           _saWWl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWWl::I64;
           I64[Sp + 16] = _saWWk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ6W; else goto caZ6C;
       uaZ6W: // global
           call _caZ6B(R1) args: 0, res: 0, upd: 0;
       caZ6C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ6v_info" {
     block_caZ6v_info:
         const _caZ6v;
         const 4;
         const 4294967326;
         const SaXeV_srt+16;
 },
 _caZ6B() //  [R1]
         { []
         }
     {offset
       caZ6B: // global
           I64[Sp] = block_caZ6G_info;
           _saWWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWWn::I64;
           if (R1 & 7 != 0) goto uaZ6Y; else goto caZ6H;
       uaZ6Y: // global
           call _caZ6G(R1) args: 0, res: 0, upd: 0;
       caZ6H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ6B_info" {
     block_caZ6B_info:
         const _caZ6B;
         const 325;
         const 4294967326;
         const SaXeV_srt+16;
 },
 _caZ6G() //  [R1]
         { []
         }
     {offset
       caZ6G: // global
           I64[Sp] = block_caZ6L_info;
           _saWWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWWp::I64;
           if (R1 & 7 != 0) goto uaZ6Z; else goto caZ6R;
       uaZ6Z: // global
           call _caZ6L(R1) args: 0, res: 0, upd: 0;
       caZ6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ6G_info" {
     block_caZ6G_info:
         const _caZ6G;
         const 837;
         const 4294967326;
         const SaXeV_srt+16;
 },
 _caZ6L() //  [R1]
         { []
         }
     {offset
       caZ6L: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ6L_info" {
     block_caZ6L_info:
         const _caZ6L;
         const 1861;
         const 4294967326;
         const SaXeV_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.720372857 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { []
         }
     {offset
       caZ7n: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caZ7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ7y; else goto caZ7z;
       caZ7y: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caZ7z: // global
           I64[Sp - 8] = block_caZ7v_info;
           R6 = 0;
           _saWWx::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _saWWx::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$creadNonBlocking_info" {
     GHC.IO.FD.$w$creadNonBlocking_info:
         const GHC.IO.FD.$w$creadNonBlocking_entry;
         const 0;
         const 55834574862;
         const 21474836480;
         const SaXeV_srt+16;
         const 964;
         const GHC.IO.FD.$w$creadNonBlocking_slow;
 },
 _caZ7v() //  [R1]
         { []
         }
     {offset
       caZ7v: // global
           I64[Sp] = block_caZ7x_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZ7O; else goto caZ7B;
       uaZ7O: // global
           call _caZ7x(R1) args: 0, res: 0, upd: 0;
       caZ7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ7v_info" {
     block_caZ7v_info:
         const _caZ7v;
         const 0;
         const 30;
 },
 _caZ7x() //  [R1]
         { []
         }
     {offset
       caZ7x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZ7H; else goto caZ7G;
       caZ7H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZ7G: // global
           if (I64[R1 + 7] == (-1)) goto caZ7N; else goto caZ7M;
       caZ7N: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ7M: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ7x_info" {
     block_caZ7x_info:
         const _caZ7x;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.729655086 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZ8c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZ8l; else goto caZ8m;
       caZ8l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ8m: // global
           I64[Sp - 24] = block_caZ89_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZ8v; else goto caZ8a;
       uaZ8v: // global
           call _caZ89(R1) args: 0, res: 0, upd: 0;
       caZ8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD3_info" {
     GHC.IO.FD.$fRawIOFD3_info:
         const GHC.IO.FD.$fRawIOFD3_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const SaXeV_srt+40;
 },
 _caZ89() //  [R1]
         { []
         }
     {offset
       caZ89: // global
           I64[Sp - 8] = block_caZ8f_info;
           _saWWK::I64 = I64[R1 + 7];
           _saWWL::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWWL::I64;
           I64[Sp + 8] = _saWWK::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ8u; else goto caZ8g;
       uaZ8u: // global
           call _caZ8f(R1) args: 0, res: 0, upd: 0;
       caZ8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ89_info" {
     block_caZ89_info:
         const _caZ89;
         const 2;
         const 4294967326;
         const SaXeV_srt+40;
 },
 _caZ8f() //  [R1]
         { []
         }
     {offset
       caZ8f: // global
           I64[Sp] = block_caZ8k_info;
           _saWWN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWWN::I64;
           if (R1 & 7 != 0) goto uaZ8w; else goto caZ8p;
       uaZ8w: // global
           call _caZ8k(R1) args: 0, res: 0, upd: 0;
       caZ8p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ8f_info" {
     block_caZ8f_info:
         const _caZ8f;
         const 195;
         const 4294967326;
         const SaXeV_srt+40;
 },
 _caZ8k() //  [R1]
         { []
         }
     {offset
       caZ8k: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ8k_info" {
     block_caZ8k_info:
         const _caZ8k;
         const 451;
         const 4294967326;
         const SaXeV_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.738338526 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.740759578 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { []
         }
     {offset
       caZ8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ8W; else goto caZ8X;
       caZ8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ8X: // global
           (_caZ8S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ8S::I64 == 0) goto caZ8U; else goto caZ8T;
       caZ8U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ8T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ8S::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD_loc_info" {
     GHC.IO.FD.$fBufferedIOFD_loc_info:
         const GHC.IO.FD.$fBufferedIOFD_loc_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.745151167 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { []
         }
     {offset
       caZ9c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZ9d; else goto caZ9e;
       caZ9d: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZ9e: // global
           I64[Sp - 8] = block_caZ99_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZ9m; else goto caZ9a;
       uaZ9m: // global
           call _caZ99(R1) args: 0, res: 0, upd: 0;
       caZ9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD14_info" {
     GHC.IO.FD.$fBufferedIOFD14_info:
         const GHC.IO.FD.$fBufferedIOFD14_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZ99() //  [R1]
         { []
         }
     {offset
       caZ99: // global
           if (I64[R1 + 7] == (-1)) goto caZ9l; else goto caZ9k;
       caZ9l: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZ9k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZ99_info" {
     block_caZ99_info:
         const _caZ99;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.750344413 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.752741937 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { []
         }
     {offset
       caZ9F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZ9G; else goto caZ9H;
       caZ9G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZ9H: // global
           (_caZ9C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZ9C::I64 == 0) goto caZ9E; else goto caZ9D;
       caZ9E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZ9D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZ9C::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD12_info" {
     GHC.IO.FD.$fBufferedIOFD12_info:
         const GHC.IO.FD.$fBufferedIOFD12_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.765961718 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { []
         }
     {offset
       caZ9Q: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWXe_entry() //  [R1]
         { []
         }
     {offset
       caZa9: // global
           _saWXe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caZaa; else goto caZab;
       caZab: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZad; else goto caZac;
       caZad: // global
           HpAlloc = 16;
           goto caZaa;
       caZaa: // global
           R1 = _saWXe::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZac: // global
           _saWWV::I64 = I64[_saWXe::P64 + 7];
           (_saWX8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWX8::I64 == 0) goto caZa8; else goto caZa7;
       caZa8: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZan_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caZa7: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWXe_info" {
     sat_saWXe_info:
         const sat_saWXe_entry;
         const 4294967296;
         const 12884901898;
         const 4294967299;
         const SaXeV_srt+56;
 },
 _caZan() //  []
         { []
         }
     {offset
       caZan: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZan_info" {
     block_caZan_info:
         const _caZan;
         const 0;
         const 30;
 },
 sat_saWXk_entry() //  [R1]
         { []
         }
     {offset
       caZaz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZaD; else goto caZaE;
       caZaD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZaE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZaw_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZaI; else goto caZax;
       uaZaI: // global
           call _caZaw(R1) args: 0, res: 0, upd: 0;
       caZax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saWXk_info" {
     sat_saWXk_info:
         const sat_saWXk_entry;
         const 1;
         const 16;
 },
 _caZaw() //  [R1]
         { []
         }
     {offset
       caZaw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZaH; else goto caZaG;
       caZaH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZaG: // global
           _saWXj::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saWXj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZaw_info" {
     block_caZaw_info:
         const _caZaw;
         const 0;
         const 30;
 },
 sat_saWXt_entry() //  [R1]
         { []
         }
     {offset
       caZaS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZb2; else goto caZb1;
       caZb2: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZb1: // global
           (_saWXr::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXr::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWXt_info" {
     sat_saWXt_info:
         const sat_saWXt_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_saWXP_entry() //  [R1]
         { []
         }
     {offset
       caZbt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZbC; else goto caZbD;
       caZbC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZbD: // global
           I64[Sp - 8] = block_caZbz_info;
           Sp = Sp - 8;
           _caZbw::I64 = I64[R1 + 7];
           _caZbx::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZby::I64 = I64[R1 + 31];
           _uaZbJ::P64 = CurrentTSO;
           I64[I64[_uaZbJ::P64 + 24] + 16] = Sp;
           _uaZbK::I64 = CurrentNursery;
           P64[_uaZbK::I64 + 8] = Hp + 8;
           I64[_uaZbJ::P64 + 104] = I64[_uaZbJ::P64 + 104] - ((Hp + 8) - I64[_uaZbK::I64]);
           (_uaZbH::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWXN::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_caZbw::I64, _caZbx::I64, _caZby::I64);
           (_uaZbI::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZbH::I64);
           BaseReg = _uaZbI::I64;
           _uaZbL::P64 = CurrentTSO;
           _uaZbM::P64 = I64[_uaZbL::P64 + 24];
           Sp = I64[_uaZbM::P64 + 16];
           SpLim = _uaZbM::P64 + 192;
           HpAlloc = 0;
           _uaZbN::I64 = CurrentNursery;
           _uaZbO::I64 = I64[_uaZbN::I64 + 8];
           Hp = _uaZbO::I64 - 8;
           _uaZbP::I64 = I64[_uaZbN::I64];
           HpLim = _uaZbP::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZbN::I64 + 48]) << 12) - 1);
           I64[_uaZbL::P64 + 104] = I64[_uaZbL::P64 + 104] + (_uaZbO::I64 - _uaZbP::I64);
           R1 = _saWXN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWXP_info" {
     sat_saWXP_info:
         const sat_saWXP_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _caZbz() //  [R1]
         { []
         }
     {offset
       caZbz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZbG; else goto caZbF;
       caZbG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZbF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZbz_info" {
     block_caZbz_info:
         const _caZbz;
         const 0;
         const 30;
 },
 sat_saWXX_entry() //  [R1]
         { []
         }
     {offset
       caZbZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZc9; else goto caZc8;
       caZc9: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZc8: // global
           (_saWXV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWXV::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWXX_info" {
     sat_saWXX_info:
         const sat_saWXX_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZcd: // global
           _saWWY::I64 = R6;
           _saWWX::I64 = R5;
           _saWWW::I64 = R4;
           _saWWV::I64 = R3;
           _saWWU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZce; else goto caZcf;
       caZcf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZch; else goto caZcg;
       caZch: // global
           HpAlloc = 40;
           goto caZce;
       caZce: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWW::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZcg: // global
           if (_saWWW::I64 == 0) goto caZcc; else goto caZcb;
       caZcc: // global
           (_saWXx::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWWV::I64, 0, 0, 0);
           Hp = Hp - 40;
           _saWYb::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWXx::I64));
           if (_saWYb::I64 != (-1)) goto caZd2; else goto caZdd;
       caZd2: // global
           P64[Sp - 40] = _saWWU::P64;
           I64[Sp - 32] = _saWWV::I64;
           I64[Sp - 24] = _saWWX::I64;
           I64[Sp - 16] = _saWWY::I64;
           I64[Sp - 8] = _saWYb::I64;
           Sp = Sp - 40;
           call _caZbc() args: 0, res: 0, upd: 0;
       caZdd: // global
           I64[Sp - 40] = block_caZda_info;
           R2 = _saWWU::P64;
           P64[Sp - 32] = _saWWU::P64;
           I64[Sp - 24] = _saWWV::I64;
           I64[Sp - 16] = _saWWX::I64;
           I64[Sp - 8] = _saWWY::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caZcb: // global
           I64[Hp - 32] = sat_saWXt_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWWV::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWWU::P64;
           Sp = Sp - 16;
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wreadRawBufferPtr_info" {
     GHC.IO.FD.$wreadRawBufferPtr_info:
         const GHC.IO.FD.$wreadRawBufferPtr_entry;
         const 0;
         const 8250632175630;
         const 30064771072;
         const SaXeV_srt;
         const 3974;
         const GHC.IO.FD.$wreadRawBufferPtr_slow;
 },
 _caZda() //  [R1]
         { []
         }
     {offset
       caZda: // global
           I64[Sp] = block_caZdc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZdB; else goto caZdg;
       uaZdB: // global
           call _caZdc(R1) args: 0, res: 0, upd: 0;
       caZdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZda_info" {
     block_caZda_info:
         const _caZda;
         const 1925;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZdc() //  [R1]
         { []
         }
     {offset
       caZdc: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _caZbc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZdc_info" {
     block_caZdc_info:
         const _caZdc;
         const 1925;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZbc() //  []
         { []
         }
     {offset
       caZbc: // global
           Hp = Hp + 16;
           _saWXA::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caZcq; else goto caZcp;
       caZcq: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZbb_info;
           R1 = _saWXA::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZcp: // global
           if (_saWXA::I64 == 0) goto caZcW; else goto caZcz;
       caZcW: // global
           _saWWV::I64 = I64[Sp + 8];
           (_saWY2::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWY2::I64 == 0) goto caZcT; else goto caZcL;
       caZcT: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZbh_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       caZcL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWWV::I64));
           I64[Sp - 8] = block_caZcJ_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       caZcz: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _caZbh() args: 0, res: 0, upd: 0;
     }
 },
 _caZbb() //  [R1]
         { []
         }
     {offset
       caZbb: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZbc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZbb_info" {
     block_caZbb_info:
         const _caZbb;
         const 3974;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZcJ() //  []
         { []
         }
     {offset
       caZcJ: // global
           call _caZbh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZcJ_info" {
     block_caZcJ_info:
         const _caZcJ;
         const 3974;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZbh() //  []
         { []
         }
     {offset
       caZbh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZct; else goto caZcs;
       caZct: // global
           HpAlloc = 40;
           I64[Sp] = block_caZbh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caZcs: // global
           _saWWU::P64 = P64[Sp + 8];
           _saWWV::I64 = I64[Sp + 16];
           _saWWX::I64 = I64[Sp + 24];
           _saWWY::I64 = I64[Sp + 32];
           _saWWZ::I64 = I64[Sp + 48];
           (_saWXG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWXG::I64 == 0) goto caZcw; else goto caZcv;
       caZcw: // global
           I64[Hp - 32] = sat_saWXX_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaZdx;
       caZcv: // global
           I64[Hp - 32] = sat_saWXP_info;
           I64[Hp - 24] = _saWWV::I64;
           I64[Hp - 16] = _saWWX::I64;
           I64[Hp - 8] = _saWWY::I64;
           I64[Hp] = _saWWZ::I64;
           P64[Sp + 48] = _saWWU::P64;
           I64[Sp + 32] = _saWWV::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto uaZdx;
       uaZdx: // global
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZbh_info" {
     block_caZbh_info:
         const _caZbh;
         const 3974;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZ9X() //  []
         { []
         }
     {offset
       caZ9X: // global
           Hp = Hp + 16;
           _saWX2::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZck; else goto caZcj;
       caZck: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZ9W_info;
           R1 = _saWX2::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZcj: // global
           I64[Hp - 8] = sat_saWXe_info;
           I64[Hp] = I64[Sp];
           _saWWU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caZaq_info;
           R5 = Hp - 7;
           R4 = _saWX2::P64;
           R3 = _saWWU::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZ9W() //  [R1]
         { []
         }
     {offset
       caZ9W: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZ9X() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZ9W_info" {
     block_caZ9W_info:
         const _caZ9W;
         const 195;
         const 30064771102;
         const SaXeV_srt+56;
 },
 _caZaq() //  [R1]
         { []
         }
     {offset
       caZaq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZcn; else goto caZcm;
       caZcn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZcm: // global
           I64[Hp - 16] = sat_saWXk_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZaq_info" {
     block_caZaq_info:
         const _caZaq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.80240034 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZfo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZfC; else goto caZfD;
       caZfC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZfD: // global
           I64[Sp - 40] = block_caZfl_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZfN; else goto caZfm;
       uaZfN: // global
           call _caZfl(R1) args: 0, res: 0, upd: 0;
       caZfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD5_info" {
     GHC.IO.FD.$fRawIOFD5_info:
         const GHC.IO.FD.$fRawIOFD5_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const SaXeV_srt+80;
 },
 _caZfl() //  [R1]
         { []
         }
     {offset
       caZfl: // global
           I64[Sp - 8] = block_caZfr_info;
           _saWYo::I64 = I64[R1 + 7];
           _saWYp::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saWYp::I64;
           I64[Sp + 16] = _saWYo::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZfM; else goto caZfs;
       uaZfM: // global
           call _caZfr(R1) args: 0, res: 0, upd: 0;
       caZfs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZfl_info" {
     block_caZfl_info:
         const _caZfl;
         const 4;
         const 4294967326;
         const SaXeV_srt+80;
 },
 _caZfr() //  [R1]
         { []
         }
     {offset
       caZfr: // global
           I64[Sp] = block_caZfw_info;
           _saWYr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saWYr::I64;
           if (R1 & 7 != 0) goto uaZfO; else goto caZfx;
       uaZfO: // global
           call _caZfw(R1) args: 0, res: 0, upd: 0;
       caZfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZfr_info" {
     block_caZfr_info:
         const _caZfr;
         const 325;
         const 4294967326;
         const SaXeV_srt+80;
 },
 _caZfw() //  [R1]
         { []
         }
     {offset
       caZfw: // global
           I64[Sp] = block_caZfB_info;
           _saWYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saWYt::I64;
           if (R1 & 7 != 0) goto uaZfP; else goto caZfH;
       uaZfP: // global
           call _caZfB(R1) args: 0, res: 0, upd: 0;
       caZfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZfw_info" {
     block_caZfw_info:
         const _caZfw;
         const 837;
         const 4294967326;
         const SaXeV_srt+80;
 },
 _caZfB() //  [R1]
         { []
         }
     {offset
       caZfB: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZfB_info" {
     block_caZfB_info:
         const _caZfB;
         const 1861;
         const 4294967326;
         const SaXeV_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.814383393 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZgj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZgs; else goto caZgt;
       caZgs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZgt: // global
           I64[Sp - 24] = block_caZgg_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZgD; else goto caZgh;
       uaZgD: // global
           call _caZgg(R1) args: 0, res: 0, upd: 0;
       caZgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD4_info" {
     GHC.IO.FD.$fRawIOFD4_info:
         const GHC.IO.FD.$fRawIOFD4_entry;
         const 0;
         const 55834574862;
         const 17179869207;
         const SaXeV_srt+80;
 },
 _caZgg() //  [R1]
         { []
         }
     {offset
       caZgg: // global
           I64[Sp - 8] = block_caZgm_info;
           _saWYB::I64 = I64[R1 + 7];
           _saWYC::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saWYC::I64;
           I64[Sp + 8] = _saWYB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZgC; else goto caZgn;
       uaZgC: // global
           call _caZgm(R1) args: 0, res: 0, upd: 0;
       caZgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZgg_info" {
     block_caZgg_info:
         const _caZgg;
         const 2;
         const 21474836510;
         const SaXeV_srt+80;
 },
 _caZgm() //  [R1]
         { []
         }
     {offset
       caZgm: // global
           I64[Sp] = block_caZgr_info;
           _saWYE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saWYE::I64;
           if (R1 & 7 != 0) goto uaZgE; else goto caZgw;
       uaZgE: // global
           call _caZgr(R1) args: 0, res: 0, upd: 0;
       caZgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZgm_info" {
     block_caZgm_info:
         const _caZgm;
         const 195;
         const 21474836510;
         const SaXeV_srt+80;
 },
 _caZgr() //  [R1]
         { []
         }
     {offset
       caZgr: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZgr_info" {
     block_caZgr_info:
         const _caZgr;
         const 451;
         const 21474836510;
         const SaXeV_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.832748712 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { []
         }
     {offset
       caZgY: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_saWZ2_entry() //  [R1]
         { []
         }
     {offset
       caZhh: // global
           _saWZ2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caZhi; else goto caZhj;
       caZhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZhl; else goto caZhk;
       caZhl: // global
           HpAlloc = 16;
           goto caZhi;
       caZhi: // global
           R1 = _saWZ2::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZhk: // global
           _saWYJ::I64 = I64[_saWZ2::P64 + 7];
           (_saWYW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWYW::I64 == 0) goto caZhg; else goto caZhf;
       caZhg: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_caZhv_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caZhf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWZ2_info" {
     sat_saWZ2_info:
         const sat_saWZ2_entry;
         const 4294967296;
         const 279172874250;
         const 4294967299;
         const SaXeV_srt+64;
 },
 _caZhv() //  []
         { []
         }
     {offset
       caZhv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZhv_info" {
     block_caZhv_info:
         const _caZhv;
         const 0;
         const 30;
 },
 sat_saWZ9_entry() //  [R1]
         { []
         }
     {offset
       caZhH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZhO; else goto caZhP;
       caZhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZhE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZhT; else goto caZhF;
       uaZhT: // global
           call _caZhE(R1) args: 0, res: 0, upd: 0;
       caZhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saWZ9_info" {
     sat_saWZ9_info:
         const sat_saWZ9_entry;
         const 1;
         const 16;
 },
 _caZhE() //  [R1]
         { []
         }
     {offset
       caZhE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZhS; else goto caZhR;
       caZhS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZhR: // global
           _saWZ8::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saWZ8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZhE_info" {
     block_caZhE_info:
         const _caZhE;
         const 0;
         const 30;
 },
 sat_saWZi_entry() //  [R1]
         { []
         }
     {offset
       caZi3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZid; else goto caZic;
       caZid: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZic: // global
           (_saWZg::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZg::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWZi_info" {
     sat_saWZi_info:
         const sat_saWZi_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_saWZB_entry() //  [R1]
         { []
         }
     {offset
       caZiz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZiI; else goto caZiJ;
       caZiI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZiJ: // global
           I64[Sp - 8] = block_caZiF_info;
           Sp = Sp - 8;
           _caZiC::I64 = I64[R1 + 7];
           _caZiD::I64 = I64[R1 + 15] + I64[R1 + 23];
           _caZiE::I64 = I64[R1 + 31];
           _uaZiP::P64 = CurrentTSO;
           I64[I64[_uaZiP::P64 + 24] + 16] = Sp;
           _uaZiQ::I64 = CurrentNursery;
           P64[_uaZiQ::I64 + 8] = Hp + 8;
           I64[_uaZiP::P64 + 104] = I64[_uaZiP::P64 + 104] - ((Hp + 8) - I64[_uaZiQ::I64]);
           (_uaZiN::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saWZz::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caZiC::I64, _caZiD::I64, _caZiE::I64);
           (_uaZiO::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZiN::I64);
           BaseReg = _uaZiO::I64;
           _uaZiR::P64 = CurrentTSO;
           _uaZiS::P64 = I64[_uaZiR::P64 + 24];
           Sp = I64[_uaZiS::P64 + 16];
           SpLim = _uaZiS::P64 + 192;
           HpAlloc = 0;
           _uaZiT::I64 = CurrentNursery;
           _uaZiU::I64 = I64[_uaZiT::I64 + 8];
           Hp = _uaZiU::I64 - 8;
           _uaZiV::I64 = I64[_uaZiT::I64];
           HpLim = _uaZiV::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZiT::I64 + 48]) << 12) - 1);
           I64[_uaZiR::P64 + 104] = I64[_uaZiR::P64 + 104] + (_uaZiU::I64 - _uaZiV::I64);
           R1 = _saWZz::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWZB_info" {
     sat_saWZB_info:
         const sat_saWZB_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _caZiF() //  [R1]
         { []
         }
     {offset
       caZiF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZiM; else goto caZiL;
       caZiM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZiL: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZiF_info" {
     block_caZiF_info:
         const _caZiF;
         const 0;
         const 30;
 },
 sat_saWZJ_entry() //  [R1]
         { []
         }
     {offset
       caZj5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZjf; else goto caZje;
       caZjf: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZje: // global
           (_saWZH::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saWZH::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saWZJ_info" {
     sat_saWZJ_info:
         const sat_saWZJ_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZjj: // global
           _saWYM::I64 = R6;
           _saWYL::I64 = R5;
           _saWYK::I64 = R4;
           _saWYJ::I64 = R3;
           _saWYI::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto caZjk; else goto caZjl;
       caZjl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZjn; else goto caZjm;
       caZjn: // global
           HpAlloc = 40;
           goto caZjk;
       caZjk: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYK::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caZjm: // global
           if (_saWYK::I64 == 0) goto caZji; else goto caZjh;
       caZji: // global
           (_saWZm::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saWYJ::I64, 1, 0, 0);
           Hp = Hp - 40;
           _saWZK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWZm::I64));
           if (_saWZK::I64 != 0) goto uaZkd; else goto uaZkc;
       uaZkd: // global
           P64[Sp - 32] = _saWYI::P64;
           I64[Sp - 24] = _saWYJ::I64;
           I64[Sp - 16] = _saWYL::I64;
           I64[Sp - 8] = _saWYM::I64;
           Sp = Sp - 40;
           call _caZin() args: 0, res: 0, upd: 0;
       uaZkc: // global
           P64[Sp - 40] = _saWYI::P64;
           I64[Sp - 32] = _saWYJ::I64;
           I64[Sp - 24] = _saWYL::I64;
           I64[Sp - 16] = _saWYM::I64;
           I64[Sp - 8] = _saWZK::I64;
           Sp = Sp - 40;
           call _caZjM() args: 0, res: 0, upd: 0;
       caZjh: // global
           I64[Hp - 32] = sat_saWZi_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _saWYJ::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _saWYI::P64;
           Sp = Sp - 16;
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wwriteRawBufferPtr_info" {
     GHC.IO.FD.$wwriteRawBufferPtr_info:
         const GHC.IO.FD.$wwriteRawBufferPtr_entry;
         const 0;
         const 837518622734;
         const 30064771072;
         const SaXeV_srt+64;
         const 3974;
         const GHC.IO.FD.$wwriteRawBufferPtr_slow;
 },
 _caZjM() //  []
         { []
         }
     {offset
       caZjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZjQ; else goto caZjP;
       caZjQ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZjK_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZjP: // global
           _saWYI::P64 = P64[Sp];
           _saWYJ::I64 = I64[Sp + 8];
           _saWYL::I64 = I64[Sp + 16];
           _saWYM::I64 = I64[Sp + 24];
           (_saWZO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZO::I64 == 0) goto caZk8; else goto caZk0;
       caZk8: // global
           Hp = Hp - 16;
           I64[Sp] = block_caZin_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           P64[Sp + 8] = _saWYI::P64;
           I64[Sp + 16] = _saWYJ::I64;
           I64[Sp + 24] = _saWYL::I64;
           I64[Sp + 32] = _saWYM::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       caZk0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saWYJ::I64));
           I64[Sp - 8] = block_caZjY_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZjK() //  [R1]
         { []
         }
     {offset
       caZjK: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caZjM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZjK_info" {
     block_caZjK_info:
         const _caZjK;
         const 3974;
         const 287762808862;
         const SaXeV_srt+64;
 },
 _caZjY() //  []
         { []
         }
     {offset
       caZjY: // global
           _saWYJ::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _saWYL::I64 = I64[Sp + 24];
           I64[Sp + 24] = _saWYJ::I64;
           _saWYM::I64 = I64[Sp + 32];
           I64[Sp + 32] = _saWYL::I64;
           I64[Sp + 40] = _saWYM::I64;
           Sp = Sp + 8;
           call _caZin() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZjY_info" {
     block_caZjY_info:
         const _caZjY;
         const 3974;
         const 287762808862;
         const SaXeV_srt+64;
 },
 _caZin() //  []
         { []
         }
     {offset
       caZin: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caZjw; else goto caZjv;
       caZjw: // global
           HpAlloc = 40;
           I64[Sp] = block_caZin_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caZjv: // global
           _saWYI::P64 = P64[Sp + 8];
           _saWYJ::I64 = I64[Sp + 16];
           _saWYL::I64 = I64[Sp + 24];
           _saWYM::I64 = I64[Sp + 32];
           _saWYN::I64 = I64[Sp + 40];
           (_saWZs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saWZs::I64 == 0) goto caZjz; else goto caZjy;
       caZjz: // global
           I64[Hp - 32] = sat_saWZJ_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaZkl;
       caZjy: // global
           I64[Hp - 32] = sat_saWZB_info;
           I64[Hp - 24] = _saWYJ::I64;
           I64[Hp - 16] = _saWYL::I64;
           I64[Hp - 8] = _saWYM::I64;
           I64[Hp] = _saWYN::I64;
           P64[Sp + 40] = _saWYI::P64;
           I64[Sp + 24] = _saWYJ::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto uaZkl;
       uaZkl: // global
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZin_info" {
     block_caZin_info:
         const _caZin;
         const 1925;
         const 287762808862;
         const SaXeV_srt+64;
 },
 _caZh5() //  []
         { []
         }
     {offset
       caZh5: // global
           Hp = Hp + 16;
           _saWYQ::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZjq; else goto caZjp;
       caZjq: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caZh4_info;
           R1 = _saWYQ::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZjp: // global
           I64[Hp - 8] = sat_saWZ2_info;
           I64[Hp] = I64[Sp];
           _saWYI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caZhy_info;
           R5 = Hp - 7;
           R4 = _saWYQ::P64;
           R3 = _saWYI::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZh4() //  [R1]
         { []
         }
     {offset
       caZh4: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZh5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZh4_info" {
     block_caZh4_info:
         const _caZh4;
         const 195;
         const 287762808862;
         const SaXeV_srt+64;
 },
 _caZhy() //  [R1]
         { []
         }
     {offset
       caZhy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZjt; else goto caZjs;
       caZjt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZjs: // global
           I64[Hp - 16] = sat_saWZ9_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZhy_info" {
     block_caZhy_info:
         const _caZhy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.86597977 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZm2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZmg; else goto caZmh;
       caZmg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZmh: // global
           I64[Sp - 40] = block_caZlZ_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZmr; else goto caZm0;
       uaZmr: // global
           call _caZlZ(R1) args: 0, res: 0, upd: 0;
       caZm0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.writeRawBufferPtr1_info" {
     GHC.IO.FD.writeRawBufferPtr1_info:
         const GHC.IO.FD.writeRawBufferPtr1_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const SaXeV_srt+120;
 },
 _caZlZ() //  [R1]
         { []
         }
     {offset
       caZlZ: // global
           I64[Sp - 8] = block_caZm5_info;
           _saX04::I64 = I64[R1 + 7];
           _saX05::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _saX05::I64;
           I64[Sp + 16] = _saX04::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZmq; else goto caZm6;
       uaZmq: // global
           call _caZm5(R1) args: 0, res: 0, upd: 0;
       caZm6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZlZ_info" {
     block_caZlZ_info:
         const _caZlZ;
         const 4;
         const 4294967326;
         const SaXeV_srt+120;
 },
 _caZm5() //  [R1]
         { []
         }
     {offset
       caZm5: // global
           I64[Sp] = block_caZma_info;
           _saX07::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _saX07::I64;
           if (R1 & 7 != 0) goto uaZms; else goto caZmb;
       uaZms: // global
           call _caZma(R1) args: 0, res: 0, upd: 0;
       caZmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZm5_info" {
     block_caZm5_info:
         const _caZm5;
         const 325;
         const 4294967326;
         const SaXeV_srt+120;
 },
 _caZma() //  [R1]
         { []
         }
     {offset
       caZma: // global
           I64[Sp] = block_caZmf_info;
           _saX09::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _saX09::I64;
           if (R1 & 7 != 0) goto uaZmt; else goto caZml;
       uaZmt: // global
           call _caZmf(R1) args: 0, res: 0, upd: 0;
       caZml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZma_info" {
     block_caZma_info:
         const _caZma;
         const 837;
         const 4294967326;
         const SaXeV_srt+120;
 },
 _caZmf() //  [R1]
         { []
         }
     {offset
       caZmf: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZmf_info" {
     block_caZmf_info:
         const _caZmf;
         const 1861;
         const 4294967326;
         const SaXeV_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.878286307 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { []
         }
     {offset
       caZmR: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caZmX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caZn2; else goto uaZnl;
       caZn2: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       uaZnl: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caZmS() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wfdWrite_info" {
     GHC.IO.FD.$wfdWrite_info:
         const GHC.IO.FD.$wfdWrite_entry;
         const 0;
         const 55834574862;
         const 21474836480;
         const SaXeV_srt+120;
         const 964;
         const GHC.IO.FD.$wfdWrite_slow;
 },
 _caZmS() //  []
         { []
         }
     {offset
       caZmS: // global
           I64[Sp - 8] = block_caZmZ_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _caZmZ() //  [R1]
         { []
         }
     {offset
       caZmZ: // global
           I64[Sp] = block_caZn1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZno; else goto caZn5;
       uaZno: // global
           call _caZn1(R1) args: 0, res: 0, upd: 0;
       caZn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZmZ_info" {
     block_caZmZ_info:
         const _caZmZ;
         const 964;
         const 38654705694;
         const SaXeV_srt+120;
 },
 _caZn1() //  [R1]
         { []
         }
     {offset
       caZn1: // global
           _saX0f::I64 = I64[Sp + 32];
           _saX0m::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_saX0m::I64,
                            _saX0f::I64)) goto caZnd; else goto caZne;
       caZnd: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZne: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _saX0m::I64;
           I64[Sp + 32] = _saX0f::I64 - _saX0m::I64;
           Sp = Sp + 8;
           call _caZmS() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZn1_info" {
     block_caZn1_info:
         const _caZn1;
         const 964;
         const 38654705694;
         const SaXeV_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.888826509 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZnV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZo4; else goto caZo5;
       caZo4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZo5: // global
           I64[Sp - 24] = block_caZnS_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZoe; else goto caZnT;
       uaZoe: // global
           call _caZnS(R1) args: 0, res: 0, upd: 0;
       caZnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD2_info" {
     GHC.IO.FD.$fRawIOFD2_info:
         const GHC.IO.FD.$fRawIOFD2_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const SaXeV_srt+136;
 },
 _caZnS() //  [R1]
         { []
         }
     {offset
       caZnS: // global
           I64[Sp - 8] = block_caZnY_info;
           _saX0v::I64 = I64[R1 + 7];
           _saX0w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX0w::I64;
           I64[Sp + 8] = _saX0v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZod; else goto caZnZ;
       uaZod: // global
           call _caZnY(R1) args: 0, res: 0, upd: 0;
       caZnZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZnS_info" {
     block_caZnS_info:
         const _caZnS;
         const 2;
         const 4294967326;
         const SaXeV_srt+136;
 },
 _caZnY() //  [R1]
         { []
         }
     {offset
       caZnY: // global
           I64[Sp] = block_caZo3_info;
           _saX0y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX0y::I64;
           if (R1 & 7 != 0) goto uaZof; else goto caZo8;
       uaZof: // global
           call _caZo3(R1) args: 0, res: 0, upd: 0;
       caZo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZnY_info" {
     block_caZnY_info:
         const _caZnY;
         const 195;
         const 4294967326;
         const SaXeV_srt+136;
 },
 _caZo3() //  [R1]
         { []
         }
     {offset
       caZo3: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZo3_info" {
     block_caZo3_info:
         const _caZo3;
         const 451;
         const 4294967326;
         const SaXeV_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.905005138 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { []
         }
     {offset
       caZoy: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saX0O_entry() //  [R1]
         { []
         }
     {offset
       caZoL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZoV; else goto caZoU;
       caZoV: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZoU: // global
           (_saX0M::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX0M::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX0O_info" {
     sat_saX0O_info:
         const sat_saX0O_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 sat_saX1e_entry() //  [R1]
         { []
         }
     {offset
       caZpi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZpr; else goto caZps;
       caZpr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZps: // global
           I64[Sp - 8] = block_caZpo_info;
           Sp = Sp - 8;
           _caZpl::I64 = I64[R1 + 7];
           _caZpm::I64 = I64[R1 + 15];
           _caZpn::I64 = I64[R1 + 23];
           _uaZpy::P64 = CurrentTSO;
           I64[I64[_uaZpy::P64 + 24] + 16] = Sp;
           _uaZpz::I64 = CurrentNursery;
           P64[_uaZpz::I64 + 8] = Hp + 8;
           I64[_uaZpy::P64 + 104] = I64[_uaZpy::P64 + 104] - ((Hp + 8) - I64[_uaZpz::I64]);
           (_uaZpw::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX1c::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_caZpl::I64, _caZpm::I64, _caZpn::I64);
           (_uaZpx::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZpw::I64);
           BaseReg = _uaZpx::I64;
           _uaZpA::P64 = CurrentTSO;
           _uaZpB::P64 = I64[_uaZpA::P64 + 24];
           Sp = I64[_uaZpB::P64 + 16];
           SpLim = _uaZpB::P64 + 192;
           HpAlloc = 0;
           _uaZpC::I64 = CurrentNursery;
           _uaZpD::I64 = I64[_uaZpC::I64 + 8];
           Hp = _uaZpD::I64 - 8;
           _uaZpE::I64 = I64[_uaZpC::I64];
           HpLim = _uaZpE::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZpC::I64 + 48]) << 12) - 1);
           I64[_uaZpA::P64 + 104] = I64[_uaZpA::P64 + 104] + (_uaZpD::I64 - _uaZpE::I64);
           R1 = _saX1c::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX1e_info" {
     sat_saX1e_info:
         const sat_saX1e_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 _caZpo() //  [R1]
         { []
         }
     {offset
       caZpo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZpv; else goto caZpu;
       caZpv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZpu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZpo_info" {
     block_caZpo_info:
         const _caZpo;
         const 0;
         const 30;
 },
 sat_saX1u_entry() //  [R1]
         { []
         }
     {offset
       caZpO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZpY; else goto caZpX;
       caZpY: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZpX: // global
           (_saX1s::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX1s::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX1u_info" {
     sat_saX1u_info:
         const sat_saX1u_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caZq2: // global
           _saX0E::I64 = R5;
           _saX0D::I64 = R4;
           _saX0C::I64 = R3;
           _saX0B::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto caZq3; else goto caZq4;
       caZq4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZq6; else goto caZq5;
       caZq6: // global
           HpAlloc = 32;
           goto caZq3;
       caZq3: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0C::I64;
           I64[Sp - 16] = _saX0D::I64;
           I64[Sp - 8] = _saX0E::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caZq5: // global
           if (_saX0C::I64 == 0) goto caZq1; else goto caZq0;
       caZq1: // global
           (_saX10::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_saX0B::I64, 1, 0, 0);
           Hp = Hp - 32;
           _saX11::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX10::I64));
           if (_saX11::I64 != 0) goto uaZrk; else goto caZrf;
       uaZrk: // global
           I64[Sp - 32] = _saX0B::I64;
           I64[Sp - 24] = _saX0D::I64;
           I64[Sp - 16] = _saX0E::I64;
           I64[Sp - 8] = _saX11::I64;
           Sp = Sp - 32;
           call _caZp6() args: 0, res: 0, upd: 0;
       caZrf: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZq0: // global
           I64[Hp - 24] = sat_saX0O_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp - 8] = block_caZq7_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cwriteNonBlocking_info" {
     GHC.IO.FD.$w$cwriteNonBlocking_info:
         const GHC.IO.FD.$w$cwriteNonBlocking_entry;
         const 0;
         const 6755403736023054;
         const 21474836480;
         const SaXeV_srt+8;
         const 964;
         const GHC.IO.FD.$w$cwriteNonBlocking_slow;
 },
 _caZp6() //  []
         { []
         }
     {offset
       caZp6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZqv; else goto caZqu;
       caZqv: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caZp5_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZqu: // global
           _saX0B::I64 = I64[Sp];
           _saX0D::I64 = I64[Sp + 8];
           _saX0E::I64 = I64[Sp + 16];
           (_saX15::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX15::I64 == 0) goto caZqV; else goto caZqA;
       caZqV: // global
           I64[Hp - 24] = sat_saX1u_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caZqS_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       caZqA: // global
           I64[Hp - 24] = sat_saX1e_info;
           I64[Hp - 16] = _saX0B::I64;
           I64[Hp - 8] = _saX0D::I64;
           I64[Hp] = _saX0E::I64;
           I64[Sp + 24] = block_caZqw_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZp5() //  [R1]
         { []
         }
     {offset
       caZp5: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caZp6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZp5_info" {
     block_caZp5_info:
         const _caZp5;
         const 964;
         const 4503603922337822;
         const SaXeV_srt+8;
 },
 _caZqS() //  [R1]
         { []
         }
     {offset
       caZqS: // global
           I64[Sp] = block_caZqU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZru; else goto caZqX;
       uaZru: // global
           call _caZqU(R1) args: 0, res: 0, upd: 0;
       caZqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZqS_info" {
     block_caZqS_info:
         const _caZqS;
         const 0;
         const 30;
 },
 _caZqU() //  [R1]
         { []
         }
     {offset
       caZqU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZr3; else goto caZr2;
       caZr3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZr2: // global
           _saX1A::I64 = I64[R1 + 7];
           if (_saX1A::I64 != (-1)) goto caZrb; else goto uaZrn;
       caZrb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1A::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrn: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZqU_info" {
     block_caZqU_info:
         const _caZqU;
         const 0;
         const 30;
 },
 _caZqw() //  [R1]
         { []
         }
     {offset
       caZqw: // global
           I64[Sp] = block_caZqy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZrs; else goto caZqC;
       uaZrs: // global
           call _caZqy(R1) args: 0, res: 0, upd: 0;
       caZqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZqw_info" {
     block_caZqw_info:
         const _caZqw;
         const 0;
         const 30;
 },
 _caZqy() //  [R1]
         { []
         }
     {offset
       caZqy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZqI; else goto caZqH;
       caZqI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZqH: // global
           _saX1k::I64 = I64[R1 + 7];
           if (_saX1k::I64 != (-1)) goto caZqQ; else goto uaZrm;
       caZqQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX1k::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrm: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZqy_info" {
     block_caZqy_info:
         const _caZqy;
         const 0;
         const 30;
 },
 _caZq7() //  [R1]
         { []
         }
     {offset
       caZq7: // global
           I64[Sp] = block_caZq9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZrq; else goto caZqb;
       uaZrq: // global
           call _caZq9(R1) args: 0, res: 0, upd: 0;
       caZqb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZq7_info" {
     block_caZq7_info:
         const _caZq7;
         const 0;
         const 30;
 },
 _caZq9() //  [R1]
         { []
         }
     {offset
       caZq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZqh; else goto caZqg;
       caZqh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZqg: // global
           _saX0U::I64 = I64[R1 + 7];
           if (_saX0U::I64 != (-1)) goto caZqp; else goto uaZrj;
       caZqp: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX0U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaZrj: // global
           Sp = Sp + 8;
           call _caZrc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZq9_info" {
     block_caZq9_info:
         const _caZq9;
         const 0;
         const 30;
 },
 _caZrc() //  []
         { []
         }
     {offset
       caZrc: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.933402366 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZsR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZt0; else goto caZt1;
       caZt0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZt1: // global
           I64[Sp - 24] = block_caZsO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZta; else goto caZsP;
       uaZta: // global
           call _caZsO(R1) args: 0, res: 0, upd: 0;
       caZsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD1_info" {
     GHC.IO.FD.$fRawIOFD1_info:
         const GHC.IO.FD.$fRawIOFD1_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const SaXeV_srt+160;
 },
 _caZsO() //  [R1]
         { []
         }
     {offset
       caZsO: // global
           I64[Sp - 8] = block_caZsU_info;
           _saX1I::I64 = I64[R1 + 7];
           _saX1J::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX1J::I64;
           I64[Sp + 8] = _saX1I::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZt9; else goto caZsV;
       uaZt9: // global
           call _caZsU(R1) args: 0, res: 0, upd: 0;
       caZsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZsO_info" {
     block_caZsO_info:
         const _caZsO;
         const 2;
         const 4294967326;
         const SaXeV_srt+160;
 },
 _caZsU() //  [R1]
         { []
         }
     {offset
       caZsU: // global
           I64[Sp] = block_caZsZ_info;
           _saX1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saX1L::I64;
           if (R1 & 7 != 0) goto uaZtb; else goto caZt4;
       uaZtb: // global
           call _caZsZ(R1) args: 0, res: 0, upd: 0;
       caZt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZsU_info" {
     block_caZsU_info:
         const _caZsU;
         const 195;
         const 4294967326;
         const SaXeV_srt+160;
 },
 _caZsZ() //  [R1]
         { []
         }
     {offset
       caZsZ: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZsZ_info" {
     block_caZsZ_info:
         const _caZsZ;
         const 451;
         const 4294967326;
         const SaXeV_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.941887564 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.945714713 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { []
         }
     {offset
       caZtB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caZtT; else goto caZtU;
       caZtT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZtU: // global
           I64[Sp - 16] = block_caZty_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZu1; else goto caZtz;
       uaZu1: // global
           call _caZty(R1) args: 0, res: 0, upd: 0;
       caZtz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry;
         const 0;
         const 279172874254;
         const 12884901903;
         const SaXeV_srt+136;
 },
 _caZty() //  [R1]
         { []
         }
     {offset
       caZty: // global
           I64[Sp - 40] = block_caZtE_info;
           _saX1T::P64 = P64[R1 + 7];
           _saX1U::P64 = P64[R1 + 15];
           _saX1S::I64 = I64[R1 + 23];
           _saX1V::I64 = I64[R1 + 31];
           _saX1W::I64 = I64[R1 + 39];
           _saX1X::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _saX1U::P64;
           I64[Sp - 24] = _saX1V::I64;
           I64[Sp - 16] = _saX1W::I64;
           I64[Sp - 8] = _saX1X::I64;
           P64[Sp] = _saX1T::P64;
           I64[Sp + 8] = _saX1S::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaZu0; else goto caZtF;
       uaZu0: // global
           call _caZtE(R1) args: 0, res: 0, upd: 0;
       caZtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZty_info" {
     block_caZty_info:
         const _caZty;
         const 1;
         const 4294967326;
         const SaXeV_srt+136;
 },
 _caZtE() //  [R1]
         { []
         }
     {offset
       caZtE: // global
           I64[Sp] = block_caZtP_info;
           _saX1W::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _saX1W::I64;
           R4 = I64[Sp + 48] + _saX1W::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZtE_info" {
     block_caZtE_info:
         const _caZtE;
         const 2950;
         const 4294967326;
         const SaXeV_srt+136;
 },
 _caZtP() //  [R1]
         { []
         }
     {offset
       caZtP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caZtZ; else goto caZtY;
       caZtZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZtY: // global
           _saX1S::I64 = I64[Sp + 48];
           _saX1T::P64 = P64[Sp + 40];
           _saX1U::P64 = P64[Sp + 8];
           _saX1V::I64 = I64[Sp + 16];
           call MO_Touch(_saX1T::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX1T::P64;
           P64[Hp - 32] = _saX1U::P64;
           I64[Hp - 24] = _saX1S::I64;
           I64[Hp - 16] = _saX1V::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZtP_info" {
     block_caZtP_info:
         const _caZtP;
         const 2950;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.956087514 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { []
         }
     {offset
       caZus: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZuw; else goto caZux;
       caZuw: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZux: // global
           I64[Sp - 8] = block_caZup_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZuB; else goto caZuq;
       uaZuB: // global
           call _caZup(R1) args: 0, res: 0, upd: 0;
       caZuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.fdIsNonBlocking_info" {
     GHC.IO.FD.fdIsNonBlocking_info:
         const GHC.IO.FD.fdIsNonBlocking_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZup() //  [R1]
         { []
         }
     {offset
       caZup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZuA; else goto caZuz;
       caZuA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZuz: // global
           _saX2b::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saX2b::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZup_info" {
     block_caZup_info:
         const _caZup;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.962194223 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { []
         }
     {offset
       caZuT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZuX; else goto caZuY;
       caZuX: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZuY: // global
           I64[Sp - 8] = block_caZuQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZv2; else goto caZuR;
       uaZv2: // global
           call _caZuQ(R1) args: 0, res: 0, upd: 0;
       caZuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.fdFD_info" {
     GHC.IO.FD.fdFD_info:
         const GHC.IO.FD.fdFD_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZuQ() //  [R1]
         { []
         }
     {offset
       caZuQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZv1; else goto caZv0;
       caZv1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZv0: // global
           _saX2e::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2e::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZuQ_info" {
     block_caZuQ_info:
         const _caZuQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.968202259 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { []
         }
     {offset
       caZvk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZvq; else goto caZvr;
       caZvq: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZvr: // global
           I64[Sp - 8] = block_caZvh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZvw; else goto caZvi;
       uaZvw: // global
           call _caZvh(R1) args: 0, res: 0, upd: 0;
       caZvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshow_info" {
     GHC.IO.FD.$fShowFD_$cshow_info:
         const GHC.IO.FD.$fShowFD_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZvh() //  [R1]
         { []
         }
     {offset
       caZvh: // global
           I64[Sp] = block_caZvn_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZvh_info" {
     block_caZvh_info:
         const _caZvh;
         const 0;
         const 30;
 },
 _caZvn() //  [R1, R2]
         { []
         }
     {offset
       caZvn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZvv; else goto caZvu;
       caZvv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZvu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZvn_info" {
     block_caZvn_info:
         const _caZvn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.976726174 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { []
         }
     {offset
       caZvV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZvY; else goto caZvZ;
       caZvY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZvZ: // global
           I64[Sp - 16] = block_caZvO_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD15_info" {
     GHC.IO.FD.$fBufferedIOFD15_info:
         const GHC.IO.FD.$fBufferedIOFD15_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _caZvO() //  [R1]
         { []
         }
     {offset
       caZvO: // global
           I64[Sp - 8] = block_caZvQ_info;
           _saX2s::P64 = R1;
           R1 = 8192;
           P64[Sp] = _saX2s::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZvO_info" {
     block_caZvO_info:
         const _caZvO;
         const 1;
         const 30;
 },
 _caZvQ() //  [R1]
         { []
         }
     {offset
       caZvQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caZw3; else goto caZw2;
       caZw3: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZw2: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZvQ_info" {
     block_caZvQ_info:
         const _caZvQ;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.984439502 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_saX2E_entry() //  [R1]
         { []
         }
     {offset
       caZwv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZwz; else goto caZwA;
       caZwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZwA: // global
           I64[Sp - 8] = block_caZws_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZwE; else goto caZwt;
       uaZwE: // global
           call _caZws(R1) args: 0, res: 0, upd: 0;
       caZwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX2E_info" {
     sat_saX2E_info:
         const sat_saX2E_entry;
         const 1;
         const 16;
 },
 _caZws() //  [R1]
         { []
         }
     {offset
       caZws: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZwD; else goto caZwC;
       caZwD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZwC: // global
           _saX2C::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2C::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZws_info" {
     block_caZws_info:
         const _caZws;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { []
         }
     {offset
       caZwF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZwJ; else goto caZwI;
       caZwJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZwI: // global
           I64[Hp - 16] = sat_saX2E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD12_info" {
     GHC.IO.FD.$fIODeviceFD12_info:
         const GHC.IO.FD.$fIODeviceFD12_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaXeV_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:55.992085282 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_saX2L_entry() //  [R1]
         { []
         }
     {offset
       caZx8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZxc; else goto caZxd;
       caZxc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZxd: // global
           I64[Sp - 8] = block_caZx5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZxh; else goto caZx6;
       uaZxh: // global
           call _caZx5(R1) args: 0, res: 0, upd: 0;
       caZx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX2L_info" {
     sat_saX2L_info:
         const sat_saX2L_entry;
         const 1;
         const 16;
 },
 _caZx5() //  [R1]
         { []
         }
     {offset
       caZx5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZxg; else goto caZxf;
       caZxg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZxf: // global
           _saX2J::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2J::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZx5_info" {
     block_caZx5_info:
         const _caZx5;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { []
         }
     {offset
       caZxi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZxm; else goto caZxl;
       caZxm: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZxl: // global
           I64[Hp - 16] = sat_saX2L_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD9_info" {
     GHC.IO.FD.$fIODeviceFD9_info:
         const GHC.IO.FD.$fIODeviceFD9_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SaXeV_srt+208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.000939936 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_saX2R_entry() //  [R1]
         { []
         }
     {offset
       caZxL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZxP; else goto caZxQ;
       caZxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZxQ: // global
           I64[Sp - 8] = block_caZxI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZxU; else goto caZxJ;
       uaZxU: // global
           call _caZxI(R1) args: 0, res: 0, upd: 0;
       caZxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX2R_info" {
     sat_saX2R_info:
         const sat_saX2R_entry;
         const 1;
         const 16;
 },
 _caZxI() //  [R1]
         { []
         }
     {offset
       caZxI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZxT; else goto caZxS;
       caZxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZxS: // global
           _saX2P::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2P::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZxI_info" {
     block_caZxI_info:
         const _caZxI;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { []
         }
     {offset
       caZxV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZxZ; else goto caZxY;
       caZxZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZxY: // global
           I64[Hp - 16] = sat_saX2R_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD8_info" {
     GHC.IO.FD.$fIODeviceFD8_info:
         const GHC.IO.FD.$fIODeviceFD8_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaXeV_srt+224;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.009286948 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_saX30_entry() //  [R1]
         { []
         }
     {offset
       caZys: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZyt; else goto caZyu;
       caZyt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZyu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZyl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZyB; else goto caZym;
       uaZyB: // global
           call _caZyl(R1) args: 0, res: 0, upd: 0;
       caZym: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX30_info" {
     sat_saX30_info:
         const sat_saX30_entry;
         const 1;
         const 16;
 },
 _caZyl() //  [R1]
         { []
         }
     {offset
       caZyl: // global
           if (R1 & 7 == 1) goto caZyp; else goto caZyq;
       caZyp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZyq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZyl_info" {
     block_caZyl_info:
         const _caZyl;
         const 0;
         const 30;
 },
 sat_saX2Y_entry() //  [R1]
         { []
         }
     {offset
       caZyJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZyN; else goto caZyO;
       caZyN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZyO: // global
           I64[Sp - 8] = block_caZyG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZyS; else goto caZyH;
       uaZyS: // global
           call _caZyG(R1) args: 0, res: 0, upd: 0;
       caZyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX2Y_info" {
     sat_saX2Y_info:
         const sat_saX2Y_entry;
         const 1;
         const 16;
 },
 _caZyG() //  [R1]
         { []
         }
     {offset
       caZyG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZyR; else goto caZyQ;
       caZyR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZyQ: // global
           _saX2W::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX2W::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZyG_info" {
     block_caZyG_info:
         const _caZyG;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { []
         }
     {offset
       caZyT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caZyX; else goto caZyW;
       caZyX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZyW: // global
           I64[Hp - 40] = sat_saX30_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_saX2Y_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD7_info" {
     GHC.IO.FD.$fIODeviceFD7_info:
         const GHC.IO.FD.$fIODeviceFD7_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SaXeV_srt+240;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.019348579 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.021078598 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.022893723 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.025066747 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.026696738 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.028424045 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.030397672 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.03207498 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.033701379 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.03543131 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.03728485 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.038950942 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.040675309 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.042897136 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.044638792 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.046951248 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.050063433 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZzQ; else goto caZzR;
       caZzQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZzR: // global
           I64[Sp - 16] = block_caZzH_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZzW; else goto caZzI;
       uaZzW: // global
           call _caZzH(R1) args: 0, res: 0, upd: 0;
       caZzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshowsPrec_info" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_info:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _caZzH() //  [R1]
         { []
         }
     {offset
       caZzH: // global
           I64[Sp] = block_caZzN_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZzH_info" {
     block_caZzH_info:
         const _caZzH;
         const 1;
         const 30;
 },
 _caZzN() //  [R1, R2]
         { []
         }
     {offset
       caZzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZzV; else goto caZzU;
       caZzV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZzU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZzN_info" {
     block_caZzN_info:
         const _caZzN;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.05793608 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { []
         }
     {offset
       caZAg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZAh; else goto caZAi;
       caZAh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZAi: // global
           I64[Sp - 16] = block_caZAd_info;
           R4 = GHC.Types.[]_closure+1;
           _saX3c::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _saX3c::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wlvl_info" {
     GHC.IO.FD.$wlvl_info:
         const GHC.IO.FD.$wlvl_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _caZAd() //  [R1, R2]
         { []
         }
     {offset
       caZAd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZAl; else goto caZAk;
       caZAl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caZAk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZAd_info" {
     block_caZAd_info:
         const _caZAd;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.063664474 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       caZAB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZAC; else goto caZAD;
       caZAC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZAD: // global
           I64[Sp - 16] = block_caZAy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZAH; else goto caZAz;
       uaZAH: // global
           call _caZAy(R1) args: 0, res: 0, upd: 0;
       caZAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD1_info" {
     GHC.IO.FD.$fShowFD1_info:
         const GHC.IO.FD.$fShowFD1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _caZAy() //  [R1]
         { []
         }
     {offset
       caZAy: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZAy_info" {
     block_caZAy_info:
         const _caZAy;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.069220129 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       caZAV: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshowList_info" {
     GHC.IO.FD.$fShowFD_$cshowList_info:
         const GHC.IO.FD.$fShowFD_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.072929299 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.07550551 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { []
         }
     {offset
       caZBd: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caZBv; else goto caZBw;
       caZBw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZBy; else goto caZBx;
       caZBy: // global
           HpAlloc = 16;
           goto caZBv;
       caZBv: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZBx: // global
           (_caZB6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_caZB6::I64 == 0) goto caZB8; else goto caZB7;
       caZB8: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       caZB7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZB6::I64;
           (_saX3r::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX3v::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3r::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3v::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . output_flags_raWV4_info" {
     output_flags_raWV4_info:
         const output_flags_raWV4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.080748521 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { []
         }
     {offset
       caZBT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZCd; else goto caZCe;
       caZCd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZCe: // global
           (_caZBN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZBN::I64 == 0) goto caZBP; else goto caZBO;
       caZBP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZBO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZBN::I64;
           I64[Sp - 24] = block_caZBQ_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZCi; else goto caZBR;
       uaZCi: // global
           call _caZBQ(R1) args: 0, res: 0, upd: 0;
       caZBR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . write_flags_raWV5_info" {
     write_flags_raWV5_info:
         const write_flags_raWV5_entry;
         const 0;
         const 4294967317;
         const SaXeV_srt+256;
 },
 _caZBQ() //  [R1]
         { []
         }
     {offset
       caZBQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZCh; else goto caZCg;
       caZCh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZCg: // global
           _saX3D::I64 = I64[R1 + 7];
           (_saX3H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3D::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3H::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZBQ_info" {
     block_caZBQ_info:
         const _caZBQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.087303029 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { []
         }
     {offset
       caZCH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZD1; else goto caZD2;
       caZD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZD2: // global
           (_caZCB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZCB::I64 == 0) goto caZCD; else goto caZCC;
       caZCD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZCC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZCB::I64;
           I64[Sp - 24] = block_caZCE_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZD6; else goto caZCF;
       uaZD6: // global
           call _caZCE(R1) args: 0, res: 0, upd: 0;
       caZCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . append_flags_raWV6_info" {
     append_flags_raWV6_info:
         const append_flags_raWV6_entry;
         const 0;
         const 4294967317;
         const SaXeV_srt+264;
 },
 _caZCE() //  [R1]
         { []
         }
     {offset
       caZCE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZD5; else goto caZD4;
       caZD5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZD4: // global
           _saX3O::I64 = I64[R1 + 7];
           (_saX3S::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3O::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX3S::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZCE_info" {
     block_caZCE_info:
         const _caZCE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.094217531 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { []
         }
     {offset
       caZDv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZDP; else goto caZDQ;
       caZDP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZDQ: // global
           (_caZDp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZDp::I64 == 0) goto caZDr; else goto caZDq;
       caZDr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZDq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZDp::I64;
           I64[Sp - 24] = block_caZDs_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZDU; else goto caZDt;
       uaZDU: // global
           call _caZDs(R1) args: 0, res: 0, upd: 0;
       caZDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . rw_flags_raWV7_info" {
     rw_flags_raWV7_info:
         const rw_flags_raWV7_entry;
         const 0;
         const 4294967317;
         const SaXeV_srt+256;
 },
 _caZDs() //  [R1]
         { []
         }
     {offset
       caZDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZDT; else goto caZDS;
       caZDT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZDS: // global
           _saX3Z::I64 = I64[R1 + 7];
           (_saX43::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX3Z::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX43::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZDs_info" {
     block_caZDs_info:
         const _caZDs;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.100830538 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { []
         }
     {offset
       caZEk: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caZEC; else goto caZED;
       caZED: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZEF; else goto caZEE;
       caZEF: // global
           HpAlloc = 16;
           goto caZEC;
       caZEC: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZEE: // global
           (_caZEd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_caZEd::I64 == 0) goto caZEf; else goto caZEe;
       caZEf: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       caZEe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZEd::I64;
           (_saX4c::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_saX4g::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4c::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX4g::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . read_flags_raWV8_info" {
     read_flags_raWV8_info:
         const read_flags_raWV8_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.105627705 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { []
         }
     {offset
       caZEY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZEZ; else goto caZF0;
       caZEZ: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZF0: // global
           I64[Sp - 8] = block_caZEV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZF8; else goto caZEW;
       uaZF8: // global
           call _caZEV(R1) args: 0, res: 0, upd: 0;
       caZEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD16_info" {
     GHC.IO.FD.$fIODeviceFD16_info:
         const GHC.IO.FD.$fIODeviceFD16_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZEV() //  [R1]
         { []
         }
     {offset
       caZEV: // global
           if (I64[R1 + 7] == (-1)) goto caZF7; else goto caZF6;
       caZF7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZF6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZEV_info" {
     block_caZEV_info:
         const _caZEV;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.110750591 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.113003377 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { []
         }
     {offset
       caZFr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZFs; else goto caZFt;
       caZFs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZFt: // global
           (_caZFo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZFo::I64 == 0) goto caZFq; else goto caZFp;
       caZFq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZFp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZFo::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD14_info" {
     GHC.IO.FD.$fIODeviceFD14_info:
         const GHC.IO.FD.$fIODeviceFD14_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.118691771 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_saX4E_entry() //  [R1]
         { []
         }
     {offset
       caZFN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZFX; else goto caZFW;
       caZFX: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZFW: // global
           (_saX4C::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4C::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX4E_info" {
     sat_saX4E_info:
         const sat_saX4E_entry;
         const 8589934592;
         const 13;
         const 4294967299;
 },
 sat_saX4I_entry() //  [R1]
         { []
         }
     {offset
       caZG4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZG5; else goto caZG6;
       caZG5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX4I_info" {
     sat_saX4I_info:
         const sat_saX4I_entry;
         const 1;
         const 16;
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { []
         }
     {offset
       caZG7: // global
           _saX4r::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caZG8; else goto caZG9;
       caZG9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZGb; else goto caZGa;
       caZGb: // global
           HpAlloc = 24;
           goto caZG8;
       caZG8: // global
           R2 = _saX4r::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZGa: // global
           (_saX4w::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_saX4E_info;
           I64[Hp - 8] = _saX4r::I64;
           I64[Hp] = _saX4w::I64;
           I64[Sp - 8] = block_caZFY_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$ctell_info" {
     GHC.IO.FD.$w$ctell_info:
         const GHC.IO.FD.$w$ctell_entry;
         const 0;
         const 30064771086;
         const 8589934596;
         const SaXeV_srt+272;
 },
 _caZFY() //  [R1]
         { []
         }
     {offset
       caZFY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZGe; else goto caZGd;
       caZGe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZGd: // global
           I64[Hp - 16] = sat_saX4I_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZFY_info" {
     block_caZFY_info:
         const _caZFY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.128651131 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { []
         }
     {offset
       caZGE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZGF; else goto caZGG;
       caZGF: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZGG: // global
           I64[Sp - 8] = block_caZGB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZGK; else goto caZGC;
       uaZGK: // global
           call _caZGB(R1) args: 0, res: 0, upd: 0;
       caZGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD13_info" {
     GHC.IO.FD.$fIODeviceFD13_info:
         const GHC.IO.FD.$fIODeviceFD13_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const SaXeV_srt+280;
 },
 _caZGB() //  [R1]
         { []
         }
     {offset
       caZGB: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZGB_info" {
     block_caZGB_info:
         const _caZGB;
         const 0;
         const 4294967326;
         const SaXeV_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.133459021 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.13569198 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { []
         }
     {offset
       caZH1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZH2; else goto caZH3;
       caZH2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZH3: // global
           (_caZGY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZGY::I64 == 0) goto caZH0; else goto caZGZ;
       caZH0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZGZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZGY::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD18_info" {
     GHC.IO.FD.$fIODeviceFD18_info:
         const GHC.IO.FD.$fIODeviceFD18_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.142081277 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_saX51_entry() //  [R1]
         { []
         }
     {offset
       caZHy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZHC; else goto caZHB;
       caZHC: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZHB: // global
           (_saX4Z::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _saX4Z::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX51_info" {
     sat_saX51_info:
         const sat_saX51_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZHD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZHE; else goto caZHF;
       caZHE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZHF: // global
           I64[Sp - 24] = block_caZHf_info;
           _saX4O::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _saX4O::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cseek_info" {
     GHC.IO.FD.$w$cseek_info:
         const GHC.IO.FD.$w$cseek_entry;
         const 0;
         const 210453397518;
         const 17179869203;
         const SaXeV_srt+272;
 },
 _caZHf() //  [R1]
         { []
         }
     {offset
       caZHf: // global
           I64[Sp] = block_caZHG_info;
           _saX4S::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX4S::I64;
           if (R1 & 7 != 0) goto uaZIf; else goto caZHO;
       uaZIf: // global
           call _caZHG(R1) args: 0, res: 0, upd: 0;
       caZHO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZHf_info" {
     block_caZHf_info:
         const _caZHf;
         const 66;
         const 141733920798;
         const SaXeV_srt+272;
 },
 _caZHG() //  [R1]
         { []
         }
     {offset
       caZHG: // global
           _caZI6::P64 = R1 & 7;
           if (_caZI6::P64 < 3) goto uaZIa; else goto caZI2;
       uaZIa: // global
           if (_caZI6::P64 < 2) goto caZHU; else goto caZHY;
       caZHU: // global
           (_saX59::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX59::I64));
           goto uaZIj;
       caZHY: // global
           (_saX5e::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5e::I64));
           goto uaZIj;
       caZI2: // global
           (_saX5j::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX5j::I64));
           goto uaZIj;
       uaZIj: // global
           call _caZHm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZHG_info" {
     block_caZHG_info:
         const _caZHG;
         const 194;
         const 141733920798;
         const SaXeV_srt+272;
 },
 _caZHm() //  []
         { []
         }
     {offset
       caZHm: // global
           Hp = Hp + 32;
           _saX4U::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caZHL; else goto caZHK;
       caZHL: // global
           HpAlloc = 32;
           I64[Sp] = block_caZHl_info;
           R1 = _saX4U::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZHK: // global
           I64[Hp - 24] = sat_saX51_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX4U::I64;
           I64[Sp + 16] = block_caZHI_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZHl() //  [R1]
         { []
         }
     {offset
       caZHl: // global
           I64[Sp] = R1;
           call _caZHm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZHl_info" {
     block_caZHl_info:
         const _caZHl;
         const 194;
         const 141733920798;
         const SaXeV_srt+272;
 },
 _caZHI() //  []
         { []
         }
     {offset
       caZHI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZHI_info" {
     block_caZHI_info:
         const _caZHI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.15620565 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZIW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZIX; else goto caZIY;
       caZIX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZIY: // global
           I64[Sp - 24] = block_caZIT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZJ2; else goto caZIU;
       uaZJ2: // global
           call _caZIT(R1) args: 0, res: 0, upd: 0;
       caZIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD17_info" {
     GHC.IO.FD.$fIODeviceFD17_info:
         const GHC.IO.FD.$fIODeviceFD17_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const SaXeV_srt+304;
 },
 _caZIT() //  [R1]
         { []
         }
     {offset
       caZIT: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZIT_info" {
     block_caZIT_info:
         const _caZIT;
         const 2;
         const 4294967326;
         const SaXeV_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.161284533 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.163151072 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.164944712 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.167153884 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.170105611 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { []
         }
     {offset
       caZJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZJn; else goto caZJo;
       caZJn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZJo: // global
           (_caZJj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZJj::I64 == 0) goto caZJl; else goto caZJk;
       caZJl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZJk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZJj::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_raWVa_info" {
     lvl4_raWVa_info:
         const lvl4_raWVa_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.173916077 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { []
         }
     {offset
       caZJC: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD11_info" {
     GHC.IO.FD.$fIODeviceFD11_info:
         const GHC.IO.FD.$fIODeviceFD11_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const SaXeV_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.177981389 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { []
         }
     {offset
       caZJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZJQ; else goto caZJR;
       caZJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZJR: // global
           I64[Sp - 16] = block_caZJN_info;
           _saX5v::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _saX5v::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wsetSize_info" {
     GHC.IO.FD.$wsetSize_info:
         const GHC.IO.FD.$wsetSize_entry;
         const 0;
         const 12884901902;
         const 12884901901;
         const SaXeV_srt+344;
 },
 _caZJN() //  [R1]
         { []
         }
     {offset
       caZJN: // global
           (_saX5C::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_saX5C::I64) == 0 :: W32) goto caZK9; else goto caZK3;
       caZK9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZK3: // global
           (_saX5H::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX5H::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZJN_info" {
     block_caZJN_info:
         const _caZJN;
         const 65;
         const 4294967326;
         const SaXeV_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.184264662 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { []
         }
     {offset
       caZKu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZKv; else goto caZKw;
       caZKv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZKw: // global
           I64[Sp - 16] = block_caZKr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZKA; else goto caZKs;
       uaZKA: // global
           call _caZKr(R1) args: 0, res: 0, upd: 0;
       caZKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD10_info" {
     GHC.IO.FD.$fIODeviceFD10_info:
         const GHC.IO.FD.$fIODeviceFD10_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const SaXeV_srt+344;
 },
 _caZKr() //  [R1]
         { []
         }
     {offset
       caZKr: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZKr_info" {
     block_caZKr_info:
         const _caZKr;
         const 1;
         const 4294967326;
         const SaXeV_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.189585054 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZKO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.writeRawBufferPtr_info" {
     GHC.IO.FD.writeRawBufferPtr_info:
         const GHC.IO.FD.writeRawBufferPtr_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const SaXeV_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.193684106 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZKZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtrNoBlock_info" {
     GHC.IO.FD.readRawBufferPtrNoBlock_info:
         const GHC.IO.FD.readRawBufferPtrNoBlock_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const SaXeV_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.197029878 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZLa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtr_info" {
     GHC.IO.FD.readRawBufferPtr_info:
         const GHC.IO.FD.readRawBufferPtr_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const SaXeV_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.202540009 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { []
         }
     {offset
       caZLi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZLo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caZLz; else goto caZLA;
       caZLz: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caZLA: // global
           I64[Sp - 32] = block_caZLw_info;
           _saX5T::P64 = R6;
           R6 = 0;
           _saX5S::P64 = R5;
           _saX5W::I64 = I64[Sp + 16];
           R5 = R4 + _saX5W::I64;
           _saX5R::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _saX5W::I64;
           I64[Sp - 24] = _saX5R::I64;
           P64[Sp - 16] = _saX5S::P64;
           P64[Sp - 8] = _saX5T::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cfillReadBuffer0_info" {
     GHC.IO.FD.$w$cfillReadBuffer0_info:
         const GHC.IO.FD.$w$cfillReadBuffer0_entry;
         const 0;
         const 30064771086;
         const 38654705664;
         const SaXeV_srt+384;
         const 14792;
         const GHC.IO.FD.$w$cfillReadBuffer0_slow;
 },
 _caZLw() //  [R1]
         { []
         }
     {offset
       caZLw: // global
           I64[Sp] = block_caZLy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZLZ; else goto caZLC;
       uaZLZ: // global
           call _caZLy(R1) args: 0, res: 0, upd: 0;
       caZLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZLw_info" {
     block_caZLw_info:
         const _caZLw;
         const 3654;
         const 30;
 },
 _caZLy() //  [R1]
         { []
         }
     {offset
       caZLy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caZLI; else goto caZLH;
       caZLI: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZLH: // global
           _saX5R::I64 = I64[Sp + 8];
           _saX5S::P64 = P64[Sp + 16];
           _saX5T::P64 = P64[Sp + 24];
           _saX5U::I64 = I64[Sp + 32];
           _saX5V::I64 = I64[Sp + 40];
           _saX5W::I64 = I64[Sp + 48];
           _saX66::I64 = I64[R1 + 7];
           if (_saX66::I64 == (-1)) goto caZLY; else goto caZLT;
       caZLY: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _caZLX::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _caZLX::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZLT: // global
           call MO_Touch(_saX5S::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _saX5S::P64;
           P64[Hp - 72] = _saX5T::P64;
           I64[Hp - 64] = _saX5R::I64;
           I64[Hp - 56] = _saX5U::I64;
           I64[Hp - 48] = _saX5V::I64;
           I64[Hp - 40] = _saX5W::I64 + _saX66::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZLy_info" {
     block_caZLy_info:
         const _caZLy;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.212858778 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { []
         }
     {offset
       caZMv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZMz; else goto caZMA;
       caZMz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZMA: // global
           I64[Sp - 16] = block_caZMs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZMI; else goto caZMt;
       uaZMI: // global
           call _caZMs(R1) args: 0, res: 0, upd: 0;
       caZMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD7_info" {
     GHC.IO.FD.$fBufferedIOFD7_info:
         const GHC.IO.FD.$fBufferedIOFD7_entry;
         const 0;
         const 38654705678;
         const 12884901903;
         const SaXeV_srt+384;
 },
 _caZMs() //  [R1]
         { []
         }
     {offset
       caZMs: // global
           I64[Sp - 8] = block_caZMy_info;
           _saX6j::I64 = I64[R1 + 7];
           _saX6k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6k::I64;
           I64[Sp + 8] = _saX6j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZMH; else goto caZMC;
       uaZMH: // global
           call _caZMy(R1) args: 0, res: 0, upd: 0;
       caZMC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZMs_info" {
     block_caZMs_info:
         const _caZMs;
         const 1;
         const 4294967326;
         const SaXeV_srt+384;
 },
 _caZMy() //  [R1]
         { []
         }
     {offset
       caZMy: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZMy_info" {
     block_caZMy_info:
         const _caZMy;
         const 194;
         const 4294967326;
         const SaXeV_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.223372038 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { []
         }
     {offset
       caZN0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saX6L_entry() //  [R1]
         { []
         }
     {offset
       caZNk: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caZNl; else goto caZNm;
       caZNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZNm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_caZNh_info;
           _saX6v::P64 = P64[R1 + 16];
           _saX6w::P64 = P64[R1 + 24];
           _saX6u::I64 = I64[R1 + 40];
           _saX6x::I64 = I64[R1 + 48];
           _saX6y::I64 = I64[R1 + 56];
           _saX6z::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saX6u::I64;
           P64[Sp - 56] = _saX6v::P64;
           P64[Sp - 48] = _saX6w::P64;
           I64[Sp - 40] = _saX6x::I64;
           I64[Sp - 32] = _saX6y::I64;
           I64[Sp - 24] = _saX6z::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaZNE; else goto caZNi;
       uaZNE: // global
           call _caZNh(R1) args: 0, res: 0, upd: 0;
       caZNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX6L_info" {
     sat_saX6L_info:
         const sat_saX6L_entry;
         const 17179869187;
         const 15;
 },
 _caZNh() //  [R1]
         { []
         }
     {offset
       caZNh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caZNr; else goto caZNq;
       caZNr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZNq: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6z::I64 = I64[Sp + 48];
           _saX6J::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_saX6J::I64 == _saX6z::I64) goto caZND; else goto caZNA;
       caZND: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZNA: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saX6v::P64;
           P64[Hp - 32] = _saX6w::P64;
           I64[Hp - 24] = _saX6u::I64;
           I64[Hp - 16] = _saX6x::I64;
           I64[Hp - 8] = _saX6J::I64;
           I64[Hp] = _saX6z::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZNh_info" {
     block_caZNh_info:
         const _caZNh;
         const 3654;
         const 30;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caZNF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZNH; else goto caZNI;
       caZNH: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caZNI: // global
           I64[Sp - 32] = block_caZNa_info;
           _saX6v::P64 = R5;
           _saX6y::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _saX6y::I64;
           _saX6u::I64 = R4;
           R4 = R4 + _saX6y::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _saX6u::I64;
           P64[Sp - 16] = _saX6v::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cflushWriteBuffer0_info" {
     GHC.IO.FD.$w$cflushWriteBuffer0_info:
         const GHC.IO.FD.$w$cflushWriteBuffer0_entry;
         const 0;
         const 12884901902;
         const 38654705664;
         const SaXeV_srt+416;
         const 14792;
         const GHC.IO.FD.$w$cflushWriteBuffer0_slow;
 },
 _caZNa() //  [R1]
         { []
         }
     {offset
       caZNa: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caZNL; else goto caZNK;
       caZNL: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZNK: // global
           _saX6u::I64 = I64[Sp + 8];
           _saX6v::P64 = P64[Sp + 16];
           _saX6w::P64 = P64[Sp + 24];
           _saX6x::I64 = I64[Sp + 32];
           _saX6y::I64 = I64[Sp + 40];
           _saX6z::I64 = I64[Sp + 48];
           call MO_Touch(_saX6v::P64);
           I64[Hp - 88] = sat_saX6L_info;
           P64[Hp - 72] = _saX6v::P64;
           P64[Hp - 64] = _saX6w::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saX6u::I64;
           I64[Hp - 40] = _saX6x::I64;
           I64[Hp - 32] = _saX6y::I64;
           I64[Hp - 24] = _saX6z::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZNa_info" {
     block_caZNa_info:
         const _caZNa;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.235398359 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       caZOj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZOn; else goto caZOo;
       caZOn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZOo: // global
           I64[Sp - 16] = block_caZOg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZOw; else goto caZOh;
       uaZOw: // global
           call _caZOg(R1) args: 0, res: 0, upd: 0;
       caZOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD1_info" {
     GHC.IO.FD.$fBufferedIOFD1_info:
         const GHC.IO.FD.$fBufferedIOFD1_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const SaXeV_srt+416;
 },
 _caZOg() //  [R1]
         { []
         }
     {offset
       caZOg: // global
           I64[Sp - 8] = block_caZOm_info;
           _saX6R::I64 = I64[R1 + 7];
           _saX6S::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX6S::I64;
           I64[Sp + 8] = _saX6R::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZOv; else goto caZOq;
       uaZOv: // global
           call _caZOm(R1) args: 0, res: 0, upd: 0;
       caZOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZOg_info" {
     block_caZOg_info:
         const _caZOg;
         const 1;
         const 4294967326;
         const SaXeV_srt+416;
 },
 _caZOm() //  [R1]
         { []
         }
     {offset
       caZOm: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZOm_info" {
     block_caZOm_info:
         const _caZOm;
         const 194;
         const 4294967326;
         const SaXeV_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.244075645 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_saX7a_entry() //  [R1]
         { []
         }
     {offset
       caZP7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZP8; else goto caZPj;
       caZP8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZPj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto caZP6; else goto caZP5;
       caZP6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZP5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX7a_info" {
     sat_saX7a_info:
         const sat_saX7a_entry;
         const 4294967296;
         const 17;
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { []
         }
     {offset
       caZPk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZPl; else goto caZPm;
       caZPl: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZPm: // global
           I64[Sp - 8] = block_caZOR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZPq; else goto caZOS;
       uaZPq: // global
           call _caZOR(R1) args: 0, res: 0, upd: 0;
       caZOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD21_info" {
     GHC.IO.FD.$fIODeviceFD21_info:
         const GHC.IO.FD.$fIODeviceFD21_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _caZOR() //  [R1]
         { []
         }
     {offset
       caZOR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZPp; else goto caZPo;
       caZPp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZPo: // global
           (_saX78::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_saX7a_info;
           I64[Hp] = _saX78::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZOR_info" {
     block_caZOR_info:
         const _caZOR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.251399814 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { []
         }
     {offset
       caZPP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZPQ; else goto caZPR;
       caZPQ: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZPR: // global
           I64[Sp - 8] = block_caZPM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZPZ; else goto caZPN;
       uaZPZ: // global
           call _caZPM(R1) args: 0, res: 0, upd: 0;
       caZPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD25_info" {
     GHC.IO.FD.$fIODeviceFD25_info:
         const GHC.IO.FD.$fIODeviceFD25_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caZPM() //  [R1]
         { []
         }
     {offset
       caZPM: // global
           if (I64[R1 + 7] == (-1)) goto caZPY; else goto caZPX;
       caZPY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caZPX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZPM_info" {
     block_caZPM_info:
         const _caZPM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.256399017 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.25876607 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { []
         }
     {offset
       caZQi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZQj; else goto caZQk;
       caZQj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZQk: // global
           (_caZQf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZQf::I64 == 0) goto caZQh; else goto caZQg;
       caZQh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZQg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZQf::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD28_info" {
     GHC.IO.FD.$fIODeviceFD28_info:
         const GHC.IO.FD.$fIODeviceFD28_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.267319366 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_saX7u_entry() //  [R1]
         { []
         }
     {offset
       caZQI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZQY; else goto caZQZ;
       caZQY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caZQZ: // global
           I64[Sp - 8] = block_caZQS_info;
           Sp = Sp - 8;
           _caZQO::I64 = I64[R1 + 7];
           _caZQP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _caZQQ::I64 = I64[R1 + 15];
           _uaZR5::P64 = CurrentTSO;
           I64[I64[_uaZR5::P64 + 24] + 16] = Sp;
           _uaZR6::I64 = CurrentNursery;
           P64[_uaZR6::I64 + 8] = Hp + 8;
           I64[_uaZR5::P64 + 104] = I64[_uaZR5::P64 + 104] - ((Hp + 8) - I64[_uaZR6::I64]);
           (_uaZR3::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saX7r::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_caZQO::I64, _caZQP::I64, _caZQQ::I64, 0);
           (_uaZR4::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uaZR3::I64);
           BaseReg = _uaZR4::I64;
           _uaZR7::P64 = CurrentTSO;
           _uaZR8::P64 = I64[_uaZR7::P64 + 24];
           Sp = I64[_uaZR8::P64 + 16];
           SpLim = _uaZR8::P64 + 192;
           HpAlloc = 0;
           _uaZR9::I64 = CurrentNursery;
           _uaZRa::I64 = I64[_uaZR9::I64 + 8];
           Hp = _uaZRa::I64 - 8;
           _uaZRb::I64 = I64[_uaZR9::I64];
           HpLim = _uaZRb::I64 + ((%MO_SS_Conv_W32_W64(I32[_uaZR9::I64 + 48]) << 12) - 1);
           I64[_uaZR7::P64 + 104] = I64[_uaZR7::P64 + 104] + (_uaZRa::I64 - _uaZRb::I64);
           R1 = _saX7r::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX7u_info" {
     sat_saX7u_info:
         const sat_saX7u_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 _caZQS() //  [R1]
         { []
         }
     {offset
       caZQS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZR2; else goto caZR1;
       caZR2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZR1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZQS_info" {
     block_caZQS_info:
         const _caZQS;
         const 0;
         const 30;
 },
 sat_saX7B_entry() //  [R1]
         { []
         }
     {offset
       caZRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZRn; else goto caZRo;
       caZRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caZRj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZRy; else goto caZRk;
       uaZRy: // global
           call _caZRj(R1) args: 0, res: 0, upd: 0;
       caZRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX7B_info" {
     sat_saX7B_info:
         const sat_saX7B_entry;
         const 1;
         const 4294967312;
         const SaXeV_srt+440;
 },
 _caZRj() //  [R1]
         { []
         }
     {offset
       caZRj: // global
           _saX7A::I64 = I64[R1 + 7];
           if (_saX7A::I64 != 0) goto uaZRx; else goto caZRv;
       uaZRx: // global
           if (_saX7A::I64 != 1) goto caZRu; else goto caZRw;
       caZRu: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caZRw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZRv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZRj_info" {
     block_caZRj_info:
         const _caZRj;
         const 0;
         const 4294967326;
         const SaXeV_srt+440;
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZRG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZRH; else goto caZRI;
       caZRH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZRI: // global
           I64[Sp - 24] = block_caZRz_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZS1; else goto caZRA;
       uaZS1: // global
           call _caZRz(R1) args: 0, res: 0, upd: 0;
       caZRA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cready_info" {
     GHC.IO.FD.$w$cready_info:
         const GHC.IO.FD.$w$cready_entry;
         const 0;
         const 63050399078154254;
         const 17179869202;
         const SaXeV_srt+272;
 },
 _caZRz() //  [R1]
         { []
         }
     {offset
       caZRz: // global
           if (R1 & 7 == 1) goto caZRD; else goto caZRE;
       caZRD: // global
           I64[Sp] = 0;
           goto uaZS0;
       caZRE: // global
           I64[Sp] = 1;
           goto uaZS0;
       uaZS0: // global
           call _caZQz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZRz_info" {
     block_caZRz_info:
         const _caZRz;
         const 194;
         const 45036000568672286;
         const SaXeV_srt+272;
 },
 _caZQz() //  []
         { []
         }
     {offset
       caZQz: // global
           Hp = Hp + 32;
           _saX7k::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caZRL; else goto caZRK;
       caZRL: // global
           HpAlloc = 32;
           I64[Sp] = block_caZQy_info;
           R1 = _saX7k::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZRK: // global
           I64[Hp - 24] = sat_saX7u_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _saX7k::I64;
           I64[Sp + 16] = block_caZRd_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caZQy() //  [R1]
         { []
         }
     {offset
       caZQy: // global
           I64[Sp] = R1;
           call _caZQz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZQy_info" {
     block_caZQy_info:
         const _caZQy;
         const 194;
         const 45036000568672286;
         const SaXeV_srt+272;
 },
 _caZRd() //  [R1]
         { []
         }
     {offset
       caZRd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZRO; else goto caZRN;
       caZRO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZRN: // global
           I64[Hp - 16] = sat_saX7B_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZRd_info" {
     block_caZRd_info:
         const _caZRd;
         const 0;
         const 4294967326;
         const SaXeV_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.285454533 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZT7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZTb; else goto caZTc;
       caZTb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZTc: // global
           I64[Sp - 24] = block_caZT4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZTk; else goto caZT5;
       uaZTk: // global
           call _caZT4(R1) args: 0, res: 0, upd: 0;
       caZT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD27_info" {
     GHC.IO.FD.$fIODeviceFD27_info:
         const GHC.IO.FD.$fIODeviceFD27_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const SaXeV_srt+448;
 },
 _caZT4() //  [R1]
         { []
         }
     {offset
       caZT4: // global
           I64[Sp] = block_caZTa_info;
           _saX7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saX7I::I64;
           if (R1 & 7 != 0) goto uaZTj; else goto caZTe;
       uaZTj: // global
           call _caZTa(R1) args: 0, res: 0, upd: 0;
       caZTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZT4_info" {
     block_caZT4_info:
         const _caZT4;
         const 2;
         const 4294967326;
         const SaXeV_srt+448;
 },
 _caZTa() //  [R1]
         { []
         }
     {offset
       caZTa: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZTa_info" {
     block_caZTa_info:
         const _caZTa;
         const 130;
         const 4294967326;
         const SaXeV_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.294746633 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_saX7W_entry() //  [R1]
         { []
         }
     {offset
       caZTU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZTV; else goto caZTW;
       caZTV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZTW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caZTN_info;
           _saX7Q::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX7Q::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaZU9; else goto caZTO;
       uaZU9: // global
           call _caZTN(R1) args: 0, res: 0, upd: 0;
       caZTO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX7W_info" {
     sat_saX7W_info:
         const sat_saX7W_entry;
         const 4294967297;
         const 19;
 },
 _caZTN() //  [R1]
         { []
         }
     {offset
       caZTN: // global
           _saX7Q::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caZTR; else goto caZTS;
       caZTR: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caZU8; else goto caZU1;
       caZU1: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caZTS: // global
           Hp = Hp + 24;
           _saX7V::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caZU8; else goto caZU7;
       caZU8: // global
           HpAlloc = 24;
           R1 = _saX7V::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZU7: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX7Q::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZTN_info" {
     block_caZTN_info:
         const _caZTN;
         const 65;
         const 30;
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { []
         }
     {offset
       caZUa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZUb; else goto caZUc;
       caZUb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZUc: // global
           I64[Sp - 16] = block_caZTC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZUh; else goto caZTD;
       uaZUh: // global
           call _caZTC(R1) args: 0, res: 0, upd: 0;
       caZTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.setNonBlockingMode1_info" {
     GHC.IO.FD.setNonBlockingMode1_info:
         const GHC.IO.FD.setNonBlockingMode1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SaXeV_srt+472;
 },
 _caZTC() //  [R1]
         { []
         }
     {offset
       caZTC: // global
           I64[Sp - 8] = block_caZTH_info;
           R3 = P64[Sp + 8];
           _saX7Q::I64 = I64[R1 + 7];
           R2 = _saX7Q::I64;
           I64[Sp] = _saX7Q::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZTC_info" {
     block_caZTC_info:
         const _caZTC;
         const 1;
         const 4294967326;
         const SaXeV_srt+472;
 },
 _caZTH() //  [R1]
         { []
         }
     {offset
       caZTH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZUg; else goto caZUf;
       caZUg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZUf: // global
           I64[Hp - 24] = sat_saX7W_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZTH_info" {
     block_caZTH_info:
         const _caZTH;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.305482854 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { []
         }
     {offset
       caZUN: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.setNonBlockingMode_info" {
     GHC.IO.FD.setNonBlockingMode_info:
         const GHC.IO.FD.setNonBlockingMode_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SaXeV_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.30856744 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.31080351 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { []
         }
     {offset
       caZV1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZV2; else goto caZV3;
       caZV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZV3: // global
           (_caZUY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZUY::I64 == 0) goto caZV0; else goto caZUZ;
       caZV0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZUZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZUY::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_raWVc_info" {
     lvl6_raWVc_info:
         const lvl6_raWVc_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.315662304 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { []
         }
     {offset
       caZVh: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD2_info" {
     GHC.IO.FD.$fIODeviceFD2_info:
         const GHC.IO.FD.$fIODeviceFD2_entry;
         const 0;
         const 4503603922337806;
         const 8589934596;
         const SaXeV_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.320107152 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caZVA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZVB; else goto caZVC;
       caZVB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZVC: // global
           _saX82::I64 = R4;
           _saX81::I64 = R3;
           _caZVu::I64 = R4;
           (_saX87::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _caZVu::I64);
           _saX88::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX87::I64));
           if (_saX88::I64 != (-1)) goto uaZVR; else goto caZVz;
       uaZVR: // global
           I64[Sp - 24] = _saX81::I64;
           I64[Sp - 16] = _saX82::I64;
           I64[Sp - 8] = _saX88::I64;
           Sp = Sp - 24;
           call _caZVF() args: 0, res: 0, upd: 0;
       caZVz: // global
           (_saX8d::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saX8d::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cdup2_info" {
     GHC.IO.FD.$w$cdup2_info:
         const GHC.IO.FD.$w$cdup2_entry;
         const 0;
         const 12884901902;
         const 17179869200;
         const SaXeV_srt+496;
 },
 _caZVF() //  []
         { []
         }
     {offset
       caZVF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZVK; else goto caZVJ;
       caZVK: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caZVE_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZVJ: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caZVE() //  [R1]
         { []
         }
     {offset
       caZVE: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caZVF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZVE_info" {
     block_caZVE_info:
         const _caZVE;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.327374828 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       caZWg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZWk; else goto caZWl;
       caZWk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZWl: // global
           I64[Sp - 16] = block_caZWd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZWt; else goto caZWe;
       uaZWt: // global
           call _caZWd(R1) args: 0, res: 0, upd: 0;
       caZWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD1_info" {
     GHC.IO.FD.$fIODeviceFD1_info:
         const GHC.IO.FD.$fIODeviceFD1_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const SaXeV_srt+496;
 },
 _caZWd() //  [R1]
         { []
         }
     {offset
       caZWd: // global
           I64[Sp - 8] = block_caZWj_info;
           _saX8j::I64 = I64[R1 + 7];
           _saX8k::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saX8k::I64;
           I64[Sp + 8] = _saX8j::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZWs; else goto caZWn;
       uaZWs: // global
           call _caZWj(R1) args: 0, res: 0, upd: 0;
       caZWn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZWd_info" {
     block_caZWd_info:
         const _caZWd;
         const 1;
         const 4294967326;
         const SaXeV_srt+496;
 },
 _caZWj() //  [R1]
         { []
         }
     {offset
       caZWj: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZWj_info" {
     block_caZWj_info:
         const _caZWj;
         const 194;
         const 4294967326;
         const SaXeV_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.334302115 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.337073333 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { []
         }
     {offset
       caZWO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZWP; else goto caZWQ;
       caZWP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZWQ: // global
           (_caZWL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caZWL::I64 == 0) goto caZWN; else goto caZWM;
       caZWN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caZWM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caZWL::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD4_info" {
     GHC.IO.FD.$fIODeviceFD4_info:
         const GHC.IO.FD.$fIODeviceFD4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.3431711 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_saX8C_entry() //  [R1]
         { []
         }
     {offset
       caZXk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caZXo; else goto caZXp;
       caZXo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZXp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caZXh_info;
           _saX8p::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saX8p::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaZXt; else goto caZXi;
       uaZXt: // global
           call _caZXh(R1) args: 0, res: 0, upd: 0;
       caZXi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX8C_info" {
     sat_saX8C_info:
         const sat_saX8C_entry;
         const 4294967297;
         const 19;
 },
 _caZXh() //  [R1]
         { []
         }
     {offset
       caZXh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZXs; else goto caZXr;
       caZXs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caZXr: // global
           _saX8B::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8B::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caZXh_info" {
     block_caZXh_info:
         const _caZXh;
         const 65;
         const 30;
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { []
         }
     {offset
       caZXx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZXy; else goto caZXz;
       caZXy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZXz: // global
           _saX8p::I64 = R3;
           (_saX8u::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _saX8v::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX8u::I64));
           if (_saX8v::I64 != (-1)) goto uaZXL; else goto caZXw;
       uaZXL: // global
           I64[Sp - 16] = _saX8p::I64;
           I64[Sp - 8] = _saX8v::I64;
           Sp = Sp - 16;
           call _caZXB() args: 0, res: 0, upd: 0;
       caZXw: // global
           I64[Sp - 16] = block_caZXb_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _saX8p::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cdup_info" {
     GHC.IO.FD.$w$cdup_info:
         const GHC.IO.FD.$w$cdup_entry;
         const 0;
         const 30064771086;
         const 12884901900;
         const SaXeV_srt+520;
 },
 _caZXB() //  []
         { []
         }
     {offset
       caZXB: // global
           Hp = Hp + 24;
           _saX8v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caZXG; else goto caZXF;
       caZXG: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caZXA_info;
           R1 = _saX8v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caZXF: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saX8v::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caZXA() //  [R1]
         { []
         }
     {offset
       caZXA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caZXB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caZXA_info" {
     block_caZXA_info:
         const _caZXA;
         const 194;
         const 30;
 },
 _caZXb() //  [R1]
         { []
         }
     {offset
       caZXb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caZXK; else goto caZXJ;
       caZXK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZXJ: // global
           I64[Hp - 24] = sat_saX8C_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZXb_info" {
     block_caZXb_info:
         const _caZXb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.355254859 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { []
         }
     {offset
       caZYn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZYo; else goto caZYp;
       caZYo: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZYp: // global
           I64[Sp - 8] = block_caZYk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZYt; else goto caZYl;
       uaZYt: // global
           call _caZYk(R1) args: 0, res: 0, upd: 0;
       caZYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD3_info" {
     GHC.IO.FD.$fIODeviceFD3_info:
         const GHC.IO.FD.$fIODeviceFD3_entry;
         const 0;
         const 38654705678;
         const 8589934597;
         const SaXeV_srt+520;
 },
 _caZYk() //  [R1]
         { []
         }
     {offset
       caZYk: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZYk_info" {
     block_caZYk_info:
         const _caZYk;
         const 0;
         const 4294967326;
         const SaXeV_srt+520;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.362733058 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_saX8N_entry() //  [R1]
         { []
         }
     {offset
       caZYO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZYS; else goto caZYT;
       caZYS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZYT: // global
           I64[Sp - 8] = block_caZYL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZYX; else goto caZYM;
       uaZYX: // global
           call _caZYL(R1) args: 0, res: 0, upd: 0;
       caZYM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX8N_info" {
     sat_saX8N_info:
         const sat_saX8N_entry;
         const 1;
         const 16;
 },
 _caZYL() //  [R1]
         { []
         }
     {offset
       caZYL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZYW; else goto caZYV;
       caZYW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZYV: // global
           _saX8L::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8L::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZYL_info" {
     block_caZYL_info:
         const _caZYL;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { []
         }
     {offset
       caZZ3: // global
           _saX8I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caZZ4; else goto caZZ5;
       caZZ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caZZ7; else goto caZZ6;
       caZZ7: // global
           HpAlloc = 24;
           goto caZZ4;
       caZZ4: // global
           R2 = _saX8I::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caZZ6: // global
           I64[Hp - 16] = sat_saX8N_info;
           P64[Hp] = _saX8I::P64;
           I64[Sp - 8] = block_caZYY_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD6_info" {
     GHC.IO.FD.$fIODeviceFD6_info:
         const GHC.IO.FD.$fIODeviceFD6_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaXeV_srt+552;
 },
 _caZYY() //  [R1]
         { []
         }
     {offset
       caZYY: // global
           I64[Sp] = block_caZZ0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaZZc; else goto caZZ1;
       uaZZc: // global
           call _caZZ0(R1) args: 0, res: 0, upd: 0;
       caZZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZYY_info" {
     block_caZYY_info:
         const _caZYY;
         const 0;
         const 30;
 },
 _caZZ0() //  [R1]
         { []
         }
     {offset
       caZZ0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZZ0_info" {
     block_caZZ0_info:
         const _caZZ0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.37510357 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_saX90_entry() //  [R1]
         { []
         }
     {offset
       caZZK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caZZO; else goto caZZP;
       caZZO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caZZP: // global
           I64[Sp - 8] = block_caZZH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaZZT; else goto caZZI;
       uaZZT: // global
           call _caZZH(R1) args: 0, res: 0, upd: 0;
       caZZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX90_info" {
     sat_saX90_info:
         const sat_saX90_entry;
         const 1;
         const 16;
 },
 _caZZH() //  [R1]
         { []
         }
     {offset
       caZZH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caZZS; else goto caZZR;
       caZZS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caZZR: // global
           _saX8Y::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saX8Y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZZH_info" {
     block_caZZH_info:
         const _caZZH;
         const 0;
         const 30;
 },
 sat_saX99_entry() //  [R1]
         { []
         }
     {offset
       cb00d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb00e; else goto cb00f;
       cb00e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb00f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb005_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub00q; else goto cb006;
       ub00q: // global
           call _cb005(R1) args: 0, res: 0, upd: 0;
       cb006: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saX99_info" {
     sat_saX99_info:
         const sat_saX99_entry;
         const 1;
         const 16;
 },
 _cb005() //  [R1]
         { []
         }
     {offset
       cb005: // global
           _cb00c::P64 = R1 & 7;
           if (_cb00c::P64 == 3) goto cb00b; else goto ub00p;
       ub00p: // global
           if (_cb00c::P64 == 4) goto cb00b; else goto cb009;
       cb00b: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb009: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb005_info" {
     block_cb005_info:
         const _cb005;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { []
         }
     {offset
       cb00r: // global
           _saX8V::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb00s; else goto cb00t;
       cb00t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb00v; else goto cb00u;
       cb00v: // global
           HpAlloc = 24;
           goto cb00s;
       cb00s: // global
           R2 = _saX8V::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb00u: // global
           I64[Hp - 16] = sat_saX90_info;
           P64[Hp] = _saX8V::P64;
           I64[Sp - 8] = block_caZZU_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD20_info" {
     GHC.IO.FD.$fIODeviceFD20_info:
         const GHC.IO.FD.$fIODeviceFD20_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const SaXeV_srt+552;
 },
 _caZZU() //  [R1]
         { []
         }
     {offset
       caZZU: // global
           I64[Sp] = block_caZZW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub00A; else goto caZZX;
       ub00A: // global
           call _caZZW(R1) args: 0, res: 0, upd: 0;
       caZZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caZZU_info" {
     block_caZZU_info:
         const _caZZU;
         const 0;
         const 30;
 },
 _caZZW() //  [R1]
         { []
         }
     {offset
       caZZW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb00z; else goto cb00y;
       cb00z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb00y: // global
           _saX95::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_saX99_info;
           P64[Hp] = _saX95::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caZZW_info" {
     block_caZZW_info:
         const _caZZW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.390105628 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { []
         }
     {offset
       cb01f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb01g; else goto cb01h;
       cb01g: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb01h: // global
           I64[Sp - 8] = block_cb01c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub01n; else goto cb01d;
       ub01n: // global
           call _cb01c(R1) args: 0, res: 0, upd: 0;
       cb01d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.release1_info" {
     GHC.IO.FD.release1_info:
         const GHC.IO.FD.release1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cb01c() //  [R1]
         { []
         }
     {offset
       cb01c: // global
           (_saX9i::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb01c_info" {
     block_cb01c_info:
         const _cb01c;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.395320884 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { []
         }
     {offset
       cb01C: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.release_info" {
     GHC.IO.FD.release_info:
         const GHC.IO.FD.release_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.39843162 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.400630008 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { []
         }
     {offset
       cb01Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb01R; else goto cb01S;
       cb01R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb01S: // global
           (_cb01N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb01N::I64 == 0) goto cb01P; else goto cb01O;
       cb01P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb01O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb01N::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD23_info" {
     GHC.IO.FD.$fIODeviceFD23_info:
         const GHC.IO.FD.$fIODeviceFD23_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.405831822 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_saX9t_entry() //  [R1]
         { []
         }
     {offset
       cb02b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb02m; else goto cb02l;
       cb02m: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb02l: // global
           (_saX9q::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9q::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX9t_info" {
     sat_saX9t_info:
         const sat_saX9t_entry;
         const 4294967296;
         const 10;
         const 4294967299;
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { []
         }
     {offset
       cb02p: // global
           _saX9j::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb02q; else goto cb02r;
       cb02r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb02t; else goto cb02s;
       cb02t: // global
           HpAlloc = 16;
           goto cb02q;
       cb02q: // global
           R2 = _saX9j::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb02s: // global
           I64[Hp - 8] = sat_saX9t_info;
           I64[Hp] = _saX9j::I64;
           I64[Sp - 8] = block_cb02n_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wclose_info" {
     GHC.IO.FD.$wclose_info:
         const GHC.IO.FD.$wclose_entry;
         const 0;
         const 30064771086;
         const 8589934596;
         const SaXeV_srt+576;
 },
 _cb02n() //  []
         { []
         }
     {offset
       cb02n: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb02n_info" {
     block_cb02n_info:
         const _cb02n;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.41373505 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { []
         }
     {offset
       cb02R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb02S; else goto cb02T;
       cb02S: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb02T: // global
           I64[Sp - 8] = block_cb02O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub02X; else goto cb02P;
       ub02X: // global
           call _cb02O(R1) args: 0, res: 0, upd: 0;
       cb02P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD26_info" {
     GHC.IO.FD.$fIODeviceFD26_info:
         const GHC.IO.FD.$fIODeviceFD26_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const SaXeV_srt+584;
 },
 _cb02O() //  [R1]
         { []
         }
     {offset
       cb02O: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb02O_info" {
     block_cb02O_info:
         const _cb02O;
         const 0;
         const 4294967326;
         const SaXeV_srt+584;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.420613016 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_saX9W_entry() //  [R1]
         { []
         }
     {offset
       cb03o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb03z; else goto cb03y;
       cb03z: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb03y: // global
           (_saX9T::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9T::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saX9W_info" {
     sat_saX9W_info:
         const sat_saX9W_entry;
         const 4294967296;
         const 10;
         const 4294967299;
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { []
         }
     {offset
       cb03D: // global
           _saX9B::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb03E; else goto cb03F;
       cb03F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb03H; else goto cb03G;
       cb03H: // global
           HpAlloc = 16;
           goto cb03E;
       cb03E: // global
           R2 = _saX9B::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb03G: // global
           (_saX9G::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_saX9B::I64);
           (_saX9K::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saX9K::I64 == 0) goto cb03C; else goto cb03B;
       cb03C: // global
           I64[Hp - 8] = sat_saX9W_info;
           I64[Hp] = _saX9B::I64;
           I64[Sp - 8] = block_cb03M_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       cb03B: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saX9B::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cclose_info" {
     GHC.IO.FD.$w$cclose_info:
         const GHC.IO.FD.$w$cclose_entry;
         const 0;
         const 261993005070;
         const 8589934596;
         const SaXeV_srt+576;
 },
 _cb03M() //  []
         { []
         }
     {offset
       cb03M: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb03M_info" {
     block_cb03M_info:
         const _cb03M;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.428622972 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { []
         }
     {offset
       cb04c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb04d; else goto cb04e;
       cb04d: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb04e: // global
           I64[Sp - 8] = block_cb049_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub04i; else goto cb04a;
       ub04i: // global
           call _cb049(R1) args: 0, res: 0, upd: 0;
       cb04a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD22_info" {
     GHC.IO.FD.$fIODeviceFD22_info:
         const GHC.IO.FD.$fIODeviceFD22_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaXeV_srt+616;
 },
 _cb049() //  [R1]
         { []
         }
     {offset
       cb049: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb049_info" {
     block_cb049_info:
         const _cb049;
         const 0;
         const 4294967326;
         const SaXeV_srt+616;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.434162154 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.436020989 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.438236281 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { []
         }
     {offset
       cb04A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb04B; else goto cb04C;
       cb04B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb04C: // global
           (_cb04x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb04x::I64 == 0) goto cb04z; else goto cb04y;
       cb04z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb04y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb04x::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD6_info" {
     GHC.IO.FD.mkFD6_info:
         const GHC.IO.FD.mkFD6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.44194214 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.444101981 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { []
         }
     {offset
       cb04R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb04S; else goto cb04T;
       cb04S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb04T: // global
           (_cb04O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb04O::I64 == 0) goto cb04Q; else goto cb04P;
       cb04Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb04P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb04O::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD10_info" {
     GHC.IO.FD.mkFD10_info:
         const GHC.IO.FD.mkFD10_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.447651675 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.449951407 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { []
         }
     {offset
       cb058: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb059; else goto cb05a;
       cb059: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05a: // global
           (_cb055::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb055::I64 == 0) goto cb057; else goto cb056;
       cb057: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb056: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb055::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD8_info" {
     GHC.IO.FD.mkFD8_info:
         const GHC.IO.FD.mkFD8_entry;
         const 0;
         const 12884901909;
         const SaXeV_srt+632;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.45403107 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.456724711 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { []
         }
     {offset
       cb05p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb05q; else goto cb05r;
       cb05q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05r: // global
           (_cb05m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb05m::I64 == 0) goto cb05o; else goto cb05n;
       cb05o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb05n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb05m::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD4_info" {
     GHC.IO.FD.mkFD4_info:
         const GHC.IO.FD.mkFD4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.460135402 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.46248691 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { []
         }
     {offset
       cb05G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb05H; else goto cb05I;
       cb05H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb05I: // global
           (_cb05D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb05D::I64 == 0) goto cb05F; else goto cb05E;
       cb05F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb05E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb05D::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD2_info" {
     GHC.IO.FD.mkFD2_info:
         const GHC.IO.FD.mkFD2_entry;
         const 0;
         const 21474836501;
         const SaXeV_srt+632;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.47405046 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_saXaj_entry() //  [R1]
         { []
         }
     {offset
       cb06b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb06c; else goto cb06d;
       cb06c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb06d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb068_info;
           _saXa8::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saXa8::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub06B; else goto cb069;
       ub06B: // global
           call _cb068(R1) args: 0, res: 0, upd: 0;
       cb069: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saXaj_info" {
     sat_saXaj_info:
         const sat_saXaj_entry;
         const 2;
         const 18;
 },
 _cb068() //  [R1]
         { []
         }
     {offset
       cb068: // global
           I64[Sp] = block_cb06g_info;
           _saXah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saXah::I64;
           if (R1 & 7 != 0) goto ub06A; else goto cb06i;
       ub06A: // global
           call _cb06g(R1) args: 0, res: 0, upd: 0;
       cb06i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cb068_info" {
     block_cb068_info:
         const _cb068;
         const 1;
         const 30;
 },
 _cb06g() //  [R1]
         { []
         }
     {offset
       cb06g: // global
           _saXah::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb06o; else goto cb06v;
       cb06o: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb06y; else goto cb06q;
       cb06q: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb06v: // global
           Hp = Hp + 24;
           _saXai::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb06y; else goto cb06x;
       cb06y: // global
           HpAlloc = 24;
           R1 = _saXai::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb06x: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXah::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb06g_info" {
     block_cb06g_info:
         const _cb06g;
         const 65;
         const 30;
 },
 sat_saXaG_entry() //  [R1]
         { []
         }
     {offset
       cb07B: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb07C; else goto cb07D;
       cb07C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb07D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb07u_info;
           _saXan::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _saXan::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub07Q; else goto cb07v;
       ub07Q: // global
           call _cb07u(R1) args: 0, res: 0, upd: 0;
       cb07v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saXaG_info" {
     sat_saXaG_info:
         const sat_saXaG_entry;
         const 4294967297;
         const 19;
 },
 _cb07u() //  [R1]
         { []
         }
     {offset
       cb07u: // global
           _saXan::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb07y; else goto cb07z;
       cb07y: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb07P; else goto cb07I;
       cb07I: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb07z: // global
           Hp = Hp + 24;
           _saXaF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb07P; else goto cb07O;
       cb07P: // global
           HpAlloc = 24;
           R1 = _saXaF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb07O: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _saXan::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb07u_info" {
     block_cb07u_info:
         const _cb07u;
         const 65;
         const 30;
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cb07Y: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb07Z; else goto cb080;
       cb07Z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb080: // global
           I64[Sp - 32] = block_cb07R_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub09v; else goto cb07S;
       ub09v: // global
           call _cb07R(R1) args: 0, res: 0, upd: 0;
       cb07S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wmkFD_info" {
     GHC.IO.FD.$wmkFD_info:
         const GHC.IO.FD.$wmkFD_entry;
         const 0;
         const 246294899589134;
         const 21474836504;
         const SaXeV_srt+552;
 },
 _cb07R() //  [R1]
         { []
         }
     {offset
       cb07R: // global
           if (R1 & 7 == 1) goto cb07V; else goto cb07W;
       cb07V: // global
           I64[Sp] = block_cb08T_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       cb07W: // global
           I64[Sp] = block_cb095_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub09u; else goto cb097;
       ub09u: // global
           call _cb095(R1) args: 0, res: 0, upd: 0;
       cb097: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb07R_info" {
     block_cb07R_info:
         const _cb07R;
         const 3;
         const 211110527500318;
         const SaXeV_srt+552;
 },
 _cb08T() //  [R1]
         { []
         }
     {offset
       cb08T: // global
           I64[Sp] = block_cb08V_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub09x; else goto cb08Y;
       ub09x: // global
           call _cb08V(R1) args: 0, res: 0, upd: 0;
       cb08Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb08T_info" {
     block_cb08T_info:
         const _cb08T;
         const 3;
         const 12884901918;
         const SaXeV_srt+664;
 },
 _cb08V() //  [R1]
         { []
         }
     {offset
       cb08V: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb08V_info" {
     block_cb08V_info:
         const _cb08V;
         const 3;
         const 12884901918;
         const SaXeV_srt+664;
 },
 _cb095() //  [R1]
         { []
         }
     {offset
       cb095: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _saXaa() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb095_info" {
     block_cb095_info:
         const _cb095;
         const 3;
         const 12884901918;
         const SaXeV_srt+664;
 },
 _saXaa() //  []
         { []
         }
     {offset
       saXaa: // global
           I64[Sp - 8] = block_cb05Z_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub09A; else goto cb060;
       ub09A: // global
           call _cb05Z(R1) args: 0, res: 0, upd: 0;
       cb060: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb05Z() //  [R1]
         { []
         }
     {offset
       cb05Z: // global
           _cb09i::P64 = R1 & 7;
           if (_cb09i::P64 == 1) goto cb08a; else goto ub09k;
       cb08a: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ub09k: // global
           _saXa5::P64 = P64[Sp + 32];
           if (_cb09i::P64 == 3) goto cb08c; else goto cb084;
       cb08c: // global
           I64[Sp] = block_cb06F_info;
           R1 = _saXa5::P64;
           if (R1 & 7 != 0) goto ub09p; else goto cb06G;
       ub09p: // global
           call _cb06F(R1) args: 0, res: 0, upd: 0;
       cb06G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb084: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb087; else goto cb086;
       cb087: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb086: // global
           I64[Hp - 48] = sat_saXaj_info;
           P64[Hp - 32] = _saXa5::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb05Z_info" {
     block_cb05Z_info:
         const _cb05Z;
         const 262;
         const 12884901918;
         const SaXeV_srt+664;
 },
 _cb06F() //  [R1]
         { []
         }
     {offset
       cb06F: // global
           _saXad::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb06K_info;
           _saXan::I64 = I64[R1 + 7];
           R1 = _saXad::P64;
           I64[Sp + 32] = _saXan::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub09q; else goto cb06L;
       ub09q: // global
           call _cb06K(R1) args: 0, res: 0, upd: 0;
       cb06L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb06F_info" {
     block_cb06F_info:
         const _cb06F;
         const 774;
         const 4294967326;
         const SaXeV_srt+664;
 },
 _cb06K() //  [R1]
         { []
         }
     {offset
       cb06K: // global
           _saXae::P64 = P64[Sp + 8];
           _saXap::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXap::I64, 0)) goto cb08P; else goto cb08Q;
       cb08P: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       cb08Q: // global
           _saXas::I64 = _saXap::I64;
           goto saXar;
       saXar: // global
           I64[Sp + 8] = block_cb06X_info;
           R1 = _saXae::P64;
           I64[Sp + 16] = _saXas::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub09r; else goto cb06Y;
       ub09r: // global
           call _cb06X(R1) args: 0, res: 0, upd: 0;
       cb06Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb06K_info" {
     block_cb06K_info:
         const _cb06K;
         const 389;
         const 4294967326;
         const SaXeV_srt+664;
 },
 _cb06X() //  [R1]
         { []
         }
     {offset
       cb06X: // global
           _saXa6::P64 = P64[Sp + 24];
           _saXau::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_saXau::I64, 0)) goto cb08K; else goto cb08L;
       cb08K: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       cb08L: // global
           _saXax::I64 = _saXau::I64;
           goto saXaw;
       saXaw: // global
           I64[Sp] = block_cb08h_info;
           R1 = _saXa6::P64;
           I64[Sp + 24] = _saXax::I64;
           if (R1 & 7 != 0) goto ub09s; else goto cb08w;
       ub09s: // global
           call _cb08h(R1) args: 0, res: 0, upd: 0;
       cb08w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb06X_info" {
     block_cb06X_info:
         const _cb06X;
         const 196;
         const 4294967326;
         const SaXeV_srt+664;
 },
 _cb08h() //  [R1]
         { []
         }
     {offset
       cb08h: // global
           _saXan::I64 = I64[Sp + 16];
           _saXas::I64 = I64[Sp + 8];
           _saXax::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb08G; else goto cb08C;
       cb08G: // global
           _saXaz::I64 = 0;
           goto saXay;
       cb08C: // global
           _saXaz::I64 = 1;
           goto saXay;
       saXay: // global
           (_saXaD::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_saXan::I64, _saXas::I64, _saXax::I64, _saXaz::I64);
           _saXaE::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXaD::I64));
           if (_saXaE::I64 != (-1)) goto ub09n; else goto cb08s;
       ub09n: // global
           I64[Sp + 24] = _saXaE::I64;
           Sp = Sp + 16;
           call _cb07o() args: 0, res: 0, upd: 0;
       cb08s: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb08h_info" {
     block_cb08h_info:
         const _cb08h;
         const 452;
         const 4294967326;
         const SaXeV_srt+664;
 },
 _cb07o() //  []
         { []
         }
     {offset
       cb07o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb08p; else goto cb08o;
       cb08p: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb07n_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb08o: // global
           I64[Hp - 48] = sat_saXaG_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb07n() //  [R1]
         { []
         }
     {offset
       cb07n: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb07o() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb07n_info" {
     block_cb07n_info:
         const _cb07n;
         const 195;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.506788392 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { []
         }
     {offset
       cb0bd: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD1_info" {
     GHC.IO.FD.mkFD1_info:
         const GHC.IO.FD.mkFD1_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const SaXeV_srt+656;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.510109786 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0bo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD_info" {
     GHC.IO.FD.mkFD_info:
         const GHC.IO.FD.mkFD_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const SaXeV_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.526836398 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_saXbr_entry() //  [R1]
         { []
         }
     {offset
       cb0c3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0c6; else goto cb0c7;
       cb0c6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0c7: // global
           I64[Sp - 8] = block_cb0bZ_info;
           Sp = Sp - 8;
           _cb0bW::I64 = I64[R1 + 7];
           _cb0bX::I64 = I64[R1 + 15];
           _ub0cd::P64 = CurrentTSO;
           I64[I64[_ub0cd::P64 + 24] + 16] = Sp;
           _ub0ce::I64 = CurrentNursery;
           P64[_ub0ce::I64 + 8] = Hp + 8;
           I64[_ub0cd::P64 + 104] = I64[_ub0cd::P64 + 104] - ((Hp + 8) - I64[_ub0ce::I64]);
           (_ub0cb::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_saXbo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_cb0bW::I64, _cb0bX::I64, 438);
           (_ub0cc::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0cb::I64);
           BaseReg = _ub0cc::I64;
           _ub0cf::P64 = CurrentTSO;
           _ub0cg::P64 = I64[_ub0cf::P64 + 24];
           Sp = I64[_ub0cg::P64 + 16];
           SpLim = _ub0cg::P64 + 192;
           HpAlloc = 0;
           _ub0ch::I64 = CurrentNursery;
           _ub0ci::I64 = I64[_ub0ch::I64 + 8];
           Hp = _ub0ci::I64 - 8;
           _ub0cj::I64 = I64[_ub0ch::I64];
           HpLim = _ub0cj::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0ch::I64 + 48]) << 12) - 1);
           I64[_ub0cf::P64 + 104] = I64[_ub0cf::P64 + 104] + (_ub0ci::I64 - _ub0cj::I64);
           R1 = _saXbo::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saXbr_info" {
     sat_saXbr_info:
         const sat_saXbr_entry;
         const 8589934592;
         const 13;
         const 4294967299;
 },
 _cb0bZ() //  [R1]
         { []
         }
     {offset
       cb0bZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0ca; else goto cb0c9;
       cb0ca: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0c9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0bZ_info" {
     block_cb0bZ_info:
         const _cb0bZ;
         const 0;
         const 30;
 },
 sat_saXbI_entry() //  [R1]
         { []
         }
     {offset
       cb0cF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0cG; else goto cb0cH;
       cb0cG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0cH: // global
           I64[Sp - 24] = block_cb0cC_info;
           _saXbz::P64 = P64[R1 + 15];
           _saXbA::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _saXbz::P64;
           P64[Sp - 8] = _saXbA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0cN; else goto cb0cD;
       ub0cN: // global
           call _cb0cC(R1) args: 0, res: 0, upd: 0;
       cb0cD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saXbI_info" {
     sat_saXbI_info:
         const sat_saXbI_entry;
         const 3;
         const 8;
         const 4294967299;
 },
 _cb0cC() //  [R1]
         { []
         }
     {offset
       cb0cC: // global
           _saXbz::P64 = P64[Sp + 8];
           _saXbA::P64 = P64[Sp + 16];
           (_saXbH::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _saXbA::P64;
           R2 = _saXbz::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0cC_info" {
     block_cb0cC_info:
         const _cb0cC;
         const 2;
         const 30;
 },
 sat_saXbJ_entry() //  [R1, R2]
         { []
         }
     {offset
       cb0cO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0cP; else goto cb0cQ;
       cb0cP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0cQ: // global
           I64[Sp - 16] = block_cb0cs_info;
           _saXbu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _saXbu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0cU; else goto cb0ct;
       ub0cU: // global
           call _cb0cs(R1) args: 0, res: 0, upd: 0;
       cb0ct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saXbJ_info" {
     sat_saXbJ_info:
         const sat_saXbJ_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cb0cs() //  [R1]
         { []
         }
     {offset
       cb0cs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb0cT; else goto cb0cS;
       cb0cT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0cS: // global
           _saXbz::P64 = P64[R1 + 7];
           _saXbA::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_saXbI_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _saXbz::P64;
           P64[Hp] = _saXbA::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0cs_info" {
     block_cb0cs_info:
         const _cb0cs;
         const 1;
         const 30;
 },
 sat_saXbw_entry() //  [R1]
         { []
         }
     {offset
       cb0d0: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saXbw_info" {
     sat_saXbw_info:
         const sat_saXbw_entry;
         const 3;
         const 4294967304;
         const 4294967299;
         const SaXeV_srt+656;
 },
 section ""relreadonly" . ub0hD_srtd" {
     ub0hD_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_saXcZ_entry() //  [R1, R2]
         { []
         }
     {offset
       cb0d3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0d4; else goto cb0d5;
       cb0d4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0d5: // global
           I64[Sp - 24] = block_cb0bG_info;
           _saXb8::P64 = P64[R1 + 6];
           _saXb9::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _saXb8::P64;
           P64[Sp - 8] = _saXb9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0h6; else goto cb0bH;
       ub0h6: // global
           call _cb0bG(R1) args: 0, res: 0, upd: 0;
       cb0bH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saXcZ_info" {
     sat_saXcZ_info:
         const sat_saXcZ_entry;
         const 2;
         const 18446744069414584331;
         const 8589934597;
         const ub0hD_srtd;
 },
 section ""relreadonly" . ub0hE_srtd" {
     ub0hE_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0bG() //  [R1]
         { []
         }
     {offset
       cb0bG: // global
           I64[Sp - 8] = block_cb0d6_info;
           _saXbh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saXbh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0h4; else goto cb0ec;
       ub0h4: // global
           call _cb0d6(R1) args: 0, res: 0, upd: 0;
       cb0ec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0bG_info" {
     block_cb0bG_info:
         const _cb0bG;
         const 2;
         const 18446744069414584350;
         const ub0hE_srtd;
 },
 section ""relreadonly" . ub0hF_srtd" {
     ub0hF_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0d6() //  [R1]
         { []
         }
     {offset
       cb0d6: // global
           _saXb8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cb0ej; else goto cb0f5;
       cb0ej: // global
           I64[Sp] = block_cb0eg_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto ub0h7; else goto cb0ek;
       ub0h7: // global
           call _cb0eg(R1) args: 0, res: 0, upd: 0;
       cb0ek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0f5: // global
           I64[Sp] = block_cb0f3_info;
           R1 = _saXb8::P64;
           if (R1 & 7 != 0) goto ub0h8; else goto cb0f6;
       ub0h8: // global
           call _cb0f3(R1) args: 0, res: 0, upd: 0;
       cb0f6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0d6_info" {
     block_cb0d6_info:
         const _cb0d6;
         const 67;
         const 18446744069414584350;
         const ub0hF_srtd;
 },
 section ""relreadonly" . ub0hG_srtd" {
     ub0hG_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0eg() //  [R1]
         { []
         }
     {offset
       cb0eg: // global
           _cb0gJ::P64 = R1 & 7;
           if (_cb0gJ::P64 < 3) goto ub0gN; else goto ub0gO;
       ub0gN: // global
           if (_cb0gJ::P64 < 2) goto cb0er; else goto cb0eB;
       cb0er: // global
           I64[Sp] = block_cb0eo_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub0hh; else goto cb0es;
       ub0hh: // global
           call _cb0eo(R1) args: 0, res: 0, upd: 0;
       cb0es: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0eB: // global
           I64[Sp] = block_cb0ez_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub0hi; else goto cb0eC;
       ub0hi: // global
           call _cb0ez(R1) args: 0, res: 0, upd: 0;
       cb0eC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0gO: // global
           if (_cb0gJ::P64 < 4) goto cb0eL; else goto cb0eV;
       cb0eL: // global
           I64[Sp] = block_cb0eJ_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub0hj; else goto cb0eM;
       ub0hj: // global
           call _cb0eJ(R1) args: 0, res: 0, upd: 0;
       cb0eM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0eV: // global
           I64[Sp] = block_cb0eT_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub0hk; else goto cb0eW;
       ub0hk: // global
           call _cb0eT(R1) args: 0, res: 0, upd: 0;
       cb0eW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0eg_info" {
     block_cb0eg_info:
         const _cb0eg;
         const 67;
         const 18446744069414584350;
         const ub0hG_srtd;
 },
 section ""relreadonly" . ub0hH_srtd" {
     ub0hH_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eo() //  [R1]
         { []
         }
     {offset
       cb0eo: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0eo_info" {
     block_cb0eo_info:
         const _cb0eo;
         const 67;
         const 18446744069414584350;
         const ub0hH_srtd;
 },
 section ""relreadonly" . ub0hI_srtd" {
     ub0hI_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0ez() //  [R1]
         { []
         }
     {offset
       cb0ez: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0ez_info" {
     block_cb0ez_info:
         const _cb0ez;
         const 67;
         const 18446744069414584350;
         const ub0hI_srtd;
 },
 section ""relreadonly" . ub0hJ_srtd" {
     ub0hJ_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eJ() //  [R1]
         { []
         }
     {offset
       cb0eJ: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0eJ_info" {
     block_cb0eJ_info:
         const _cb0eJ;
         const 67;
         const 18446744069414584350;
         const ub0hJ_srtd;
 },
 section ""relreadonly" . ub0hK_srtd" {
     ub0hK_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0eT() //  [R1]
         { []
         }
     {offset
       cb0eT: // global
           I64[Sp] = I64[R1 + 7];
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0eT_info" {
     block_cb0eT_info:
         const _cb0eT;
         const 67;
         const 18446744069414584350;
         const ub0hK_srtd;
 },
 section ""relreadonly" . ub0hL_srtd" {
     ub0hL_srtd:
         const SaXeV_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb0f3() //  [R1]
         { []
         }
     {offset
       cb0f3: // global
           _cb0fO::P64 = R1 & 7;
           if (_cb0fO::P64 < 3) goto ub0gP; else goto ub0gQ;
       ub0gP: // global
           if (_cb0fO::P64 < 2) goto cb0fd; else goto cb0fn;
       cb0fd: // global
           I64[Sp] = block_cb0fa_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub0hp; else goto cb0fe;
       ub0hp: // global
           call _cb0fa(R1) args: 0, res: 0, upd: 0;
       cb0fe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0fn: // global
           I64[Sp] = block_cb0fl_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub0hq; else goto cb0fo;
       ub0hq: // global
           call _cb0fl(R1) args: 0, res: 0, upd: 0;
       cb0fo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0gQ: // global
           if (_cb0fO::P64 < 4) goto cb0fx; else goto cb0fH;
       cb0fx: // global
           I64[Sp] = block_cb0fv_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub0hr; else goto cb0fy;
       ub0hr: // global
           call _cb0fv(R1) args: 0, res: 0, upd: 0;
       cb0fy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb0fH: // global
           I64[Sp] = block_cb0fF_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub0hs; else goto cb0fI;
       ub0hs: // global
           call _cb0fF(R1) args: 0, res: 0, upd: 0;
       cb0fI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0f3_info" {
     block_cb0f3_info:
         const _cb0f3;
         const 67;
         const 18446744069414584350;
         const ub0hL_srtd;
 },
 section ""relreadonly" . ub0hM_srtd" {
     ub0hM_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fa() //  [R1]
         { []
         }
     {offset
       cb0fa: // global
           _saXci::I64 = I64[R1 + 7];
           (_saXcm::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXci::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcm::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0fa_info" {
     block_cb0fa_info:
         const _cb0fa;
         const 67;
         const 18446744069414584350;
         const ub0hM_srtd;
 },
 section ""relreadonly" . ub0hN_srtd" {
     ub0hN_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fl() //  [R1]
         { []
         }
     {offset
       cb0fl: // global
           _saXct::I64 = I64[R1 + 7];
           (_saXcx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXct::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcx::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0fl_info" {
     block_cb0fl_info:
         const _cb0fl;
         const 67;
         const 18446744069414584350;
         const ub0hN_srtd;
 },
 section ""relreadonly" . ub0hO_srtd" {
     ub0hO_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fv() //  [R1]
         { []
         }
     {offset
       cb0fv: // global
           _saXcE::I64 = I64[R1 + 7];
           (_saXcI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcE::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcI::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0fv_info" {
     block_cb0fv_info:
         const _cb0fv;
         const 67;
         const 18446744069414584350;
         const ub0hO_srtd;
 },
 section ""relreadonly" . ub0hP_srtd" {
     ub0hP_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0fF() //  [R1]
         { []
         }
     {offset
       cb0fF: // global
           _saXcP::I64 = I64[R1 + 7];
           (_saXcT::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _saXcP::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXcT::I64));
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0fF_info" {
     block_cb0fF_info:
         const _cb0fF;
         const 67;
         const 18446744069414584350;
         const ub0hP_srtd;
 },
 _cb0bO() //  []
         { []
         }
     {offset
       cb0bO: // global
           Hp = Hp + 24;
           _saXbj::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb0dd; else goto cb0dc;
       cb0dd: // global
           HpAlloc = 24;
           I64[Sp] = block_cb0bN_info;
           R1 = _saXbj::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0dc: // global
           I64[Hp - 16] = sat_saXbr_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saXbj::I64;
           I64[Sp + 8] = block_cb0cl_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub0hQ_srtd" {
     ub0hQ_srtd:
         const SaXeV_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb0bN() //  [R1]
         { []
         }
     {offset
       cb0bN: // global
           I64[Sp] = R1;
           call _cb0bO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0bN_info" {
     block_cb0bN_info:
         const _cb0bN;
         const 67;
         const 18446744069414584350;
         const ub0hQ_srtd;
 },
 section ""relreadonly" . ub0hR_srtd" {
     ub0hR_srtd:
         const SaXeV_srt+352;
         const 39;
         const 274877906945;
 },
 _cb0cl() //  [R1]
         { []
         }
     {offset
       cb0cl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb0dg; else goto cb0df;
       cb0dg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0df: // global
           I64[Hp - 40] = sat_saXbJ_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saXbw_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cb0d8_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0cl_info" {
     block_cb0cl_info:
         const _cb0cl;
         const 2;
         const 18446744069414584350;
         const ub0hR_srtd;
 },
 _cb0d8() //  [R1]
         { []
         }
     {offset
       cb0d8: // global
           I64[Sp] = block_cb0da_info;
           _saXbM::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _saXbM::P64;
           if (R1 & 7 != 0) goto ub0h9; else goto cb0di;
       ub0h9: // global
           call _cb0da(R1) args: 0, res: 0, upd: 0;
       cb0di: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0d8_info" {
     block_cb0d8_info:
         const _cb0d8;
         const 130;
         const 4294967326;
         const SaXeV_srt+720;
 },
 _cb0da() //  [R1]
         { []
         }
     {offset
       cb0da: // global
           I64[Sp - 8] = block_cb0dm_info;
           _saXbO::P64 = P64[R1 + 7];
           _saXbP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _saXbP::P64;
           P64[Sp + 8] = _saXbO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0ha; else goto cb0do;
       ub0ha: // global
           call _cb0dm(R1) args: 0, res: 0, upd: 0;
       cb0do: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0da_info" {
     block_cb0da_info:
         const _cb0da;
         const 2;
         const 4294967326;
         const SaXeV_srt+720;
 },
 _cb0dm() //  [R1]
         { []
         }
     {offset
       cb0dm: // global
           if (R1 & 7 == 2) goto cb0dz; else goto ub0h0;
       cb0dz: // global
           _saXbP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb0dx_info;
           R1 = _saXbP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub0hb; else goto cb0dA;
       ub0hb: // global
           call _cb0dx(R1) args: 0, res: 0, upd: 0;
       cb0dA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0h0: // global
           Sp = Sp + 24;
           call _cb0dG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0dm_info" {
     block_cb0dm_info:
         const _cb0dm;
         const 3;
         const 4294967326;
         const SaXeV_srt+720;
 },
 _cb0dx() //  [R1]
         { []
         }
     {offset
       cb0dx: // global
           if (R1 & 7 == 3) goto cb0dL; else goto ub0h1;
       cb0dL: // global
           I64[Sp + 16] = block_cb0dJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub0hd; else goto cb0dM;
       ub0hd: // global
           call _cb0dJ(R1) args: 0, res: 0, upd: 0;
       cb0dM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub0h1: // global
           Sp = Sp + 16;
           call _cb0dG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0dx_info" {
     block_cb0dx_info:
         const _cb0dx;
         const 2;
         const 4294967326;
         const SaXeV_srt+720;
 },
 _cb0dJ() //  [R1]
         { []
         }
     {offset
       cb0dJ: // global
           (_saXbY::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _saXbZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saXbY::I64));
           if (_saXbZ::I64 == 0) goto ub0h2; else goto cb0dZ;
       ub0h2: // global
           I64[Sp - 8] = _saXbZ::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _cb0e5() args: 0, res: 0, upd: 0;
       cb0dZ: // global
           (_saXc3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _saXc3::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0dJ_info" {
     block_cb0dJ_info:
         const _cb0dJ;
         const 0;
         const 4294967326;
         const SaXeV_srt+720;
 },
 _cb0e5() //  []
         { []
         }
     {offset
       cb0e5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0eb; else goto cb0ea;
       cb0eb: // global
           HpAlloc = 24;
           _saXbZ::I64 = I64[Sp];
           I64[Sp] = block_cb0e4_info;
           R1 = _saXbZ::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0ea: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb0e4() //  [R1]
         { []
         }
     {offset
       cb0e4: // global
           I64[Sp] = R1;
           call _cb0e5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0e4_info" {
     block_cb0e4_info:
         const _cb0e4;
         const 1;
         const 30;
 },
 _cb0dG() //  []
         { []
         }
     {offset
       cb0dG: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub0hS_srtd" {
     ub0hS_srtd:
         const SaXeV_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb0hx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0hy; else goto cb0hz;
       cb0hy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0hz: // global
           I64[Sp - 32] = block_cb0bz_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.openFile1_info" {
     GHC.IO.FD.openFile1_info:
         const GHC.IO.FD.openFile1_entry;
         const 0;
         const 18446744069414584334;
         const 17179869207;
         const ub0hS_srtd;
 },
 section ""relreadonly" . ub0hT_srtd" {
     ub0hT_srtd:
         const SaXeV_srt+264;
         const 58;
         const 279788325873647617;
 },
 _cb0bz() //  [R1]
         { []
         }
     {offset
       cb0bz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0hC; else goto cb0hB;
       cb0hC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0hB: // global
           I64[Hp - 16] = sat_saXcZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0bz_info" {
     block_cb0bz_info:
         const _cb0bz;
         const 3;
         const 18446744069414584350;
         const ub0hT_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.594639716 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb0l1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.openFile_info" {
     GHC.IO.FD.openFile_info:
         const GHC.IO.FD.openFile_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const SaXeV_srt+736;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.601403211 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { []
         }
     {offset
       cb0l9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_saXdj_entry() //  [R1]
         { []
         }
     {offset
       cb0lw: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb0lD; else goto cb0lE;
       cb0lD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0lE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb0lt_info;
           _saXd3::P64 = P64[R1 + 16];
           _saXd4::P64 = P64[R1 + 24];
           _saXd2::I64 = I64[R1 + 40];
           _saXd5::I64 = I64[R1 + 48];
           _saXd6::I64 = I64[R1 + 56];
           _saXd7::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _saXd2::I64;
           P64[Sp - 56] = _saXd3::P64;
           P64[Sp - 48] = _saXd4::P64;
           I64[Sp - 40] = _saXd5::I64;
           I64[Sp - 32] = _saXd6::I64;
           I64[Sp - 24] = _saXd7::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub0lI; else goto cb0lu;
       ub0lI: // global
           call _cb0lt(R1) args: 0, res: 0, upd: 0;
       cb0lu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saXdj_info" {
     sat_saXdj_info:
         const sat_saXdj_entry;
         const 17179869187;
         const 15;
 },
 _cb0lt() //  [R1]
         { []
         }
     {offset
       cb0lt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb0lH; else goto cb0lG;
       cb0lH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0lG: // global
           _saXdi::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _saXdi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb0lt_info" {
     block_cb0lt_info:
         const _cb0lt;
         const 3654;
         const 30;
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0lJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb0lL; else goto cb0lM;
       cb0lL: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb0lM: // global
           I64[Sp - 32] = block_cb0lm_info;
           _saXd4::P64 = R6;
           R6 = 0;
           _saXd3::P64 = R5;
           _saXd7::I64 = I64[Sp + 16];
           R5 = R4 + _saXd7::I64;
           _saXd2::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _saXd7::I64;
           I64[Sp - 24] = _saXd2::I64;
           P64[Sp - 16] = _saXd3::P64;
           P64[Sp - 8] = _saXd4::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cfillReadBuffer_info" {
     GHC.IO.FD.$w$cfillReadBuffer_info:
         const GHC.IO.FD.$w$cfillReadBuffer_entry;
         const 0;
         const 30064771086;
         const 38654705664;
         const SaXeV_srt+744;
         const 14792;
         const GHC.IO.FD.$w$cfillReadBuffer_slow;
 },
 _cb0lm() //  [R1]
         { []
         }
     {offset
       cb0lm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb0lP; else goto cb0lO;
       cb0lP: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0lO: // global
           _saXd2::I64 = I64[Sp + 8];
           _saXd3::P64 = P64[Sp + 16];
           _saXd4::P64 = P64[Sp + 24];
           _saXd5::I64 = I64[Sp + 32];
           _saXd6::I64 = I64[Sp + 40];
           _saXd7::I64 = I64[Sp + 48];
           call MO_Touch(_saXd3::P64);
           I64[Hp - 88] = sat_saXdj_info;
           P64[Hp - 72] = _saXd3::P64;
           P64[Hp - 64] = _saXd4::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _saXd2::I64;
           I64[Hp - 40] = _saXd5::I64;
           I64[Hp - 32] = _saXd6::I64;
           I64[Hp - 24] = _saXd7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0lm_info" {
     block_cb0lm_info:
         const _cb0lm;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.613118578 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { []
         }
     {offset
       cb0ms: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0mw; else goto cb0mx;
       cb0mw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0mx: // global
           I64[Sp - 16] = block_cb0mp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0mF; else goto cb0mq;
       ub0mF: // global
           call _cb0mp(R1) args: 0, res: 0, upd: 0;
       cb0mq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD11_info" {
     GHC.IO.FD.$fBufferedIOFD11_info:
         const GHC.IO.FD.$fBufferedIOFD11_entry;
         const 0;
         const 38654705678;
         const 12884901903;
         const SaXeV_srt+744;
 },
 _cb0mp() //  [R1]
         { []
         }
     {offset
       cb0mp: // global
           I64[Sp - 8] = block_cb0mv_info;
           _saXdp::I64 = I64[R1 + 7];
           _saXdq::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saXdq::I64;
           I64[Sp + 8] = _saXdp::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0mE; else goto cb0mz;
       ub0mE: // global
           call _cb0mv(R1) args: 0, res: 0, upd: 0;
       cb0mz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0mp_info" {
     block_cb0mp_info:
         const _cb0mp;
         const 1;
         const 4294967326;
         const SaXeV_srt+744;
 },
 _cb0mv() //  [R1]
         { []
         }
     {offset
       cb0mv: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0mv_info" {
     block_cb0mv_info:
         const _cb0mv;
         const 194;
         const 4294967326;
         const SaXeV_srt+744;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.622527877 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_saXdI_entry() //  [R1]
         { []
         }
     {offset
       cb0n7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0nb; else goto cb0nc;
       cb0nb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0nc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0n4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0ng; else goto cb0n5;
       ub0ng: // global
           call _cb0n4(R1) args: 0, res: 0, upd: 0;
       cb0n5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_saXdI_info" {
     sat_saXdI_info:
         const sat_saXdI_entry;
         const 1;
         const 16;
 },
 _cb0n4() //  [R1]
         { []
         }
     {offset
       cb0n4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb0nf; else goto cb0ne;
       cb0nf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0ne: // global
           _saXdD::P64 = P64[R1 + 7];
           _saXdC::I64 = I64[R1 + 23];
           _saXdF::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _saXdD::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _saXdC::I64;
           I64[Hp - 16] = _saXdF::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb0n4_info" {
     block_cb0n4_info:
         const _cb0n4;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { []
         }
     {offset
       cb0nh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0nl; else goto cb0nk;
       cb0nl: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0nk: // global
           I64[Hp - 16] = sat_saXdI_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD6_info" {
     GHC.IO.FD.$fBufferedIOFD6_info:
         const GHC.IO.FD.$fBufferedIOFD6_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.62935443 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.631727887 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { []
         }
     {offset
       cb0nG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0nK; else goto cb0nJ;
       cb0nK: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0nJ: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.FD_info" {
     GHC.IO.FD.FD_info:
         const GHC.IO.FD.FD_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.63569302 UTC

[section ""cstring" . iaZ0W_str" {
     iaZ0W_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]
 },
 GHC.IO.FD.FD_con_entry() //  [R1]
         { []
         }
     {offset
       cb0nQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.FD_con_info" {
     GHC.IO.FD.FD_con_info:
         const GHC.IO.FD.FD_con_entry;
         const 8589934592;
         const 6;
         const iaZ0W_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:56.639413361 UTC

[section ""relreadonly" . SaXeV_srt" {
     SaXeV_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.328758022 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:06:00.331144706 UTC

[section ""data" . GHC.IO.FD.$WFD_closure" {
     GHC.IO.FD.$WFD_closure:
         const GHC.IO.FD.$WFD_info;
 },
 GHC.IO.FD.$WFD_entry() //  [R2, R3]
         { []
         }
     {offset
       cb0Gz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0GI; else goto cb0GJ;
       cb0GI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$WFD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0GJ: // global
           I64[Sp - 16] = block_cb0Gw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0GP; else goto cb0Gx;
       ub0GP: // global
           call _cb0Gw(R1) args: 0, res: 0, upd: 0;
       cb0Gx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$WFD_info" {
     GHC.IO.FD.$WFD_info:
         const GHC.IO.FD.$WFD_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cb0Gw() //  [R1]
         { []
         }
     {offset
       cb0Gw: // global
           I64[Sp] = block_cb0GC_info;
           _sb0o0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb0o0::I64;
           if (R1 & 7 != 0) goto ub0GO; else goto cb0GD;
       ub0GO: // global
           call _cb0GC(R1) args: 0, res: 0, upd: 0;
       cb0GD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Gw_info" {
     block_cb0Gw_info:
         const _cb0Gw;
         const 1;
         const 30;
 },
 _cb0GC() //  [R1]
         { []
         }
     {offset
       cb0GC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0GN; else goto cb0GM;
       cb0GN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0GM: // global
           _sb0o2::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sb0o2::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0GC_info" {
     block_cb0GC_info:
         const _cb0GC;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.341312343 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD5_closure" {
     GHC.IO.FD.$fBufferedIOFD5_closure:
         const GHC.IO.FD.$fBufferedIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD5_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb0Hh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb0Hi; else goto ub0HR;
       cb0Hi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ub0HR: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cb0H9() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD5_info" {
     GHC.IO.FD.$fBufferedIOFD5_info:
         const GHC.IO.FD.$fBufferedIOFD5_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const Sb0HW_srt;
 },
 _cb0H9() //  []
         { []
         }
     {offset
       cb0H9: // global
           I64[Sp - 8] = block_cb0Hc_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Hc() //  [R1]
         { []
         }
     {offset
       cb0Hc: // global
           I64[Sp - 8] = block_cb0He_info;
           _sb0o9::P64 = R1;
           R1 = R1;
           P64[Sp] = _sb0o9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0HT; else goto cb0Hf;
       ub0HT: // global
           call _cb0He(R1) args: 0, res: 0, upd: 0;
       cb0Hf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Hc_info" {
     block_cb0Hc_info:
         const _cb0Hc;
         const 3;
         const 4294967326;
         const Sb0HW_srt;
 },
 _cb0He() //  [R1]
         { []
         }
     {offset
       cb0He: // global
           if (I64[R1 + 7] == (-1)) goto cb0HP; else goto cb0Hq;
       cb0HP: // global
           _sb0o3::P64 = P64[Sp + 16];
           _sb0o4::P64 = P64[Sp + 24];
           _sb0o5::P64 = P64[Sp + 32];
           (_sb0og::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           _sb0oh::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0og::I64));
           if (_sb0oh::I64 != 4) goto ub0HQ; else goto cb0HF;
       ub0HQ: // global
           if (_sb0oh::I64 != 11) goto cb0Hz; else goto cb0HL;
       cb0Hz: // global
           R2 = _sb0o3::P64;
           Sp = Sp + 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 0, upd: 8;
       cb0HL: // global
           R1 = _sb0o5::P64;
           Sp = Sp + 40;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cb0HF: // global
           P64[Sp + 16] = _sb0o3::P64;
           P64[Sp + 24] = _sb0o4::P64;
           P64[Sp + 32] = _sb0o5::P64;
           Sp = Sp + 16;
           call _cb0H9() args: 0, res: 0, upd: 0;
       cb0Hq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0He_info" {
     block_cb0He_info:
         const _cb0He;
         const 4;
         const 4294967326;
         const Sb0HW_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.348797167 UTC

[section ""cstring" . lvl_raWUX_bytes" {
     lvl_raWUX_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.351219163 UTC

[section ""data" . lvl1_raWUY_closure" {
     lvl1_raWUY_closure:
         const lvl1_raWUY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_raWUY_entry() //  [R1]
         { []
         }
     {offset
       cb0Il: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0Im; else goto cb0In;
       cb0Im: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0In: // global
           (_cb0Ii::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0Ii::I64 == 0) goto cb0Ik; else goto cb0Ij;
       cb0Ik: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0Ij: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0Ii::I64;
           R2 = lvl_raWUX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_raWUY_info" {
     lvl1_raWUY_info:
         const lvl1_raWUY_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.355125737 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD9_bytes" {
     GHC.IO.FD.$fBufferedIOFD9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.357302163 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD8_closure" {
     GHC.IO.FD.$fBufferedIOFD8_closure:
         const GHC.IO.FD.$fBufferedIOFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD8_entry() //  [R1]
         { []
         }
     {offset
       cb0ID: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0IE; else goto cb0IF;
       cb0IE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0IF: // global
           (_cb0IA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0IA::I64 == 0) goto cb0IC; else goto cb0IB;
       cb0IC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0IB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0IA::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD8_info" {
     GHC.IO.FD.$fBufferedIOFD8_info:
         const GHC.IO.FD.$fBufferedIOFD8_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.360837536 UTC

[section ""data" . lvl2_raWUZ_closure" {
     lvl2_raWUZ_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.362818032 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD3_closure" {
     GHC.IO.FD.$fBufferedIOFD3_closure:
         const GHC.IO.FD.$fBufferedIOFD3_info;
 },
 GHC.IO.FD.$fBufferedIOFD3_entry() //  []
         { []
         }
     {offset
       cb0IT: // global
           R1 = lvl2_raWUZ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD3_info" {
     GHC.IO.FD.$fBufferedIOFD3_info:
         const GHC.IO.FD.$fBufferedIOFD3_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.366665603 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD2_closure" {
     GHC.IO.FD.$fBufferedIOFD2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.368237586 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD10_closure" {
     GHC.IO.FD.$fBufferedIOFD10_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.374900704 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow() //  [R1]
         { []
         }
     {offset
       cb0J4: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0oI_entry() //  [R1]
         { []
         }
     {offset
       cb0Jj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Jt; else goto cb0Js;
       cb0Jt: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Js: // global
           (_sb0oG::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0oG::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0oI_info" {
     sat_sb0oI_info:
         const sat_sb0oI_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_sb0oV_entry() //  [R1]
         { []
         }
     {offset
       cb0JN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0JW; else goto cb0JX;
       cb0JW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0JX: // global
           I64[Sp - 8] = block_cb0JT_info;
           Sp = Sp - 8;
           _cb0JQ::I64 = I64[R1 + 7];
           _cb0JR::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0JS::I64 = I64[R1 + 31];
           _ub0K3::P64 = CurrentTSO;
           I64[I64[_ub0K3::P64 + 24] + 16] = Sp;
           _ub0K4::I64 = CurrentNursery;
           P64[_ub0K4::I64 + 8] = Hp + 8;
           I64[_ub0K3::P64 + 104] = I64[_ub0K3::P64 + 104] - ((Hp + 8) - I64[_ub0K4::I64]);
           (_ub0K1::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0oT::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_cb0JQ::I64, _cb0JR::I64, _cb0JS::I64);
           (_ub0K2::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0K1::I64);
           BaseReg = _ub0K2::I64;
           _ub0K5::P64 = CurrentTSO;
           _ub0K6::P64 = I64[_ub0K5::P64 + 24];
           Sp = I64[_ub0K6::P64 + 16];
           SpLim = _ub0K6::P64 + 192;
           HpAlloc = 0;
           _ub0K7::I64 = CurrentNursery;
           _ub0K8::I64 = I64[_ub0K7::I64 + 8];
           Hp = _ub0K8::I64 - 8;
           _ub0K9::I64 = I64[_ub0K7::I64];
           HpLim = _ub0K9::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0K7::I64 + 48]) << 12) - 1);
           I64[_ub0K5::P64 + 104] = I64[_ub0K5::P64 + 104] + (_ub0K8::I64 - _ub0K9::I64);
           R1 = _sb0oT::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0oV_info" {
     sat_sb0oV_info:
         const sat_sb0oV_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _cb0JT() //  [R1]
         { []
         }
     {offset
       cb0JT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0K0; else goto cb0JZ;
       cb0K0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0JZ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0JT_info" {
     block_cb0JT_info:
         const _cb0JT;
         const 0;
         const 30;
 },
 GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { []
         }
     {offset
       cb0Ke: // global
           _sb0on::I64 = R6;
           _sb0om::I64 = R5;
           _sb0ol::I64 = R4;
           _sb0ok::I64 = R3;
           _sb0oj::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0Kf; else goto cb0Kg;
       cb0Kg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Ki; else goto cb0Kh;
       cb0Ki: // global
           HpAlloc = 40;
           goto cb0Kf;
       cb0Kf: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
           P64[Sp - 40] = _sb0oj::P64;
           I64[Sp - 32] = _sb0ok::I64;
           I64[Sp - 24] = _sb0ol::I64;
           I64[Sp - 16] = _sb0om::I64;
           I64[Sp - 8] = _sb0on::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0Kh: // global
           if (_sb0ol::I64 == 0) goto cb0Kd; else goto cb0Kc;
       cb0Kd: // global
           (_sb0oM::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0ok::I64, 0, 0, 0);
           Hp = Hp - 40;
           _sb0oN::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0oM::I64));
           if (_sb0oN::I64 != 0) goto ub0KS; else goto cb0KM;
       ub0KS: // global
           P64[Sp - 40] = _sb0oj::P64;
           I64[Sp - 32] = _sb0ok::I64;
           I64[Sp - 24] = _sb0om::I64;
           I64[Sp - 16] = _sb0on::I64;
           I64[Sp - 8] = _sb0oN::I64;
           Sp = Sp - 40;
           call _cb0JE() args: 0, res: 0, upd: 0;
       cb0KM: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0Kc: // global
           I64[Hp - 32] = sat_sb0oI_info;
           I64[Hp - 24] = _sb0ok::I64;
           I64[Hp - 16] = _sb0om::I64;
           I64[Hp - 8] = _sb0on::I64;
           I64[Hp] = I64[Sp];
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0oj::P64;
           Sp = Sp - 8;
           call _sb0oq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wreadRawBufferPtrNoBlock_info" {
     GHC.IO.FD.$wreadRawBufferPtrNoBlock_info:
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry;
         const 0;
         const 12884901902;
         const 30064771072;
         const Sb0HW_srt+8;
         const 3974;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_slow;
 },
 _cb0JE() //  []
         { []
         }
     {offset
       cb0JE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0KJ; else goto cb0KI;
       cb0KJ: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_cb0JD_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0KI: // global
           I64[Hp - 32] = sat_sb0oV_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = P64[Sp];
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 32;
           call _sb0oq() args: 0, res: 0, upd: 0;
     }
 },
 _cb0JD() //  [R1]
         { []
         }
     {offset
       cb0JD: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb0JE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0JD_info" {
     block_cb0JD_info:
         const _cb0JD;
         const 3974;
         const 4294967326;
         const Sb0HW_srt+8;
 },
 _sb0oq() //  []
         { []
         }
     {offset
       sb0oq: // global
           _sb0oj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb0Km_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = P64[Sp];
           R2 = _sb0oj::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Km() //  [R1]
         { []
         }
     {offset
       cb0Km: // global
           I64[Sp] = block_cb0Ko_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0KZ; else goto cb0Kr;
       ub0KZ: // global
           call _cb0Ko(R1) args: 0, res: 0, upd: 0;
       cb0Kr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Km_info" {
     block_cb0Km_info:
         const _cb0Km;
         const 0;
         const 30;
 },
 _cb0Ko() //  [R1]
         { []
         }
     {offset
       cb0Ko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Kx; else goto cb0Kw;
       cb0Kx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Kw: // global
           _sb0oy::I64 = I64[R1 + 7];
           if (_sb0oy::I64 != (-1)) goto ub0KQ; else goto cb0KD;
       ub0KQ: // global
           if (_sb0oy::I64 != 0) goto cb0KC; else goto cb0KE;
       cb0KC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0oy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0KE: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0KD: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Ko_info" {
     block_cb0Ko_info:
         const _cb0Ko;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.396032021 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock1_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0Mk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb0My; else goto cb0Mz;
       cb0My: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0Mz: // global
           I64[Sp - 40] = block_cb0Mh_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub0MJ; else goto cb0Mi;
       ub0MJ: // global
           call _cb0Mh(R1) args: 0, res: 0, upd: 0;
       cb0Mi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtrNoBlock1_info" {
     GHC.IO.FD.readRawBufferPtrNoBlock1_info:
         const GHC.IO.FD.readRawBufferPtrNoBlock1_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const Sb0HW_srt+16;
 },
 _cb0Mh() //  [R1]
         { []
         }
     {offset
       cb0Mh: // global
           I64[Sp - 8] = block_cb0Mn_info;
           _sb0p3::I64 = I64[R1 + 7];
           _sb0p4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0p4::I64;
           I64[Sp + 16] = _sb0p3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0MI; else goto cb0Mo;
       ub0MI: // global
           call _cb0Mn(R1) args: 0, res: 0, upd: 0;
       cb0Mo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Mh_info" {
     block_cb0Mh_info:
         const _cb0Mh;
         const 4;
         const 4294967326;
         const Sb0HW_srt+16;
 },
 _cb0Mn() //  [R1]
         { []
         }
     {offset
       cb0Mn: // global
           I64[Sp] = block_cb0Ms_info;
           _sb0p6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0p6::I64;
           if (R1 & 7 != 0) goto ub0MK; else goto cb0Mt;
       ub0MK: // global
           call _cb0Ms(R1) args: 0, res: 0, upd: 0;
       cb0Mt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Mn_info" {
     block_cb0Mn_info:
         const _cb0Mn;
         const 325;
         const 4294967326;
         const Sb0HW_srt+16;
 },
 _cb0Ms() //  [R1]
         { []
         }
     {offset
       cb0Ms: // global
           I64[Sp] = block_cb0Mx_info;
           _sb0p8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0p8::I64;
           if (R1 & 7 != 0) goto ub0ML; else goto cb0MD;
       ub0ML: // global
           call _cb0Mx(R1) args: 0, res: 0, upd: 0;
       cb0MD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Ms_info" {
     block_cb0Ms_info:
         const _cb0Ms;
         const 837;
         const 4294967326;
         const Sb0HW_srt+16;
 },
 _cb0Mx() //  [R1]
         { []
         }
     {offset
       cb0Mx: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Mx_info" {
     block_cb0Mx_info:
         const _cb0Mx;
         const 1861;
         const 4294967326;
         const Sb0HW_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.407826829 UTC

[section ""data" . GHC.IO.FD.$w$creadNonBlocking_closure" {
     GHC.IO.FD.$w$creadNonBlocking_closure:
         const GHC.IO.FD.$w$creadNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$creadNonBlocking_slow() //  [R1]
         { []
         }
     {offset
       cb0Nd: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$creadNonBlocking_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cb0Nj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0No; else goto cb0Np;
       cb0No: // global
           R1 = GHC.IO.FD.$w$creadNonBlocking_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb0Np: // global
           I64[Sp - 8] = block_cb0Nl_info;
           R6 = 0;
           _sb0pg::I64 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 16] = _sb0pg::I64;
           Sp = Sp - 16;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$creadNonBlocking_info" {
     GHC.IO.FD.$w$creadNonBlocking_info:
         const GHC.IO.FD.$w$creadNonBlocking_entry;
         const 0;
         const 55834574862;
         const 21474836480;
         const Sb0HW_srt+16;
         const 964;
         const GHC.IO.FD.$w$creadNonBlocking_slow;
 },
 _cb0Nl() //  [R1]
         { []
         }
     {offset
       cb0Nl: // global
           I64[Sp] = block_cb0Nn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0NE; else goto cb0Nr;
       ub0NE: // global
           call _cb0Nn(R1) args: 0, res: 0, upd: 0;
       cb0Nr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Nl_info" {
     block_cb0Nl_info:
         const _cb0Nl;
         const 0;
         const 30;
 },
 _cb0Nn() //  [R1]
         { []
         }
     {offset
       cb0Nn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Nx; else goto cb0Nw;
       cb0Nx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Nw: // global
           if (I64[R1 + 7] == (-1)) goto cb0ND; else goto cb0NC;
       cb0ND: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0NC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Nn_info" {
     block_cb0Nn_info:
         const _cb0Nn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.416825366 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD3_closure" {
     GHC.IO.FD.$fRawIOFD3_closure:
         const GHC.IO.FD.$fRawIOFD3_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb0O6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0Of; else goto cb0Og;
       cb0Of: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0Og: // global
           I64[Sp - 24] = block_cb0O3_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0Op; else goto cb0O4;
       ub0Op: // global
           call _cb0O3(R1) args: 0, res: 0, upd: 0;
       cb0O4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD3_info" {
     GHC.IO.FD.$fRawIOFD3_info:
         const GHC.IO.FD.$fRawIOFD3_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const Sb0HW_srt+40;
 },
 _cb0O3() //  [R1]
         { []
         }
     {offset
       cb0O3: // global
           I64[Sp - 8] = block_cb0O9_info;
           _sb0pt::I64 = I64[R1 + 7];
           _sb0pu::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0pu::I64;
           I64[Sp + 8] = _sb0pt::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Oo; else goto cb0Oa;
       ub0Oo: // global
           call _cb0O9(R1) args: 0, res: 0, upd: 0;
       cb0Oa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0O3_info" {
     block_cb0O3_info:
         const _cb0O3;
         const 2;
         const 4294967326;
         const Sb0HW_srt+40;
 },
 _cb0O9() //  [R1]
         { []
         }
     {offset
       cb0O9: // global
           I64[Sp] = block_cb0Oe_info;
           _sb0pw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0pw::I64;
           if (R1 & 7 != 0) goto ub0Oq; else goto cb0Oj;
       ub0Oq: // global
           call _cb0Oe(R1) args: 0, res: 0, upd: 0;
       cb0Oj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0O9_info" {
     block_cb0O9_info:
         const _cb0O9;
         const 195;
         const 4294967326;
         const Sb0HW_srt+40;
 },
 _cb0Oe() //  [R1]
         { []
         }
     {offset
       cb0Oe: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$creadNonBlocking_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Oe_info" {
     block_cb0Oe_info:
         const _cb0Oe;
         const 451;
         const 4294967326;
         const Sb0HW_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.425364934 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD4_bytes" {
     GHC.IO.FD.$fBufferedIOFD4_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,87,114,105,116,101,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.427629941 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_loc_closure" {
     GHC.IO.FD.$fBufferedIOFD_loc_closure:
         const GHC.IO.FD.$fBufferedIOFD_loc_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_loc_entry() //  [R1]
         { []
         }
     {offset
       cb0OS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0OT; else goto cb0OU;
       cb0OT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0OU: // global
           (_cb0OP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0OP::I64 == 0) goto cb0OR; else goto cb0OQ;
       cb0OR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0OQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0OP::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD_loc_info" {
     GHC.IO.FD.$fBufferedIOFD_loc_info:
         const GHC.IO.FD.$fBufferedIOFD_loc_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.433367861 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD14_closure" {
     GHC.IO.FD.$fBufferedIOFD14_closure:
         const GHC.IO.FD.$fBufferedIOFD14_info;
 },
 GHC.IO.FD.$fBufferedIOFD14_entry() //  [R2]
         { []
         }
     {offset
       cb0Pa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Pb; else goto cb0Pc;
       cb0Pb: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD14_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb0Pc: // global
           I64[Sp - 8] = block_cb0P7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Pk; else goto cb0P8;
       ub0Pk: // global
           call _cb0P7(R1) args: 0, res: 0, upd: 0;
       cb0P8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD14_info" {
     GHC.IO.FD.$fBufferedIOFD14_info:
         const GHC.IO.FD.$fBufferedIOFD14_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb0P7() //  [R1]
         { []
         }
     {offset
       cb0P7: // global
           if (I64[R1 + 7] == (-1)) goto cb0Pj; else goto cb0Pi;
       cb0Pj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb0Pi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0P7_info" {
     block_cb0P7_info:
         const _cb0P7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.438165077 UTC

[section ""cstring" . GHC.IO.FD.$fBufferedIOFD13_bytes" {
     GHC.IO.FD.$fBufferedIOFD13_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,102,100,82,101,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.44036852 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD12_closure" {
     GHC.IO.FD.$fBufferedIOFD12_closure:
         const GHC.IO.FD.$fBufferedIOFD12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD12_entry() //  [R1]
         { []
         }
     {offset
       cb0PG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0PH; else goto cb0PI;
       cb0PH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0PI: // global
           (_cb0PD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb0PD::I64 == 0) goto cb0PF; else goto cb0PE;
       cb0PF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb0PE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb0PD::I64;
           R2 = GHC.IO.FD.$fBufferedIOFD13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD12_info" {
     GHC.IO.FD.$fBufferedIOFD12_info:
         const GHC.IO.FD.$fBufferedIOFD12_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.453642958 UTC

[section ""data" . GHC.IO.FD.$wreadRawBufferPtr_closure" {
     GHC.IO.FD.$wreadRawBufferPtr_closure:
         const GHC.IO.FD.$wreadRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wreadRawBufferPtr_slow() //  [R1]
         { []
         }
     {offset
       cb0PS: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0pX_entry() //  [R1]
         { []
         }
     {offset
       cb0Qb: // global
           _sb0pX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Qc; else goto cb0Qd;
       cb0Qd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Qf; else goto cb0Qe;
       cb0Qf: // global
           HpAlloc = 16;
           goto cb0Qc;
       cb0Qc: // global
           R1 = _sb0pX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Qe: // global
           _sb0pE::I64 = I64[_sb0pX::P64 + 7];
           (_sb0pR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0pR::I64 == 0) goto cb0Qa; else goto cb0Q9;
       cb0Qa: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Qp_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       cb0Q9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0pX_info" {
     sat_sb0pX_info:
         const sat_sb0pX_entry;
         const 4294967296;
         const 12884901898;
         const 4294967299;
         const Sb0HW_srt+56;
 },
 _cb0Qp() //  []
         { []
         }
     {offset
       cb0Qp: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Qp_info" {
     block_cb0Qp_info:
         const _cb0Qp;
         const 0;
         const 30;
 },
 sat_sb0q3_entry() //  [R1]
         { []
         }
     {offset
       cb0QB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0QF; else goto cb0QG;
       cb0QF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0QG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0Qy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0QK; else goto cb0Qz;
       ub0QK: // global
           call _cb0Qy(R1) args: 0, res: 0, upd: 0;
       cb0Qz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0q3_info" {
     sat_sb0q3_info:
         const sat_sb0q3_entry;
         const 1;
         const 16;
 },
 _cb0Qy() //  [R1]
         { []
         }
     {offset
       cb0Qy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0QJ; else goto cb0QI;
       cb0QJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0QI: // global
           _sb0q2::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0q2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb0Qy_info" {
     block_cb0Qy_info:
         const _cb0Qy;
         const 0;
         const 30;
 },
 sat_sb0qc_entry() //  [R1]
         { []
         }
     {offset
       cb0QU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0R4; else goto cb0R3;
       cb0R4: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0R3: // global
           (_sb0qa::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0qa::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0qc_info" {
     sat_sb0qc_info:
         const sat_sb0qc_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_sb0qy_entry() //  [R1]
         { []
         }
     {offset
       cb0Rv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0RE; else goto cb0RF;
       cb0RE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0RF: // global
           I64[Sp - 8] = block_cb0RB_info;
           Sp = Sp - 8;
           _cb0Ry::I64 = I64[R1 + 7];
           _cb0Rz::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0RA::I64 = I64[R1 + 31];
           _ub0RL::P64 = CurrentTSO;
           I64[I64[_ub0RL::P64 + 24] + 16] = Sp;
           _ub0RM::I64 = CurrentNursery;
           P64[_ub0RM::I64 + 8] = Hp + 8;
           I64[_ub0RL::P64 + 104] = I64[_ub0RL::P64 + 104] - ((Hp + 8) - I64[_ub0RM::I64]);
           (_ub0RJ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0qw::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC21ZCbaseZCSystemziPosixziInternalsZCread(_cb0Ry::I64, _cb0Rz::I64, _cb0RA::I64);
           (_ub0RK::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0RJ::I64);
           BaseReg = _ub0RK::I64;
           _ub0RN::P64 = CurrentTSO;
           _ub0RO::P64 = I64[_ub0RN::P64 + 24];
           Sp = I64[_ub0RO::P64 + 16];
           SpLim = _ub0RO::P64 + 192;
           HpAlloc = 0;
           _ub0RP::I64 = CurrentNursery;
           _ub0RQ::I64 = I64[_ub0RP::I64 + 8];
           Hp = _ub0RQ::I64 - 8;
           _ub0RR::I64 = I64[_ub0RP::I64];
           HpLim = _ub0RR::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0RP::I64 + 48]) << 12) - 1);
           I64[_ub0RN::P64 + 104] = I64[_ub0RN::P64 + 104] + (_ub0RQ::I64 - _ub0RR::I64);
           R1 = _sb0qw::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0qy_info" {
     sat_sb0qy_info:
         const sat_sb0qy_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _cb0RB() //  [R1]
         { []
         }
     {offset
       cb0RB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0RI; else goto cb0RH;
       cb0RI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0RH: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0RB_info" {
     block_cb0RB_info:
         const _cb0RB;
         const 0;
         const 30;
 },
 sat_sb0qG_entry() //  [R1]
         { []
         }
     {offset
       cb0S1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Sb; else goto cb0Sa;
       cb0Sb: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Sa: // global
           (_sb0qE::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC22ZCbaseZCSystemziPosixziInternalsZCread(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0qE::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0qG_info" {
     sat_sb0qG_info:
         const sat_sb0qG_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$wreadRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0Sf: // global
           _sb0pH::I64 = R6;
           _sb0pG::I64 = R5;
           _sb0pF::I64 = R4;
           _sb0pE::I64 = R3;
           _sb0pD::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0Sg; else goto cb0Sh;
       cb0Sh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Sj; else goto cb0Si;
       cb0Sj: // global
           HpAlloc = 40;
           goto cb0Sg;
       cb0Sg: // global
           R1 = GHC.IO.FD.$wreadRawBufferPtr_closure;
           P64[Sp - 40] = _sb0pD::P64;
           I64[Sp - 32] = _sb0pE::I64;
           I64[Sp - 24] = _sb0pF::I64;
           I64[Sp - 16] = _sb0pG::I64;
           I64[Sp - 8] = _sb0pH::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0Si: // global
           if (_sb0pF::I64 == 0) goto cb0Se; else goto cb0Sd;
       cb0Se: // global
           (_sb0qg::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0pE::I64, 0, 0, 0);
           Hp = Hp - 40;
           _sb0qU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0qg::I64));
           if (_sb0qU::I64 != (-1)) goto cb0T4; else goto cb0Tf;
       cb0T4: // global
           P64[Sp - 40] = _sb0pD::P64;
           I64[Sp - 32] = _sb0pE::I64;
           I64[Sp - 24] = _sb0pG::I64;
           I64[Sp - 16] = _sb0pH::I64;
           I64[Sp - 8] = _sb0qU::I64;
           Sp = Sp - 40;
           call _cb0Re() args: 0, res: 0, upd: 0;
       cb0Tf: // global
           I64[Sp - 40] = block_cb0Tc_info;
           R2 = _sb0pD::P64;
           P64[Sp - 32] = _sb0pD::P64;
           I64[Sp - 24] = _sb0pE::I64;
           I64[Sp - 16] = _sb0pG::I64;
           I64[Sp - 8] = _sb0pH::I64;
           Sp = Sp - 40;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       cb0Sd: // global
           I64[Hp - 32] = sat_sb0qc_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _sb0pE::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0pD::P64;
           Sp = Sp - 16;
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wreadRawBufferPtr_info" {
     GHC.IO.FD.$wreadRawBufferPtr_info:
         const GHC.IO.FD.$wreadRawBufferPtr_entry;
         const 0;
         const 8250632175630;
         const 30064771072;
         const Sb0HW_srt;
         const 3974;
         const GHC.IO.FD.$wreadRawBufferPtr_slow;
 },
 _cb0Tc() //  [R1]
         { []
         }
     {offset
       cb0Tc: // global
           I64[Sp] = block_cb0Te_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub0TD; else goto cb0Ti;
       ub0TD: // global
           call _cb0Te(R1) args: 0, res: 0, upd: 0;
       cb0Ti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Tc_info" {
     block_cb0Tc_info:
         const _cb0Tc;
         const 1925;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0Te() //  [R1]
         { []
         }
     {offset
       cb0Te: // global
           P64[Sp] = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           I64[Sp + 16] = I64[Sp + 24];
           I64[Sp + 24] = I64[Sp + 32];
           I64[Sp + 32] = I64[R1 + 7];
           call _cb0Re() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0Te_info" {
     block_cb0Te_info:
         const _cb0Te;
         const 1925;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0Re() //  []
         { []
         }
     {offset
       cb0Re: // global
           Hp = Hp + 16;
           _sb0qj::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cb0Ss; else goto cb0Sr;
       cb0Ss: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0Rd_info;
           R1 = _sb0qj::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0Sr: // global
           if (_sb0qj::I64 == 0) goto cb0SY; else goto cb0SB;
       cb0SY: // global
           _sb0pE::I64 = I64[Sp + 8];
           (_sb0qL::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0qL::I64 == 0) goto cb0SV; else goto cb0SN;
       cb0SV: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Rj_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           Sp = Sp - 8;
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
       cb0SN: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0pE::I64));
           I64[Sp - 8] = block_cb0SL_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtRead_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cb0SB: // global
           Hp = Hp - 16;
           Sp = Sp - 8;
           call _cb0Rj() args: 0, res: 0, upd: 0;
     }
 },
 _cb0Rd() //  [R1]
         { []
         }
     {offset
       cb0Rd: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb0Re() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0Rd_info" {
     block_cb0Rd_info:
         const _cb0Rd;
         const 3974;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0SL() //  []
         { []
         }
     {offset
       cb0SL: // global
           call _cb0Rj() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0SL_info" {
     block_cb0SL_info:
         const _cb0SL;
         const 3974;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0Rj() //  []
         { []
         }
     {offset
       cb0Rj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0Sv; else goto cb0Su;
       cb0Sv: // global
           HpAlloc = 40;
           I64[Sp] = block_cb0Rj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb0Su: // global
           _sb0pD::P64 = P64[Sp + 8];
           _sb0pE::I64 = I64[Sp + 16];
           _sb0pG::I64 = I64[Sp + 24];
           _sb0pH::I64 = I64[Sp + 32];
           _sb0pI::I64 = I64[Sp + 48];
           (_sb0qp::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0qp::I64 == 0) goto cb0Sy; else goto cb0Sx;
       cb0Sy: // global
           I64[Hp - 32] = sat_sb0qG_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = _sb0pI::I64;
           P64[Sp + 48] = _sb0pD::P64;
           I64[Sp + 32] = _sb0pE::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto ub0Tz;
       cb0Sx: // global
           I64[Hp - 32] = sat_sb0qy_info;
           I64[Hp - 24] = _sb0pE::I64;
           I64[Hp - 16] = _sb0pG::I64;
           I64[Hp - 8] = _sb0pH::I64;
           I64[Hp] = _sb0pI::I64;
           P64[Sp + 48] = _sb0pD::P64;
           I64[Sp + 32] = _sb0pE::I64;
           P64[Sp + 40] = Hp - 31;
           Sp = Sp + 32;
           goto ub0Tz;
       ub0Tz: // global
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0Rj_info" {
     block_cb0Rj_info:
         const _cb0Rj;
         const 3974;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0PZ() //  []
         { []
         }
     {offset
       cb0PZ: // global
           Hp = Hp + 16;
           _sb0pL::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb0Sm; else goto cb0Sl;
       cb0Sm: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0PY_info;
           R1 = _sb0pL::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0Sl: // global
           I64[Hp - 8] = sat_sb0pX_info;
           I64[Hp] = I64[Sp];
           _sb0pD::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb0Qs_info;
           R5 = Hp - 7;
           R4 = _sb0pL::P64;
           R3 = _sb0pD::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0PY() //  [R1]
         { []
         }
     {offset
       cb0PY: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb0PZ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0PY_info" {
     block_cb0PY_info:
         const _cb0PY;
         const 195;
         const 30064771102;
         const Sb0HW_srt+56;
 },
 _cb0Qs() //  [R1]
         { []
         }
     {offset
       cb0Qs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb0Sp; else goto cb0So;
       cb0Sp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0So: // global
           I64[Hp - 16] = sat_sb0q3_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Qs_info" {
     block_cb0Qs_info:
         const _cb0Qs;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.490101452 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD5_closure" {
     GHC.IO.FD.$fRawIOFD5_closure:
         const GHC.IO.FD.$fRawIOFD5_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0VO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb0W2; else goto cb0W3;
       cb0W2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0W3: // global
           I64[Sp - 40] = block_cb0VL_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub0Wd; else goto cb0VM;
       ub0Wd: // global
           call _cb0VL(R1) args: 0, res: 0, upd: 0;
       cb0VM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD5_info" {
     GHC.IO.FD.$fRawIOFD5_info:
         const GHC.IO.FD.$fRawIOFD5_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const Sb0HW_srt+80;
 },
 _cb0VL() //  [R1]
         { []
         }
     {offset
       cb0VL: // global
           I64[Sp - 8] = block_cb0VR_info;
           _sb0r7::I64 = I64[R1 + 7];
           _sb0r8::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0r8::I64;
           I64[Sp + 16] = _sb0r7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0Wc; else goto cb0VS;
       ub0Wc: // global
           call _cb0VR(R1) args: 0, res: 0, upd: 0;
       cb0VS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0VL_info" {
     block_cb0VL_info:
         const _cb0VL;
         const 4;
         const 4294967326;
         const Sb0HW_srt+80;
 },
 _cb0VR() //  [R1]
         { []
         }
     {offset
       cb0VR: // global
           I64[Sp] = block_cb0VW_info;
           _sb0ra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0ra::I64;
           if (R1 & 7 != 0) goto ub0We; else goto cb0VX;
       ub0We: // global
           call _cb0VW(R1) args: 0, res: 0, upd: 0;
       cb0VX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0VR_info" {
     block_cb0VR_info:
         const _cb0VR;
         const 325;
         const 4294967326;
         const Sb0HW_srt+80;
 },
 _cb0VW() //  [R1]
         { []
         }
     {offset
       cb0VW: // global
           I64[Sp] = block_cb0W1_info;
           _sb0rc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0rc::I64;
           if (R1 & 7 != 0) goto ub0Wf; else goto cb0W7;
       ub0Wf: // global
           call _cb0W1(R1) args: 0, res: 0, upd: 0;
       cb0W7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0VW_info" {
     block_cb0VW_info:
         const _cb0VW;
         const 837;
         const 4294967326;
         const Sb0HW_srt+80;
 },
 _cb0W1() //  [R1]
         { []
         }
     {offset
       cb0W1: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0W1_info" {
     block_cb0W1_info:
         const _cb0W1;
         const 1861;
         const 4294967326;
         const Sb0HW_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.501800124 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD4_closure" {
     GHC.IO.FD.$fRawIOFD4_closure:
         const GHC.IO.FD.$fRawIOFD4_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb0WN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb0WW; else goto cb0WX;
       cb0WW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0WX: // global
           I64[Sp - 24] = block_cb0WK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0X7; else goto cb0WL;
       ub0X7: // global
           call _cb0WK(R1) args: 0, res: 0, upd: 0;
       cb0WL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD4_info" {
     GHC.IO.FD.$fRawIOFD4_info:
         const GHC.IO.FD.$fRawIOFD4_entry;
         const 0;
         const 55834574862;
         const 17179869207;
         const Sb0HW_srt+80;
 },
 _cb0WK() //  [R1]
         { []
         }
     {offset
       cb0WK: // global
           I64[Sp - 8] = block_cb0WQ_info;
           _sb0rk::I64 = I64[R1 + 7];
           _sb0rl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0rl::I64;
           I64[Sp + 8] = _sb0rk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0X6; else goto cb0WR;
       ub0X6: // global
           call _cb0WQ(R1) args: 0, res: 0, upd: 0;
       cb0WR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0WK_info" {
     block_cb0WK_info:
         const _cb0WK;
         const 2;
         const 21474836510;
         const Sb0HW_srt+80;
 },
 _cb0WQ() //  [R1]
         { []
         }
     {offset
       cb0WQ: // global
           I64[Sp] = block_cb0WV_info;
           _sb0rn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0rn::I64;
           if (R1 & 7 != 0) goto ub0X8; else goto cb0X0;
       ub0X8: // global
           call _cb0WV(R1) args: 0, res: 0, upd: 0;
       cb0X0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0WQ_info" {
     block_cb0WQ_info:
         const _cb0WQ;
         const 195;
         const 21474836510;
         const Sb0HW_srt+80;
 },
 _cb0WV() //  [R1]
         { []
         }
     {offset
       cb0WV: // global
           R6 = 0;
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 24] = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0WV_info" {
     block_cb0WV_info:
         const _cb0WV;
         const 451;
         const 21474836510;
         const Sb0HW_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.518938236 UTC

[section ""data" . GHC.IO.FD.$wwriteRawBufferPtr_closure" {
     GHC.IO.FD.$wwriteRawBufferPtr_closure:
         const GHC.IO.FD.$wwriteRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_slow() //  [R1]
         { []
         }
     {offset
       cb0Xv: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sb0rL_entry() //  [R1]
         { []
         }
     {offset
       cb0XO: // global
           _sb0rL::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cb0XP; else goto cb0XQ;
       cb0XQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0XS; else goto cb0XR;
       cb0XS: // global
           HpAlloc = 16;
           goto cb0XP;
       cb0XP: // global
           R1 = _sb0rL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0XR: // global
           _sb0rs::I64 = I64[_sb0rL::P64 + 7];
           (_sb0rF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0rF::I64 == 0) goto cb0XN; else goto cb0XM;
       cb0XN: // global
           Hp = Hp - 16;
           I64[Sp - 8] = block_cb0Y2_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           Sp = Sp - 8;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       cb0XM: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0rL_info" {
     sat_sb0rL_info:
         const sat_sb0rL_entry;
         const 4294967296;
         const 279172874250;
         const 4294967299;
         const Sb0HW_srt+64;
 },
 _cb0Y2() //  []
         { []
         }
     {offset
       cb0Y2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Y2_info" {
     block_cb0Y2_info:
         const _cb0Y2;
         const 0;
         const 30;
 },
 sat_sb0rS_entry() //  [R1]
         { []
         }
     {offset
       cb0Ye: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb0Yl; else goto cb0Ym;
       cb0Yl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb0Ym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb0Yb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub0Yq; else goto cb0Yc;
       ub0Yq: // global
           call _cb0Yb(R1) args: 0, res: 0, upd: 0;
       cb0Yc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0rS_info" {
     sat_sb0rS_info:
         const sat_sb0rS_entry;
         const 1;
         const 16;
 },
 _cb0Yb() //  [R1]
         { []
         }
     {offset
       cb0Yb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Yp; else goto cb0Yo;
       cb0Yp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb0Yo: // global
           _sb0rR::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0rR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb0Yb_info" {
     block_cb0Yb_info:
         const _cb0Yb;
         const 0;
         const 30;
 },
 sat_sb0s1_entry() //  [R1]
         { []
         }
     {offset
       cb0YA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0YK; else goto cb0YJ;
       cb0YK: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0YJ: // global
           (_sb0rZ::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0rZ::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0s1_info" {
     sat_sb0s1_info:
         const sat_sb0s1_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 sat_sb0sk_entry() //  [R1]
         { []
         }
     {offset
       cb0Z6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb0Zf; else goto cb0Zg;
       cb0Zf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0Zg: // global
           I64[Sp - 8] = block_cb0Zc_info;
           Sp = Sp - 8;
           _cb0Z9::I64 = I64[R1 + 7];
           _cb0Za::I64 = I64[R1 + 15] + I64[R1 + 23];
           _cb0Zb::I64 = I64[R1 + 31];
           _ub0Zm::P64 = CurrentTSO;
           I64[I64[_ub0Zm::P64 + 24] + 16] = Sp;
           _ub0Zn::I64 = CurrentNursery;
           P64[_ub0Zn::I64 + 8] = Hp + 8;
           I64[_ub0Zm::P64 + 104] = I64[_ub0Zm::P64 + 104] - ((Hp + 8) - I64[_ub0Zn::I64]);
           (_ub0Zk::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0si::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_cb0Z9::I64, _cb0Za::I64, _cb0Zb::I64);
           (_ub0Zl::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub0Zk::I64);
           BaseReg = _ub0Zl::I64;
           _ub0Zo::P64 = CurrentTSO;
           _ub0Zp::P64 = I64[_ub0Zo::P64 + 24];
           Sp = I64[_ub0Zp::P64 + 16];
           SpLim = _ub0Zp::P64 + 192;
           HpAlloc = 0;
           _ub0Zq::I64 = CurrentNursery;
           _ub0Zr::I64 = I64[_ub0Zq::I64 + 8];
           Hp = _ub0Zr::I64 - 8;
           _ub0Zs::I64 = I64[_ub0Zq::I64];
           HpLim = _ub0Zs::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub0Zq::I64 + 48]) << 12) - 1);
           I64[_ub0Zo::P64 + 104] = I64[_ub0Zo::P64 + 104] + (_ub0Zr::I64 - _ub0Zs::I64);
           R1 = _sb0si::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0sk_info" {
     sat_sb0sk_info:
         const sat_sb0sk_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 _cb0Zc() //  [R1]
         { []
         }
     {offset
       cb0Zc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0Zj; else goto cb0Zi;
       cb0Zj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0Zi: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Zc_info" {
     block_cb0Zc_info:
         const _cb0Zc;
         const 0;
         const 30;
 },
 sat_sb0ss_entry() //  [R1]
         { []
         }
     {offset
       cb0ZC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0ZM; else goto cb0ZL;
       cb0ZM: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb0ZL: // global
           (_sb0sq::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15] + I64[R1 + 23], I64[R1 + 31]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0sq::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0ss_info" {
     sat_sb0ss_info:
         const sat_sb0ss_entry;
         const 17179869184;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$wwriteRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb0ZQ: // global
           _sb0rv::I64 = R6;
           _sb0ru::I64 = R5;
           _sb0rt::I64 = R4;
           _sb0rs::I64 = R3;
           _sb0rr::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cb0ZR; else goto cb0ZS;
       cb0ZS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb0ZU; else goto cb0ZT;
       cb0ZU: // global
           HpAlloc = 40;
           goto cb0ZR;
       cb0ZR: // global
           R1 = GHC.IO.FD.$wwriteRawBufferPtr_closure;
           P64[Sp - 40] = _sb0rr::P64;
           I64[Sp - 32] = _sb0rs::I64;
           I64[Sp - 24] = _sb0rt::I64;
           I64[Sp - 16] = _sb0ru::I64;
           I64[Sp - 8] = _sb0rv::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cb0ZT: // global
           if (_sb0rt::I64 == 0) goto cb0ZP; else goto cb0ZO;
       cb0ZP: // global
           (_sb0s5::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0rs::I64, 1, 0, 0);
           Hp = Hp - 40;
           _sb0st::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0s5::I64));
           if (_sb0st::I64 != 0) goto ub10K; else goto ub10J;
       ub10K: // global
           P64[Sp - 32] = _sb0rr::P64;
           I64[Sp - 24] = _sb0rs::I64;
           I64[Sp - 16] = _sb0ru::I64;
           I64[Sp - 8] = _sb0rv::I64;
           Sp = Sp - 40;
           call _cb0YU() args: 0, res: 0, upd: 0;
       ub10J: // global
           P64[Sp - 40] = _sb0rr::P64;
           I64[Sp - 32] = _sb0rs::I64;
           I64[Sp - 24] = _sb0ru::I64;
           I64[Sp - 16] = _sb0rv::I64;
           I64[Sp - 8] = _sb0st::I64;
           Sp = Sp - 40;
           call _cb10j() args: 0, res: 0, upd: 0;
       cb0ZO: // global
           I64[Hp - 32] = sat_sb0s1_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = I64[Sp];
           I64[Sp - 16] = _sb0rs::I64;
           P64[Sp - 8] = Hp - 31;
           P64[Sp] = _sb0rr::P64;
           Sp = Sp - 16;
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wwriteRawBufferPtr_info" {
     GHC.IO.FD.$wwriteRawBufferPtr_info:
         const GHC.IO.FD.$wwriteRawBufferPtr_entry;
         const 0;
         const 837518622734;
         const 30064771072;
         const Sb0HW_srt+64;
         const 3974;
         const GHC.IO.FD.$wwriteRawBufferPtr_slow;
 },
 _cb10j() //  []
         { []
         }
     {offset
       cb10j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb10n; else goto cb10m;
       cb10n: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb10h_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb10m: // global
           _sb0rr::P64 = P64[Sp];
           _sb0rs::I64 = I64[Sp + 8];
           _sb0ru::I64 = I64[Sp + 16];
           _sb0rv::I64 = I64[Sp + 24];
           (_sb0sx::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0sx::I64 == 0) goto cb10F; else goto cb10x;
       cb10F: // global
           Hp = Hp - 16;
           I64[Sp] = block_cb0YU_info;
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           P64[Sp + 8] = _sb0rr::P64;
           I64[Sp + 16] = _sb0rs::I64;
           I64[Sp + 24] = _sb0ru::I64;
           I64[Sp + 32] = _sb0rv::I64;
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
       cb10x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0rs::I64));
           I64[Sp - 8] = block_cb10v_info;
           R3 = Hp - 7;
           R2 = GHC.Event.Internal.evtWrite_closure;
           Sp = Sp - 8;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb10h() //  [R1]
         { []
         }
     {offset
       cb10h: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cb10j() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb10h_info" {
     block_cb10h_info:
         const _cb10h;
         const 3974;
         const 287762808862;
         const Sb0HW_srt+64;
 },
 _cb10v() //  []
         { []
         }
     {offset
       cb10v: // global
           _sb0rs::I64 = I64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 8];
           _sb0ru::I64 = I64[Sp + 24];
           I64[Sp + 24] = _sb0rs::I64;
           _sb0rv::I64 = I64[Sp + 32];
           I64[Sp + 32] = _sb0ru::I64;
           I64[Sp + 40] = _sb0rv::I64;
           Sp = Sp + 8;
           call _cb0YU() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb10v_info" {
     block_cb10v_info:
         const _cb10v;
         const 3974;
         const 287762808862;
         const Sb0HW_srt+64;
 },
 _cb0YU() //  []
         { []
         }
     {offset
       cb0YU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb103; else goto cb102;
       cb103: // global
           HpAlloc = 40;
           I64[Sp] = block_cb0YU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb102: // global
           _sb0rr::P64 = P64[Sp + 8];
           _sb0rs::I64 = I64[Sp + 16];
           _sb0ru::I64 = I64[Sp + 24];
           _sb0rv::I64 = I64[Sp + 32];
           _sb0rw::I64 = I64[Sp + 40];
           (_sb0sb::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0sb::I64 == 0) goto cb106; else goto cb105;
       cb106: // global
           I64[Hp - 32] = sat_sb0ss_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = _sb0rw::I64;
           P64[Sp + 40] = _sb0rr::P64;
           I64[Sp + 24] = _sb0rs::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto ub10S;
       cb105: // global
           I64[Hp - 32] = sat_sb0sk_info;
           I64[Hp - 24] = _sb0rs::I64;
           I64[Hp - 16] = _sb0ru::I64;
           I64[Hp - 8] = _sb0rv::I64;
           I64[Hp] = _sb0rw::I64;
           P64[Sp + 40] = _sb0rr::P64;
           I64[Sp + 24] = _sb0rs::I64;
           P64[Sp + 32] = Hp - 31;
           Sp = Sp + 24;
           goto ub10S;
       ub10S: // global
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0YU_info" {
     block_cb0YU_info:
         const _cb0YU;
         const 1925;
         const 287762808862;
         const Sb0HW_srt+64;
 },
 _cb0XC() //  []
         { []
         }
     {offset
       cb0XC: // global
           Hp = Hp + 16;
           _sb0rz::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb0ZX; else goto cb0ZW;
       cb0ZX: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb0XB_info;
           R1 = _sb0rz::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0ZW: // global
           I64[Hp - 8] = sat_sb0rL_info;
           I64[Hp] = I64[Sp];
           _sb0rr::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb0Y5_info;
           R5 = Hp - 7;
           R4 = _sb0rz::P64;
           R3 = _sb0rr::P64;
           R2 = GHC.IO.FD.$fBufferedIOFD14_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_entry(R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0XB() //  [R1]
         { []
         }
     {offset
       cb0XB: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb0XC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb0XB_info" {
     block_cb0XB_info:
         const _cb0XB;
         const 195;
         const 287762808862;
         const Sb0HW_srt+64;
 },
 _cb0Y5() //  [R1]
         { []
         }
     {offset
       cb0Y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb100; else goto cb0ZZ;
       cb100: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0ZZ: // global
           I64[Hp - 16] = sat_sb0rS_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb0Y5_info" {
     block_cb0Y5_info:
         const _cb0Y5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.552202997 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr1_closure" {
     GHC.IO.FD.writeRawBufferPtr1_closure:
         const GHC.IO.FD.writeRawBufferPtr1_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb12V: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb139; else goto cb13a;
       cb139: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.writeRawBufferPtr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb13a: // global
           I64[Sp - 40] = block_cb12S_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub13k; else goto cb12T;
       ub13k: // global
           call _cb12S(R1) args: 0, res: 0, upd: 0;
       cb12T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.writeRawBufferPtr1_info" {
     GHC.IO.FD.writeRawBufferPtr1_info:
         const GHC.IO.FD.writeRawBufferPtr1_entry;
         const 0;
         const 12884901902;
         const 25769803801;
         const Sb0HW_srt+120;
 },
 _cb12S() //  [R1]
         { []
         }
     {offset
       cb12S: // global
           I64[Sp - 8] = block_cb12Y_info;
           _sb0sN::I64 = I64[R1 + 7];
           _sb0sO::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0sO::I64;
           I64[Sp + 16] = _sb0sN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub13j; else goto cb12Z;
       ub13j: // global
           call _cb12Y(R1) args: 0, res: 0, upd: 0;
       cb12Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb12S_info" {
     block_cb12S_info:
         const _cb12S;
         const 4;
         const 4294967326;
         const Sb0HW_srt+120;
 },
 _cb12Y() //  [R1]
         { []
         }
     {offset
       cb12Y: // global
           I64[Sp] = block_cb133_info;
           _sb0sQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sb0sQ::I64;
           if (R1 & 7 != 0) goto ub13l; else goto cb134;
       ub13l: // global
           call _cb133(R1) args: 0, res: 0, upd: 0;
       cb134: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb12Y_info" {
     block_cb12Y_info:
         const _cb12Y;
         const 325;
         const 4294967326;
         const Sb0HW_srt+120;
 },
 _cb133() //  [R1]
         { []
         }
     {offset
       cb133: // global
           I64[Sp] = block_cb138_info;
           _sb0sS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb0sS::I64;
           if (R1 & 7 != 0) goto ub13m; else goto cb13e;
       ub13m: // global
           call _cb138(R1) args: 0, res: 0, upd: 0;
       cb13e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb133_info" {
     block_cb133_info:
         const _cb133;
         const 837;
         const 4294967326;
         const Sb0HW_srt+120;
 },
 _cb138() //  [R1]
         { []
         }
     {offset
       cb138: // global
           R6 = I64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb138_info" {
     block_cb138_info:
         const _cb138;
         const 1861;
         const 4294967326;
         const Sb0HW_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.564046881 UTC

[section ""data" . GHC.IO.FD.$wfdWrite_closure" {
     GHC.IO.FD.$wfdWrite_closure:
         const GHC.IO.FD.$wfdWrite_info;
         const 0;
 },
 GHC.IO.FD.$wfdWrite_slow() //  [R1]
         { []
         }
     {offset
       cb13O: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$wfdWrite_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cb13U: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb13Z; else goto ub14i;
       cb13Z: // global
           R1 = GHC.IO.FD.$wfdWrite_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ub14i: // global
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cb13P() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wfdWrite_info" {
     GHC.IO.FD.$wfdWrite_info:
         const GHC.IO.FD.$wfdWrite_entry;
         const 0;
         const 55834574862;
         const 21474836480;
         const Sb0HW_srt+120;
         const 964;
         const GHC.IO.FD.$wfdWrite_slow;
 },
 _cb13P() //  []
         { []
         }
     {offset
       cb13P: // global
           I64[Sp - 8] = block_cb13W_info;
           R6 = 0;
           R5 = I64[Sp + 16];
           R4 = I64[Sp + 8];
           R3 = I64[Sp];
           R2 = lvl1_raWUY_closure;
           I64[Sp - 16] = I64[Sp + 24];
           Sp = Sp - 16;
           call GHC.IO.FD.$wwriteRawBufferPtr_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb13W() //  [R1]
         { []
         }
     {offset
       cb13W: // global
           I64[Sp] = block_cb13Y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub14l; else goto cb142;
       ub14l: // global
           call _cb13Y(R1) args: 0, res: 0, upd: 0;
       cb142: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb13W_info" {
     block_cb13W_info:
         const _cb13W;
         const 964;
         const 38654705694;
         const Sb0HW_srt+120;
 },
 _cb13Y() //  [R1]
         { []
         }
     {offset
       cb13Y: // global
           _sb0sY::I64 = I64[Sp + 32];
           _sb0t5::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_sb0t5::I64,
                            _sb0sY::I64)) goto cb14a; else goto cb14b;
       cb14a: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb14b: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] + _sb0t5::I64;
           I64[Sp + 32] = _sb0sY::I64 - _sb0t5::I64;
           Sp = Sp + 8;
           call _cb13P() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb13Y_info" {
     block_cb13Y_info:
         const _cb13Y;
         const 964;
         const 38654705694;
         const Sb0HW_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.574758436 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD2_closure" {
     GHC.IO.FD.$fRawIOFD2_closure:
         const GHC.IO.FD.$fRawIOFD2_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb14V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb154; else goto cb155;
       cb154: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb155: // global
           I64[Sp - 24] = block_cb14S_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub15e; else goto cb14T;
       ub15e: // global
           call _cb14S(R1) args: 0, res: 0, upd: 0;
       cb14T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD2_info" {
     GHC.IO.FD.$fRawIOFD2_info:
         const GHC.IO.FD.$fRawIOFD2_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const Sb0HW_srt+136;
 },
 _cb14S() //  [R1]
         { []
         }
     {offset
       cb14S: // global
           I64[Sp - 8] = block_cb14Y_info;
           _sb0te::I64 = I64[R1 + 7];
           _sb0tf::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0tf::I64;
           I64[Sp + 8] = _sb0te::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub15d; else goto cb14Z;
       ub15d: // global
           call _cb14Y(R1) args: 0, res: 0, upd: 0;
       cb14Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb14S_info" {
     block_cb14S_info:
         const _cb14S;
         const 2;
         const 4294967326;
         const Sb0HW_srt+136;
 },
 _cb14Y() //  [R1]
         { []
         }
     {offset
       cb14Y: // global
           I64[Sp] = block_cb153_info;
           _sb0th::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0th::I64;
           if (R1 & 7 != 0) goto ub15f; else goto cb158;
       ub15f: // global
           call _cb153(R1) args: 0, res: 0, upd: 0;
       cb158: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb14Y_info" {
     block_cb14Y_info:
         const _cb14Y;
         const 195;
         const 4294967326;
         const Sb0HW_srt+136;
 },
 _cb153() //  [R1]
         { []
         }
     {offset
       cb153: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb153_info" {
     block_cb153_info:
         const _cb153;
         const 451;
         const 4294967326;
         const Sb0HW_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.590151889 UTC

[section ""data" . GHC.IO.FD.$w$cwriteNonBlocking_closure" {
     GHC.IO.FD.$w$cwriteNonBlocking_closure:
         const GHC.IO.FD.$w$cwriteNonBlocking_info;
         const 0;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_slow() //  [R1]
         { []
         }
     {offset
       cb15B: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb0tx_entry() //  [R1]
         { []
         }
     {offset
       cb15O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb15Y; else goto cb15X;
       cb15Y: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb15X: // global
           (_sb0tv::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0tv::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0tx_info" {
     sat_sb0tx_info:
         const sat_sb0tx_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 sat_sb0tX_entry() //  [R1]
         { []
         }
     {offset
       cb16l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb16u; else goto cb16v;
       cb16u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb16v: // global
           I64[Sp - 8] = block_cb16r_info;
           Sp = Sp - 8;
           _cb16o::I64 = I64[R1 + 7];
           _cb16p::I64 = I64[R1 + 15];
           _cb16q::I64 = I64[R1 + 23];
           _ub16B::P64 = CurrentTSO;
           I64[I64[_ub16B::P64 + 24] + 16] = Sp;
           _ub16C::I64 = CurrentNursery;
           P64[_ub16C::I64 + 8] = Hp + 8;
           I64[_ub16B::P64 + 104] = I64[_ub16B::P64 + 104] - ((Hp + 8) - I64[_ub16C::I64]);
           (_ub16z::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0tV::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC19ZCbaseZCSystemziPosixziInternalsZCwrite(_cb16o::I64, _cb16p::I64, _cb16q::I64);
           (_ub16A::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub16z::I64);
           BaseReg = _ub16A::I64;
           _ub16D::P64 = CurrentTSO;
           _ub16E::P64 = I64[_ub16D::P64 + 24];
           Sp = I64[_ub16E::P64 + 16];
           SpLim = _ub16E::P64 + 192;
           HpAlloc = 0;
           _ub16F::I64 = CurrentNursery;
           _ub16G::I64 = I64[_ub16F::I64 + 8];
           Hp = _ub16G::I64 - 8;
           _ub16H::I64 = I64[_ub16F::I64];
           HpLim = _ub16H::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub16F::I64 + 48]) << 12) - 1);
           I64[_ub16D::P64 + 104] = I64[_ub16D::P64 + 104] + (_ub16G::I64 - _ub16H::I64);
           R1 = _sb0tV::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0tX_info" {
     sat_sb0tX_info:
         const sat_sb0tX_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 _cb16r() //  [R1]
         { []
         }
     {offset
       cb16r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb16y; else goto cb16x;
       cb16y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb16x: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb16r_info" {
     block_cb16r_info:
         const _cb16r;
         const 0;
         const 30;
 },
 sat_sb0ud_entry() //  [R1]
         { []
         }
     {offset
       cb16R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb171; else goto cb170;
       cb171: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb170: // global
           (_sb0ub::I64) = call "capi" arg hints:  [‘signed’,
                                                    PtrHint,]  result hints:  [‘signed’] ghczuwrapperZC20ZCbaseZCSystemziPosixziInternalsZCwrite(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0ub::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0ud_info" {
     sat_sb0ud_info:
         const sat_sb0ud_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$w$cwriteNonBlocking_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cb175: // global
           _sb0tn::I64 = R5;
           _sb0tm::I64 = R4;
           _sb0tl::I64 = R3;
           _sb0tk::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cb176; else goto cb177;
       cb177: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb179; else goto cb178;
       cb179: // global
           HpAlloc = 32;
           goto cb176;
       cb176: // global
           R1 = GHC.IO.FD.$w$cwriteNonBlocking_closure;
           I64[Sp - 32] = _sb0tk::I64;
           I64[Sp - 24] = _sb0tl::I64;
           I64[Sp - 16] = _sb0tm::I64;
           I64[Sp - 8] = _sb0tn::I64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb178: // global
           if (_sb0tl::I64 == 0) goto cb174; else goto cb173;
       cb174: // global
           (_sb0tJ::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_sb0tk::I64, 1, 0, 0);
           Hp = Hp - 32;
           _sb0tK::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0tJ::I64));
           if (_sb0tK::I64 != 0) goto ub18n; else goto cb18i;
       ub18n: // global
           I64[Sp - 32] = _sb0tk::I64;
           I64[Sp - 24] = _sb0tm::I64;
           I64[Sp - 16] = _sb0tn::I64;
           I64[Sp - 8] = _sb0tK::I64;
           Sp = Sp - 32;
           call _cb169() args: 0, res: 0, upd: 0;
       cb18i: // global
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb173: // global
           I64[Hp - 24] = sat_sb0tx_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp - 8] = block_cb17a_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp - 8;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cwriteNonBlocking_info" {
     GHC.IO.FD.$w$cwriteNonBlocking_info:
         const GHC.IO.FD.$w$cwriteNonBlocking_entry;
         const 0;
         const 6755403736023054;
         const 21474836480;
         const Sb0HW_srt+8;
         const 964;
         const GHC.IO.FD.$w$cwriteNonBlocking_slow;
 },
 _cb169() //  []
         { []
         }
     {offset
       cb169: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb17y; else goto cb17x;
       cb17y: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb168_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb17x: // global
           _sb0tk::I64 = I64[Sp];
           _sb0tm::I64 = I64[Sp + 8];
           _sb0tn::I64 = I64[Sp + 16];
           (_sb0tO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0tO::I64 == 0) goto cb17Y; else goto cb17D;
       cb17Y: // global
           I64[Hp - 24] = sat_sb0ud_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp + 24] = block_cb17V_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       cb17D: // global
           I64[Hp - 24] = sat_sb0tX_info;
           I64[Hp - 16] = _sb0tk::I64;
           I64[Hp - 8] = _sb0tm::I64;
           I64[Hp] = _sb0tn::I64;
           I64[Sp + 24] = block_cb17z_info;
           R4 = GHC.IO.FD.$fBufferedIOFD3_closure+1;
           R3 = Hp - 23;
           R2 = GHC.IO.FD.$fBufferedIOFD_loc_closure;
           Sp = Sp + 24;
           call GHC.IO.FD.$fBufferedIOFD5_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb168() //  [R1]
         { []
         }
     {offset
       cb168: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cb169() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb168_info" {
     block_cb168_info:
         const _cb168;
         const 964;
         const 4503603922337822;
         const Sb0HW_srt+8;
 },
 _cb17V() //  [R1]
         { []
         }
     {offset
       cb17V: // global
           I64[Sp] = block_cb17X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18x; else goto cb180;
       ub18x: // global
           call _cb17X(R1) args: 0, res: 0, upd: 0;
       cb180: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb17V_info" {
     block_cb17V_info:
         const _cb17V;
         const 0;
         const 30;
 },
 _cb17X() //  [R1]
         { []
         }
     {offset
       cb17X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb186; else goto cb185;
       cb186: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb185: // global
           _sb0uj::I64 = I64[R1 + 7];
           if (_sb0uj::I64 != (-1)) goto cb18e; else goto ub18q;
       cb18e: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0uj::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18q: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb17X_info" {
     block_cb17X_info:
         const _cb17X;
         const 0;
         const 30;
 },
 _cb17z() //  [R1]
         { []
         }
     {offset
       cb17z: // global
           I64[Sp] = block_cb17B_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18v; else goto cb17F;
       ub18v: // global
           call _cb17B(R1) args: 0, res: 0, upd: 0;
       cb17F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb17z_info" {
     block_cb17z_info:
         const _cb17z;
         const 0;
         const 30;
 },
 _cb17B() //  [R1]
         { []
         }
     {offset
       cb17B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb17L; else goto cb17K;
       cb17L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb17K: // global
           _sb0u3::I64 = I64[R1 + 7];
           if (_sb0u3::I64 != (-1)) goto cb17T; else goto ub18p;
       cb17T: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0u3::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18p: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb17B_info" {
     block_cb17B_info:
         const _cb17B;
         const 0;
         const 30;
 },
 _cb17a() //  [R1]
         { []
         }
     {offset
       cb17a: // global
           I64[Sp] = block_cb17c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub18t; else goto cb17e;
       ub18t: // global
           call _cb17c(R1) args: 0, res: 0, upd: 0;
       cb17e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb17a_info" {
     block_cb17a_info:
         const _cb17a;
         const 0;
         const 30;
 },
 _cb17c() //  [R1]
         { []
         }
     {offset
       cb17c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb17k; else goto cb17j;
       cb17k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb17j: // global
           _sb0tD::I64 = I64[R1 + 7];
           if (_sb0tD::I64 != (-1)) goto cb17s; else goto ub18m;
       cb17s: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0tD::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ub18m: // global
           Sp = Sp + 8;
           call _cb18f() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb17c_info" {
     block_cb17c_info:
         const _cb17c;
         const 0;
         const 30;
 },
 _cb18f() //  []
         { []
         }
     {offset
       cb18f: // global
           Hp = Hp - 16;
           R1 = GHC.IO.FD.$fBufferedIOFD2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.619046819 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD1_closure" {
     GHC.IO.FD.$fRawIOFD1_closure:
         const GHC.IO.FD.$fRawIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fRawIOFD1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1ab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1ak; else goto cb1al;
       cb1ak: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fRawIOFD1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1al: // global
           I64[Sp - 24] = block_cb1a8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1au; else goto cb1a9;
       ub1au: // global
           call _cb1a8(R1) args: 0, res: 0, upd: 0;
       cb1a9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fRawIOFD1_info" {
     GHC.IO.FD.$fRawIOFD1_info:
         const GHC.IO.FD.$fRawIOFD1_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const Sb0HW_srt+160;
 },
 _cb1a8() //  [R1]
         { []
         }
     {offset
       cb1a8: // global
           I64[Sp - 8] = block_cb1ae_info;
           _sb0ur::I64 = I64[R1 + 7];
           _sb0us::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0us::I64;
           I64[Sp + 8] = _sb0ur::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1at; else goto cb1af;
       ub1at: // global
           call _cb1ae(R1) args: 0, res: 0, upd: 0;
       cb1af: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1a8_info" {
     block_cb1a8_info:
         const _cb1a8;
         const 2;
         const 4294967326;
         const Sb0HW_srt+160;
 },
 _cb1ae() //  [R1]
         { []
         }
     {offset
       cb1ae: // global
           I64[Sp] = block_cb1aj_info;
           _sb0uu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb0uu::I64;
           if (R1 & 7 != 0) goto ub1av; else goto cb1ao;
       ub1av: // global
           call _cb1aj(R1) args: 0, res: 0, upd: 0;
       cb1ao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1ae_info" {
     block_cb1ae_info:
         const _cb1ae;
         const 195;
         const 4294967326;
         const Sb0HW_srt+160;
 },
 _cb1aj() //  [R1]
         { []
         }
     {offset
       cb1aj: // global
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1aj_info" {
     block_cb1aj_info:
         const _cb1aj;
         const 451;
         const 4294967326;
         const Sb0HW_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.627168428 UTC

[section ""data" . GHC.IO.FD.$fRawIOFD_closure" {
     GHC.IO.FD.$fRawIOFD_closure:
         const GHC.IO.Device.C:RawIO_con_info;
         const GHC.IO.FD.$fRawIOFD4_closure+4;
         const GHC.IO.FD.$fRawIOFD3_closure+4;
         const GHC.IO.FD.$fRawIOFD2_closure+4;
         const GHC.IO.FD.$fRawIOFD1_closure+4;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.631190583 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1aY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb1bg; else goto cb1bh;
       cb1bg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1bh: // global
           I64[Sp - 16] = block_cb1aV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1bo; else goto cb1aW;
       ub1bo: // global
           call _cb1aV(R1) args: 0, res: 0, upd: 0;
       cb1aW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info" {
     GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_info:
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_entry;
         const 0;
         const 279172874254;
         const 12884901903;
         const Sb0HW_srt+136;
 },
 _cb1aV() //  [R1]
         { []
         }
     {offset
       cb1aV: // global
           I64[Sp - 40] = block_cb1b1_info;
           _sb0uC::P64 = P64[R1 + 7];
           _sb0uD::P64 = P64[R1 + 15];
           _sb0uB::I64 = I64[R1 + 23];
           _sb0uE::I64 = I64[R1 + 31];
           _sb0uF::I64 = I64[R1 + 39];
           _sb0uG::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _sb0uD::P64;
           I64[Sp - 24] = _sb0uE::I64;
           I64[Sp - 16] = _sb0uF::I64;
           I64[Sp - 8] = _sb0uG::I64;
           P64[Sp] = _sb0uC::P64;
           I64[Sp + 8] = _sb0uB::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub1bn; else goto cb1b2;
       ub1bn: // global
           call _cb1b1(R1) args: 0, res: 0, upd: 0;
       cb1b2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1aV_info" {
     block_cb1aV_info:
         const _cb1aV;
         const 1;
         const 4294967326;
         const Sb0HW_srt+136;
 },
 _cb1b1() //  [R1]
         { []
         }
     {offset
       cb1b1: // global
           I64[Sp] = block_cb1bc_info;
           _sb0uF::I64 = I64[Sp + 24];
           R5 = I64[Sp + 32] - _sb0uF::I64;
           R4 = I64[Sp + 48] + _sb0uF::I64;
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1b1_info" {
     block_cb1b1_info:
         const _cb1b1;
         const 2950;
         const 4294967326;
         const Sb0HW_srt+136;
 },
 _cb1bc() //  [R1]
         { []
         }
     {offset
       cb1bc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1bm; else goto cb1bl;
       cb1bm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1bl: // global
           _sb0uB::I64 = I64[Sp + 48];
           _sb0uC::P64 = P64[Sp + 40];
           _sb0uD::P64 = P64[Sp + 8];
           _sb0uE::I64 = I64[Sp + 16];
           call MO_Touch(_sb0uC::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0uC::P64;
           P64[Hp - 32] = _sb0uD::P64;
           I64[Hp - 24] = _sb0uB::I64;
           I64[Hp - 16] = _sb0uE::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1bc_info" {
     block_cb1bc_info:
         const _cb1bc;
         const 2950;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.64080521 UTC

[section ""data" . GHC.IO.FD.fdIsNonBlocking_closure" {
     GHC.IO.FD.fdIsNonBlocking_closure:
         const GHC.IO.FD.fdIsNonBlocking_info;
 },
 GHC.IO.FD.fdIsNonBlocking_entry() //  [R2]
         { []
         }
     {offset
       cb1bT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1bX; else goto cb1bY;
       cb1bX: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdIsNonBlocking_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1bY: // global
           I64[Sp - 8] = block_cb1bQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1c2; else goto cb1bR;
       ub1c2: // global
           call _cb1bQ(R1) args: 0, res: 0, upd: 0;
       cb1bR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.fdIsNonBlocking_info" {
     GHC.IO.FD.fdIsNonBlocking_info:
         const GHC.IO.FD.fdIsNonBlocking_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb1bQ() //  [R1]
         { []
         }
     {offset
       cb1bQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1c1; else goto cb1c0;
       cb1c1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1c0: // global
           _sb0uU::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb0uU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1bQ_info" {
     block_cb1bQ_info:
         const _cb1bQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.646760142 UTC

[section ""data" . GHC.IO.FD.fdFD_closure" {
     GHC.IO.FD.fdFD_closure:
         const GHC.IO.FD.fdFD_info;
 },
 GHC.IO.FD.fdFD_entry() //  [R2]
         { []
         }
     {offset
       cb1cm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1cq; else goto cb1cr;
       cb1cq: // global
           R2 = R2;
           R1 = GHC.IO.FD.fdFD_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1cr: // global
           I64[Sp - 8] = block_cb1cj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1cv; else goto cb1ck;
       ub1cv: // global
           call _cb1cj(R1) args: 0, res: 0, upd: 0;
       cb1ck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.fdFD_info" {
     GHC.IO.FD.fdFD_info:
         const GHC.IO.FD.fdFD_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb1cj() //  [R1]
         { []
         }
     {offset
       cb1cj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1cu; else goto cb1ct;
       cb1cu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ct: // global
           _sb0uX::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0uX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1cj_info" {
     block_cb1cj_info:
         const _cb1cj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.652721808 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshow_closure" {
     GHC.IO.FD.$fShowFD_$cshow_closure:
         const GHC.IO.FD.$fShowFD_$cshow_info;
 },
 GHC.IO.FD.$fShowFD_$cshow_entry() //  [R2]
         { []
         }
     {offset
       cb1cP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1cV; else goto cb1cW;
       cb1cV: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1cW: // global
           I64[Sp - 8] = block_cb1cM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1d1; else goto cb1cN;
       ub1d1: // global
           call _cb1cM(R1) args: 0, res: 0, upd: 0;
       cb1cN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshow_info" {
     GHC.IO.FD.$fShowFD_$cshow_info:
         const GHC.IO.FD.$fShowFD_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb1cM() //  [R1]
         { []
         }
     {offset
       cb1cM: // global
           I64[Sp] = block_cb1cS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1cM_info" {
     block_cb1cM_info:
         const _cb1cM;
         const 0;
         const 30;
 },
 _cb1cS() //  [R1, R2]
         { []
         }
     {offset
       cb1cS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1d0; else goto cb1cZ;
       cb1d0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1cZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1cS_info" {
     block_cb1cS_info:
         const _cb1cS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.660897852 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD15_closure" {
     GHC.IO.FD.$fBufferedIOFD15_closure:
         const GHC.IO.FD.$fBufferedIOFD15_info;
 },
 GHC.IO.FD.$fBufferedIOFD15_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1du: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1dx; else goto cb1dy;
       cb1dx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1dy: // global
           I64[Sp - 16] = block_cb1dn_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD15_info" {
     GHC.IO.FD.$fBufferedIOFD15_info:
         const GHC.IO.FD.$fBufferedIOFD15_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cb1dn() //  [R1]
         { []
         }
     {offset
       cb1dn: // global
           I64[Sp - 8] = block_cb1dp_info;
           _sb0vb::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sb0vb::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1dn_info" {
     block_cb1dn_info:
         const _cb1dn;
         const 1;
         const 30;
 },
 _cb1dp() //  [R1]
         { []
         }
     {offset
       cb1dp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb1dC; else goto cb1dB;
       cb1dC: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1dB: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 8192;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1dp_info" {
     block_cb1dp_info:
         const _cb1dp;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.669065504 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD12_closure" {
     GHC.IO.FD.$fIODeviceFD12_closure:
         const GHC.IO.FD.$fIODeviceFD12_info;
         const 0;
 },
 sat_sb0vn_entry() //  [R1]
         { []
         }
     {offset
       cb1e9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ed; else goto cb1ee;
       cb1ed: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1ee: // global
           I64[Sp - 8] = block_cb1e6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1ei; else goto cb1e7;
       ub1ei: // global
           call _cb1e6(R1) args: 0, res: 0, upd: 0;
       cb1e7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0vn_info" {
     sat_sb0vn_info:
         const sat_sb0vn_entry;
         const 1;
         const 16;
 },
 _cb1e6() //  [R1]
         { []
         }
     {offset
       cb1e6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1eh; else goto cb1eg;
       cb1eh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1eg: // global
           _sb0vl::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1e6_info" {
     block_cb1e6_info:
         const _cb1e6;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD12_entry() //  [R2]
         { []
         }
     {offset
       cb1ej: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1en; else goto cb1em;
       cb1en: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1em: // global
           I64[Hp - 16] = sat_sb0vn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call System.Posix.Internals.fdFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD12_info" {
     GHC.IO.FD.$fIODeviceFD12_info:
         const GHC.IO.FD.$fIODeviceFD12_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sb0HW_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.677223153 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD9_closure" {
     GHC.IO.FD.$fIODeviceFD9_closure:
         const GHC.IO.FD.$fIODeviceFD9_info;
         const 0;
 },
 sat_sb0vu_entry() //  [R1]
         { []
         }
     {offset
       cb1eP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1eT; else goto cb1eU;
       cb1eT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1eU: // global
           I64[Sp - 8] = block_cb1eM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1eY; else goto cb1eN;
       ub1eY: // global
           call _cb1eM(R1) args: 0, res: 0, upd: 0;
       cb1eN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0vu_info" {
     sat_sb0vu_info:
         const sat_sb0vu_entry;
         const 1;
         const 16;
 },
 _cb1eM() //  [R1]
         { []
         }
     {offset
       cb1eM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1eX; else goto cb1eW;
       cb1eX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1eW: // global
           _sb0vs::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1eM_info" {
     block_cb1eM_info:
         const _cb1eM;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD9_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1eZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1f3; else goto cb1f2;
       cb1f3: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1f2: // global
           I64[Hp - 16] = sat_sb0vu_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call System.Posix.Internals.setEcho1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD9_info" {
     GHC.IO.FD.$fIODeviceFD9_info:
         const GHC.IO.FD.$fIODeviceFD9_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sb0HW_srt+208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.685390544 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD8_closure" {
     GHC.IO.FD.$fIODeviceFD8_closure:
         const GHC.IO.FD.$fIODeviceFD8_info;
         const 0;
 },
 sat_sb0vA_entry() //  [R1]
         { []
         }
     {offset
       cb1fv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1fz; else goto cb1fA;
       cb1fz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1fA: // global
           I64[Sp - 8] = block_cb1fs_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1fE; else goto cb1ft;
       ub1fE: // global
           call _cb1fs(R1) args: 0, res: 0, upd: 0;
       cb1ft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0vA_info" {
     sat_sb0vA_info:
         const sat_sb0vA_entry;
         const 1;
         const 16;
 },
 _cb1fs() //  [R1]
         { []
         }
     {offset
       cb1fs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1fD; else goto cb1fC;
       cb1fD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1fC: // global
           _sb0vy::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1fs_info" {
     block_cb1fs_info:
         const _cb1fs;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD8_entry() //  [R2]
         { []
         }
     {offset
       cb1fF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1fJ; else goto cb1fI;
       cb1fJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1fI: // global
           I64[Hp - 16] = sat_sb0vA_info;
           P64[Hp] = R2;
           R3 = System.Posix.Internals.getEcho2_closure+2;
           R2 = Hp - 16;
           call System.Posix.Internals.getEcho3_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD8_info" {
     GHC.IO.FD.$fIODeviceFD8_info:
         const GHC.IO.FD.$fIODeviceFD8_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sb0HW_srt+224;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.694341531 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD7_closure" {
     GHC.IO.FD.$fIODeviceFD7_closure:
         const GHC.IO.FD.$fIODeviceFD7_info;
         const 0;
 },
 sat_sb0vJ_entry() //  [R1]
         { []
         }
     {offset
       cb1gg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1gh; else goto cb1gi;
       cb1gh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1gi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1g9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1gp; else goto cb1ga;
       ub1gp: // global
           call _cb1g9(R1) args: 0, res: 0, upd: 0;
       cb1ga: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0vJ_info" {
     sat_sb0vJ_info:
         const sat_sb0vJ_entry;
         const 1;
         const 16;
 },
 _cb1g9() //  [R1]
         { []
         }
     {offset
       cb1g9: // global
           if (R1 & 7 == 1) goto cb1gd; else goto cb1ge;
       cb1gd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1ge: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1g9_info" {
     block_cb1g9_info:
         const _cb1g9;
         const 0;
         const 30;
 },
 sat_sb0vH_entry() //  [R1]
         { []
         }
     {offset
       cb1gx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1gB; else goto cb1gC;
       cb1gB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1gC: // global
           I64[Sp - 8] = block_cb1gu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1gG; else goto cb1gv;
       ub1gG: // global
           call _cb1gu(R1) args: 0, res: 0, upd: 0;
       cb1gv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0vH_info" {
     sat_sb0vH_info:
         const sat_sb0vH_entry;
         const 1;
         const 16;
 },
 _cb1gu() //  [R1]
         { []
         }
     {offset
       cb1gu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1gF; else goto cb1gE;
       cb1gF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1gE: // global
           _sb0vF::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0vF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1gu_info" {
     block_cb1gu_info:
         const _cb1gu;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD7_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1gH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb1gL; else goto cb1gK;
       cb1gL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1gK: // global
           I64[Hp - 40] = sat_sb0vJ_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sb0vH_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call System.Posix.Internals.setCooked1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD7_info" {
     GHC.IO.FD.$fIODeviceFD7_info:
         const GHC.IO.FD.$fIODeviceFD7_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sb0HW_srt+240;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.705010724 UTC

[section ""cstring" . GHC.IO.FD.$trModule4_bytes" {
     GHC.IO.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.706758901 UTC

[section ""data" . GHC.IO.FD.$trModule3_closure" {
     GHC.IO.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.708817373 UTC

[section ""cstring" . GHC.IO.FD.$trModule2_bytes" {
     GHC.IO.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.710641357 UTC

[section ""data" . GHC.IO.FD.$trModule1_closure" {
     GHC.IO.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.712546392 UTC

[section ""data" . GHC.IO.FD.$trModule_closure" {
     GHC.IO.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.FD.$trModule3_closure+1;
         const GHC.IO.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.714601862 UTC

[section ""data" . $krep_raWV0_closure" {
     $krep_raWV0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.716508351 UTC

[section ""data" . $krep1_raWV1_closure" {
     $krep1_raWV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.718376293 UTC

[section ""cstring" . GHC.IO.FD.$tcFD2_bytes" {
     GHC.IO.FD.$tcFD2_bytes:
         I8[] [70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.720566562 UTC

[section ""data" . GHC.IO.FD.$tcFD1_closure" {
     GHC.IO.FD.$tcFD1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tcFD2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.722431089 UTC

[section ""data" . GHC.IO.FD.$tcFD_closure" {
     GHC.IO.FD.$tcFD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tcFD1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10838815552519039062;
         const 15546290101957756376;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.724253881 UTC

[section ""data" . $krep2_raWV2_closure" {
     $krep2_raWV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.FD.$tcFD_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.726132871 UTC

[section ""data" . $krep3_raWV3_closure" {
     $krep3_raWV3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raWV0_closure+1;
         const $krep2_raWV2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.728013213 UTC

[section ""data" . GHC.IO.FD.$tc'FD1_closure" {
     GHC.IO.FD.$tc'FD1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raWV1_closure+1;
         const $krep3_raWV3_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.73015916 UTC

[section ""cstring" . GHC.IO.FD.$tc'FD3_bytes" {
     GHC.IO.FD.$tc'FD3_bytes:
         I8[] [39,70,68]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.733042067 UTC

[section ""data" . GHC.IO.FD.$tc'FD2_closure" {
     GHC.IO.FD.$tc'FD2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.FD.$tc'FD3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.734874341 UTC

[section ""data" . GHC.IO.FD.$tc'FD_closure" {
     GHC.IO.FD.$tc'FD_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.FD.$trModule_closure+1;
         const GHC.IO.FD.$tc'FD2_closure+1;
         const GHC.IO.FD.$tc'FD1_closure+4;
         const 9025179437427398028;
         const 18071003818566613836;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.737946496 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowsPrec_closure" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_closure:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_info;
 },
 GHC.IO.FD.$fShowFD_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1hG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1hM; else goto cb1hN;
       cb1hM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1hN: // global
           I64[Sp - 16] = block_cb1hD_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1hS; else goto cb1hE;
       ub1hS: // global
           call _cb1hD(R1) args: 0, res: 0, upd: 0;
       cb1hE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshowsPrec_info" {
     GHC.IO.FD.$fShowFD_$cshowsPrec_info:
         const GHC.IO.FD.$fShowFD_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cb1hD() //  [R1]
         { []
         }
     {offset
       cb1hD: // global
           I64[Sp] = block_cb1hJ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1hD_info" {
     block_cb1hD_info:
         const _cb1hD;
         const 1;
         const 30;
 },
 _cb1hJ() //  [R1, R2]
         { []
         }
     {offset
       cb1hJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1hR; else goto cb1hQ;
       cb1hR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1hQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1hJ_info" {
     block_cb1hJ_info:
         const _cb1hJ;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.745400505 UTC

[section ""data" . GHC.IO.FD.$wlvl_closure" {
     GHC.IO.FD.$wlvl_closure:
         const GHC.IO.FD.$wlvl_info;
 },
 GHC.IO.FD.$wlvl_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1ig: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1ih; else goto cb1ii;
       cb1ih: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1ii: // global
           I64[Sp - 16] = block_cb1id_info;
           R4 = GHC.Types.[]_closure+1;
           _sb0vV::P64 = R3;
           R3 = R2;
           R2 = 0;
           P64[Sp - 8] = _sb0vV::P64;
           Sp = Sp - 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wlvl_info" {
     GHC.IO.FD.$wlvl_info:
         const GHC.IO.FD.$wlvl_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _cb1id() //  [R1, R2]
         { []
         }
     {offset
       cb1id: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1il; else goto cb1ik;
       cb1il: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cb1ik: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1id_info" {
     block_cb1id_info:
         const _cb1id;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.751255069 UTC

[section ""data" . GHC.IO.FD.$fShowFD1_closure" {
     GHC.IO.FD.$fShowFD1_closure:
         const GHC.IO.FD.$fShowFD1_info;
 },
 GHC.IO.FD.$fShowFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1iE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1iF; else goto cb1iG;
       cb1iF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fShowFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1iG: // global
           I64[Sp - 16] = block_cb1iB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1iK; else goto cb1iC;
       ub1iK: // global
           call _cb1iB(R1) args: 0, res: 0, upd: 0;
       cb1iC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD1_info" {
     GHC.IO.FD.$fShowFD1_info:
         const GHC.IO.FD.$fShowFD1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cb1iB() //  [R1]
         { []
         }
     {offset
       cb1iB: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1iB_info" {
     block_cb1iB_info:
         const _cb1iB;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.756397043 UTC

[section ""data" . GHC.IO.FD.$fShowFD_$cshowList_closure" {
     GHC.IO.FD.$fShowFD_$cshowList_closure:
         const GHC.IO.FD.$fShowFD_$cshowList_info;
 },
 GHC.IO.FD.$fShowFD_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1iZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fShowFD1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fShowFD_$cshowList_info" {
     GHC.IO.FD.$fShowFD_$cshowList_info:
         const GHC.IO.FD.$fShowFD_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.759833759 UTC

[section ""data" . GHC.IO.FD.$fShowFD_closure" {
     GHC.IO.FD.$fShowFD_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.FD.$fShowFD_$cshowsPrec_closure+3;
         const GHC.IO.FD.$fShowFD_$cshow_closure+1;
         const GHC.IO.FD.$fShowFD_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.762417901 UTC

[section ""data" . output_flags_raWV4_closure" {
     output_flags_raWV4_closure:
         const output_flags_raWV4_info;
         const 0;
         const 0;
         const 0;
 },
 output_flags_raWV4_entry() //  [R1]
         { []
         }
     {offset
       cb1jh: // global
           _raWV4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb1jz; else goto cb1jA;
       cb1jA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1jC; else goto cb1jB;
       cb1jC: // global
           HpAlloc = 16;
           goto cb1jz;
       cb1jz: // global
           R1 = _raWV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1jB: // global
           (_cb1ja::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV4::P64);
           if (_cb1ja::I64 == 0) goto cb1jc; else goto cb1jb;
       cb1jc: // global
           call (I64[I64[_raWV4::P64]])() args: 8, res: 0, upd: 8;
       cb1jb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1ja::I64;
           (_sb0wa::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_sb0we::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_creat();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wa::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0we::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . output_flags_raWV4_info" {
     output_flags_raWV4_info:
         const output_flags_raWV4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.768010071 UTC

[section ""data" . write_flags_raWV5_closure" {
     write_flags_raWV5_closure:
         const write_flags_raWV5_info;
         const 0;
         const 0;
         const 0;
 },
 write_flags_raWV5_entry() //  [R1]
         { []
         }
     {offset
       cb1jZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1kj; else goto cb1kk;
       cb1kj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1kk: // global
           (_cb1jT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1jT::I64 == 0) goto cb1jV; else goto cb1jU;
       cb1jV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1jU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1jT::I64;
           I64[Sp - 24] = block_cb1jW_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1ko; else goto cb1jX;
       ub1ko: // global
           call _cb1jW(R1) args: 0, res: 0, upd: 0;
       cb1jX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . write_flags_raWV5_info" {
     write_flags_raWV5_info:
         const write_flags_raWV5_entry;
         const 0;
         const 4294967317;
         const Sb0HW_srt+256;
 },
 _cb1jW() //  [R1]
         { []
         }
     {offset
       cb1jW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1kn; else goto cb1km;
       cb1kn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1km: // global
           _sb0wm::I64 = I64[R1 + 7];
           (_sb0wq::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_wronly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wm::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wq::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1jW_info" {
     block_cb1jW_info:
         const _cb1jW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.774763771 UTC

[section ""data" . append_flags_raWV6_closure" {
     append_flags_raWV6_closure:
         const append_flags_raWV6_info;
         const 0;
         const 0;
         const 0;
 },
 append_flags_raWV6_entry() //  [R1]
         { []
         }
     {offset
       cb1kQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1la; else goto cb1lb;
       cb1la: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1lb: // global
           (_cb1kK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1kK::I64 == 0) goto cb1kM; else goto cb1kL;
       cb1kM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1kL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1kK::I64;
           I64[Sp - 24] = block_cb1kN_info;
           R1 = write_flags_raWV5_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1lf; else goto cb1kO;
       ub1lf: // global
           call _cb1kN(R1) args: 0, res: 0, upd: 0;
       cb1kO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . append_flags_raWV6_info" {
     append_flags_raWV6_info:
         const append_flags_raWV6_entry;
         const 0;
         const 4294967317;
         const Sb0HW_srt+264;
 },
 _cb1kN() //  [R1]
         { []
         }
     {offset
       cb1kN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1le; else goto cb1ld;
       cb1le: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1ld: // global
           _sb0wx::I64 = I64[R1 + 7];
           (_sb0wB::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_append();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wx::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wB::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1kN_info" {
     block_cb1kN_info:
         const _cb1kN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.781395104 UTC

[section ""data" . rw_flags_raWV7_closure" {
     rw_flags_raWV7_closure:
         const rw_flags_raWV7_info;
         const 0;
         const 0;
         const 0;
 },
 rw_flags_raWV7_entry() //  [R1]
         { []
         }
     {offset
       cb1lH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1m1; else goto cb1m2;
       cb1m1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1m2: // global
           (_cb1lB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1lB::I64 == 0) goto cb1lD; else goto cb1lC;
       cb1lD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1lC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1lB::I64;
           I64[Sp - 24] = block_cb1lE_info;
           R1 = output_flags_raWV4_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1m6; else goto cb1lF;
       ub1m6: // global
           call _cb1lE(R1) args: 0, res: 0, upd: 0;
       cb1lF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . rw_flags_raWV7_info" {
     rw_flags_raWV7_info:
         const rw_flags_raWV7_entry;
         const 0;
         const 4294967317;
         const Sb0HW_srt+256;
 },
 _cb1lE() //  [R1]
         { []
         }
     {offset
       cb1lE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1m5; else goto cb1m4;
       cb1m5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1m4: // global
           _sb0wI::I64 = I64[R1 + 7];
           (_sb0wM::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdwr();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0wI::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1lE_info" {
     block_cb1lE_info:
         const _cb1lE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.787816977 UTC

[section ""data" . read_flags_raWV8_closure" {
     read_flags_raWV8_closure:
         const read_flags_raWV8_info;
         const 0;
         const 0;
         const 0;
 },
 read_flags_raWV8_entry() //  [R1]
         { []
         }
     {offset
       cb1mz: // global
           _raWV8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb1mR; else goto cb1mS;
       cb1mS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1mU; else goto cb1mT;
       cb1mU: // global
           HpAlloc = 16;
           goto cb1mR;
       cb1mR: // global
           R1 = _raWV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1mT: // global
           (_cb1ms::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raWV8::P64);
           if (_cb1ms::I64 == 0) goto cb1mu; else goto cb1mt;
       cb1mu: // global
           call (I64[I64[_raWV8::P64]])() args: 8, res: 0, upd: 8;
       cb1mt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1ms::I64;
           (_sb0wV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_noctty();
           (_sb0wZ::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_rdonly();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wV::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0wZ::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . read_flags_raWV8_info" {
     read_flags_raWV8_info:
         const read_flags_raWV8_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.792592114 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD16_closure" {
     GHC.IO.FD.$fIODeviceFD16_closure:
         const GHC.IO.FD.$fIODeviceFD16_info;
 },
 GHC.IO.FD.$fIODeviceFD16_entry() //  [R2]
         { []
         }
     {offset
       cb1nf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ng; else goto cb1nh;
       cb1ng: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1nh: // global
           I64[Sp - 8] = block_cb1nc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1np; else goto cb1nd;
       ub1np: // global
           call _cb1nc(R1) args: 0, res: 0, upd: 0;
       cb1nd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD16_info" {
     GHC.IO.FD.$fIODeviceFD16_info:
         const GHC.IO.FD.$fIODeviceFD16_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb1nc() //  [R1]
         { []
         }
     {offset
       cb1nc: // global
           if (I64[R1 + 7] == (-1)) goto cb1no; else goto cb1nn;
       cb1no: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1nn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1nc_info" {
     block_cb1nc_info:
         const _cb1nc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.798221422 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD15_bytes" {
     GHC.IO.FD.$fIODeviceFD15_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.800341071 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD14_closure" {
     GHC.IO.FD.$fIODeviceFD14_closure:
         const GHC.IO.FD.$fIODeviceFD14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD14_entry() //  [R1]
         { []
         }
     {offset
       cb1nL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1nM; else goto cb1nN;
       cb1nM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1nN: // global
           (_cb1nI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1nI::I64 == 0) goto cb1nK; else goto cb1nJ;
       cb1nK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1nJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1nI::I64;
           R2 = GHC.IO.FD.$fIODeviceFD15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD14_info" {
     GHC.IO.FD.$fIODeviceFD14_info:
         const GHC.IO.FD.$fIODeviceFD14_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.805802504 UTC

[section ""data" . GHC.IO.FD.$w$ctell_closure" {
     GHC.IO.FD.$w$ctell_closure:
         const GHC.IO.FD.$w$ctell_info;
         const 0;
 },
 sat_sb0xn_entry() //  [R1]
         { []
         }
     {offset
       cb1o8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1oi; else goto cb1oh;
       cb1oi: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1oh: // global
           (_sb0xl::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], 0, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0xl::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0xn_info" {
     sat_sb0xn_info:
         const sat_sb0xn_entry;
         const 8589934592;
         const 13;
         const 4294967299;
 },
 sat_sb0xr_entry() //  [R1]
         { []
         }
     {offset
       cb1op: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1oq; else goto cb1or;
       cb1oq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1or: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0xr_info" {
     sat_sb0xr_info:
         const sat_sb0xr_entry;
         const 1;
         const 16;
 },
 GHC.IO.FD.$w$ctell_entry() //  [R2]
         { []
         }
     {offset
       cb1os: // global
           _sb0xa::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1ot; else goto cb1ou;
       cb1ou: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1ow; else goto cb1ov;
       cb1ow: // global
           HpAlloc = 24;
           goto cb1ot;
       cb1ot: // global
           R2 = _sb0xa::I64;
           R1 = GHC.IO.FD.$w$ctell_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1ov: // global
           (_sb0xf::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Hp - 16] = sat_sb0xn_info;
           I64[Hp - 8] = _sb0xa::I64;
           I64[Hp] = _sb0xf::I64;
           I64[Sp - 8] = block_cb1oj_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.$fIODeviceFD14_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$ctell_info" {
     GHC.IO.FD.$w$ctell_info:
         const GHC.IO.FD.$w$ctell_entry;
         const 0;
         const 30064771086;
         const 8589934596;
         const Sb0HW_srt+272;
 },
 _cb1oj() //  [R1]
         { []
         }
     {offset
       cb1oj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1oz; else goto cb1oy;
       cb1oz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1oy: // global
           I64[Hp - 16] = sat_sb0xr_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1oj_info" {
     block_cb1oj_info:
         const _cb1oj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.81545245 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD13_closure" {
     GHC.IO.FD.$fIODeviceFD13_closure:
         const GHC.IO.FD.$fIODeviceFD13_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD13_entry() //  [R2]
         { []
         }
     {offset
       cb1p4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1p5; else goto cb1p6;
       cb1p5: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD13_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1p6: // global
           I64[Sp - 8] = block_cb1p1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1pa; else goto cb1p2;
       ub1pa: // global
           call _cb1p1(R1) args: 0, res: 0, upd: 0;
       cb1p2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD13_info" {
     GHC.IO.FD.$fIODeviceFD13_info:
         const GHC.IO.FD.$fIODeviceFD13_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const Sb0HW_srt+280;
 },
 _cb1p1() //  [R1]
         { []
         }
     {offset
       cb1p1: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$ctell_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1p1_info" {
     block_cb1p1_info:
         const _cb1p1;
         const 0;
         const 4294967326;
         const Sb0HW_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.820072049 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD19_bytes" {
     GHC.IO.FD.$fIODeviceFD19_bytes:
         I8[] [115,101,101,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.822327465 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD18_closure" {
     GHC.IO.FD.$fIODeviceFD18_closure:
         const GHC.IO.FD.$fIODeviceFD18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD18_entry() //  [R1]
         { []
         }
     {offset
       cb1ps: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1pt; else goto cb1pu;
       cb1pt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1pu: // global
           (_cb1pp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1pp::I64 == 0) goto cb1pr; else goto cb1pq;
       cb1pr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1pq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1pp::I64;
           R2 = GHC.IO.FD.$fIODeviceFD19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD18_info" {
     GHC.IO.FD.$fIODeviceFD18_info:
         const GHC.IO.FD.$fIODeviceFD18_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.82888808 UTC

[section ""data" . GHC.IO.FD.$w$cseek_closure" {
     GHC.IO.FD.$w$cseek_closure:
         const GHC.IO.FD.$w$cseek_info;
         const 0;
 },
 sat_sb0xK_entry() //  [R1]
         { []
         }
     {offset
       cb1q0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1q4; else goto cb1q3;
       cb1q4: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1q3: // global
           (_sb0xI::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC23ZCbaseZCSystemziPosixziInternalsZClseek(I64[R1 + 7], I64[R1 + 15], I64[R1 + 23]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _sb0xI::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0xK_info" {
     sat_sb0xK_info:
         const sat_sb0xK_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 GHC.IO.FD.$w$cseek_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1q5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1q6; else goto cb1q7;
       cb1q6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cseek_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1q7: // global
           I64[Sp - 24] = block_cb1pH_info;
           _sb0xx::I64 = R2;
           R2 = R4;
           I64[Sp - 16] = _sb0xx::I64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cseek_info" {
     GHC.IO.FD.$w$cseek_info:
         const GHC.IO.FD.$w$cseek_entry;
         const 0;
         const 210453397518;
         const 17179869203;
         const Sb0HW_srt+272;
 },
 _cb1pH() //  [R1]
         { []
         }
     {offset
       cb1pH: // global
           I64[Sp] = block_cb1q8_info;
           _sb0xB::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb0xB::I64;
           if (R1 & 7 != 0) goto ub1qH; else goto cb1qg;
       ub1qH: // global
           call _cb1q8(R1) args: 0, res: 0, upd: 0;
       cb1qg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1pH_info" {
     block_cb1pH_info:
         const _cb1pH;
         const 66;
         const 141733920798;
         const Sb0HW_srt+272;
 },
 _cb1q8() //  [R1]
         { []
         }
     {offset
       cb1q8: // global
           _cb1qy::P64 = R1 & 7;
           if (_cb1qy::P64 < 3) goto ub1qC; else goto cb1qu;
       ub1qC: // global
           if (_cb1qy::P64 < 2) goto cb1qm; else goto cb1qq;
       cb1qm: // global
           (_sb0xS::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC1ZCbaseZCSystemziPosixziInternalsZCSEEKzuSET();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0xS::I64));
           goto ub1qL;
       cb1qq: // global
           (_sb0xX::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC2ZCbaseZCSystemziPosixziInternalsZCSEEKzuCUR();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0xX::I64));
           goto ub1qL;
       cb1qu: // global
           (_sb0y2::I64) = call "capi" arg hints:  []  result hints:  [‘signed’] ghczuwrapperZC0ZCbaseZCSystemziPosixziInternalsZCSEEKzuEND();
           I64[Sp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0y2::I64));
           goto ub1qL;
       ub1qL: // global
           call _cb1pO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1q8_info" {
     block_cb1q8_info:
         const _cb1q8;
         const 194;
         const 141733920798;
         const Sb0HW_srt+272;
 },
 _cb1pO() //  []
         { []
         }
     {offset
       cb1pO: // global
           Hp = Hp + 32;
           _sb0xD::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1qd; else goto cb1qc;
       cb1qd: // global
           HpAlloc = 32;
           I64[Sp] = block_cb1pN_info;
           R1 = _sb0xD::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1qc: // global
           I64[Hp - 24] = sat_sb0xK_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sb0xD::I64;
           I64[Sp + 16] = block_cb1qa_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD18_closure;
           R2 = GHC.IO.FD.$fIODeviceFD16_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1pN() //  [R1]
         { []
         }
     {offset
       cb1pN: // global
           I64[Sp] = R1;
           call _cb1pO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1pN_info" {
     block_cb1pN_info:
         const _cb1pN;
         const 194;
         const 141733920798;
         const Sb0HW_srt+272;
 },
 _cb1qa() //  []
         { []
         }
     {offset
       cb1qa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1qa_info" {
     block_cb1qa_info:
         const _cb1qa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.842598546 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD17_closure" {
     GHC.IO.FD.$fIODeviceFD17_closure:
         const GHC.IO.FD.$fIODeviceFD17_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD17_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1rv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1rw; else goto cb1rx;
       cb1rw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1rx: // global
           I64[Sp - 24] = block_cb1rs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1rB; else goto cb1rt;
       ub1rB: // global
           call _cb1rs(R1) args: 0, res: 0, upd: 0;
       cb1rt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD17_info" {
     GHC.IO.FD.$fIODeviceFD17_info:
         const GHC.IO.FD.$fIODeviceFD17_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const Sb0HW_srt+304;
 },
 _cb1rs() //  [R1]
         { []
         }
     {offset
       cb1rs: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cseek_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1rs_info" {
     block_cb1rs_info:
         const _cb1rs;
         const 2;
         const 4294967326;
         const Sb0HW_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.847491626 UTC

[section ""data" . GHC.IO.FD.stdin_closure" {
     GHC.IO.FD.stdin_closure:
         const GHC.IO.FD.FD_con_info;
         const 0;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.849189832 UTC

[section ""data" . GHC.IO.FD.stdout_closure" {
     GHC.IO.FD.stdout_closure:
         const GHC.IO.FD.FD_con_info;
         const 1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.851477202 UTC

[section ""data" . GHC.IO.FD.stderr_closure" {
     GHC.IO.FD.stderr_closure:
         const GHC.IO.FD.FD_con_info;
         const 2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.853137768 UTC

[section ""cstring" . lvl3_raWV9_bytes" {
     lvl3_raWV9_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,115,101,116,83,105,122,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.855245411 UTC

[section ""data" . lvl4_raWVa_closure" {
     lvl4_raWVa_closure:
         const lvl4_raWVa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raWVa_entry() //  [R1]
         { []
         }
     {offset
       cb1rW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1rX; else goto cb1rY;
       cb1rX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1rY: // global
           (_cb1rT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1rT::I64 == 0) goto cb1rV; else goto cb1rU;
       cb1rV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1rU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1rT::I64;
           R2 = lvl3_raWV9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_raWVa_info" {
     lvl4_raWVa_info:
         const lvl4_raWVa_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.859521909 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD11_closure" {
     GHC.IO.FD.$fIODeviceFD11_closure:
         const GHC.IO.FD.$fIODeviceFD11_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD11_entry() //  [R2]
         { []
         }
     {offset
       cb1sd: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl4_raWVa_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD11_info" {
     GHC.IO.FD.$fIODeviceFD11_info:
         const GHC.IO.FD.$fIODeviceFD11_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const Sb0HW_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.863870771 UTC

[section ""data" . GHC.IO.FD.$wsetSize_closure" {
     GHC.IO.FD.$wsetSize_closure:
         const GHC.IO.FD.$wsetSize_info;
         const 0;
 },
 GHC.IO.FD.$wsetSize_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1sq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1sr; else goto cb1ss;
       cb1sr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wsetSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1ss: // global
           I64[Sp - 16] = block_cb1so_info;
           _sb0ye::I64 = R2;
           R2 = R3;
           I64[Sp - 8] = _sb0ye::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wsetSize_info" {
     GHC.IO.FD.$wsetSize_info:
         const GHC.IO.FD.$wsetSize_entry;
         const 0;
         const 12884901902;
         const 12884901901;
         const Sb0HW_srt+344;
 },
 _cb1so() //  [R1]
         { []
         }
     {offset
       cb1so: // global
           (_sb0yl::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[Sp + 8], R1);
           if (%MO_SS_Conv_W64_W32(_sb0yl::I64) == 0 :: W32) goto cb1sK; else goto cb1sE;
       cb1sK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1sE: // global
           (_sb0yq::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0yq::I64;
           Sp = Sp + 16;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1so_info" {
     block_cb1so_info:
         const _cb1so;
         const 65;
         const 4294967326;
         const Sb0HW_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.869847017 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD10_closure" {
     GHC.IO.FD.$fIODeviceFD10_closure:
         const GHC.IO.FD.$fIODeviceFD10_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD10_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1t7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1t8; else goto cb1t9;
       cb1t8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1t9: // global
           I64[Sp - 16] = block_cb1t4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1td; else goto cb1t5;
       ub1td: // global
           call _cb1t4(R1) args: 0, res: 0, upd: 0;
       cb1t5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD10_info" {
     GHC.IO.FD.$fIODeviceFD10_info:
         const GHC.IO.FD.$fIODeviceFD10_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const Sb0HW_srt+344;
 },
 _cb1t4() //  [R1]
         { []
         }
     {offset
       cb1t4: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.FD.$wsetSize_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1t4_info" {
     block_cb1t4_info:
         const _cb1t4;
         const 1;
         const 4294967326;
         const Sb0HW_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.875565092 UTC

[section ""data" . GHC.IO.FD.writeRawBufferPtr_closure" {
     GHC.IO.FD.writeRawBufferPtr_closure:
         const GHC.IO.FD.writeRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.writeRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1ts: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.writeRawBufferPtr1_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.writeRawBufferPtr_info" {
     GHC.IO.FD.writeRawBufferPtr_info:
         const GHC.IO.FD.writeRawBufferPtr_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const Sb0HW_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.879174008 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtrNoBlock_closure" {
     GHC.IO.FD.readRawBufferPtrNoBlock_closure:
         const GHC.IO.FD.readRawBufferPtrNoBlock_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtrNoBlock_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1tD: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.readRawBufferPtrNoBlock1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtrNoBlock_info" {
     GHC.IO.FD.readRawBufferPtrNoBlock_info:
         const GHC.IO.FD.readRawBufferPtrNoBlock_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const Sb0HW_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.882467553 UTC

[section ""data" . GHC.IO.FD.readRawBufferPtr_closure" {
     GHC.IO.FD.readRawBufferPtr_closure:
         const GHC.IO.FD.readRawBufferPtr_info;
         const 0;
 },
 GHC.IO.FD.readRawBufferPtr_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1tO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$fRawIOFD5_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.readRawBufferPtr_info" {
     GHC.IO.FD.readRawBufferPtr_info:
         const GHC.IO.FD.readRawBufferPtr_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const Sb0HW_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.888402176 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer0_closure" {
     GHC.IO.FD.$w$cfillReadBuffer0_closure:
         const GHC.IO.FD.$w$cfillReadBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer0_slow() //  [R1]
         { []
         }
     {offset
       cb1tW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.FD.$w$cfillReadBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1u2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb1ud; else goto cb1ue;
       cb1ud: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb1ue: // global
           I64[Sp - 32] = block_cb1ua_info;
           _sb0yC::P64 = R6;
           R6 = 0;
           _sb0yB::P64 = R5;
           _sb0yF::I64 = I64[Sp + 16];
           R5 = R4 + _sb0yF::I64;
           _sb0yA::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp - 40] = I64[Sp] - _sb0yF::I64;
           I64[Sp - 24] = _sb0yA::I64;
           P64[Sp - 16] = _sb0yB::P64;
           P64[Sp - 8] = _sb0yC::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cfillReadBuffer0_info" {
     GHC.IO.FD.$w$cfillReadBuffer0_info:
         const GHC.IO.FD.$w$cfillReadBuffer0_entry;
         const 0;
         const 30064771086;
         const 38654705664;
         const Sb0HW_srt+384;
         const 14792;
         const GHC.IO.FD.$w$cfillReadBuffer0_slow;
 },
 _cb1ua() //  [R1]
         { []
         }
     {offset
       cb1ua: // global
           I64[Sp] = block_cb1uc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1uD; else goto cb1ug;
       ub1uD: // global
           call _cb1uc(R1) args: 0, res: 0, upd: 0;
       cb1ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1ua_info" {
     block_cb1ua_info:
         const _cb1ua;
         const 3654;
         const 30;
 },
 _cb1uc() //  [R1]
         { []
         }
     {offset
       cb1uc: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb1um; else goto cb1ul;
       cb1um: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ul: // global
           _sb0yA::I64 = I64[Sp + 8];
           _sb0yB::P64 = P64[Sp + 16];
           _sb0yC::P64 = P64[Sp + 24];
           _sb0yD::I64 = I64[Sp + 32];
           _sb0yE::I64 = I64[Sp + 40];
           _sb0yF::I64 = I64[Sp + 48];
           _sb0yP::I64 = I64[R1 + 7];
           if (_sb0yP::I64 == (-1)) goto cb1uC; else goto cb1ux;
       cb1uC: // global
           call MO_Touch(_sb0yB::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _sb0yB::P64;
           P64[Hp - 72] = _sb0yC::P64;
           I64[Hp - 64] = _sb0yA::I64;
           I64[Hp - 56] = _sb0yD::I64;
           I64[Hp - 48] = _sb0yE::I64;
           I64[Hp - 40] = _sb0yF::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           P64[Hp - 16] = Hp - 87;
           _cb1uB::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cb1uB::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1ux: // global
           call MO_Touch(_sb0yB::P64);
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = _sb0yB::P64;
           P64[Hp - 72] = _sb0yC::P64;
           I64[Hp - 64] = _sb0yA::I64;
           I64[Hp - 56] = _sb0yD::I64;
           I64[Hp - 48] = _sb0yE::I64;
           I64[Hp - 40] = _sb0yF::I64 + _sb0yP::I64;
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1uc_info" {
     block_cb1uc_info:
         const _cb1uc;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.898725089 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD7_closure" {
     GHC.IO.FD.$fBufferedIOFD7_closure:
         const GHC.IO.FD.$fBufferedIOFD7_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD7_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1vi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1vm; else goto cb1vn;
       cb1vm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1vn: // global
           I64[Sp - 16] = block_cb1vf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1vv; else goto cb1vg;
       ub1vv: // global
           call _cb1vf(R1) args: 0, res: 0, upd: 0;
       cb1vg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD7_info" {
     GHC.IO.FD.$fBufferedIOFD7_info:
         const GHC.IO.FD.$fBufferedIOFD7_entry;
         const 0;
         const 38654705678;
         const 12884901903;
         const Sb0HW_srt+384;
 },
 _cb1vf() //  [R1]
         { []
         }
     {offset
       cb1vf: // global
           I64[Sp - 8] = block_cb1vl_info;
           _sb0z2::I64 = I64[R1 + 7];
           _sb0z3::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0z3::I64;
           I64[Sp + 8] = _sb0z2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1vu; else goto cb1vp;
       ub1vu: // global
           call _cb1vl(R1) args: 0, res: 0, upd: 0;
       cb1vp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1vf_info" {
     block_cb1vf_info:
         const _cb1vf;
         const 1;
         const 4294967326;
         const Sb0HW_srt+384;
 },
 _cb1vl() //  [R1]
         { []
         }
     {offset
       cb1vl: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer0_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1vl_info" {
     block_cb1vl_info:
         const _cb1vl;
         const 194;
         const 4294967326;
         const Sb0HW_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.908709928 UTC

[section ""data" . GHC.IO.FD.$w$cflushWriteBuffer0_closure" {
     GHC.IO.FD.$w$cflushWriteBuffer0_closure:
         const GHC.IO.FD.$w$cflushWriteBuffer0_info;
         const 0;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_slow() //  [R1]
         { []
         }
     {offset
       cb1vP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb0zu_entry() //  [R1]
         { []
         }
     {offset
       cb1w9: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb1wa; else goto cb1wb;
       cb1wa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1wb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb1w6_info;
           _sb0ze::P64 = P64[R1 + 16];
           _sb0zf::P64 = P64[R1 + 24];
           _sb0zd::I64 = I64[R1 + 40];
           _sb0zg::I64 = I64[R1 + 48];
           _sb0zh::I64 = I64[R1 + 56];
           _sb0zi::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _sb0zd::I64;
           P64[Sp - 56] = _sb0ze::P64;
           P64[Sp - 48] = _sb0zf::P64;
           I64[Sp - 40] = _sb0zg::I64;
           I64[Sp - 32] = _sb0zh::I64;
           I64[Sp - 24] = _sb0zi::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub1wt; else goto cb1w7;
       ub1wt: // global
           call _cb1w6(R1) args: 0, res: 0, upd: 0;
       cb1w7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0zu_info" {
     sat_sb0zu_info:
         const sat_sb0zu_entry;
         const 17179869187;
         const 15;
 },
 _cb1w6() //  [R1]
         { []
         }
     {offset
       cb1w6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1wg; else goto cb1wf;
       cb1wg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1wf: // global
           _sb0zd::I64 = I64[Sp + 8];
           _sb0ze::P64 = P64[Sp + 16];
           _sb0zf::P64 = P64[Sp + 24];
           _sb0zg::I64 = I64[Sp + 32];
           _sb0zi::I64 = I64[Sp + 48];
           _sb0zs::I64 = I64[Sp + 40] + I64[R1 + 7];
           if (_sb0zs::I64 == _sb0zi::I64) goto cb1ws; else goto cb1wp;
       cb1ws: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0ze::P64;
           P64[Hp - 32] = _sb0zf::P64;
           I64[Hp - 24] = _sb0zd::I64;
           I64[Hp - 16] = _sb0zg::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1wp: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0ze::P64;
           P64[Hp - 32] = _sb0zf::P64;
           I64[Hp - 24] = _sb0zd::I64;
           I64[Hp - 16] = _sb0zg::I64;
           I64[Hp - 8] = _sb0zs::I64;
           I64[Hp] = _sb0zi::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1w6_info" {
     block_cb1w6_info:
         const _cb1w6;
         const 3654;
         const 30;
 },
 GHC.IO.FD.$w$cflushWriteBuffer0_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1wu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1ww; else goto cb1wx;
       cb1ww: // global
           R1 = GHC.IO.FD.$w$cflushWriteBuffer0_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb1wx: // global
           I64[Sp - 32] = block_cb1vZ_info;
           _sb0ze::P64 = R5;
           _sb0zh::I64 = I64[Sp + 8];
           R5 = I64[Sp + 16] - _sb0zh::I64;
           _sb0zd::I64 = R4;
           R4 = R4 + _sb0zh::I64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 24] = _sb0zd::I64;
           P64[Sp - 16] = _sb0ze::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cflushWriteBuffer0_info" {
     GHC.IO.FD.$w$cflushWriteBuffer0_info:
         const GHC.IO.FD.$w$cflushWriteBuffer0_entry;
         const 0;
         const 12884901902;
         const 38654705664;
         const Sb0HW_srt+416;
         const 14792;
         const GHC.IO.FD.$w$cflushWriteBuffer0_slow;
 },
 _cb1vZ() //  [R1]
         { []
         }
     {offset
       cb1vZ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb1wA; else goto cb1wz;
       cb1wA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1wz: // global
           _sb0zd::I64 = I64[Sp + 8];
           _sb0ze::P64 = P64[Sp + 16];
           _sb0zf::P64 = P64[Sp + 24];
           _sb0zg::I64 = I64[Sp + 32];
           _sb0zh::I64 = I64[Sp + 40];
           _sb0zi::I64 = I64[Sp + 48];
           call MO_Touch(_sb0ze::P64);
           I64[Hp - 88] = sat_sb0zu_info;
           P64[Hp - 72] = _sb0ze::P64;
           P64[Hp - 64] = _sb0zf::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sb0zd::I64;
           I64[Hp - 40] = _sb0zg::I64;
           I64[Hp - 32] = _sb0zh::I64;
           I64[Hp - 24] = _sb0zi::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1vZ_info" {
     block_cb1vZ_info:
         const _cb1vZ;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.920872105 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD1_closure" {
     GHC.IO.FD.$fBufferedIOFD1_closure:
         const GHC.IO.FD.$fBufferedIOFD1_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1xf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1xj; else goto cb1xk;
       cb1xj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1xk: // global
           I64[Sp - 16] = block_cb1xc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1xs; else goto cb1xd;
       ub1xs: // global
           call _cb1xc(R1) args: 0, res: 0, upd: 0;
       cb1xd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD1_info" {
     GHC.IO.FD.$fBufferedIOFD1_info:
         const GHC.IO.FD.$fBufferedIOFD1_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const Sb0HW_srt+416;
 },
 _cb1xc() //  [R1]
         { []
         }
     {offset
       cb1xc: // global
           I64[Sp - 8] = block_cb1xi_info;
           _sb0zA::I64 = I64[R1 + 7];
           _sb0zB::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0zB::I64;
           I64[Sp + 8] = _sb0zA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1xr; else goto cb1xm;
       ub1xr: // global
           call _cb1xi(R1) args: 0, res: 0, upd: 0;
       cb1xm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1xc_info" {
     block_cb1xc_info:
         const _cb1xc;
         const 1;
         const 4294967326;
         const Sb0HW_srt+416;
 },
 _cb1xi() //  [R1]
         { []
         }
     {offset
       cb1xi: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cflushWriteBuffer0_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1xi_info" {
     block_cb1xi_info:
         const _cb1xi;
         const 194;
         const 4294967326;
         const Sb0HW_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.929413674 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD21_closure" {
     GHC.IO.FD.$fIODeviceFD21_closure:
         const GHC.IO.FD.$fIODeviceFD21_info;
 },
 sat_sb0zT_entry() //  [R1]
         { []
         }
     {offset
       cb1y5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1y6; else goto cb1yh;
       cb1y6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1yh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (%MO_SS_Conv_W64_W32(I64[R1 + 16]) == 0 :: W32) goto cb1y4; else goto cb1y3;
       cb1y4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1y3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0zT_info" {
     sat_sb0zT_info:
         const sat_sb0zT_entry;
         const 4294967296;
         const 17;
 },
 GHC.IO.FD.$fIODeviceFD21_entry() //  [R2]
         { []
         }
     {offset
       cb1yi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1yj; else goto cb1yk;
       cb1yj: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1yk: // global
           I64[Sp - 8] = block_cb1xP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1yo; else goto cb1xQ;
       ub1yo: // global
           call _cb1xP(R1) args: 0, res: 0, upd: 0;
       cb1xQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD21_info" {
     GHC.IO.FD.$fIODeviceFD21_info:
         const GHC.IO.FD.$fIODeviceFD21_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cb1xP() //  [R1]
         { []
         }
     {offset
       cb1xP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1yn; else goto cb1ym;
       cb1yn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1ym: // global
           (_sb0zR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] isatty(I64[R1 + 7]);
           I64[Hp - 16] = sat_sb0zT_info;
           I64[Hp] = _sb0zR::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1xP_info" {
     block_cb1xP_info:
         const _cb1xP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.936938657 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD25_closure" {
     GHC.IO.FD.$fIODeviceFD25_closure:
         const GHC.IO.FD.$fIODeviceFD25_info;
 },
 GHC.IO.FD.$fIODeviceFD25_entry() //  [R2]
         { []
         }
     {offset
       cb1yS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1yT; else goto cb1yU;
       cb1yT: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD25_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1yU: // global
           I64[Sp - 8] = block_cb1yP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1z2; else goto cb1yQ;
       ub1z2: // global
           call _cb1yP(R1) args: 0, res: 0, upd: 0;
       cb1yQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD25_info" {
     GHC.IO.FD.$fIODeviceFD25_info:
         const GHC.IO.FD.$fIODeviceFD25_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cb1yP() //  [R1]
         { []
         }
     {offset
       cb1yP: // global
           if (I64[R1 + 7] == (-1)) goto cb1z1; else goto cb1z0;
       cb1z1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb1z0: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1yP_info" {
     block_cb1yP_info:
         const _cb1yP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.942546631 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD29_bytes" {
     GHC.IO.FD.$fIODeviceFD29_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,114,101,97,100,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.944743175 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD28_closure" {
     GHC.IO.FD.$fIODeviceFD28_closure:
         const GHC.IO.FD.$fIODeviceFD28_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD28_entry() //  [R1]
         { []
         }
     {offset
       cb1zo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1zp; else goto cb1zq;
       cb1zp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1zq: // global
           (_cb1zl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1zl::I64 == 0) goto cb1zn; else goto cb1zm;
       cb1zn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1zm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1zl::I64;
           R2 = GHC.IO.FD.$fIODeviceFD29_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD28_info" {
     GHC.IO.FD.$fIODeviceFD28_info:
         const GHC.IO.FD.$fIODeviceFD28_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.952987786 UTC

[section ""data" . GHC.IO.FD.$w$cready_closure" {
     GHC.IO.FD.$w$cready_closure:
         const GHC.IO.FD.$w$cready_info;
         const 0;
 },
 sat_sb0Ad_entry() //  [R1]
         { []
         }
     {offset
       cb1zP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1A5; else goto cb1A6;
       cb1A5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1A6: // global
           I64[Sp - 8] = block_cb1zZ_info;
           Sp = Sp - 8;
           _cb1zV::I64 = I64[R1 + 7];
           _cb1zW::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 23]));
           _cb1zX::I64 = I64[R1 + 15];
           _ub1Ac::P64 = CurrentTSO;
           I64[I64[_ub1Ac::P64 + 24] + 16] = Sp;
           _ub1Ad::I64 = CurrentNursery;
           P64[_ub1Ad::I64 + 8] = Hp + 8;
           I64[_ub1Ac::P64 + 104] = I64[_ub1Ac::P64 + 104] - ((Hp + 8) - I64[_ub1Ad::I64]);
           (_ub1Aa::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0Aa::I64) = call "ccall" arg hints:  [‘signed’, ,
                                                     ‘signed’,]  result hints:  [‘signed’] fdReady(_cb1zV::I64, _cb1zW::I64, _cb1zX::I64, 0);
           (_ub1Ab::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub1Aa::I64);
           BaseReg = _ub1Ab::I64;
           _ub1Ae::P64 = CurrentTSO;
           _ub1Af::P64 = I64[_ub1Ae::P64 + 24];
           Sp = I64[_ub1Af::P64 + 16];
           SpLim = _ub1Af::P64 + 192;
           HpAlloc = 0;
           _ub1Ag::I64 = CurrentNursery;
           _ub1Ah::I64 = I64[_ub1Ag::I64 + 8];
           Hp = _ub1Ah::I64 - 8;
           _ub1Ai::I64 = I64[_ub1Ag::I64];
           HpLim = _ub1Ai::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub1Ag::I64 + 48]) << 12) - 1);
           I64[_ub1Ae::P64 + 104] = I64[_ub1Ae::P64 + 104] + (_ub1Ah::I64 - _ub1Ai::I64);
           R1 = _sb0Aa::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Ad_info" {
     sat_sb0Ad_info:
         const sat_sb0Ad_entry;
         const 12884901888;
         const 8;
         const 4294967299;
 },
 _cb1zZ() //  [R1]
         { []
         }
     {offset
       cb1zZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1A9; else goto cb1A8;
       cb1A9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1A8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1zZ_info" {
     block_cb1zZ_info:
         const _cb1zZ;
         const 0;
         const 30;
 },
 sat_sb0Ak_entry() //  [R1]
         { []
         }
     {offset
       cb1At: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Au; else goto cb1Av;
       cb1Au: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Av: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1Aq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1AF; else goto cb1Ar;
       ub1AF: // global
           call _cb1Aq(R1) args: 0, res: 0, upd: 0;
       cb1Ar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0Ak_info" {
     sat_sb0Ak_info:
         const sat_sb0Ak_entry;
         const 1;
         const 4294967312;
         const Sb0HW_srt+440;
 },
 _cb1Aq() //  [R1]
         { []
         }
     {offset
       cb1Aq: // global
           _sb0Aj::I64 = I64[R1 + 7];
           if (_sb0Aj::I64 != 0) goto ub1AE; else goto cb1AC;
       ub1AE: // global
           if (_sb0Aj::I64 != 1) goto cb1AB; else goto cb1AD;
       cb1AB: // global
           R1 = GHC.Enum.$fEnumBool1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cb1AD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1AC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1Aq_info" {
     block_cb1Aq_info:
         const _cb1Aq;
         const 0;
         const 4294967326;
         const Sb0HW_srt+440;
 },
 GHC.IO.FD.$w$cready_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1AN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1AO; else goto cb1AP;
       cb1AO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cready_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1AP: // global
           I64[Sp - 24] = block_cb1AG_info;
           R1 = R3;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1B8; else goto cb1AH;
       ub1B8: // global
           call _cb1AG(R1) args: 0, res: 0, upd: 0;
       cb1AH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cready_info" {
     GHC.IO.FD.$w$cready_info:
         const GHC.IO.FD.$w$cready_entry;
         const 0;
         const 63050399078154254;
         const 17179869202;
         const Sb0HW_srt+272;
 },
 _cb1AG() //  [R1]
         { []
         }
     {offset
       cb1AG: // global
           if (R1 & 7 == 1) goto cb1AK; else goto cb1AL;
       cb1AK: // global
           I64[Sp] = 0;
           goto ub1B7;
       cb1AL: // global
           I64[Sp] = 1;
           goto ub1B7;
       ub1B7: // global
           call _cb1zG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1AG_info" {
     block_cb1AG_info:
         const _cb1AG;
         const 194;
         const 45036000568672286;
         const Sb0HW_srt+272;
 },
 _cb1zG() //  []
         { []
         }
     {offset
       cb1zG: // global
           Hp = Hp + 32;
           _sb0A3::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1AS; else goto cb1AR;
       cb1AS: // global
           HpAlloc = 32;
           I64[Sp] = block_cb1zF_info;
           R1 = _sb0A3::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1AR: // global
           I64[Hp - 24] = sat_sb0Ad_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sb0A3::I64;
           I64[Sp + 16] = block_cb1Ak_info;
           R4 = Hp - 23;
           R3 = GHC.IO.FD.$fIODeviceFD28_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 16;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb1zF() //  [R1]
         { []
         }
     {offset
       cb1zF: // global
           I64[Sp] = R1;
           call _cb1zG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1zF_info" {
     block_cb1zF_info:
         const _cb1zF;
         const 194;
         const 45036000568672286;
         const Sb0HW_srt+272;
 },
 _cb1Ak() //  [R1]
         { []
         }
     {offset
       cb1Ak: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1AV; else goto cb1AU;
       cb1AV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1AU: // global
           I64[Hp - 16] = sat_sb0Ak_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Ak_info" {
     block_cb1Ak_info:
         const _cb1Ak;
         const 0;
         const 4294967326;
         const Sb0HW_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.970859198 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD27_closure" {
     GHC.IO.FD.$fIODeviceFD27_closure:
         const GHC.IO.FD.$fIODeviceFD27_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD27_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1Cp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Ct; else goto cb1Cu;
       cb1Ct: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD27_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Cu: // global
           I64[Sp - 24] = block_cb1Cm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1CC; else goto cb1Cn;
       ub1CC: // global
           call _cb1Cm(R1) args: 0, res: 0, upd: 0;
       cb1Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD27_info" {
     GHC.IO.FD.$fIODeviceFD27_info:
         const GHC.IO.FD.$fIODeviceFD27_entry;
         const 0;
         const 21474836494;
         const 17179869207;
         const Sb0HW_srt+448;
 },
 _cb1Cm() //  [R1]
         { []
         }
     {offset
       cb1Cm: // global
           I64[Sp] = block_cb1Cs_info;
           _sb0Ar::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb0Ar::I64;
           if (R1 & 7 != 0) goto ub1CB; else goto cb1Cw;
       ub1CB: // global
           call _cb1Cs(R1) args: 0, res: 0, upd: 0;
       cb1Cw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Cm_info" {
     block_cb1Cm_info:
         const _cb1Cm;
         const 2;
         const 4294967326;
         const Sb0HW_srt+448;
 },
 _cb1Cs() //  [R1]
         { []
         }
     {offset
       cb1Cs: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cready_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Cs_info" {
     block_cb1Cs_info:
         const _cb1Cs;
         const 130;
         const 4294967326;
         const Sb0HW_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.979741975 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode1_closure" {
     GHC.IO.FD.setNonBlockingMode1_closure:
         const GHC.IO.FD.setNonBlockingMode1_info;
         const 0;
 },
 sat_sb0AF_entry() //  [R1]
         { []
         }
     {offset
       cb1De: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1Df; else goto cb1Dg;
       cb1Df: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Dg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1D7_info;
           _sb0Az::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0Az::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1Dt; else goto cb1D8;
       ub1Dt: // global
           call _cb1D7(R1) args: 0, res: 0, upd: 0;
       cb1D8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0AF_info" {
     sat_sb0AF_info:
         const sat_sb0AF_entry;
         const 4294967297;
         const 19;
 },
 _cb1D7() //  [R1]
         { []
         }
     {offset
       cb1D7: // global
           _sb0Az::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1Db; else goto cb1Dc;
       cb1Db: // global
           Hp = Hp + 24;
           _sb0AE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1Ds; else goto cb1Dl;
       cb1Dl: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Az::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1Dc: // global
           Hp = Hp + 24;
           _sb0AE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1Ds; else goto cb1Dr;
       cb1Ds: // global
           HpAlloc = 24;
           R1 = _sb0AE::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1Dr: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Az::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1D7_info" {
     block_cb1D7_info:
         const _cb1D7;
         const 65;
         const 30;
 },
 GHC.IO.FD.setNonBlockingMode1_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1Du: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Dv; else goto cb1Dw;
       cb1Dv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.setNonBlockingMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Dw: // global
           I64[Sp - 16] = block_cb1CW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1DB; else goto cb1CX;
       ub1DB: // global
           call _cb1CW(R1) args: 0, res: 0, upd: 0;
       cb1CX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.setNonBlockingMode1_info" {
     GHC.IO.FD.setNonBlockingMode1_info:
         const GHC.IO.FD.setNonBlockingMode1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sb0HW_srt+472;
 },
 _cb1CW() //  [R1]
         { []
         }
     {offset
       cb1CW: // global
           I64[Sp - 8] = block_cb1D1_info;
           R3 = P64[Sp + 8];
           _sb0Az::I64 = I64[R1 + 7];
           R2 = _sb0Az::I64;
           I64[Sp] = _sb0Az::I64;
           Sp = Sp - 8;
           call System.Posix.Internals.$wsetNonBlockingFD_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1CW_info" {
     block_cb1CW_info:
         const _cb1CW;
         const 1;
         const 4294967326;
         const Sb0HW_srt+472;
 },
 _cb1D1() //  [R1]
         { []
         }
     {offset
       cb1D1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1DA; else goto cb1Dz;
       cb1DA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Dz: // global
           I64[Hp - 24] = sat_sb0AF_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1D1_info" {
     block_cb1D1_info:
         const _cb1D1;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.990722941 UTC

[section ""data" . GHC.IO.FD.setNonBlockingMode_closure" {
     GHC.IO.FD.setNonBlockingMode_closure:
         const GHC.IO.FD.setNonBlockingMode_info;
         const 0;
 },
 GHC.IO.FD.setNonBlockingMode_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1Ee: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.setNonBlockingMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.setNonBlockingMode_info" {
     GHC.IO.FD.setNonBlockingMode_info:
         const GHC.IO.FD.setNonBlockingMode_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sb0HW_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.993976549 UTC

[section ""cstring" . lvl5_raWVb_bytes" {
     lvl5_raWVb_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112,50]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.996022629 UTC

[section ""data" . lvl6_raWVc_closure" {
     lvl6_raWVc_closure:
         const lvl6_raWVc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_raWVc_entry() //  [R1]
         { []
         }
     {offset
       cb1Es: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Et; else goto cb1Eu;
       cb1Et: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Eu: // global
           (_cb1Ep::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Ep::I64 == 0) goto cb1Er; else goto cb1Eq;
       cb1Er: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Eq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Ep::I64;
           R2 = lvl5_raWVb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_raWVc_info" {
     lvl6_raWVc_info:
         const lvl6_raWVc_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:00.999758176 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD2_closure" {
     GHC.IO.FD.$fIODeviceFD2_closure:
         const GHC.IO.FD.$fIODeviceFD2_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD2_entry() //  [R2]
         { []
         }
     {offset
       cb1EJ: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_raWVc_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD2_info" {
     GHC.IO.FD.$fIODeviceFD2_info:
         const GHC.IO.FD.$fIODeviceFD2_entry;
         const 0;
         const 4503603922337806;
         const 8589934596;
         const Sb0HW_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.004597816 UTC

[section ""data" . GHC.IO.FD.$w$cdup2_closure" {
     GHC.IO.FD.$w$cdup2_closure:
         const GHC.IO.FD.$w$cdup2_info;
         const 0;
 },
 GHC.IO.FD.$w$cdup2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb1F2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1F3; else goto cb1F4;
       cb1F3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1F4: // global
           _sb0AL::I64 = R4;
           _sb0AK::I64 = R3;
           _cb1EW::I64 = R4;
           (_sb0AQ::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] dup2(R2, _cb1EW::I64);
           _sb0AR::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0AQ::I64));
           if (_sb0AR::I64 != (-1)) goto ub1Fj; else goto cb1F1;
       ub1Fj: // global
           I64[Sp - 24] = _sb0AK::I64;
           I64[Sp - 16] = _sb0AL::I64;
           I64[Sp - 8] = _sb0AR::I64;
           Sp = Sp - 24;
           call _cb1F7() args: 0, res: 0, upd: 0;
       cb1F1: // global
           (_sb0AW::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0AW::I64;
           call GHC.IO.FD.$fIODeviceFD2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cdup2_info" {
     GHC.IO.FD.$w$cdup2_info:
         const GHC.IO.FD.$w$cdup2_entry;
         const 0;
         const 12884901902;
         const 17179869200;
         const Sb0HW_srt+496;
 },
 _cb1F7() //  []
         { []
         }
     {offset
       cb1F7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Fc; else goto cb1Fb;
       cb1Fc: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cb1F6_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1Fb: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1F6() //  [R1]
         { []
         }
     {offset
       cb1F6: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cb1F7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1F6_info" {
     block_cb1F6_info:
         const _cb1F6;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.011273625 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD1_closure" {
     GHC.IO.FD.$fIODeviceFD1_closure:
         const GHC.IO.FD.$fIODeviceFD1_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD1_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1FK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1FO; else goto cb1FP;
       cb1FO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1FP: // global
           I64[Sp - 16] = block_cb1FH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1FX; else goto cb1FI;
       ub1FX: // global
           call _cb1FH(R1) args: 0, res: 0, upd: 0;
       cb1FI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD1_info" {
     GHC.IO.FD.$fIODeviceFD1_info:
         const GHC.IO.FD.$fIODeviceFD1_entry;
         const 0;
         const 21474836494;
         const 12884901903;
         const Sb0HW_srt+496;
 },
 _cb1FH() //  [R1]
         { []
         }
     {offset
       cb1FH: // global
           I64[Sp - 8] = block_cb1FN_info;
           _sb0B2::I64 = I64[R1 + 7];
           _sb0B3::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0B3::I64;
           I64[Sp + 8] = _sb0B2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1FW; else goto cb1FR;
       ub1FW: // global
           call _cb1FN(R1) args: 0, res: 0, upd: 0;
       cb1FR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1FH_info" {
     block_cb1FH_info:
         const _cb1FH;
         const 1;
         const 4294967326;
         const Sb0HW_srt+496;
 },
 _cb1FN() //  [R1]
         { []
         }
     {offset
       cb1FN: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.FD.$w$cdup2_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1FN_info" {
     block_cb1FN_info:
         const _cb1FN;
         const 194;
         const 4294967326;
         const Sb0HW_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.018314149 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD5_bytes" {
     GHC.IO.FD.$fIODeviceFD5_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,100,117,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.020523011 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD4_closure" {
     GHC.IO.FD.$fIODeviceFD4_closure:
         const GHC.IO.FD.$fIODeviceFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD4_entry() //  [R1]
         { []
         }
     {offset
       cb1Gk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Gl; else goto cb1Gm;
       cb1Gl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Gm: // global
           (_cb1Gh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Gh::I64 == 0) goto cb1Gj; else goto cb1Gi;
       cb1Gj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Gi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Gh::I64;
           R2 = GHC.IO.FD.$fIODeviceFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD4_info" {
     GHC.IO.FD.$fIODeviceFD4_info:
         const GHC.IO.FD.$fIODeviceFD4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.026876194 UTC

[section ""data" . GHC.IO.FD.$w$cdup_closure" {
     GHC.IO.FD.$w$cdup_closure:
         const GHC.IO.FD.$w$cdup_info;
         const 0;
 },
 sat_sb0Bl_entry() //  [R1]
         { []
         }
     {offset
       cb1GR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1GV; else goto cb1GW;
       cb1GV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1GW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1GO_info;
           _sb0B8::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0B8::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1H0; else goto cb1GP;
       ub1H0: // global
           call _cb1GO(R1) args: 0, res: 0, upd: 0;
       cb1GP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0Bl_info" {
     sat_sb0Bl_info:
         const sat_sb0Bl_entry;
         const 4294967297;
         const 19;
 },
 _cb1GO() //  [R1]
         { []
         }
     {offset
       cb1GO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1GZ; else goto cb1GY;
       cb1GZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1GY: // global
           _sb0Bk::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Bk::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1GO_info" {
     block_cb1GO_info:
         const _cb1GO;
         const 65;
         const 30;
 },
 GHC.IO.FD.$w$cdup_entry() //  [R2, R3]
         { []
         }
     {offset
       cb1H4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1H5; else goto cb1H6;
       cb1H5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$w$cdup_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1H6: // global
           _sb0B8::I64 = R3;
           (_sb0Bd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] dup(R2);
           _sb0Be::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Bd::I64));
           if (_sb0Be::I64 != (-1)) goto ub1Hi; else goto cb1H3;
       ub1Hi: // global
           I64[Sp - 16] = _sb0B8::I64;
           I64[Sp - 8] = _sb0Be::I64;
           Sp = Sp - 16;
           call _cb1H8() args: 0, res: 0, upd: 0;
       cb1H3: // global
           I64[Sp - 16] = block_cb1GI_info;
           R2 = GHC.IO.FD.$fIODeviceFD4_closure;
           I64[Sp - 8] = _sb0B8::I64;
           Sp = Sp - 16;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cdup_info" {
     GHC.IO.FD.$w$cdup_info:
         const GHC.IO.FD.$w$cdup_entry;
         const 0;
         const 30064771086;
         const 12884901900;
         const Sb0HW_srt+520;
 },
 _cb1H8() //  []
         { []
         }
     {offset
       cb1H8: // global
           Hp = Hp + 24;
           _sb0Be::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb1Hd; else goto cb1Hc;
       cb1Hd: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cb1H7_info;
           R1 = _sb0Be::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1Hc: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0Be::I64;
           I64[Hp] = I64[Sp];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1H7() //  [R1]
         { []
         }
     {offset
       cb1H7: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb1H8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1H7_info" {
     block_cb1H7_info:
         const _cb1H7;
         const 194;
         const 30;
 },
 _cb1GI() //  [R1]
         { []
         }
     {offset
       cb1GI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1Hh; else goto cb1Hg;
       cb1Hh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Hg: // global
           I64[Hp - 24] = sat_sb0Bl_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1GI_info" {
     block_cb1GI_info:
         const _cb1GI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.038998739 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD3_closure" {
     GHC.IO.FD.$fIODeviceFD3_closure:
         const GHC.IO.FD.$fIODeviceFD3_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD3_entry() //  [R2]
         { []
         }
     {offset
       cb1I1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1I2; else goto cb1I3;
       cb1I2: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1I3: // global
           I64[Sp - 8] = block_cb1HY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1I7; else goto cb1HZ;
       ub1I7: // global
           call _cb1HY(R1) args: 0, res: 0, upd: 0;
       cb1HZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD3_info" {
     GHC.IO.FD.$fIODeviceFD3_info:
         const GHC.IO.FD.$fIODeviceFD3_entry;
         const 0;
         const 38654705678;
         const 8589934597;
         const Sb0HW_srt+520;
 },
 _cb1HY() //  [R1]
         { []
         }
     {offset
       cb1HY: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cdup_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1HY_info" {
     block_cb1HY_info:
         const _cb1HY;
         const 0;
         const 4294967326;
         const Sb0HW_srt+520;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.046124454 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD6_closure" {
     GHC.IO.FD.$fIODeviceFD6_closure:
         const GHC.IO.FD.$fIODeviceFD6_info;
         const 0;
 },
 sat_sb0Bw_entry() //  [R1]
         { []
         }
     {offset
       cb1It: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Ix; else goto cb1Iy;
       cb1Ix: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Iy: // global
           I64[Sp - 8] = block_cb1Iq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1IC; else goto cb1Ir;
       ub1IC: // global
           call _cb1Iq(R1) args: 0, res: 0, upd: 0;
       cb1Ir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Bw_info" {
     sat_sb0Bw_info:
         const sat_sb0Bw_entry;
         const 1;
         const 16;
 },
 _cb1Iq() //  [R1]
         { []
         }
     {offset
       cb1Iq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1IB; else goto cb1IA;
       cb1IB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1IA: // global
           _sb0Bu::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0Bu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Iq_info" {
     block_cb1Iq_info:
         const _cb1Iq;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD6_entry() //  [R2]
         { []
         }
     {offset
       cb1II: // global
           _sb0Br::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1IJ; else goto cb1IK;
       cb1IK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1IM; else goto cb1IL;
       cb1IM: // global
           HpAlloc = 24;
           goto cb1IJ;
       cb1IJ: // global
           R2 = _sb0Br::P64;
           R1 = GHC.IO.FD.$fIODeviceFD6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1IL: // global
           I64[Hp - 16] = sat_sb0Bw_info;
           P64[Hp] = _sb0Br::P64;
           I64[Sp - 8] = block_cb1ID_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD6_info" {
     GHC.IO.FD.$fIODeviceFD6_info:
         const GHC.IO.FD.$fIODeviceFD6_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sb0HW_srt+552;
 },
 _cb1ID() //  [R1]
         { []
         }
     {offset
       cb1ID: // global
           I64[Sp] = block_cb1IF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1IR; else goto cb1IG;
       ub1IR: // global
           call _cb1IF(R1) args: 0, res: 0, upd: 0;
       cb1IG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1ID_info" {
     block_cb1ID_info:
         const _cb1ID;
         const 0;
         const 30;
 },
 _cb1IF() //  [R1]
         { []
         }
     {offset
       cb1IF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1IF_info" {
     block_cb1IF_info:
         const _cb1IF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.058489972 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD20_closure" {
     GHC.IO.FD.$fIODeviceFD20_closure:
         const GHC.IO.FD.$fIODeviceFD20_info;
         const 0;
 },
 sat_sb0BJ_entry() //  [R1]
         { []
         }
     {offset
       cb1Ju: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Jy; else goto cb1Jz;
       cb1Jy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Jz: // global
           I64[Sp - 8] = block_cb1Jr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1JD; else goto cb1Js;
       ub1JD: // global
           call _cb1Jr(R1) args: 0, res: 0, upd: 0;
       cb1Js: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0BJ_info" {
     sat_sb0BJ_info:
         const sat_sb0BJ_entry;
         const 1;
         const 16;
 },
 _cb1Jr() //  [R1]
         { []
         }
     {offset
       cb1Jr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1JC; else goto cb1JB;
       cb1JC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1JB: // global
           _sb0BH::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sb0BH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Jr_info" {
     block_cb1Jr_info:
         const _cb1Jr;
         const 0;
         const 30;
 },
 sat_sb0BS_entry() //  [R1]
         { []
         }
     {offset
       cb1JX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1JY; else goto cb1JZ;
       cb1JY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1JZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb1JP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1Ka; else goto cb1JQ;
       ub1Ka: // global
           call _cb1JP(R1) args: 0, res: 0, upd: 0;
       cb1JQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0BS_info" {
     sat_sb0BS_info:
         const sat_sb0BS_entry;
         const 1;
         const 16;
 },
 _cb1JP() //  [R1]
         { []
         }
     {offset
       cb1JP: // global
           _cb1JW::P64 = R1 & 7;
           if (_cb1JW::P64 == 3) goto cb1JV; else goto ub1K9;
       ub1K9: // global
           if (_cb1JW::P64 == 4) goto cb1JV; else goto cb1JT;
       cb1JV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1JT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1JP_info" {
     block_cb1JP_info:
         const _cb1JP;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fIODeviceFD20_entry() //  [R2]
         { []
         }
     {offset
       cb1Kb: // global
           _sb0BE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Kc; else goto cb1Kd;
       cb1Kd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Kf; else goto cb1Ke;
       cb1Kf: // global
           HpAlloc = 24;
           goto cb1Kc;
       cb1Kc: // global
           R2 = _sb0BE::P64;
           R1 = GHC.IO.FD.$fIODeviceFD20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Ke: // global
           I64[Hp - 16] = sat_sb0BJ_info;
           P64[Hp] = _sb0BE::P64;
           I64[Sp - 8] = block_cb1JE_info;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD20_info" {
     GHC.IO.FD.$fIODeviceFD20_info:
         const GHC.IO.FD.$fIODeviceFD20_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const Sb0HW_srt+552;
 },
 _cb1JE() //  [R1]
         { []
         }
     {offset
       cb1JE: // global
           I64[Sp] = block_cb1JG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1Kk; else goto cb1JH;
       ub1Kk: // global
           call _cb1JG(R1) args: 0, res: 0, upd: 0;
       cb1JH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1JE_info" {
     block_cb1JE_info:
         const _cb1JE;
         const 0;
         const 30;
 },
 _cb1JG() //  [R1]
         { []
         }
     {offset
       cb1JG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1Kj; else goto cb1Ki;
       cb1Kj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Ki: // global
           _sb0BO::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sb0BS_info;
           P64[Hp] = _sb0BO::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1JG_info" {
     block_cb1JG_info:
         const _cb1JG;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.073161742 UTC

[section ""data" . GHC.IO.FD.release1_closure" {
     GHC.IO.FD.release1_closure:
         const GHC.IO.FD.release1_info;
 },
 GHC.IO.FD.release1_entry() //  [R2]
         { []
         }
     {offset
       cb1L9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1La; else goto cb1Lb;
       cb1La: // global
           R2 = R2;
           R1 = GHC.IO.FD.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Lb: // global
           I64[Sp - 8] = block_cb1L6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1Lh; else goto cb1L7;
       ub1Lh: // global
           call _cb1L6(R1) args: 0, res: 0, upd: 0;
       cb1L7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.release1_info" {
     GHC.IO.FD.release1_info:
         const GHC.IO.FD.release1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cb1L6() //  [R1]
         { []
         }
     {offset
       cb1L6: // global
           (_sb0C1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1L6_info" {
     block_cb1L6_info:
         const _cb1L6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.078245191 UTC

[section ""data" . GHC.IO.FD.release_closure" {
     GHC.IO.FD.release_closure:
         const GHC.IO.FD.release_info;
 },
 GHC.IO.FD.release_entry() //  [R2]
         { []
         }
     {offset
       cb1Ly: // global
           R2 = R2;
           call GHC.IO.FD.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.release_info" {
     GHC.IO.FD.release_info:
         const GHC.IO.FD.release_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.08133039 UTC

[section ""cstring" . GHC.IO.FD.$fIODeviceFD24_bytes" {
     GHC.IO.FD.$fIODeviceFD24_bytes:
         I8[] [71,72,67,46,73,79,46,70,68,46,99,108,111,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.083941509 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD23_closure" {
     GHC.IO.FD.$fIODeviceFD23_closure:
         const GHC.IO.FD.$fIODeviceFD23_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD23_entry() //  [R1]
         { []
         }
     {offset
       cb1LM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1LN; else goto cb1LO;
       cb1LN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1LO: // global
           (_cb1LJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1LJ::I64 == 0) goto cb1LL; else goto cb1LK;
       cb1LL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1LK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1LJ::I64;
           R2 = GHC.IO.FD.$fIODeviceFD24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD23_info" {
     GHC.IO.FD.$fIODeviceFD23_info:
         const GHC.IO.FD.$fIODeviceFD23_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.088605987 UTC

[section ""data" . GHC.IO.FD.$wclose_closure" {
     GHC.IO.FD.$wclose_closure:
         const GHC.IO.FD.$wclose_info;
         const 0;
 },
 sat_sb0Cc_entry() //  [R1]
         { []
         }
     {offset
       cb1M8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1Mj; else goto cb1Mi;
       cb1Mj: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1Mi: // global
           (_sb0C9::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0C9::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Cc_info" {
     sat_sb0Cc_info:
         const sat_sb0Cc_entry;
         const 4294967296;
         const 10;
         const 4294967299;
 },
 GHC.IO.FD.$wclose_entry() //  [R2]
         { []
         }
     {offset
       cb1Mm: // global
           _sb0C2::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Mn; else goto cb1Mo;
       cb1Mo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1Mq; else goto cb1Mp;
       cb1Mq: // global
           HpAlloc = 16;
           goto cb1Mn;
       cb1Mn: // global
           R2 = _sb0C2::I64;
           R1 = GHC.IO.FD.$wclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Mp: // global
           I64[Hp - 8] = sat_sb0Cc_info;
           I64[Hp] = _sb0C2::I64;
           I64[Sp - 8] = block_cb1Mk_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wclose_info" {
     GHC.IO.FD.$wclose_info:
         const GHC.IO.FD.$wclose_entry;
         const 0;
         const 30064771086;
         const 8589934596;
         const Sb0HW_srt+576;
 },
 _cb1Mk() //  []
         { []
         }
     {offset
       cb1Mk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Mk_info" {
     block_cb1Mk_info:
         const _cb1Mk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.096072429 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD26_closure" {
     GHC.IO.FD.$fIODeviceFD26_closure:
         const GHC.IO.FD.$fIODeviceFD26_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD26_entry() //  [R2]
         { []
         }
     {offset
       cb1MS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1MT; else goto cb1MU;
       cb1MT: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1MU: // global
           I64[Sp - 8] = block_cb1MP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1MY; else goto cb1MQ;
       ub1MY: // global
           call _cb1MP(R1) args: 0, res: 0, upd: 0;
       cb1MQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD26_info" {
     GHC.IO.FD.$fIODeviceFD26_info:
         const GHC.IO.FD.$fIODeviceFD26_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const Sb0HW_srt+584;
 },
 _cb1MP() //  [R1]
         { []
         }
     {offset
       cb1MP: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$wclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1MP_info" {
     block_cb1MP_info:
         const _cb1MP;
         const 0;
         const 4294967326;
         const Sb0HW_srt+584;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.103016235 UTC

[section ""data" . GHC.IO.FD.$w$cclose_closure" {
     GHC.IO.FD.$w$cclose_closure:
         const GHC.IO.FD.$w$cclose_info;
         const 0;
 },
 sat_sb0CF_entry() //  [R1]
         { []
         }
     {offset
       cb1Nq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1NB; else goto cb1NA;
       cb1NB: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1NA: // global
           (_sb0CC::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0CC::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0CF_info" {
     sat_sb0CF_info:
         const sat_sb0CF_entry;
         const 4294967296;
         const 10;
         const 4294967299;
 },
 GHC.IO.FD.$w$cclose_entry() //  [R2]
         { []
         }
     {offset
       cb1NF: // global
           _sb0Ck::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb1NG; else goto cb1NH;
       cb1NH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1NJ; else goto cb1NI;
       cb1NJ: // global
           HpAlloc = 16;
           goto cb1NG;
       cb1NG: // global
           R2 = _sb0Ck::I64;
           R1 = GHC.IO.FD.$w$cclose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1NI: // global
           (_sb0Cp::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] unlockFile(_sb0Ck::I64);
           (_sb0Ct::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sb0Ct::I64 == 0) goto cb1NE; else goto cb1ND;
       cb1NE: // global
           I64[Hp - 8] = sat_sb0CF_info;
           I64[Hp] = _sb0Ck::I64;
           I64[Sp - 8] = block_cb1NO_info;
           R4 = Hp - 7;
           R3 = GHC.IO.FD.$fIODeviceFD23_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
       cb1ND: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Ck::I64));
           R3 = Hp - 7;
           R2 = GHC.IO.FD.$fIODeviceFD26_closure+2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cclose_info" {
     GHC.IO.FD.$w$cclose_info:
         const GHC.IO.FD.$w$cclose_entry;
         const 0;
         const 261993005070;
         const 8589934596;
         const Sb0HW_srt+576;
 },
 _cb1NO() //  []
         { []
         }
     {offset
       cb1NO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1NO_info" {
     block_cb1NO_info:
         const _cb1NO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.111288136 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD22_closure" {
     GHC.IO.FD.$fIODeviceFD22_closure:
         const GHC.IO.FD.$fIODeviceFD22_info;
         const 0;
 },
 GHC.IO.FD.$fIODeviceFD22_entry() //  [R2]
         { []
         }
     {offset
       cb1Oj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1Ok; else goto cb1Ol;
       cb1Ok: // global
           R2 = R2;
           R1 = GHC.IO.FD.$fIODeviceFD22_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Ol: // global
           I64[Sp - 8] = block_cb1Og_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1Op; else goto cb1Oh;
       ub1Op: // global
           call _cb1Og(R1) args: 0, res: 0, upd: 0;
       cb1Oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fIODeviceFD22_info" {
     GHC.IO.FD.$fIODeviceFD22_info:
         const GHC.IO.FD.$fIODeviceFD22_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sb0HW_srt+616;
 },
 _cb1Og() //  [R1]
         { []
         }
     {offset
       cb1Og: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Og_info" {
     block_cb1Og_info:
         const _cb1Og;
         const 0;
         const 4294967326;
         const Sb0HW_srt+616;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.115898307 UTC

[section ""data" . GHC.IO.FD.$fIODeviceFD_closure" {
     GHC.IO.FD.$fIODeviceFD_closure:
         const GHC.IO.Device.C:IODevice_con_info;
         const GHC.IO.FD.$fIODeviceFD27_closure+4;
         const GHC.IO.FD.$fIODeviceFD22_closure+2;
         const GHC.IO.FD.$fIODeviceFD21_closure+2;
         const GHC.IO.FD.$fIODeviceFD20_closure+2;
         const GHC.IO.FD.$fIODeviceFD17_closure+4;
         const GHC.IO.FD.$fIODeviceFD13_closure+2;
         const GHC.IO.FD.$fIODeviceFD12_closure+2;
         const GHC.IO.FD.$fIODeviceFD10_closure+3;
         const GHC.IO.FD.$fIODeviceFD9_closure+3;
         const GHC.IO.FD.$fIODeviceFD8_closure+2;
         const GHC.IO.FD.$fIODeviceFD7_closure+3;
         const GHC.IO.FD.$fIODeviceFD6_closure+2;
         const GHC.IO.FD.$fIODeviceFD3_closure+2;
         const GHC.IO.FD.$fIODeviceFD1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.117801054 UTC

[section ""cstring" . GHC.IO.FD.mkFD7_bytes" {
     GHC.IO.FD.mkFD7_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.120001188 UTC

[section ""data" . GHC.IO.FD.mkFD6_closure" {
     GHC.IO.FD.mkFD6_closure:
         const GHC.IO.FD.mkFD6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD6_entry() //  [R1]
         { []
         }
     {offset
       cb1OI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1OJ; else goto cb1OK;
       cb1OJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1OK: // global
           (_cb1OF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1OF::I64 == 0) goto cb1OH; else goto cb1OG;
       cb1OH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1OG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1OF::I64;
           R2 = GHC.IO.FD.mkFD7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD6_info" {
     GHC.IO.FD.mkFD6_info:
         const GHC.IO.FD.mkFD6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.123742642 UTC

[section ""cstring" . GHC.IO.FD.mkFD11_bytes" {
     GHC.IO.FD.mkFD11_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.125973552 UTC

[section ""data" . GHC.IO.FD.mkFD10_closure" {
     GHC.IO.FD.mkFD10_closure:
         const GHC.IO.FD.mkFD10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD10_entry() //  [R1]
         { []
         }
     {offset
       cb1P0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1P1; else goto cb1P2;
       cb1P1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1P2: // global
           (_cb1OX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1OX::I64 == 0) goto cb1OZ; else goto cb1OY;
       cb1OZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1OY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1OX::I64;
           R2 = GHC.IO.FD.mkFD11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD10_info" {
     GHC.IO.FD.mkFD10_info:
         const GHC.IO.FD.mkFD10_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.129442624 UTC

[section ""data" . GHC.IO.FD.mkFD9_closure" {
     GHC.IO.FD.mkFD9_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD10_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.131800666 UTC

[section ""data" . GHC.IO.FD.mkFD8_closure" {
     GHC.IO.FD.mkFD8_closure:
         const GHC.IO.FD.mkFD8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD8_entry() //  [R1]
         { []
         }
     {offset
       cb1Pi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Pj; else goto cb1Pk;
       cb1Pj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Pk: // global
           (_cb1Pf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Pf::I64 == 0) goto cb1Ph; else goto cb1Pg;
       cb1Ph: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Pg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Pf::I64;
           R2 = GHC.IO.FD.mkFD9_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD8_info" {
     GHC.IO.FD.mkFD8_info:
         const GHC.IO.FD.mkFD8_entry;
         const 0;
         const 12884901909;
         const Sb0HW_srt+632;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.136149603 UTC

[section ""cstring" . GHC.IO.FD.mkFD5_bytes" {
     GHC.IO.FD.mkFD5_bytes:
         I8[] [102,105,108,101,32,105,115,32,108,111,99,107,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.138271284 UTC

[section ""data" . GHC.IO.FD.mkFD4_closure" {
     GHC.IO.FD.mkFD4_closure:
         const GHC.IO.FD.mkFD4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD4_entry() //  [R1]
         { []
         }
     {offset
       cb1PA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1PB; else goto cb1PC;
       cb1PB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1PC: // global
           (_cb1Px::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1Px::I64 == 0) goto cb1Pz; else goto cb1Py;
       cb1Pz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1Py: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1Px::I64;
           R2 = GHC.IO.FD.mkFD5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD4_info" {
     GHC.IO.FD.mkFD4_info:
         const GHC.IO.FD.mkFD4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.141998582 UTC

[section ""data" . GHC.IO.FD.mkFD3_closure" {
     GHC.IO.FD.mkFD3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceBusy_closure+1;
         const GHC.IO.FD.mkFD6_closure;
         const GHC.IO.FD.mkFD4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.144244365 UTC

[section ""data" . GHC.IO.FD.mkFD2_closure" {
     GHC.IO.FD.mkFD2_closure:
         const GHC.IO.FD.mkFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.FD.mkFD2_entry() //  [R1]
         { []
         }
     {offset
       cb1PS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1PT; else goto cb1PU;
       cb1PT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1PU: // global
           (_cb1PP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb1PP::I64 == 0) goto cb1PR; else goto cb1PQ;
       cb1PR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb1PQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb1PP::I64;
           R2 = GHC.IO.FD.mkFD3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD2_info" {
     GHC.IO.FD.mkFD2_info:
         const GHC.IO.FD.mkFD2_entry;
         const 0;
         const 21474836501;
         const Sb0HW_srt+632;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.155828497 UTC

[section ""data" . GHC.IO.FD.$wmkFD_closure" {
     GHC.IO.FD.$wmkFD_closure:
         const GHC.IO.FD.$wmkFD_info;
         const 0;
 },
 sat_sb0D2_entry() //  [R1]
         { []
         }
     {offset
       cb1Qo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1Qp; else goto cb1Qq;
       cb1Qp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1Qq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1Ql_info;
           _sb0CR::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sb0CR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1QO; else goto cb1Qm;
       ub1QO: // global
           call _cb1Ql(R1) args: 0, res: 0, upd: 0;
       cb1Qm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0D2_info" {
     sat_sb0D2_info:
         const sat_sb0D2_entry;
         const 2;
         const 18;
 },
 _cb1Ql() //  [R1]
         { []
         }
     {offset
       cb1Ql: // global
           I64[Sp] = block_cb1Qt_info;
           _sb0D0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb0D0::I64;
           if (R1 & 7 != 0) goto ub1QN; else goto cb1Qv;
       ub1QN: // global
           call _cb1Qt(R1) args: 0, res: 0, upd: 0;
       cb1Qv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1Ql_info" {
     block_cb1Ql_info:
         const _cb1Ql;
         const 1;
         const 30;
 },
 _cb1Qt() //  [R1]
         { []
         }
     {offset
       cb1Qt: // global
           _sb0D0::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1QB; else goto cb1QI;
       cb1QB: // global
           Hp = Hp + 24;
           _sb0D1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1QL; else goto cb1QD;
       cb1QD: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D0::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1QI: // global
           Hp = Hp + 24;
           _sb0D1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1QL; else goto cb1QK;
       cb1QL: // global
           HpAlloc = 24;
           R1 = _sb0D1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1QK: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D0::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1Qt_info" {
     block_cb1Qt_info:
         const _cb1Qt;
         const 65;
         const 30;
 },
 sat_sb0Dp_entry() //  [R1]
         { []
         }
     {offset
       cb1RO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1RP; else goto cb1RQ;
       cb1RP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb1RQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb1RH_info;
           _sb0D6::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb0D6::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1S3; else goto cb1RI;
       ub1S3: // global
           call _cb1RH(R1) args: 0, res: 0, upd: 0;
       cb1RI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0Dp_info" {
     sat_sb0Dp_info:
         const sat_sb0Dp_entry;
         const 4294967297;
         const 19;
 },
 _cb1RH() //  [R1]
         { []
         }
     {offset
       cb1RH: // global
           _sb0D6::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cb1RL; else goto cb1RM;
       cb1RL: // global
           Hp = Hp + 24;
           _sb0Do::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1S2; else goto cb1RV;
       cb1RV: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D6::I64;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb1RM: // global
           Hp = Hp + 24;
           _sb0Do::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb1S2; else goto cb1S1;
       cb1S2: // global
           HpAlloc = 24;
           R1 = _sb0Do::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb1S1: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sb0D6::I64;
           I64[Hp] = 1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb1RH_info" {
     block_cb1RH_info:
         const _cb1RH;
         const 65;
         const 30;
 },
 GHC.IO.FD.$wmkFD_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cb1Sb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb1Sc; else goto cb1Sd;
       cb1Sc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$wmkFD_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1Sd: // global
           I64[Sp - 32] = block_cb1S4_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub1TI; else goto cb1S5;
       ub1TI: // global
           call _cb1S4(R1) args: 0, res: 0, upd: 0;
       cb1S5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$wmkFD_info" {
     GHC.IO.FD.$wmkFD_info:
         const GHC.IO.FD.$wmkFD_entry;
         const 0;
         const 246294899589134;
         const 21474836504;
         const Sb0HW_srt+552;
 },
 _cb1S4() //  [R1]
         { []
         }
     {offset
       cb1S4: // global
           if (R1 & 7 == 1) goto cb1S8; else goto cb1S9;
       cb1S8: // global
           I64[Sp] = block_cb1T6_info;
           R2 = P64[Sp + 8];
           call System.Posix.Internals.fdStat1_entry(R2) args: 8, res: 8, upd: 8;
       cb1S9: // global
           I64[Sp] = block_cb1Ti_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub1TH; else goto cb1Tk;
       ub1TH: // global
           call _cb1Ti(R1) args: 0, res: 0, upd: 0;
       cb1Tk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1S4_info" {
     block_cb1S4_info:
         const _cb1S4;
         const 3;
         const 211110527500318;
         const Sb0HW_srt+552;
 },
 _cb1T6() //  [R1]
         { []
         }
     {offset
       cb1T6: // global
           I64[Sp] = block_cb1T8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub1TK; else goto cb1Tb;
       ub1TK: // global
           call _cb1T8(R1) args: 0, res: 0, upd: 0;
       cb1Tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1T6_info" {
     block_cb1T6_info:
         const _cb1T6;
         const 3;
         const 12884901918;
         const Sb0HW_srt+664;
 },
 _cb1T8() //  [R1]
         { []
         }
     {offset
       cb1T8: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call _sb0CT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1T8_info" {
     block_cb1T8_info:
         const _cb1T8;
         const 3;
         const 12884901918;
         const Sb0HW_srt+664;
 },
 _cb1Ti() //  [R1]
         { []
         }
     {offset
       cb1Ti: // global
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call _sb0CT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Ti_info" {
     block_cb1Ti_info:
         const _cb1Ti;
         const 3;
         const 12884901918;
         const Sb0HW_srt+664;
 },
 _sb0CT() //  []
         { []
         }
     {offset
       sb0CT: // global
           I64[Sp - 8] = block_cb1Qc_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub1TN; else goto cb1Qd;
       ub1TN: // global
           call _cb1Qc(R1) args: 0, res: 0, upd: 0;
       cb1Qd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1Qc() //  [R1]
         { []
         }
     {offset
       cb1Qc: // global
           _cb1Tv::P64 = R1 & 7;
           if (_cb1Tv::P64 == 1) goto cb1Sn; else goto ub1Tx;
       cb1Sn: // global
           R1 = GHC.IO.FD.mkFD8_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ub1Tx: // global
           _sb0CO::P64 = P64[Sp + 32];
           if (_cb1Tv::P64 == 3) goto cb1Sp; else goto cb1Sh;
       cb1Sp: // global
           I64[Sp] = block_cb1QS_info;
           R1 = _sb0CO::P64;
           if (R1 & 7 != 0) goto ub1TC; else goto cb1QT;
       ub1TC: // global
           call _cb1QS(R1) args: 0, res: 0, upd: 0;
       cb1QT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Sh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1Sk; else goto cb1Sj;
       cb1Sk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Sj: // global
           I64[Hp - 48] = sat_sb0D2_info;
           P64[Hp - 32] = _sb0CO::P64;
           P64[Hp - 24] = P64[Sp + 48];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Qc_info" {
     block_cb1Qc_info:
         const _cb1Qc;
         const 262;
         const 12884901918;
         const Sb0HW_srt+664;
 },
 _cb1QS() //  [R1]
         { []
         }
     {offset
       cb1QS: // global
           _sb0CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb1QX_info;
           _sb0D6::I64 = I64[R1 + 7];
           R1 = _sb0CW::P64;
           I64[Sp + 32] = _sb0D6::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub1TD; else goto cb1QY;
       ub1TD: // global
           call _cb1QX(R1) args: 0, res: 0, upd: 0;
       cb1QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1QS_info" {
     block_cb1QS_info:
         const _cb1QS;
         const 774;
         const 4294967326;
         const Sb0HW_srt+664;
 },
 _cb1QX() //  [R1]
         { []
         }
     {offset
       cb1QX: // global
           _sb0CX::P64 = P64[Sp + 8];
           _sb0D8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sb0D8::I64, 0)) goto cb1T2; else goto cb1T3;
       cb1T2: // global
           _sb0Db::I64 = _sb0D8::I64;
           goto sb0Da;
       cb1T3: // global
           _sb0Db::I64 = _sb0D8::I64;
           goto sb0Da;
       sb0Da: // global
           I64[Sp + 8] = block_cb1Ra_info;
           R1 = _sb0CX::P64;
           I64[Sp + 16] = _sb0Db::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub1TE; else goto cb1Rb;
       ub1TE: // global
           call _cb1Ra(R1) args: 0, res: 0, upd: 0;
       cb1Rb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1QX_info" {
     block_cb1QX_info:
         const _cb1QX;
         const 389;
         const 4294967326;
         const Sb0HW_srt+664;
 },
 _cb1Ra() //  [R1]
         { []
         }
     {offset
       cb1Ra: // global
           _sb0CP::P64 = P64[Sp + 24];
           _sb0Dd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sb0Dd::I64, 0)) goto cb1SX; else goto cb1SY;
       cb1SX: // global
           _sb0Dg::I64 = _sb0Dd::I64;
           goto sb0Df;
       cb1SY: // global
           _sb0Dg::I64 = _sb0Dd::I64;
           goto sb0Df;
       sb0Df: // global
           I64[Sp] = block_cb1Su_info;
           R1 = _sb0CP::P64;
           I64[Sp + 24] = _sb0Dg::I64;
           if (R1 & 7 != 0) goto ub1TF; else goto cb1SJ;
       ub1TF: // global
           call _cb1Su(R1) args: 0, res: 0, upd: 0;
       cb1SJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Ra_info" {
     block_cb1Ra_info:
         const _cb1Ra;
         const 196;
         const 4294967326;
         const Sb0HW_srt+664;
 },
 _cb1Su() //  [R1]
         { []
         }
     {offset
       cb1Su: // global
           _sb0D6::I64 = I64[Sp + 16];
           _sb0Db::I64 = I64[Sp + 8];
           _sb0Dg::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb1ST; else goto cb1SP;
       cb1ST: // global
           _sb0Di::I64 = 0;
           goto sb0Dh;
       cb1SP: // global
           _sb0Di::I64 = 1;
           goto sb0Dh;
       sb0Dh: // global
           (_sb0Dm::I64) = call "ccall" arg hints:  [‘signed’, , ,
                                                     ‘signed’]  result hints:  [‘signed’] lockFile(_sb0D6::I64, _sb0Db::I64, _sb0Dg::I64, _sb0Di::I64);
           _sb0Dn::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Dm::I64));
           if (_sb0Dn::I64 != (-1)) goto ub1TA; else goto cb1SF;
       ub1TA: // global
           I64[Sp + 24] = _sb0Dn::I64;
           Sp = Sp + 16;
           call _cb1RB() args: 0, res: 0, upd: 0;
       cb1SF: // global
           R1 = GHC.IO.FD.mkFD2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Su_info" {
     block_cb1Su_info:
         const _cb1Su;
         const 452;
         const 4294967326;
         const Sb0HW_srt+664;
 },
 _cb1RB() //  []
         { []
         }
     {offset
       cb1RB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb1SC; else goto cb1SB;
       cb1SC: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb1RA_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1SB: // global
           I64[Hp - 48] = sat_sb0Dp_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1RA() //  [R1]
         { []
         }
     {offset
       cb1RA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb1RB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1RA_info" {
     block_cb1RA_info:
         const _cb1RA;
         const 195;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.188689415 UTC

[section ""data" . GHC.IO.FD.mkFD1_closure" {
     GHC.IO.FD.mkFD1_closure:
         const GHC.IO.FD.mkFD1_info;
         const 0;
 },
 GHC.IO.FD.mkFD1_entry() //  [R2, R3, R4, R6]
         { []
         }
     {offset
       cb1VP: // global
           R5 = R6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD1_info" {
     GHC.IO.FD.mkFD1_info:
         const GHC.IO.FD.mkFD1_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const Sb0HW_srt+656;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.192000473 UTC

[section ""data" . GHC.IO.FD.mkFD_closure" {
     GHC.IO.FD.mkFD_closure:
         const GHC.IO.FD.mkFD_info;
         const 0;
 },
 GHC.IO.FD.mkFD_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb1W0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.mkFD1_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.mkFD_info" {
     GHC.IO.FD.mkFD_info:
         const GHC.IO.FD.mkFD_entry;
         const 0;
         const 4294967310;
         const 25769803801;
         const Sb0HW_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.209435827 UTC

[section ""data" . GHC.IO.FD.openFile1_closure" {
     GHC.IO.FD.openFile1_closure:
         const GHC.IO.FD.openFile1_info;
         const 0;
 },
 sat_sb0Ea_entry() //  [R1]
         { []
         }
     {offset
       cb1WF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb1WI; else goto cb1WJ;
       cb1WI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1WJ: // global
           I64[Sp - 8] = block_cb1WB_info;
           Sp = Sp - 8;
           _cb1Wy::I64 = I64[R1 + 7];
           _cb1Wz::I64 = I64[R1 + 15];
           _ub1WP::P64 = CurrentTSO;
           I64[I64[_ub1WP::P64 + 24] + 16] = Sp;
           _ub1WQ::I64 = CurrentNursery;
           P64[_ub1WQ::I64 + 8] = Hp + 8;
           I64[_ub1WP::P64 + 104] = I64[_ub1WP::P64 + 104] - ((Hp + 8) - I64[_ub1WQ::I64]);
           (_ub1WN::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sb0E7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’,]  result hints:  [‘signed’] __hscore_open(_cb1Wy::I64, _cb1Wz::I64, 438);
           (_ub1WO::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ub1WN::I64);
           BaseReg = _ub1WO::I64;
           _ub1WR::P64 = CurrentTSO;
           _ub1WS::P64 = I64[_ub1WR::P64 + 24];
           Sp = I64[_ub1WS::P64 + 16];
           SpLim = _ub1WS::P64 + 192;
           HpAlloc = 0;
           _ub1WT::I64 = CurrentNursery;
           _ub1WU::I64 = I64[_ub1WT::I64 + 8];
           Hp = _ub1WU::I64 - 8;
           _ub1WV::I64 = I64[_ub1WT::I64];
           HpLim = _ub1WV::I64 + ((%MO_SS_Conv_W32_W64(I32[_ub1WT::I64 + 48]) << 12) - 1);
           I64[_ub1WR::P64 + 104] = I64[_ub1WR::P64 + 104] + (_ub1WU::I64 - _ub1WV::I64);
           R1 = _sb0E7::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Ea_info" {
     sat_sb0Ea_info:
         const sat_sb0Ea_entry;
         const 8589934592;
         const 13;
         const 4294967299;
 },
 _cb1WB() //  [R1]
         { []
         }
     {offset
       cb1WB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1WM; else goto cb1WL;
       cb1WM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1WL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1WB_info" {
     block_cb1WB_info:
         const _cb1WB;
         const 0;
         const 30;
 },
 sat_sb0Er_entry() //  [R1]
         { []
         }
     {offset
       cb1Xh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb1Xi; else goto cb1Xj;
       cb1Xi: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb1Xj: // global
           I64[Sp - 24] = block_cb1Xe_info;
           _sb0Ei::P64 = P64[R1 + 15];
           _sb0Ej::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sb0Ei::P64;
           P64[Sp - 8] = _sb0Ej::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub1Xp; else goto cb1Xf;
       ub1Xp: // global
           call _cb1Xe(R1) args: 0, res: 0, upd: 0;
       cb1Xf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Er_info" {
     sat_sb0Er_info:
         const sat_sb0Er_entry;
         const 3;
         const 8;
         const 4294967299;
 },
 _cb1Xe() //  [R1]
         { []
         }
     {offset
       cb1Xe: // global
           _sb0Ei::P64 = P64[Sp + 8];
           _sb0Ej::P64 = P64[Sp + 16];
           (_sb0Eq::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(I64[R1 + 7]);
           R3 = _sb0Ej::P64;
           R2 = _sb0Ei::P64;
           Sp = Sp + 24;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Xe_info" {
     block_cb1Xe_info:
         const _cb1Xe;
         const 2;
         const 30;
 },
 sat_sb0Es_entry() //  [R1, R2]
         { []
         }
     {offset
       cb1Xq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1Xr; else goto cb1Xs;
       cb1Xr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1Xs: // global
           I64[Sp - 16] = block_cb1X4_info;
           _sb0Ed::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sb0Ed::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1Xw; else goto cb1X5;
       ub1Xw: // global
           call _cb1X4(R1) args: 0, res: 0, upd: 0;
       cb1X5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Es_info" {
     sat_sb0Es_info:
         const sat_sb0Es_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cb1X4() //  [R1]
         { []
         }
     {offset
       cb1X4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb1Xv; else goto cb1Xu;
       cb1Xv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1Xu: // global
           _sb0Ei::P64 = P64[R1 + 7];
           _sb0Ej::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sb0Er_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sb0Ei::P64;
           P64[Hp] = _sb0Ej::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1X4_info" {
     block_cb1X4_info:
         const _cb1X4;
         const 1;
         const 30;
 },
 sat_sb0Ef_entry() //  [R1]
         { []
         }
     {offset
       cb1XC: // global
           R5 = P64[R1 + 15];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 7];
           R2 = P64[R1 + 23];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0Ef_info" {
     sat_sb0Ef_info:
         const sat_sb0Ef_entry;
         const 3;
         const 4294967304;
         const 4294967299;
         const Sb0HW_srt+656;
 },
 section ""relreadonly" . ub22f_srtd" {
     ub22f_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 sat_sb0FI_entry() //  [R1, R2]
         { []
         }
     {offset
       cb1XF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb1XG; else goto cb1XH;
       cb1XG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb1XH: // global
           I64[Sp - 24] = block_cb1Wi_info;
           _sb0DR::P64 = P64[R1 + 6];
           _sb0DS::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb0DR::P64;
           P64[Sp - 8] = _sb0DS::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub21I; else goto cb1Wj;
       ub21I: // global
           call _cb1Wi(R1) args: 0, res: 0, upd: 0;
       cb1Wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sb0FI_info" {
     sat_sb0FI_info:
         const sat_sb0FI_entry;
         const 2;
         const 18446744069414584331;
         const 8589934597;
         const ub22f_srtd;
 },
 section ""relreadonly" . ub22g_srtd" {
     ub22g_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1Wi() //  [R1]
         { []
         }
     {offset
       cb1Wi: // global
           I64[Sp - 8] = block_cb1XI_info;
           _sb0E0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _sb0E0::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub21G; else goto cb1YO;
       ub21G: // global
           call _cb1XI(R1) args: 0, res: 0, upd: 0;
       cb1YO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Wi_info" {
     block_cb1Wi_info:
         const _cb1Wi;
         const 2;
         const 18446744069414584350;
         const ub22g_srtd;
 },
 section ""relreadonly" . ub22h_srtd" {
     ub22h_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1XI() //  [R1]
         { []
         }
     {offset
       cb1XI: // global
           _sb0DR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cb1YV; else goto cb1ZH;
       cb1YV: // global
           I64[Sp] = block_cb1YS_info;
           R1 = _sb0DR::P64;
           if (R1 & 7 != 0) goto ub21J; else goto cb1YW;
       ub21J: // global
           call _cb1YS(R1) args: 0, res: 0, upd: 0;
       cb1YW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1ZH: // global
           I64[Sp] = block_cb1ZF_info;
           R1 = _sb0DR::P64;
           if (R1 & 7 != 0) goto ub21K; else goto cb1ZI;
       ub21K: // global
           call _cb1ZF(R1) args: 0, res: 0, upd: 0;
       cb1ZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1XI_info" {
     block_cb1XI_info:
         const _cb1XI;
         const 67;
         const 18446744069414584350;
         const ub22h_srtd;
 },
 section ""relreadonly" . ub22i_srtd" {
     ub22i_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1YS() //  [R1]
         { []
         }
     {offset
       cb1YS: // global
           _cb21l::P64 = R1 & 7;
           if (_cb21l::P64 < 3) goto ub21p; else goto ub21q;
       ub21p: // global
           if (_cb21l::P64 < 2) goto cb1Z3; else goto cb1Zd;
       cb1Z3: // global
           I64[Sp] = block_cb1Z0_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub21T; else goto cb1Z4;
       ub21T: // global
           call _cb1Z0(R1) args: 0, res: 0, upd: 0;
       cb1Z4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Zd: // global
           I64[Sp] = block_cb1Zb_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub21U; else goto cb1Ze;
       ub21U: // global
           call _cb1Zb(R1) args: 0, res: 0, upd: 0;
       cb1Ze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21q: // global
           if (_cb21l::P64 < 4) goto cb1Zn; else goto cb1Zx;
       cb1Zn: // global
           I64[Sp] = block_cb1Zl_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub21V; else goto cb1Zo;
       ub21V: // global
           call _cb1Zl(R1) args: 0, res: 0, upd: 0;
       cb1Zo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1Zx: // global
           I64[Sp] = block_cb1Zv_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub21W; else goto cb1Zy;
       ub21W: // global
           call _cb1Zv(R1) args: 0, res: 0, upd: 0;
       cb1Zy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1YS_info" {
     block_cb1YS_info:
         const _cb1YS;
         const 67;
         const 18446744069414584350;
         const ub22i_srtd;
 },
 section ""relreadonly" . ub22j_srtd" {
     ub22j_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Z0() //  [R1]
         { []
         }
     {offset
       cb1Z0: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Z0_info" {
     block_cb1Z0_info:
         const _cb1Z0;
         const 67;
         const 18446744069414584350;
         const ub22j_srtd;
 },
 section ""relreadonly" . ub22k_srtd" {
     ub22k_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zb() //  [R1]
         { []
         }
     {offset
       cb1Zb: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Zb_info" {
     block_cb1Zb_info:
         const _cb1Zb;
         const 67;
         const 18446744069414584350;
         const ub22k_srtd;
 },
 section ""relreadonly" . ub22l_srtd" {
     ub22l_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zl() //  [R1]
         { []
         }
     {offset
       cb1Zl: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Zl_info" {
     block_cb1Zl_info:
         const _cb1Zl;
         const 67;
         const 18446744069414584350;
         const ub22l_srtd;
 },
 section ""relreadonly" . ub22m_srtd" {
     ub22m_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Zv() //  [R1]
         { []
         }
     {offset
       cb1Zv: // global
           I64[Sp] = I64[R1 + 7];
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Zv_info" {
     block_cb1Zv_info:
         const _cb1Zv;
         const 67;
         const 18446744069414584350;
         const ub22m_srtd;
 },
 section ""relreadonly" . ub22n_srtd" {
     ub22n_srtd:
         const Sb0HW_srt+264;
         const 57;
         const 135673137797793793;
 },
 _cb1ZF() //  [R1]
         { []
         }
     {offset
       cb1ZF: // global
           _cb20q::P64 = R1 & 7;
           if (_cb20q::P64 < 3) goto ub21r; else goto ub21s;
       ub21r: // global
           if (_cb20q::P64 < 2) goto cb1ZP; else goto cb1ZZ;
       cb1ZP: // global
           I64[Sp] = block_cb1ZM_info;
           R1 = read_flags_raWV8_closure;
           if (R1 & 7 != 0) goto ub221; else goto cb1ZQ;
       ub221: // global
           call _cb1ZM(R1) args: 0, res: 0, upd: 0;
       cb1ZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb1ZZ: // global
           I64[Sp] = block_cb1ZX_info;
           R1 = write_flags_raWV5_closure;
           if (R1 & 7 != 0) goto ub222; else goto cb200;
       ub222: // global
           call _cb1ZX(R1) args: 0, res: 0, upd: 0;
       cb200: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21s: // global
           if (_cb20q::P64 < 4) goto cb209; else goto cb20j;
       cb209: // global
           I64[Sp] = block_cb207_info;
           R1 = append_flags_raWV6_closure;
           if (R1 & 7 != 0) goto ub223; else goto cb20a;
       ub223: // global
           call _cb207(R1) args: 0, res: 0, upd: 0;
       cb20a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb20j: // global
           I64[Sp] = block_cb20h_info;
           R1 = rw_flags_raWV7_closure;
           if (R1 & 7 != 0) goto ub224; else goto cb20k;
       ub224: // global
           call _cb20h(R1) args: 0, res: 0, upd: 0;
       cb20k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1ZF_info" {
     block_cb1ZF_info:
         const _cb1ZF;
         const 67;
         const 18446744069414584350;
         const ub22n_srtd;
 },
 section ""relreadonly" . ub22o_srtd" {
     ub22o_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1ZM() //  [R1]
         { []
         }
     {offset
       cb1ZM: // global
           _sb0F1::I64 = I64[R1 + 7];
           (_sb0F5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0F1::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0F5::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1ZM_info" {
     block_cb1ZM_info:
         const _cb1ZM;
         const 67;
         const 18446744069414584350;
         const ub22o_srtd;
 },
 section ""relreadonly" . ub22p_srtd" {
     ub22p_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1ZX() //  [R1]
         { []
         }
     {offset
       cb1ZX: // global
           _sb0Fc::I64 = I64[R1 + 7];
           (_sb0Fg::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fc::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Fg::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1ZX_info" {
     block_cb1ZX_info:
         const _cb1ZX;
         const 67;
         const 18446744069414584350;
         const ub22p_srtd;
 },
 section ""relreadonly" . ub22q_srtd" {
     ub22q_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb207() //  [R1]
         { []
         }
     {offset
       cb207: // global
           _sb0Fn::I64 = I64[R1 + 7];
           (_sb0Fr::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fn::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0Fr::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb207_info" {
     block_cb207_info:
         const _cb207;
         const 67;
         const 18446744069414584350;
         const ub22q_srtd;
 },
 section ""relreadonly" . ub22r_srtd" {
     ub22r_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb20h() //  [R1]
         { []
         }
     {offset
       cb20h: // global
           _sb0Fy::I64 = I64[R1 + 7];
           (_sb0FC::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           I64[Sp] = _sb0Fy::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0FC::I64));
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb20h_info" {
     block_cb20h_info:
         const _cb20h;
         const 67;
         const 18446744069414584350;
         const ub22r_srtd;
 },
 _cb1Wq() //  []
         { []
         }
     {offset
       cb1Wq: // global
           Hp = Hp + 24;
           _sb0E2::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cb1XP; else goto cb1XO;
       cb1XP: // global
           HpAlloc = 24;
           I64[Sp] = block_cb1Wp_info;
           R1 = _sb0E2::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1XO: // global
           I64[Hp - 16] = sat_sb0Ea_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sb0E2::I64;
           I64[Sp + 8] = block_cb1WX_info;
           R4 = Hp - 15;
           R3 = GHC.IO.FD.mkFD6_closure;
           R2 = GHC.IO.FD.$fIODeviceFD25_closure+1;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub22s_srtd" {
     ub22s_srtd:
         const Sb0HW_srt+352;
         const 43;
         const 4673998159873;
 },
 _cb1Wp() //  [R1]
         { []
         }
     {offset
       cb1Wp: // global
           I64[Sp] = R1;
           call _cb1Wq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Wp_info" {
     block_cb1Wp_info:
         const _cb1Wp;
         const 67;
         const 18446744069414584350;
         const ub22s_srtd;
 },
 section ""relreadonly" . ub22t_srtd" {
     ub22t_srtd:
         const Sb0HW_srt+352;
         const 39;
         const 274877906945;
 },
 _cb1WX() //  [R1]
         { []
         }
     {offset
       cb1WX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb1XS; else goto cb1XR;
       cb1XS: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1XR: // global
           I64[Hp - 40] = sat_sb0Es_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sb0Ef_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cb1XK_info;
           R2 = Hp - 39;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1WX_info" {
     block_cb1WX_info:
         const _cb1WX;
         const 2;
         const 18446744069414584350;
         const ub22t_srtd;
 },
 _cb1XK() //  [R1]
         { []
         }
     {offset
       cb1XK: // global
           I64[Sp] = block_cb1XM_info;
           _sb0Ev::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sb0Ev::P64;
           if (R1 & 7 != 0) goto ub21L; else goto cb1XU;
       ub21L: // global
           call _cb1XM(R1) args: 0, res: 0, upd: 0;
       cb1XU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1XK_info" {
     block_cb1XK_info:
         const _cb1XK;
         const 130;
         const 4294967326;
         const Sb0HW_srt+720;
 },
 _cb1XM() //  [R1]
         { []
         }
     {offset
       cb1XM: // global
           I64[Sp - 8] = block_cb1XY_info;
           _sb0Ex::P64 = P64[R1 + 7];
           _sb0Ey::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb0Ey::P64;
           P64[Sp + 8] = _sb0Ex::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub21M; else goto cb1Y0;
       ub21M: // global
           call _cb1XY(R1) args: 0, res: 0, upd: 0;
       cb1Y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1XM_info" {
     block_cb1XM_info:
         const _cb1XM;
         const 2;
         const 4294967326;
         const Sb0HW_srt+720;
 },
 _cb1XY() //  [R1]
         { []
         }
     {offset
       cb1XY: // global
           if (R1 & 7 == 2) goto cb1Yb; else goto ub21C;
       cb1Yb: // global
           _sb0Ey::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb1Y9_info;
           R1 = _sb0Ey::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub21N; else goto cb1Yc;
       ub21N: // global
           call _cb1Y9(R1) args: 0, res: 0, upd: 0;
       cb1Yc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21C: // global
           Sp = Sp + 24;
           call _cb1Yi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1XY_info" {
     block_cb1XY_info:
         const _cb1XY;
         const 3;
         const 4294967326;
         const Sb0HW_srt+720;
 },
 _cb1Y9() //  [R1]
         { []
         }
     {offset
       cb1Y9: // global
           if (R1 & 7 == 3) goto cb1Yn; else goto ub21D;
       cb1Yn: // global
           I64[Sp + 16] = block_cb1Yl_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub21P; else goto cb1Yo;
       ub21P: // global
           call _cb1Yl(R1) args: 0, res: 0, upd: 0;
       cb1Yo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub21D: // global
           Sp = Sp + 16;
           call _cb1Yi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1Y9_info" {
     block_cb1Y9_info:
         const _cb1Y9;
         const 2;
         const 4294967326;
         const Sb0HW_srt+720;
 },
 _cb1Yl() //  [R1]
         { []
         }
     {offset
       cb1Yl: // global
           (_sb0EH::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] __hscore_ftruncate(I64[R1 + 7], 0);
           _sb0EI::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sb0EH::I64));
           if (_sb0EI::I64 == 0) goto ub21E; else goto cb1YB;
       ub21E: // global
           I64[Sp - 8] = _sb0EI::I64;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call _cb1YH() args: 0, res: 0, upd: 0;
       cb1YB: // global
           (_sb0EM::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sb0EM::I64;
           Sp = Sp + 8;
           call GHC.IO.FD.$fIODeviceFD11_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Yl_info" {
     block_cb1Yl_info:
         const _cb1Yl;
         const 0;
         const 4294967326;
         const Sb0HW_srt+720;
 },
 _cb1YH() //  []
         { []
         }
     {offset
       cb1YH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb1YN; else goto cb1YM;
       cb1YN: // global
           HpAlloc = 24;
           _sb0EI::I64 = I64[Sp];
           I64[Sp] = block_cb1YG_info;
           R1 = _sb0EI::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1YM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = GHC.IO.Device.RegularFile_closure+3;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb1YG() //  [R1]
         { []
         }
     {offset
       cb1YG: // global
           I64[Sp] = R1;
           call _cb1YH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cb1YG_info" {
     block_cb1YG_info:
         const _cb1YG;
         const 1;
         const 30;
 },
 _cb1Yi() //  []
         { []
         }
     {offset
       cb1Yi: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub22u_srtd" {
     ub22u_srtd:
         const Sb0HW_srt+264;
         const 60;
         const 1144479454328782849;
 },
 GHC.IO.FD.openFile1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb229: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb22a; else goto cb22b;
       cb22a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.openFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb22b: // global
           I64[Sp - 32] = block_cb1Wb_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.openFile1_info" {
     GHC.IO.FD.openFile1_info:
         const GHC.IO.FD.openFile1_entry;
         const 0;
         const 18446744069414584334;
         const 17179869207;
         const ub22u_srtd;
 },
 section ""relreadonly" . ub22v_srtd" {
     ub22v_srtd:
         const Sb0HW_srt+264;
         const 58;
         const 279788325873647617;
 },
 _cb1Wb() //  [R1]
         { []
         }
     {offset
       cb1Wb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb22e; else goto cb22d;
       cb22e: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb22d: // global
           I64[Hp - 16] = sat_sb0FI_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 14;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb1Wb_info" {
     block_cb1Wb_info:
         const _cb1Wb;
         const 3;
         const 18446744069414584350;
         const ub22v_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.275866615 UTC

[section ""data" . GHC.IO.FD.openFile_closure" {
     GHC.IO.FD.openFile_closure:
         const GHC.IO.FD.openFile_info;
         const 0;
 },
 GHC.IO.FD.openFile_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cb26b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.openFile_info" {
     GHC.IO.FD.openFile_info:
         const GHC.IO.FD.openFile_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sb0HW_srt+736;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.282098154 UTC

[section ""data" . GHC.IO.FD.$w$cfillReadBuffer_closure" {
     GHC.IO.FD.$w$cfillReadBuffer_closure:
         const GHC.IO.FD.$w$cfillReadBuffer_info;
         const 0;
 },
 GHC.IO.FD.$w$cfillReadBuffer_slow() //  [R1]
         { []
         }
     {offset
       cb26j: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb0G2_entry() //  [R1]
         { []
         }
     {offset
       cb26G: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb26N; else goto cb26O;
       cb26N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb26O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cb26D_info;
           _sb0FM::P64 = P64[R1 + 16];
           _sb0FN::P64 = P64[R1 + 24];
           _sb0FL::I64 = I64[R1 + 40];
           _sb0FO::I64 = I64[R1 + 48];
           _sb0FP::I64 = I64[R1 + 56];
           _sb0FQ::I64 = I64[R1 + 64];
           R1 = P64[R1 + 32];
           I64[Sp - 64] = _sb0FL::I64;
           P64[Sp - 56] = _sb0FM::P64;
           P64[Sp - 48] = _sb0FN::P64;
           I64[Sp - 40] = _sb0FO::I64;
           I64[Sp - 32] = _sb0FP::I64;
           I64[Sp - 24] = _sb0FQ::I64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ub26S; else goto cb26E;
       ub26S: // global
           call _cb26D(R1) args: 0, res: 0, upd: 0;
       cb26E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0G2_info" {
     sat_sb0G2_info:
         const sat_sb0G2_entry;
         const 17179869187;
         const 15;
 },
 _cb26D() //  [R1]
         { []
         }
     {offset
       cb26D: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb26R; else goto cb26Q;
       cb26R: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb26Q: // global
           _sb0G1::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sb0G1::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb26D_info" {
     block_cb26D_info:
         const _cb26D;
         const 3654;
         const 30;
 },
 GHC.IO.FD.$w$cfillReadBuffer_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cb26T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb26V; else goto cb26W;
       cb26V: // global
           R1 = GHC.IO.FD.$w$cfillReadBuffer_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb26W: // global
           I64[Sp - 32] = block_cb26w_info;
           _sb0FN::P64 = R6;
           R6 = 0;
           _sb0FM::P64 = R5;
           _sb0FQ::I64 = I64[Sp + 16];
           R5 = R4 + _sb0FQ::I64;
           _sb0FL::I64 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 40] = I64[Sp] - _sb0FQ::I64;
           I64[Sp - 24] = _sb0FL::I64;
           P64[Sp - 16] = _sb0FM::P64;
           P64[Sp - 8] = _sb0FN::P64;
           Sp = Sp - 40;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$w$cfillReadBuffer_info" {
     GHC.IO.FD.$w$cfillReadBuffer_info:
         const GHC.IO.FD.$w$cfillReadBuffer_entry;
         const 0;
         const 30064771086;
         const 38654705664;
         const Sb0HW_srt+744;
         const 14792;
         const GHC.IO.FD.$w$cfillReadBuffer_slow;
 },
 _cb26w() //  [R1]
         { []
         }
     {offset
       cb26w: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb26Z; else goto cb26Y;
       cb26Z: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb26Y: // global
           _sb0FL::I64 = I64[Sp + 8];
           _sb0FM::P64 = P64[Sp + 16];
           _sb0FN::P64 = P64[Sp + 24];
           _sb0FO::I64 = I64[Sp + 32];
           _sb0FP::I64 = I64[Sp + 40];
           _sb0FQ::I64 = I64[Sp + 48];
           call MO_Touch(_sb0FM::P64);
           I64[Hp - 88] = sat_sb0G2_info;
           P64[Hp - 72] = _sb0FM::P64;
           P64[Hp - 64] = _sb0FN::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sb0FL::I64;
           I64[Hp - 40] = _sb0FO::I64;
           I64[Hp - 32] = _sb0FP::I64;
           I64[Hp - 24] = _sb0FQ::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb26w_info" {
     block_cb26w_info:
         const _cb26w;
         const 3654;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.294433585 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD11_closure" {
     GHC.IO.FD.$fBufferedIOFD11_closure:
         const GHC.IO.FD.$fBufferedIOFD11_info;
         const 0;
 },
 GHC.IO.FD.$fBufferedIOFD11_entry() //  [R2, R3]
         { []
         }
     {offset
       cb27I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb27M; else goto cb27N;
       cb27M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb27N: // global
           I64[Sp - 16] = block_cb27F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub27V; else goto cb27G;
       ub27V: // global
           call _cb27F(R1) args: 0, res: 0, upd: 0;
       cb27G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD11_info" {
     GHC.IO.FD.$fBufferedIOFD11_info:
         const GHC.IO.FD.$fBufferedIOFD11_entry;
         const 0;
         const 38654705678;
         const 12884901903;
         const Sb0HW_srt+744;
 },
 _cb27F() //  [R1]
         { []
         }
     {offset
       cb27F: // global
           I64[Sp - 8] = block_cb27L_info;
           _sb0G8::I64 = I64[R1 + 7];
           _sb0G9::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _sb0G9::I64;
           I64[Sp + 8] = _sb0G8::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub27U; else goto cb27P;
       ub27U: // global
           call _cb27L(R1) args: 0, res: 0, upd: 0;
       cb27P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cb27F_info" {
     block_cb27F_info:
         const _cb27F;
         const 1;
         const 4294967326;
         const Sb0HW_srt+744;
 },
 _cb27L() //  [R1]
         { []
         }
     {offset
       cb27L: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.FD.$w$cfillReadBuffer_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb27L_info" {
     block_cb27L_info:
         const _cb27L;
         const 194;
         const 4294967326;
         const Sb0HW_srt+744;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.303175745 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD6_closure" {
     GHC.IO.FD.$fBufferedIOFD6_closure:
         const GHC.IO.FD.$fBufferedIOFD6_info;
 },
 sat_sb0Gr_entry() //  [R1]
         { []
         }
     {offset
       cb28p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb28t; else goto cb28u;
       cb28t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb28u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb28m_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub28y; else goto cb28n;
       ub28y: // global
           call _cb28m(R1) args: 0, res: 0, upd: 0;
       cb28n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sb0Gr_info" {
     sat_sb0Gr_info:
         const sat_sb0Gr_entry;
         const 1;
         const 16;
 },
 _cb28m() //  [R1]
         { []
         }
     {offset
       cb28m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb28x; else goto cb28w;
       cb28x: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb28w: // global
           _sb0Gm::P64 = P64[R1 + 7];
           _sb0Gl::I64 = I64[R1 + 23];
           _sb0Go::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb0Gm::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb0Gl::I64;
           I64[Hp - 16] = _sb0Go::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cb28m_info" {
     block_cb28m_info:
         const _cb28m;
         const 0;
         const 30;
 },
 GHC.IO.FD.$fBufferedIOFD6_entry() //  [R2, R3]
         { []
         }
     {offset
       cb28z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb28D; else goto cb28C;
       cb28D: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.$fBufferedIOFD6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb28C: // global
           I64[Hp - 16] = sat_sb0Gr_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.$fBufferedIOFD6_info" {
     GHC.IO.FD.$fBufferedIOFD6_info:
         const GHC.IO.FD.$fBufferedIOFD6_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.310217336 UTC

[section ""data" . GHC.IO.FD.$fBufferedIOFD_closure" {
     GHC.IO.FD.$fBufferedIOFD_closure:
         const GHC.IO.BufferedIO.C:BufferedIO_con_info;
         const GHC.IO.FD.$fBufferedIOFD15_closure+3;
         const GHC.IO.FD.$fBufferedIOFD11_closure+3;
         const GHC.IO.FD.$fBufferedIOFD7_closure+3;
         const GHC.IO.FD.$fBufferedIOFD6_closure+3;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure+3;
         const GHC.IO.FD.$fBufferedIOFD1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.312689721 UTC

[section ""data" . GHC.IO.FD.FD_closure" {
     GHC.IO.FD.FD_closure:
         const GHC.IO.FD.FD_info;
 },
 GHC.IO.FD.FD_entry() //  [R2, R3]
         { []
         }
     {offset
       cb294: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb298; else goto cb297;
       cb298: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.FD.FD_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb297: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.FD_info" {
     GHC.IO.FD.FD_info:
         const GHC.IO.FD.FD_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.316779475 UTC

[section ""cstring" . ib29g_str" {
     ib29g_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,70,68,46,70,68]
 },
 GHC.IO.FD.FD_con_entry() //  [R1]
         { []
         }
     {offset
       cb29f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.FD.FD_con_info" {
     GHC.IO.FD.FD_con_info:
         const GHC.IO.FD.FD_con_entry;
         const 8589934592;
         const 6;
         const ib29g_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:01.320506143 UTC

[section ""relreadonly" . Sb0HW_srt" {
     Sb0HW_srt:
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fBufferedIOFD5_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$w$creadNonBlocking_closure;
         const GHC.IO.FD.$fRawIOFD3_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const Foreign.C.Error.throwErrnoIfMinus1RetryMayBlock2_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$fRawIOFD4_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.IO.FD.$wwriteRawBufferPtr_closure;
         const GHC.IO.FD.writeRawBufferPtr1_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const lvl1_raWUY_closure;
         const GHC.IO.FD.$fRawIOFD2_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD_loc_closure;
         const GHC.IO.FD.$fRawIOFD1_closure;
         const GHC.IO.FD.$fBufferedIOFD_$swriteBuf1_closure;
         const System.Posix.Internals.fdFileSize1_closure;
         const GHC.IO.FD.$fIODeviceFD12_closure;
         const System.Posix.Internals.setEcho1_closure;
         const GHC.IO.FD.$fIODeviceFD9_closure;
         const System.Posix.Internals.getEcho3_closure;
         const GHC.IO.FD.$fIODeviceFD8_closure;
         const System.Posix.Internals.setCooked1_closure;
         const GHC.IO.FD.$fIODeviceFD7_closure;
         const output_flags_raWV4_closure;
         const write_flags_raWV5_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$w$ctell_closure;
         const GHC.IO.FD.$fIODeviceFD14_closure;
         const GHC.IO.FD.$fIODeviceFD13_closure;
         const GHC.IO.FD.$w$cseek_closure;
         const GHC.IO.FD.$fIODeviceFD18_closure;
         const GHC.IO.FD.$fIODeviceFD17_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl4_raWVa_closure;
         const GHC.IO.FD.$wsetSize_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.FD.$fIODeviceFD10_closure;
         const GHC.IO.FD.readRawBufferPtrNoBlock1_closure;
         const GHC.IO.FD.$fRawIOFD5_closure;
         const GHC.IO.FD.$w$cfillReadBuffer0_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const GHC.IO.FD.$fBufferedIOFD7_closure;
         const GHC.IO.FD.$w$cflushWriteBuffer0_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$fBufferedIOFD1_closure;
         const GHC.Enum.$fEnumBool1_closure;
         const GHC.IO.FD.$w$cready_closure;
         const GHC.IO.FD.$fIODeviceFD28_closure;
         const GHC.IO.FD.$fIODeviceFD27_closure;
         const System.Posix.Internals.$wsetNonBlockingFD_closure;
         const GHC.IO.FD.setNonBlockingMode1_closure;
         const lvl6_raWVc_closure;
         const GHC.IO.FD.$w$cdup2_closure;
         const GHC.IO.FD.$fIODeviceFD2_closure;
         const GHC.IO.FD.$fIODeviceFD1_closure;
         const GHC.IO.FD.$w$cdup_closure;
         const GHC.IO.FD.$fIODeviceFD4_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.IO.FD.$fIODeviceFD3_closure;
         const System.Posix.Internals.fdStat1_closure;
         const GHC.IO.FD.$fIODeviceFD6_closure;
         const GHC.IO.FD.$fIODeviceFD20_closure;
         const GHC.IO.FD.$fIODeviceFD23_closure;
         const GHC.IO.FD.$wclose_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const GHC.IO.FD.$fIODeviceFD26_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.$fIODeviceFD22_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.FD.mkFD9_closure;
         const GHC.IO.FD.mkFD3_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.FD.mkFD2_closure;
         const GHC.IO.FD.mkFD8_closure;
         const GHC.IO.FD.mkFD1_closure;
         const GHC.IO.FD.mkFD6_closure;
         const append_flags_raWV6_closure;
         const rw_flags_raWV7_closure;
         const read_flags_raWV8_closure;
         const GHC.IO.FD.$fIODeviceFD11_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.FD.$w$cfillReadBuffer_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.FD.$fBufferedIOFD11_closure;
 }]

