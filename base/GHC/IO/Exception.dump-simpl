
==================== Tidy Core ====================
2018-03-16 16:03:24.422299627 UTC

Result size of Tidy Core
  = {terms: 3,580, types: 2,886, coercions: 523, joins: 3/7}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 130 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2
  = "thread blocked indefinitely in an MVar operation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1
  = unpackCString#
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec
  :: Int -> BlockedIndefinitelyOnMVar -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d8hsI [Occ=Once!] :: BlockedIndefinitelyOnMVar)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d8hsI of { BlockedIndefinitelyOnMVar ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d8hsI :: BlockedIndefinitelyOnMVar)
      (eta_B1 :: String) ->
      case ds1_d8hsI of { BlockedIndefinitelyOnMVar ->
      ++
        @ Char
        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1
        eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow
  :: BlockedIndefinitelyOnMVar -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: BlockedIndefinitelyOnMVar) ->
                 case x_i7Jay of { BlockedIndefinitelyOnMVar ->
                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1
                 }}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow
  = \ (x_i7Jay :: BlockedIndefinitelyOnMVar) ->
      case x_i7Jay of { BlockedIndefinitelyOnMVar ->
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1
  :: BlockedIndefinitelyOnMVar -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hsI [Occ=Once!] :: BlockedIndefinitelyOnMVar)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d8hsI of { BlockedIndefinitelyOnMVar ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1
  = \ (ds_d8hsI :: BlockedIndefinitelyOnMVar) (eta_B1 :: String) ->
      case ds_d8hsI of { BlockedIndefinitelyOnMVar ->
      ++
        @ Char
        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar1
        eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList
  :: [BlockedIndefinitelyOnMVar] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [BlockedIndefinitelyOnMVar])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ BlockedIndefinitelyOnMVar
                   GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList
  = \ (ls_i7JaB :: [BlockedIndefinitelyOnMVar])
      (s_i7JaC :: String) ->
      showList__
        @ BlockedIndefinitelyOnMVar
        GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar [InlPrag=NOUSERINLINE CONLIKE]
  :: Show BlockedIndefinitelyOnMVar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: BlockedIndefinitelyOnMVar
                       GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec
                       GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow
                       GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar
  = GHC.Show.C:Show
      @ BlockedIndefinitelyOnMVar
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowsPrec
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 140 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2
  = "thread blocked indefinitely in an STM transaction"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1
  = unpackCString#
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec
  :: Int -> BlockedIndefinitelyOnSTM -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d8hsD [Occ=Once!] :: BlockedIndefinitelyOnSTM)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d8hsD of { BlockedIndefinitelyOnSTM ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d8hsD :: BlockedIndefinitelyOnSTM)
      (eta_B1 :: String) ->
      case ds1_d8hsD of { BlockedIndefinitelyOnSTM ->
      ++
        @ Char GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow
  :: BlockedIndefinitelyOnSTM -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: BlockedIndefinitelyOnSTM) ->
                 case x_i7Jay of { BlockedIndefinitelyOnSTM ->
                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1
                 }}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow
  = \ (x_i7Jay :: BlockedIndefinitelyOnSTM) ->
      case x_i7Jay of { BlockedIndefinitelyOnSTM ->
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1
  :: BlockedIndefinitelyOnSTM -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hsD [Occ=Once!] :: BlockedIndefinitelyOnSTM)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d8hsD of { BlockedIndefinitelyOnSTM ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1
  = \ (ds_d8hsD :: BlockedIndefinitelyOnSTM) (eta_B1 :: String) ->
      case ds_d8hsD of { BlockedIndefinitelyOnSTM ->
      ++
        @ Char GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList
  :: [BlockedIndefinitelyOnSTM] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [BlockedIndefinitelyOnSTM])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ BlockedIndefinitelyOnSTM
                   GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList
  = \ (ls_i7JaB :: [BlockedIndefinitelyOnSTM]) (s_i7JaC :: String) ->
      showList__
        @ BlockedIndefinitelyOnSTM
        GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM [InlPrag=NOUSERINLINE CONLIKE]
  :: Show BlockedIndefinitelyOnSTM
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: BlockedIndefinitelyOnSTM
                       GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec
                       GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow
                       GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList]
GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM
  = GHC.Show.C:Show
      @ BlockedIndefinitelyOnSTM
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowsPrec
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$fExceptionDeadlock2 = "<<deadlock>>"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionDeadlock1
  = unpackCString# GHC.IO.Exception.$fExceptionDeadlock2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowDeadlock_$cshowsPrec
  :: Int -> Deadlock -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d8hsy [Occ=Once!] :: Deadlock)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d8hsy of { Deadlock ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionDeadlock1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowDeadlock_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d8hsy :: Deadlock) (eta_B1 :: String) ->
      case ds1_d8hsy of { Deadlock ->
      ++ @ Char GHC.IO.Exception.$fExceptionDeadlock1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock_$cshow :: Deadlock -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: Deadlock) ->
                 case x_i7Jay of { Deadlock ->
                 GHC.IO.Exception.$fExceptionDeadlock1
                 }}]
GHC.IO.Exception.$fExceptionDeadlock_$cshow
  = \ (x_i7Jay :: Deadlock) ->
      case x_i7Jay of { Deadlock ->
      GHC.IO.Exception.$fExceptionDeadlock1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowDeadlock1 :: Deadlock -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hsy [Occ=Once!] :: Deadlock)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d8hsy of { Deadlock ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionDeadlock1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowDeadlock1
  = \ (ds_d8hsy :: Deadlock) (eta_B1 :: String) ->
      case ds_d8hsy of { Deadlock ->
      ++ @ Char GHC.IO.Exception.$fExceptionDeadlock1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowDeadlock_$cshowList :: [Deadlock] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [Deadlock])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ Deadlock GHC.IO.Exception.$fShowDeadlock1 ls_i7JaB s_i7JaC}]
GHC.IO.Exception.$fShowDeadlock_$cshowList
  = \ (ls_i7JaB :: [Deadlock]) (s_i7JaC :: String) ->
      showList__
        @ Deadlock GHC.IO.Exception.$fShowDeadlock1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowDeadlock [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Deadlock
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Deadlock
                       GHC.IO.Exception.$fShowDeadlock_$cshowsPrec
                       GHC.IO.Exception.$fExceptionDeadlock_$cshow
                       GHC.IO.Exception.$fShowDeadlock_$cshowList]
GHC.IO.Exception.$fShowDeadlock
  = GHC.Show.C:Show
      @ Deadlock
      GHC.IO.Exception.$fShowDeadlock_$cshowsPrec
      GHC.IO.Exception.$fExceptionDeadlock_$cshow
      GHC.IO.Exception.$fShowDeadlock_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded2
  = "allocation limit exceeded"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded1
  = unpackCString#
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec
  :: Int -> AllocationLimitExceeded -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d8hsr [Occ=Once!] :: AllocationLimitExceeded)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d8hsr of { AllocationLimitExceeded ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionAllocationLimitExceeded1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d8hsr :: AllocationLimitExceeded)
      (eta_B1 :: String) ->
      case ds1_d8hsr of { AllocationLimitExceeded ->
      ++
        @ Char GHC.IO.Exception.$fExceptionAllocationLimitExceeded1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow
  :: AllocationLimitExceeded -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: AllocationLimitExceeded) ->
                 case x_i7Jay of { AllocationLimitExceeded ->
                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded1
                 }}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow
  = \ (x_i7Jay :: AllocationLimitExceeded) ->
      case x_i7Jay of { AllocationLimitExceeded ->
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAllocationLimitExceeded1
  :: AllocationLimitExceeded -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hsr [Occ=Once!] :: AllocationLimitExceeded)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d8hsr of { AllocationLimitExceeded ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionAllocationLimitExceeded1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowAllocationLimitExceeded1
  = \ (ds_d8hsr :: AllocationLimitExceeded) (eta_B1 :: String) ->
      case ds_d8hsr of { AllocationLimitExceeded ->
      ++
        @ Char GHC.IO.Exception.$fExceptionAllocationLimitExceeded1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList
  :: [AllocationLimitExceeded] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [AllocationLimitExceeded])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ AllocationLimitExceeded
                   GHC.IO.Exception.$fShowAllocationLimitExceeded1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList
  = \ (ls_i7JaB :: [AllocationLimitExceeded]) (s_i7JaC :: String) ->
      showList__
        @ AllocationLimitExceeded
        GHC.IO.Exception.$fShowAllocationLimitExceeded1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAllocationLimitExceeded [InlPrag=NOUSERINLINE CONLIKE]
  :: Show AllocationLimitExceeded
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: AllocationLimitExceeded
                       GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec
                       GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow
                       GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList]
GHC.IO.Exception.$fShowAllocationLimitExceeded
  = GHC.Show.C:Show
      @ AllocationLimitExceeded
      GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowsPrec
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow
      GHC.IO.Exception.$fShowAllocationLimitExceeded_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed1 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$fExceptionCompactionFailed1
  = "compaction failed: "#

-- RHS size: {terms: 5, types: 2, coercions: 1, joins: 0/0}
GHC.IO.Exception.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: CompactionFailed -> [Char] -> [Char]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 50 60}]
GHC.IO.Exception.$w$cshowsPrec2
  = \ (w_s8iu2 :: CompactionFailed) ->
      ++
        @ Char
        (unpackAppendCString#
           GHC.IO.Exception.$fExceptionCompactionFailed1
           (w_s8iu2
            `cast` (GHC.IO.Exception.N:CompactionFailed[0]
                    :: (CompactionFailed :: *) ~R# (String :: *))))

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> CompactionFailed -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (w1_s8iu2 [Occ=Once] :: CompactionFailed) ->
                 GHC.IO.Exception.$w$cshowsPrec2 w1_s8iu2}]
GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s8iu2 :: CompactionFailed) ->
      GHC.IO.Exception.$w$cshowsPrec2 w1_s8iu2

-- RHS size: {terms: 4, types: 1, coercions: 1, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed_$cshow
  :: CompactionFailed -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once] :: CompactionFailed) ->
                 unpackAppendCString#
                   GHC.IO.Exception.$fExceptionCompactionFailed1
                   (x_i7Jay
                    `cast` (GHC.IO.Exception.N:CompactionFailed[0]
                            :: (CompactionFailed :: *) ~R# (String :: *)))}]
GHC.IO.Exception.$fExceptionCompactionFailed_$cshow
  = \ (x_i7Jay :: CompactionFailed) ->
      unpackAppendCString#
        GHC.IO.Exception.$fExceptionCompactionFailed1
        (x_i7Jay
         `cast` (GHC.IO.Exception.N:CompactionFailed[0]
                 :: (CompactionFailed :: *) ~R# (String :: *)))

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowCompactionFailed_$cshowList
  :: [CompactionFailed] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [CompactionFailed])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ CompactionFailed
                   GHC.IO.Exception.$w$cshowsPrec2
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowCompactionFailed_$cshowList
  = \ (ls_i7JaB :: [CompactionFailed]) (s_i7JaC :: String) ->
      showList__
        @ CompactionFailed GHC.IO.Exception.$w$cshowsPrec2 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowCompactionFailed [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CompactionFailed
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CompactionFailed
                       GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec
                       GHC.IO.Exception.$fExceptionCompactionFailed_$cshow
                       GHC.IO.Exception.$fShowCompactionFailed_$cshowList]
GHC.IO.Exception.$fShowCompactionFailed
  = GHC.Show.C:Show
      @ CompactionFailed
      GHC.IO.Exception.$fShowCompactionFailed_$cshowsPrec
      GHC.IO.Exception.$fExceptionCompactionFailed_$cshow
      GHC.IO.Exception.$fShowCompactionFailed_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec
  :: Int -> AssertionFailed -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d8hsf [Occ=Once] :: AssertionFailed) ->
                 ++
                   @ Char
                   (ds1_d8hsf
                    `cast` (GHC.IO.Exception.N:AssertionFailed[0]
                            :: (AssertionFailed :: *) ~R# (String :: *)))}]
GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d8hsf :: AssertionFailed) ->
      ++
        @ Char
        (ds1_d8hsf
         `cast` (GHC.IO.Exception.N:AssertionFailed[0]
                 :: (AssertionFailed :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed1
  :: AssertionFailed -> AssertionFailed
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_i7Jay [Occ=Once] :: AssertionFailed) -> x_i7Jay}]
GHC.IO.Exception.$fExceptionAssertionFailed1
  = \ (x_i7Jay :: AssertionFailed) -> x_i7Jay

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
GHC.IO.Exception.$fShowAssertionFailed_$cshowList
  :: [AssertionFailed] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [AssertionFailed])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ AssertionFailed
                   ((++ @ Char)
                    `cast` (Sym (GHC.IO.Exception.N:AssertionFailed[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (AssertionFailed -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowAssertionFailed_$cshowList
  = \ (ls_i7JaB :: [AssertionFailed]) (s_i7JaC :: String) ->
      showList__
        @ AssertionFailed
        ((++ @ Char)
         `cast` (Sym (GHC.IO.Exception.N:AssertionFailed[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (AssertionFailed -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
GHC.IO.Exception.$fShowAssertionFailed [InlPrag=NOUSERINLINE CONLIKE]
  :: Show AssertionFailed
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: AssertionFailed
                       GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec
                       GHC.IO.Exception.$fExceptionAssertionFailed1
                       `cast` (<AssertionFailed>_R
                               ->_R GHC.IO.Exception.N:AssertionFailed[0]
                               :: (AssertionFailed -> AssertionFailed :: *)
                                  ~R# (AssertionFailed -> String :: *))
                       GHC.IO.Exception.$fShowAssertionFailed_$cshowList]
GHC.IO.Exception.$fShowAssertionFailed
  = GHC.Show.C:Show
      @ AssertionFailed
      GHC.IO.Exception.$fShowAssertionFailed_$cshowsPrec
      (GHC.IO.Exception.$fExceptionAssertionFailed1
       `cast` (<AssertionFailed>_R
               ->_R GHC.IO.Exception.N:AssertionFailed[0]
               :: (AssertionFailed -> AssertionFailed :: *)
                  ~R# (AssertionFailed -> String :: *)))
      GHC.IO.Exception.$fShowAssertionFailed_$cshowList

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow
  :: SomeAsyncException -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hs4 [Occ=Once!] :: SomeAsyncException) ->
                 case ds_d8hs4 of
                 { SomeAsyncException @ e_a8h3y $dException_a8h3z [Occ=Once]
                                      e1_a8gza [Occ=Once] ->
                 show
                   @ e_a8h3y
                   (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
                   e1_a8gza
                 }}]
GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow
  = \ (ds_d8hs4 :: SomeAsyncException) ->
      case ds_d8hs4 of
      { SomeAsyncException @ e_a8h3y $dException_a8h3z e1_a8gza ->
      show
        @ e_a8h3y
        (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
        e1_a8gza
      }

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec
  :: Int -> SomeAsyncException -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (x_i7QGZ [Occ=Once!] :: SomeAsyncException)
                 (s_i7QH0 [Occ=Once] :: String) ->
                 case x_i7QGZ of
                 { SomeAsyncException @ e_a8h3y $dException_a8h3z [Occ=Once]
                                      e1_a8gza [Occ=Once] ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        (show
                           @ e_a8h3y
                           (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
                           e1_a8gza))
                   s_i7QH0
                 }}]
GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec
  = \ _ [Occ=Dead]
      (x_i7QGZ :: SomeAsyncException)
      (s_i7QH0 :: String) ->
      case x_i7QGZ of
      { SomeAsyncException @ e_a8h3y $dException_a8h3z e1_a8gza ->
      ++
        @ Char
        (show
           @ e_a8h3y
           (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
           e1_a8gza)
        s_i7QH0
      }

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowSomeAsyncException1
  :: SomeAsyncException -> String -> [Char]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7QGZ [Occ=Once!] :: SomeAsyncException)
                 (s_i7QH0 [Occ=Once, OS=OneShot] :: String) ->
                 case x_i7QGZ of
                 { SomeAsyncException @ e_a8h3y $dException_a8h3z [Occ=Once]
                                      e1_a8gza [Occ=Once] ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        (show
                           @ e_a8h3y
                           (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
                           e1_a8gza))
                   s_i7QH0
                 }}]
GHC.IO.Exception.$fShowSomeAsyncException1
  = \ (x_i7QGZ :: SomeAsyncException)
      (s_i7QH0 [OS=OneShot] :: String) ->
      case x_i7QGZ of
      { SomeAsyncException @ e_a8h3y $dException_a8h3z e1_a8gza ->
      ++
        @ Char
        (show
           @ e_a8h3y
           (GHC.Exception.$p2Exception @ e_a8h3y $dException_a8h3z)
           e1_a8gza)
        s_i7QH0
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowSomeAsyncException_$cshowList
  :: [SomeAsyncException] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [SomeAsyncException])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ SomeAsyncException
                   GHC.IO.Exception.$fShowSomeAsyncException1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowSomeAsyncException_$cshowList
  = \ (ls_i7JaB :: [SomeAsyncException]) (s_i7JaC :: String) ->
      showList__
        @ SomeAsyncException
        GHC.IO.Exception.$fShowSomeAsyncException1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowSomeAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Show SomeAsyncException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: SomeAsyncException
                       GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec
                       GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow
                       GHC.IO.Exception.$fShowSomeAsyncException_$cshowList]
GHC.IO.Exception.$fShowSomeAsyncException
  = GHC.Show.C:Show
      @ SomeAsyncException
      GHC.IO.Exception.$fShowSomeAsyncException_$cshowsPrec
      GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow
      GHC.IO.Exception.$fShowSomeAsyncException_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAsyncException8 = "stack overflow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionAsyncException7
  = unpackCString# GHC.IO.Exception.$fExceptionAsyncException8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAsyncException6 = "heap overflow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionAsyncException5
  = unpackCString# GHC.IO.Exception.$fExceptionAsyncException6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAsyncException4 = "thread killed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionAsyncException3
  = unpackCString# GHC.IO.Exception.$fExceptionAsyncException4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAsyncException2 = "user interrupt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionAsyncException1
  = unpackCString# GHC.IO.Exception.$fExceptionAsyncException2

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: AsyncException -> String -> String
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [140 0] 160 0}]
GHC.IO.Exception.$w$cshowsPrec1
  = \ (w_s8iu6 :: AsyncException) (w1_s8iu7 :: String) ->
      case w_s8iu6 of {
        StackOverflow ->
          ++ @ Char GHC.IO.Exception.$fExceptionAsyncException7 w1_s8iu7;
        HeapOverflow ->
          ++ @ Char GHC.IO.Exception.$fExceptionAsyncException5 w1_s8iu7;
        ThreadKilled ->
          ++ @ Char GHC.IO.Exception.$fExceptionAsyncException3 w1_s8iu7;
        UserInterrupt ->
          ++ @ Char GHC.IO.Exception.$fExceptionAsyncException1 w1_s8iu7
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAsyncException_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> AsyncException -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s8iu6 [Occ=Once] :: AsyncException)
                 (w2_s8iu7 [Occ=Once] :: String) ->
                 GHC.IO.Exception.$w$cshowsPrec1 w1_s8iu6 w2_s8iu7}]
GHC.IO.Exception.$fShowAsyncException_$cshowsPrec
  = \ _ [Occ=Dead]
      (w1_s8iu6 :: AsyncException)
      (w2_s8iu7 :: String) ->
      GHC.IO.Exception.$w$cshowsPrec1 w1_s8iu6 w2_s8iu7

-- RHS size: {terms: 11, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException_$cshow
  :: AsyncException -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Jja [Occ=Once!] :: AsyncException) ->
                 case x_X7Jja of {
                   StackOverflow -> GHC.IO.Exception.$fExceptionAsyncException7;
                   HeapOverflow -> GHC.IO.Exception.$fExceptionAsyncException5;
                   ThreadKilled -> GHC.IO.Exception.$fExceptionAsyncException3;
                   UserInterrupt -> GHC.IO.Exception.$fExceptionAsyncException1
                 }}]
GHC.IO.Exception.$fExceptionAsyncException_$cshow
  = \ (x_X7Jja :: AsyncException) ->
      case x_X7Jja of {
        StackOverflow -> GHC.IO.Exception.$fExceptionAsyncException7;
        HeapOverflow -> GHC.IO.Exception.$fExceptionAsyncException5;
        ThreadKilled -> GHC.IO.Exception.$fExceptionAsyncException3;
        UserInterrupt -> GHC.IO.Exception.$fExceptionAsyncException1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAsyncException_$cshowList
  :: [AsyncException] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [AsyncException])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ AsyncException GHC.IO.Exception.$w$cshowsPrec1 ls_i7JaB s_i7JaC}]
GHC.IO.Exception.$fShowAsyncException_$cshowList
  = \ (ls_i7JaB :: [AsyncException]) (s_i7JaC :: String) ->
      showList__
        @ AsyncException GHC.IO.Exception.$w$cshowsPrec1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Show AsyncException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: AsyncException
                       GHC.IO.Exception.$fShowAsyncException_$cshowsPrec
                       GHC.IO.Exception.$fExceptionAsyncException_$cshow
                       GHC.IO.Exception.$fShowAsyncException_$cshowList]
GHC.IO.Exception.$fShowAsyncException
  = GHC.Show.C:Show
      @ AsyncException
      GHC.IO.Exception.$fShowAsyncException_$cshowsPrec
      GHC.IO.Exception.$fExceptionAsyncException_$cshow
      GHC.IO.Exception.$fShowAsyncException_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$fExceptionArrayException4
  = "array index out of range"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionArrayException3 = ": "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$fExceptionArrayException2
  = "undefined array element"#

-- RHS size: {terms: 30, types: 17, coercions: 0, joins: 0/0}
GHC.IO.Exception.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: ArrayException -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [140 0] 240 0}]
GHC.IO.Exception.$w$cshowsPrec
  = \ (w_s8iua :: ArrayException) (w1_s8iub :: String) ->
      case w_s8iua of {
        IndexOutOfBounds s_a8gz8 ->
          unpackAppendCString#
            GHC.IO.Exception.$fExceptionArrayException4
            (case s_a8gz8 of wild1_i8hrH {
               [] -> w1_s8iub;
               : ds1_i8hNn ds2_i8hNo ->
                 unpackAppendCString#
                   GHC.IO.Exception.$fExceptionArrayException3
                   (++ @ Char wild1_i8hrH w1_s8iub)
             });
        UndefinedElement s_a8gz9 ->
          unpackAppendCString#
            GHC.IO.Exception.$fExceptionArrayException2
            (case s_a8gz9 of wild1_i8hrH {
               [] -> w1_s8iub;
               : ds1_i8hNn ds2_i8hNo ->
                 unpackAppendCString#
                   GHC.IO.Exception.$fExceptionArrayException3
                   (++ @ Char wild1_i8hrH w1_s8iub)
             })
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> ArrayException -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s8iua [Occ=Once] :: ArrayException)
                 (w2_s8iub [Occ=Once] :: String) ->
                 GHC.IO.Exception.$w$cshowsPrec w1_s8iua w2_s8iub}]
GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec
  = \ _ [Occ=Dead]
      (w1_s8iua :: ArrayException)
      (w2_s8iub :: String) ->
      GHC.IO.Exception.$w$cshowsPrec w1_s8iua w2_s8iub

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionArrayException1 = GHC.Types.I# 0#

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException_$cshow
  :: ArrayException -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Jjl [Occ=Once] :: ArrayException) ->
                 GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec
                   GHC.IO.Exception.$fExceptionArrayException1
                   x_X7Jjl
                   (GHC.Types.[] @ Char)}]
GHC.IO.Exception.$fExceptionArrayException_$cshow
  = \ (x_X7Jjl :: ArrayException) ->
      GHC.IO.Exception.$w$cshowsPrec x_X7Jjl (GHC.Types.[] @ Char)

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowArrayException_$cshowList
  :: [ArrayException] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [ArrayException])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ ArrayException GHC.IO.Exception.$w$cshowsPrec ls_i7JaB s_i7JaC}]
GHC.IO.Exception.$fShowArrayException_$cshowList
  = \ (ls_i7JaB :: [ArrayException]) (s_i7JaC :: String) ->
      showList__
        @ ArrayException GHC.IO.Exception.$w$cshowsPrec ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowArrayException [InlPrag=NOUSERINLINE CONLIKE]
  :: Show ArrayException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: ArrayException
                       GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec
                       GHC.IO.Exception.$fExceptionArrayException_$cshow
                       GHC.IO.Exception.$fShowArrayException_$cshowList]
GHC.IO.Exception.$fShowArrayException
  = GHC.Show.C:Show
      @ ArrayException
      GHC.IO.Exception.$fExceptionArrayException_$cshowsPrec
      GHC.IO.Exception.$fExceptionArrayException_$cshow
      GHC.IO.Exception.$fShowArrayException_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.$fExceptionFixIOException2
  = "cyclic evaluation in fixIO"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionFixIOException1
  = unpackCString# GHC.IO.Exception.$fExceptionFixIOException2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowFixIOException_$cshowsPrec
  :: Int -> FixIOException -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d8hrz [Occ=Once!] :: FixIOException)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d8hrz of { FixIOException ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionFixIOException1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowFixIOException_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d8hrz :: FixIOException)
      (eta_B1 :: String) ->
      case ds1_d8hrz of { FixIOException ->
      ++ @ Char GHC.IO.Exception.$fExceptionFixIOException1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException_$cshow
  :: FixIOException -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Jjv [Occ=Once!] :: FixIOException) ->
                 case x_X7Jjv of { FixIOException ->
                 GHC.IO.Exception.$fExceptionFixIOException1
                 }}]
GHC.IO.Exception.$fExceptionFixIOException_$cshow
  = \ (x_X7Jjv :: FixIOException) ->
      case x_X7Jjv of { FixIOException ->
      GHC.IO.Exception.$fExceptionFixIOException1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowFixIOException1 :: FixIOException -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hrz [Occ=Once!] :: FixIOException)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d8hrz of { FixIOException ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        GHC.IO.Exception.$fExceptionFixIOException1)
                   eta_B1
                 }}]
GHC.IO.Exception.$fShowFixIOException1
  = \ (ds_d8hrz :: FixIOException) (eta_B1 :: String) ->
      case ds_d8hrz of { FixIOException ->
      ++ @ Char GHC.IO.Exception.$fExceptionFixIOException1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowFixIOException_$cshowList
  :: [FixIOException] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [FixIOException])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ FixIOException
                   GHC.IO.Exception.$fShowFixIOException1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowFixIOException_$cshowList
  = \ (ls_i7JaB :: [FixIOException]) (s_i7JaC :: String) ->
      showList__
        @ FixIOException
        GHC.IO.Exception.$fShowFixIOException1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowFixIOException [InlPrag=NOUSERINLINE CONLIKE]
  :: Show FixIOException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: FixIOException
                       GHC.IO.Exception.$fShowFixIOException_$cshowsPrec
                       GHC.IO.Exception.$fExceptionFixIOException_$cshow
                       GHC.IO.Exception.$fShowFixIOException_$cshowList]
GHC.IO.Exception.$fShowFixIOException
  = GHC.Show.C:Show
      @ FixIOException
      GHC.IO.Exception.$fShowFixIOException_$cshowsPrec
      GHC.IO.Exception.$fExceptionFixIOException_$cshow
      GHC.IO.Exception.$fShowFixIOException_$cshowList

-- RHS size: {terms: 14, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqIOErrorType_$c==
  :: IOErrorType -> IOErrorType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a8gyU [Occ=Once] :: IOErrorType)
                 (y_a8gyV [Occ=Once] :: IOErrorType) ->
                 case y_a8gyV of x1_i8hrw { __DEFAULT ->
                 case dataToTag# @ IOErrorType x1_i8hrw of wild_X51 { __DEFAULT ->
                 case x_a8gyU of x2_X8hDc { __DEFAULT ->
                 case dataToTag# @ IOErrorType x2_X8hDc of wild1_XI { __DEFAULT ->
                 tagToEnum# @ Bool (==# wild1_XI wild_X51)
                 }
                 }
                 }
                 }}]
GHC.IO.Exception.$fEqIOErrorType_$c==
  = \ (x_a8gyU :: IOErrorType) (y_a8gyV :: IOErrorType) ->
      case dataToTag# @ IOErrorType y_a8gyV of wild_X51 { __DEFAULT ->
      case dataToTag# @ IOErrorType x_a8gyU of wild1_XI { __DEFAULT ->
      tagToEnum# @ Bool (==# wild1_XI wild_X51)
      }
      }

-- RHS size: {terms: 18, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqIOErrorType_$c/= [InlPrag=INLINE (sat-args=2)]
  :: IOErrorType -> IOErrorType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once] :: IOErrorType)
                 (y_a22c [Occ=Once] :: IOErrorType) ->
                 case y_a22c of x1_i8hrw { __DEFAULT ->
                 case dataToTag# @ IOErrorType x1_i8hrw of wild_X51 { __DEFAULT ->
                 case x_a22b of x2_X8hDc { __DEFAULT ->
                 case dataToTag# @ IOErrorType x2_X8hDc of wild1_XI { __DEFAULT ->
                 case ==# wild1_XI wild_X51 of {
                   __DEFAULT -> GHC.Types.True;
                   1# -> GHC.Types.False
                 }
                 }
                 }
                 }
                 }}]
GHC.IO.Exception.$fEqIOErrorType_$c/=
  = \ (eta_B2 :: IOErrorType) (eta1_B1 :: IOErrorType) ->
      case dataToTag# @ IOErrorType eta1_B1 of wild_X51 { __DEFAULT ->
      case dataToTag# @ IOErrorType eta_B2 of wild1_XI { __DEFAULT ->
      case ==# wild1_XI wild_X51 of {
        __DEFAULT -> GHC.Types.True;
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqIOErrorType [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq IOErrorType
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: IOErrorType
                        GHC.IO.Exception.$fEqIOErrorType_$c==
                        GHC.IO.Exception.$fEqIOErrorType_$c/=]
GHC.IO.Exception.$fEqIOErrorType
  = GHC.Classes.C:Eq
      @ IOErrorType
      GHC.IO.Exception.$fEqIOErrorType_$c==
      GHC.IO.Exception.$fEqIOErrorType_$c/=

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r8j2D :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r8j2D = "already exists"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_r8j2E :: [Char]
[GblId]
lvl1_r8j2E = unpackCString# lvl_r8j2D

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_r8j2F :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_r8j2F = "does not exist"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl3_r8j2G :: [Char]
[GblId]
lvl3_r8j2G = unpackCString# lvl2_r8j2F

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_r8j2H :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_r8j2H = "resource busy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl5_r8j2I :: [Char]
[GblId]
lvl5_r8j2I = unpackCString# lvl4_r8j2H

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_r8j2J :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_r8j2J = "resource exhausted"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_r8j2K :: [Char]
[GblId]
lvl7_r8j2K = unpackCString# lvl6_r8j2J

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl8_r8j2L :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl8_r8j2L = "end of file"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_r8j2M :: [Char]
[GblId]
lvl9_r8j2M = unpackCString# lvl8_r8j2L

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl10_r8j2N :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl10_r8j2N = "illegal operation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl11_r8j2O :: [Char]
[GblId]
lvl11_r8j2O = unpackCString# lvl10_r8j2N

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl12_r8j2P :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl12_r8j2P = "permission denied"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl13_r8j2Q :: [Char]
[GblId]
lvl13_r8j2Q = unpackCString# lvl12_r8j2P

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl14_r8j2R :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl14_r8j2R = "user error"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl15_r8j2S :: [Char]
[GblId]
lvl15_r8j2S = unpackCString# lvl14_r8j2R

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl16_r8j2T :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl16_r8j2T = "unsatisfied constraints"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl17_r8j2U :: [Char]
[GblId]
lvl17_r8j2U = unpackCString# lvl16_r8j2T

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl18_r8j2V :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl18_r8j2V = "system error"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl19_r8j2W :: [Char]
[GblId]
lvl19_r8j2W = unpackCString# lvl18_r8j2V

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl20_r8j2X :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl20_r8j2X = "protocol error"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl21_r8j2Y :: [Char]
[GblId]
lvl21_r8j2Y = unpackCString# lvl20_r8j2X

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl22_r8j2Z :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl22_r8j2Z = "failed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl23_r8j30 :: [Char]
[GblId]
lvl23_r8j30 = unpackCString# lvl22_r8j2Z

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl24_r8j31 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl24_r8j31 = "invalid argument"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl25_r8j32 :: [Char]
[GblId]
lvl25_r8j32 = unpackCString# lvl24_r8j31

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl26_r8j33 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl26_r8j33 = "inappropriate type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl27_r8j34 :: [Char]
[GblId]
lvl27_r8j34 = unpackCString# lvl26_r8j33

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl28_r8j35 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl28_r8j35 = "hardware fault"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl29_r8j36 :: [Char]
[GblId]
lvl29_r8j36 = unpackCString# lvl28_r8j35

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl30_r8j37 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl30_r8j37 = "unsupported operation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl31_r8j38 :: [Char]
[GblId]
lvl31_r8j38 = unpackCString# lvl30_r8j37

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl32_r8j39 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl32_r8j39 = "timeout"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl33_r8j3a :: [Char]
[GblId]
lvl33_r8j3a = unpackCString# lvl32_r8j39

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl34_r8j3b :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl34_r8j3b = "resource vanished"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl35_r8j3c :: [Char]
[GblId]
lvl35_r8j3c = unpackCString# lvl34_r8j3b

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl36_r8j3d :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl36_r8j3d = "interrupted"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl37_r8j3e :: [Char]
[GblId]
lvl37_r8j3e = unpackCString# lvl36_r8j3d

-- RHS size: {terms: 80, types: 22, coercions: 0, joins: 0/0}
GHC.IO.Exception.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: IOErrorType -> String -> [Char]
[GblId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []]
GHC.IO.Exception.$w$cshowsPrec4
  = \ (w_s8iue :: IOErrorType) (w1_s8iuf :: String) ->
      case w_s8iue of {
        AlreadyExists -> ++ @ Char lvl1_r8j2E w1_s8iuf;
        NoSuchThing -> ++ @ Char lvl3_r8j2G w1_s8iuf;
        ResourceBusy -> ++ @ Char lvl5_r8j2I w1_s8iuf;
        ResourceExhausted -> ++ @ Char lvl7_r8j2K w1_s8iuf;
        EOF -> ++ @ Char lvl9_r8j2M w1_s8iuf;
        IllegalOperation -> ++ @ Char lvl11_r8j2O w1_s8iuf;
        PermissionDenied -> ++ @ Char lvl13_r8j2Q w1_s8iuf;
        UserError -> ++ @ Char lvl15_r8j2S w1_s8iuf;
        UnsatisfiedConstraints -> ++ @ Char lvl17_r8j2U w1_s8iuf;
        SystemError -> ++ @ Char lvl19_r8j2W w1_s8iuf;
        ProtocolError -> ++ @ Char lvl21_r8j2Y w1_s8iuf;
        OtherError -> ++ @ Char lvl23_r8j30 w1_s8iuf;
        InvalidArgument -> ++ @ Char lvl25_r8j32 w1_s8iuf;
        InappropriateType -> ++ @ Char lvl27_r8j34 w1_s8iuf;
        HardwareFault -> ++ @ Char lvl29_r8j36 w1_s8iuf;
        UnsupportedOperation -> ++ @ Char lvl31_r8j38 w1_s8iuf;
        TimeExpired -> ++ @ Char lvl33_r8j3a w1_s8iuf;
        ResourceVanished -> ++ @ Char lvl35_r8j3c w1_s8iuf;
        Interrupted -> ++ @ Char lvl37_r8j3e w1_s8iuf
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> IOErrorType -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s8iue [Occ=Once] :: IOErrorType)
                 (w2_s8iuf [Occ=Once] :: String) ->
                 GHC.IO.Exception.$w$cshowsPrec4 w1_s8iue w2_s8iuf}]
GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s8iue :: IOErrorType) (w2_s8iuf :: String) ->
      GHC.IO.Exception.$w$cshowsPrec4 w1_s8iue w2_s8iuf

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOErrorType_$cshow :: IOErrorType -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Jki [Occ=Once] :: IOErrorType) ->
                 GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec
                   GHC.IO.Exception.$fExceptionArrayException1
                   x_X7Jki
                   (GHC.Types.[] @ Char)}]
GHC.IO.Exception.$fShowIOErrorType_$cshow
  = \ (x_X7Jki :: IOErrorType) ->
      GHC.IO.Exception.$w$cshowsPrec4 x_X7Jki (GHC.Types.[] @ Char)

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOErrorType_$cshowList
  :: [IOErrorType] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [IOErrorType])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ IOErrorType GHC.IO.Exception.$w$cshowsPrec4 ls_i7JaB s_i7JaC}]
GHC.IO.Exception.$fShowIOErrorType_$cshowList
  = \ (ls_i7JaB :: [IOErrorType]) (s_i7JaC :: String) ->
      showList__
        @ IOErrorType GHC.IO.Exception.$w$cshowsPrec4 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOErrorType [InlPrag=NOUSERINLINE CONLIKE]
  :: Show IOErrorType
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: IOErrorType
                       GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec
                       GHC.IO.Exception.$fShowIOErrorType_$cshow
                       GHC.IO.Exception.$fShowIOErrorType_$cshowList]
GHC.IO.Exception.$fShowIOErrorType
  = GHC.Show.C:Show
      @ IOErrorType
      GHC.IO.Exception.$fShowIOErrorType_$cshowsPrec
      GHC.IO.Exception.$fShowIOErrorType_$cshow
      GHC.IO.Exception.$fShowIOErrorType_$cshowList

-- RHS size: {terms: 131, types: 111, coercions: 2, joins: 2/2}
GHC.IO.Exception.$fEqIOException_$c==
  :: IOException -> IOException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),1*U(1*U,U,1*U,1*U,1*U,1*U)><S(LSLLLL),1*U(1*U,U,1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 20] 506 80}]
GHC.IO.Exception.$fEqIOException_$c==
  = \ (ds_d8hqy :: IOException) (ds1_d8hqz :: IOException) ->
      case ds_d8hqy of
      { IOError h1_a8gyW e1_a8gyX loc1_a8gyY str1_a8gyZ en1_a8gz0
                fn1_a8gz1 ->
      case ds1_d8hqz of
      { IOError h2_a8gz2 e2_a8gz3 loc2_a8gz4 str2_a8gz5 en2_a8gz6
                fn2_a8gz7 ->
      case dataToTag# @ IOErrorType e2_a8gz3 of wild2_X51 { __DEFAULT ->
      case dataToTag# @ IOErrorType e1_a8gyX of wild3_XI { __DEFAULT ->
      case ==# wild3_XI wild2_X51 of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case eqString str1_a8gyZ str2_a8gz5 of {
            False -> GHC.Types.False;
            True ->
              join {
                $j_s8hO7 [Dmd=<L,1*U>] :: Bool
                [LclId[JoinId(0)]]
                $j_s8hO7
                  = case eqString loc1_a8gyY loc2_a8gz4 of {
                      False -> GHC.Types.False;
                      True ->
                        join {
                          $j1_s8hO2 [Dmd=<L,1*U>] :: Bool
                          [LclId[JoinId(0)]]
                          $j1_s8hO2
                            = case fn1_a8gz1 of {
                                Nothing ->
                                  case fn2_a8gz7 of {
                                    Nothing -> GHC.Types.True;
                                    Just ipv_i890B -> GHC.Types.False
                                  };
                                Just a1_i890t ->
                                  case fn2_a8gz7 of {
                                    Nothing -> GHC.Types.False;
                                    Just b1_i890y -> eqString a1_i890t b1_i890y
                                  }
                              } } in
                        case en1_a8gz0 of {
                          Nothing ->
                            case en2_a8gz6 of {
                              Nothing -> jump $j1_s8hO2;
                              Just ipv_i890B -> GHC.Types.False
                            };
                          Just a1_i890t ->
                            case en2_a8gz6 of {
                              Nothing -> GHC.Types.False;
                              Just b1_i890y ->
                                case a1_i890t
                                     `cast` (Foreign.C.Types.N:CInt[0]
                                             :: (CInt :: *) ~R# (GHC.Int.Int32 :: *))
                                of
                                { GHC.Int.I32# x_i8hv8 ->
                                case b1_i890y
                                     `cast` (Foreign.C.Types.N:CInt[0]
                                             :: (CInt :: *) ~R# (GHC.Int.Int32 :: *))
                                of
                                { GHC.Int.I32# y_i8hvc ->
                                case ==# x_i8hv8 y_i8hvc of {
                                  __DEFAULT -> GHC.Types.False;
                                  1# -> jump $j1_s8hO2
                                }
                                }
                                }
                            }
                        }
                    } } in
              case h1_a8gyW of {
                Nothing ->
                  case h2_a8gz2 of {
                    Nothing -> jump $j_s8hO7;
                    Just ipv_i890B -> GHC.Types.False
                  };
                Just a1_i890t ->
                  case h2_a8gz2 of {
                    Nothing -> GHC.Types.False;
                    Just b1_i890y ->
                      case a1_i890t of {
                        FileHandle ds2_i8huy dt_i8huz ->
                          case b1_i890y of {
                            FileHandle ds3_i8huI dt1_i8huJ ->
                              case sameMVar# @ RealWorld @ Handle__ dt_i8huz dt1_i8huJ of {
                                __DEFAULT -> GHC.Types.False;
                                1# -> jump $j_s8hO7
                              };
                            DuplexHandle ipv_i8hOb ipv1_i8hOc ipv2_i8hOd -> GHC.Types.False
                          };
                        DuplexHandle ds2_i8huN dt_i8huO dt1_i8huP ->
                          case b1_i890y of {
                            FileHandle ipv_i8hOf ipv1_i8hOg -> GHC.Types.False;
                            DuplexHandle ds3_i8huU dt2_i8huV dt3_i8huW ->
                              case sameMVar# @ RealWorld @ Handle__ dt_i8huO dt2_i8huV of {
                                __DEFAULT -> GHC.Types.False;
                                1# -> jump $j_s8hO7
                              }
                          }
                      }
                  }
              }
          }
      }
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqIOException_$c/= [InlPrag=INLINE (sat-args=2)]
  :: IOException -> IOException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),1*U(1*U,U,1*U,1*U,1*U,1*U)><S(LSLLLL),1*U(1*U,U,1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once] :: IOException)
                 (y_a22c [Occ=Once] :: IOException) ->
                 case GHC.IO.Exception.$fEqIOException_$c== x_a22b y_a22c of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
GHC.IO.Exception.$fEqIOException_$c/=
  = \ (eta_B2 :: IOException) (eta1_B1 :: IOException) ->
      case GHC.IO.Exception.$fEqIOException_$c== eta_B2 eta1_B1 of {
        False -> GHC.Types.True;
        True -> GHC.Types.False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqIOException [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq IOException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: IOException
                        GHC.IO.Exception.$fEqIOException_$c==
                        GHC.IO.Exception.$fEqIOException_$c/=]
GHC.IO.Exception.$fEqIOException
  = GHC.Classes.C:Eq
      @ IOException
      GHC.IO.Exception.$fEqIOException_$c==
      GHC.IO.Exception.$fEqIOException_$c/=

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionIOException1
  = unpackCString# GHC.IO.Exception.$fExceptionArrayException3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionIOException3 = " ("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionIOException2 = ")"#

-- RHS size: {terms: 68, types: 45, coercions: 0, joins: 0/2}
GHC.IO.Exception.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: Maybe Handle
     -> IOErrorType
     -> String
     -> String
     -> Maybe FilePath
     -> String
     -> String
[GblId,
 Arity=6,
 Str=<L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 30 30 90 0] 600 0}]
GHC.IO.Exception.$w$cshowsPrec3
  = \ (ww_s8iuG :: Maybe Handle)
      (ww1_s8iuH :: IOErrorType)
      (ww2_s8iuI :: String)
      (ww3_s8iuJ :: String)
      (ww4_s8iuL :: Maybe FilePath)
      (w_s8iuD :: String) ->
      let {
        eta_X9W :: String
        [LclId]
        eta_X9W
          = let {
              karg_s8hOz :: String
              [LclId]
              karg_s8hOz
                = GHC.IO.Exception.$w$cshowsPrec4
                    ww1_s8iuH
                    (case ww3_s8iuJ of wild_XY {
                       [] -> w_s8iuD;
                       : ipv_s8hvR ipv1_s8hvS ->
                         unpackAppendCString#
                           GHC.IO.Exception.$fExceptionIOException3
                           (++
                              @ Char
                              wild_XY
                              (unpackAppendCString#
                                 GHC.IO.Exception.$fExceptionIOException2 w_s8iuD))
                     }) } in
            case ww2_s8iuI of wild_XY {
              [] -> karg_s8hOz;
              : ipv_s8hvM ipv1_s8hvN ->
                ++
                  @ Char
                  wild_XY
                  (unpackAppendCString#
                     GHC.IO.Exception.$fExceptionArrayException3 karg_s8hOz)
            } } in
      case ww4_s8iuL of {
        Nothing ->
          case ww_s8iuG of {
            Nothing -> eta_X9W;
            Just h_a8gyR ->
              case h_a8gyR of {
                FileHandle file_i8hvw dt_i8hvx ->
                  unpackAppendCString#
                    GHC.IO.Handle.Types.showHandle1
                    (++
                       @ Char
                       file_i8hvw
                       (unpackAppendCString#
                          GHC.IO.Handle.Types.$fReadNewlineMode5
                          (++ @ Char GHC.IO.Exception.$fExceptionIOException1 eta_X9W)));
                DuplexHandle file_i8hvA dt_i8hvB dt1_i8hvC ->
                  unpackAppendCString#
                    GHC.IO.Handle.Types.showHandle1
                    (++
                       @ Char
                       file_i8hvA
                       (unpackAppendCString#
                          GHC.IO.Handle.Types.$fReadNewlineMode5
                          (++ @ Char GHC.IO.Exception.$fExceptionIOException1 eta_X9W)))
              }
          };
        Just name_a8gyS ->
          ++
            @ Char
            name_a8gyS
            (unpackAppendCString#
               GHC.IO.Exception.$fExceptionArrayException3 eta_X9W)
      }

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> IOException -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S(LLLLLS),1*U(1*U,1*U,1*U,1*U,A,1*U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s8iuC [Occ=Once!] :: IOException)
                 (w2_s8iuD [Occ=Once] :: String) ->
                 case w1_s8iuC of
                 { IOError ww1_s8iuG [Occ=Once] ww2_s8iuH [Occ=Once]
                           ww3_s8iuI [Occ=Once] ww4_s8iuJ [Occ=Once] _ [Occ=Dead]
                           ww6_s8iuL [Occ=Once] ->
                 GHC.IO.Exception.$w$cshowsPrec3
                   ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww6_s8iuL w2_s8iuD
                 }}]
GHC.IO.Exception.$fExceptionIOException_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s8iuC :: IOException) (w2_s8iuD :: String) ->
      case w1_s8iuC of
      { IOError ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww5_s8iuK
                ww6_s8iuL ->
      GHC.IO.Exception.$w$cshowsPrec3
        ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww6_s8iuL w2_s8iuD
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException_$cshow
  :: IOException -> String
[GblId,
 Arity=1,
 Str=<S(LLLLLS),1*U(1*U,1*U,1*U,1*U,A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7JkA [Occ=Once] :: IOException) ->
                 GHC.IO.Exception.$fExceptionIOException_$cshowsPrec
                   GHC.IO.Exception.$fExceptionArrayException1
                   x_X7JkA
                   (GHC.Types.[] @ Char)}]
GHC.IO.Exception.$fExceptionIOException_$cshow
  = \ (x_X7JkA :: IOException) ->
      case x_X7JkA of
      { IOError ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww5_s8iuK
                ww6_s8iuL ->
      GHC.IO.Exception.$w$cshowsPrec3
        ww1_s8iuG
        ww2_s8iuH
        ww3_s8iuI
        ww4_s8iuJ
        ww6_s8iuL
        (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOException1 :: IOException -> ShowS
[GblId,
 Arity=2,
 Str=<S(LLLLLS),1*U(1*U,1*U,1*U,1*U,A,1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 80 0}]
GHC.IO.Exception.$fShowIOException1
  = \ (w_s8iuC :: IOException) (w1_s8iuD :: String) ->
      case w_s8iuC of
      { IOError ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww5_s8iuK
                ww6_s8iuL ->
      GHC.IO.Exception.$w$cshowsPrec3
        ww1_s8iuG ww2_s8iuH ww3_s8iuI ww4_s8iuJ ww6_s8iuL w1_s8iuD
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOException_$cshowList
  :: [IOException] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [IOException])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ IOException
                   GHC.IO.Exception.$fShowIOException1
                   ls_i7JaB
                   s_i7JaC}]
GHC.IO.Exception.$fShowIOException_$cshowList
  = \ (ls_i7JaB :: [IOException]) (s_i7JaC :: String) ->
      showList__
        @ IOException GHC.IO.Exception.$fShowIOException1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowIOException [InlPrag=NOUSERINLINE CONLIKE]
  :: Show IOException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: IOException
                       GHC.IO.Exception.$fExceptionIOException_$cshowsPrec
                       GHC.IO.Exception.$fExceptionIOException_$cshow
                       GHC.IO.Exception.$fShowIOException_$cshowList]
GHC.IO.Exception.$fShowIOException
  = GHC.Show.C:Show
      @ IOException
      GHC.IO.Exception.$fExceptionIOException_$cshowsPrec
      GHC.IO.Exception.$fExceptionIOException_$cshow
      GHC.IO.Exception.$fShowIOException_$cshowList

-- RHS size: {terms: 12, types: 82, coercions: 109, joins: 0/0}
GHC.IO.Exception.$fGenericExitCode_$cto
  :: forall x. Rep ExitCode x -> ExitCode
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_a8gXk)
                 (ds_d8hpJ [Occ=Once] :: Rep ExitCode x_a8gXk) ->
                 case ds_d8hpJ
                      `cast` ((Sub (GHC.IO.Exception.Rep_ExitCode[0]) ; GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <D>_P
                                                                            <'MetaData
                                                                               "ExitCode"
                                                                               "GHC.IO.Exception"
                                                                               "base"
                                                                               'False>_P
                                                                            <M1
                                                                               C
                                                                               ('MetaCons
                                                                                  "ExitSuccess"
                                                                                  'PrefixI
                                                                                  'False)
                                                                               U1
                                                                             :+: M1
                                                                                   C
                                                                                   ('MetaCons
                                                                                      "ExitFailure"
                                                                                      'PrefixI
                                                                                      'False)
                                                                                   (M1
                                                                                      S
                                                                                      ('MetaSel
                                                                                         'Nothing
                                                                                         'NoSourceUnpackedness
                                                                                         'NoSourceStrictness
                                                                                         'DecidedLazy)
                                                                                      (K1
                                                                                         R
                                                                                         Int))>_R) <x_a8gXk>_N
                              :: (Rep ExitCode x_a8gXk :: *)
                                 ~R# ((:+:)
                                        (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
                                        (M1
                                           C
                                           ('MetaCons "ExitFailure" 'PrefixI 'False)
                                           (M1
                                              S
                                              ('MetaSel
                                                 'Nothing
                                                 'NoSourceUnpackedness
                                                 'NoSourceStrictness
                                                 'DecidedLazy)
                                              (K1 R Int)))
                                        x_a8gXk :: *))
                 of {
                   L1 ds1_d8hpL [Occ=Once] ->
                     case ds1_d8hpL
                          `cast` (GHC.Generics.N:M1[0]
                                      <*>_N
                                      <C>_P
                                      <'MetaCons "ExitSuccess" 'PrefixI 'False>_P
                                      <U1>_R <x_a8gXk>_N
                                  :: (M1
                                        C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1 x_a8gXk :: *)
                                     ~R# (U1 x_a8gXk :: *))
                     of
                     { U1 ->
                     GHC.IO.Exception.ExitSuccess
                     };
                   R1 ds1_d8hpN [Occ=Once] ->
                     GHC.IO.Exception.ExitFailure
                       (ds1_d8hpN
                        `cast` ((GHC.Generics.N:M1[0]
                                     <*>_N
                                     <C>_P
                                     <'MetaCons "ExitFailure" 'PrefixI 'False>_P
                                     <M1
                                        S
                                        ('MetaSel
                                           'Nothing
                                           'NoSourceUnpackedness
                                           'NoSourceStrictness
                                           'DecidedLazy)
                                        (K1 R Int)>_R ; GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <S>_P
                                                            <'MetaSel
                                                               'Nothing
                                                               'NoSourceUnpackedness
                                                               'NoSourceStrictness
                                                               'DecidedLazy>_P
                                                            <K1
                                                               R
                                                               Int>_R) <x_a8gXk>_N ; GHC.Generics.N:K1[0]
                                                                                         <*>_N
                                                                                         <R>_P
                                                                                         <Int>_R
                                                                                         <x_a8gXk>_P
                                :: (M1
                                      C
                                      ('MetaCons "ExitFailure" 'PrefixI 'False)
                                      (M1
                                         S
                                         ('MetaSel
                                            'Nothing
                                            'NoSourceUnpackedness
                                            'NoSourceStrictness
                                            'DecidedLazy)
                                         (K1 R Int))
                                      x_a8gXk :: *)
                                   ~R# (Int :: *)))
                 }}]
GHC.IO.Exception.$fGenericExitCode_$cto
  = \ (@ x_a8gXk) (ds_d8hpJ :: Rep ExitCode x_a8gXk) ->
      case ds_d8hpJ
           `cast` ((Sub (GHC.IO.Exception.Rep_ExitCode[0]) ; GHC.Generics.N:M1[0]
                                                                 <*>_N
                                                                 <D>_P
                                                                 <'MetaData
                                                                    "ExitCode"
                                                                    "GHC.IO.Exception"
                                                                    "base"
                                                                    'False>_P
                                                                 <M1
                                                                    C
                                                                    ('MetaCons
                                                                       "ExitSuccess"
                                                                       'PrefixI
                                                                       'False)
                                                                    U1
                                                                  :+: M1
                                                                        C
                                                                        ('MetaCons
                                                                           "ExitFailure"
                                                                           'PrefixI
                                                                           'False)
                                                                        (M1
                                                                           S
                                                                           ('MetaSel
                                                                              'Nothing
                                                                              'NoSourceUnpackedness
                                                                              'NoSourceStrictness
                                                                              'DecidedLazy)
                                                                           (K1
                                                                              R
                                                                              Int))>_R) <x_a8gXk>_N
                   :: (Rep ExitCode x_a8gXk :: *)
                      ~R# ((:+:)
                             (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
                             (M1
                                C
                                ('MetaCons "ExitFailure" 'PrefixI 'False)
                                (M1
                                   S
                                   ('MetaSel
                                      'Nothing
                                      'NoSourceUnpackedness
                                      'NoSourceStrictness
                                      'DecidedLazy)
                                   (K1 R Int)))
                             x_a8gXk :: *))
      of {
        L1 ds1_d8hpL ->
          case ds1_d8hpL
               `cast` (GHC.Generics.N:M1[0]
                           <*>_N
                           <C>_P
                           <'MetaCons "ExitSuccess" 'PrefixI 'False>_P
                           <U1>_R <x_a8gXk>_N
                       :: (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1 x_a8gXk :: *)
                          ~R# (U1 x_a8gXk :: *))
          of
          { U1 ->
          GHC.IO.Exception.ExitSuccess
          };
        R1 ds1_d8hpN ->
          GHC.IO.Exception.ExitFailure
            (ds1_d8hpN
             `cast` ((GHC.Generics.N:M1[0]
                          <*>_N
                          <C>_P
                          <'MetaCons "ExitFailure" 'PrefixI 'False>_P
                          <M1
                             S
                             ('MetaSel
                                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                             (K1 R Int)>_R ; GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <S>_P
                                                 <'MetaSel
                                                    'Nothing
                                                    'NoSourceUnpackedness
                                                    'NoSourceStrictness
                                                    'DecidedLazy>_P
                                                 <K1 R Int>_R) <x_a8gXk>_N ; GHC.Generics.N:K1[0]
                                                                                 <*>_N
                                                                                 <R>_P
                                                                                 <Int>_R
                                                                                 <x_a8gXk>_P
                     :: (M1
                           C
                           ('MetaCons "ExitFailure" 'PrefixI 'False)
                           (M1
                              S
                              ('MetaSel
                                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                              (K1 R Int))
                           x_a8gXk :: *)
                        ~R# (Int :: *)))
      }

-- RHS size: {terms: 3, types: 41, coercions: 13, joins: 0/0}
GHC.IO.Exception.$fGenericExitCode2
  :: forall x.
     (:+:)
       (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
       (M1
          C
          ('MetaCons "ExitFailure" 'PrefixI 'False)
          (M1
             S
             ('MetaSel
                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
             (K1 R Int)))
       x
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fGenericExitCode2
  = \ (@ x_a8gWk) ->
      GHC.Generics.L1
        @ *
        @ (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
        @ (M1
             C
             ('MetaCons "ExitFailure" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R Int)))
        @ x_a8gWk
        ((GHC.Generics.U1 @ * @ x_a8gWk)
         `cast` (Sym (GHC.Generics.N:M1[0]
                          <*>_N
                          <C>_P
                          <'MetaCons "ExitSuccess" 'PrefixI 'False>_P
                          <U1>_R) <x_a8gWk>_N
                 :: (U1 x_a8gWk :: *)
                    ~R# (M1
                           C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1 x_a8gWk :: *)))

-- RHS size: {terms: 9, types: 42, coercions: 50, joins: 0/0}
GHC.IO.Exception.$fGenericExitCode1
  :: forall x.
     ExitCode
     -> (:+:)
          (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
          (M1
             C
             ('MetaCons "ExitFailure" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R Int)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_a8gWk) (x1_a8gMj [Occ=Once!] :: ExitCode) ->
                 case x1_a8gMj of {
                   ExitSuccess -> GHC.IO.Exception.$fGenericExitCode2 @ x_a8gWk;
                   ExitFailure g1_a8gMk [Occ=Once] ->
                     GHC.Generics.R1
                       @ *
                       @ (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
                       @ (M1
                            C
                            ('MetaCons "ExitFailure" 'PrefixI 'False)
                            (M1
                               S
                               ('MetaSel
                                  'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                               (K1 R Int)))
                       @ x_a8gWk
                       (g1_a8gMk
                        `cast` (Sym (GHC.Generics.N:K1[0]
                                         <*>_N
                                         <R>_P
                                         <Int>_R
                                         <x_a8gWk>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                  <*>_N
                                                                  <S>_P
                                                                  <'MetaSel
                                                                     'Nothing
                                                                     'NoSourceUnpackedness
                                                                     'NoSourceStrictness
                                                                     'DecidedLazy>_P
                                                                  <K1
                                                                     R
                                                                     Int>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                                        <*>_N
                                                                                        <C>_P
                                                                                        <'MetaCons
                                                                                           "ExitFailure"
                                                                                           'PrefixI
                                                                                           'False>_P
                                                                                        <M1
                                                                                           S
                                                                                           ('MetaSel
                                                                                              'Nothing
                                                                                              'NoSourceUnpackedness
                                                                                              'NoSourceStrictness
                                                                                              'DecidedLazy)
                                                                                           (K1
                                                                                              R
                                                                                              Int)>_R)) <x_a8gWk>_N
                                :: (Int :: *)
                                   ~R# (M1
                                          C
                                          ('MetaCons "ExitFailure" 'PrefixI 'False)
                                          (M1
                                             S
                                             ('MetaSel
                                                'Nothing
                                                'NoSourceUnpackedness
                                                'NoSourceStrictness
                                                'DecidedLazy)
                                             (K1 R Int))
                                          x_a8gWk :: *)))
                 }}]
GHC.IO.Exception.$fGenericExitCode1
  = \ (@ x_a8gWk) (x1_a8gMj :: ExitCode) ->
      case x1_a8gMj of {
        ExitSuccess -> GHC.IO.Exception.$fGenericExitCode2 @ x_a8gWk;
        ExitFailure g1_a8gMk ->
          GHC.Generics.R1
            @ *
            @ (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
            @ (M1
                 C
                 ('MetaCons "ExitFailure" 'PrefixI 'False)
                 (M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                    (K1 R Int)))
            @ x_a8gWk
            (g1_a8gMk
             `cast` (Sym (GHC.Generics.N:K1[0]
                              <*>_N <R>_P <Int>_R <x_a8gWk>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                           <*>_N
                                                                           <S>_P
                                                                           <'MetaSel
                                                                              'Nothing
                                                                              'NoSourceUnpackedness
                                                                              'NoSourceStrictness
                                                                              'DecidedLazy>_P
                                                                           <K1
                                                                              R
                                                                              Int>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                                                 <*>_N
                                                                                                 <C>_P
                                                                                                 <'MetaCons
                                                                                                    "ExitFailure"
                                                                                                    'PrefixI
                                                                                                    'False>_P
                                                                                                 <M1
                                                                                                    S
                                                                                                    ('MetaSel
                                                                                                       'Nothing
                                                                                                       'NoSourceUnpackedness
                                                                                                       'NoSourceStrictness
                                                                                                       'DecidedLazy)
                                                                                                    (K1
                                                                                                       R
                                                                                                       Int)>_R)) <x_a8gWk>_N
                     :: (Int :: *)
                        ~R# (M1
                               C
                               ('MetaCons "ExitFailure" 'PrefixI 'False)
                               (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R Int))
                               x_a8gWk :: *)))
      }

-- RHS size: {terms: 3, types: 1, coercions: 56, joins: 0/0}
GHC.IO.Exception.$fGenericExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic ExitCode
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic TYPE: ExitCode
                              GHC.IO.Exception.$fGenericExitCode1
                              `cast` (forall (x :: <*>_N).
                                      <ExitCode>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <D>_P
                                                     <'MetaData
                                                        "ExitCode"
                                                        "GHC.IO.Exception"
                                                        "base"
                                                        'False>_P
                                                     <M1
                                                        C
                                                        ('MetaCons "ExitSuccess" 'PrefixI 'False)
                                                        U1
                                                      :+: M1
                                                            C
                                                            ('MetaCons
                                                               "ExitFailure" 'PrefixI 'False)
                                                            (M1
                                                               S
                                                               ('MetaSel
                                                                  'Nothing
                                                                  'NoSourceUnpackedness
                                                                  'NoSourceStrictness
                                                                  'DecidedLazy)
                                                               (K1
                                                                  R
                                                                  Int))>_R) ; Sub (Sym (GHC.IO.Exception.Rep_ExitCode[0]))) <x>_N
                                      :: (forall x.
                                          ExitCode
                                          -> (:+:)
                                               (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
                                               (M1
                                                  C
                                                  ('MetaCons "ExitFailure" 'PrefixI 'False)
                                                  (M1
                                                     S
                                                     ('MetaSel
                                                        'Nothing
                                                        'NoSourceUnpackedness
                                                        'NoSourceStrictness
                                                        'DecidedLazy)
                                                     (K1 R Int)))
                                               x :: *)
                                         ~R# (forall x. ExitCode -> Rep ExitCode x :: *))
                              GHC.IO.Exception.$fGenericExitCode_$cto]
GHC.IO.Exception.$fGenericExitCode
  = GHC.Generics.C:Generic
      @ ExitCode
      (GHC.IO.Exception.$fGenericExitCode1
       `cast` (forall (x :: <*>_N).
               <ExitCode>_R
               ->_R (Sym (GHC.Generics.N:M1[0]
                              <*>_N
                              <D>_P
                              <'MetaData "ExitCode" "GHC.IO.Exception" "base" 'False>_P
                              <M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1
                               :+: M1
                                     C
                                     ('MetaCons "ExitFailure" 'PrefixI 'False)
                                     (M1
                                        S
                                        ('MetaSel
                                           'Nothing
                                           'NoSourceUnpackedness
                                           'NoSourceStrictness
                                           'DecidedLazy)
                                        (K1
                                           R
                                           Int))>_R) ; Sub (Sym (GHC.IO.Exception.Rep_ExitCode[0]))) <x>_N
               :: (forall x.
                   ExitCode
                   -> (:+:)
                        (M1 C ('MetaCons "ExitSuccess" 'PrefixI 'False) U1)
                        (M1
                           C
                           ('MetaCons "ExitFailure" 'PrefixI 'False)
                           (M1
                              S
                              ('MetaSel
                                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                              (K1 R Int)))
                        x :: *)
                  ~R# (forall x. ExitCode -> Rep ExitCode x :: *)))
      GHC.IO.Exception.$fGenericExitCode_$cto

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$fExceptionExitCode3 = "ExitSuccess"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fExceptionExitCode2
  = unpackCString# GHC.IO.Exception.$fExceptionExitCode3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode1 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$fExceptionExitCode1 = "ExitFailure "#

-- RHS size: {terms: 51, types: 35, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowExitCode_$cshowsPrec
  :: Int -> ExitCode -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 60 0] 301 30}]
GHC.IO.Exception.$fShowExitCode_$cshowsPrec
  = \ (ds_d8hpG :: Int) (ds1_d8hpH :: ExitCode) (eta_B1 :: String) ->
      case ds1_d8hpH of {
        ExitSuccess ->
          ++ @ Char GHC.IO.Exception.$fExceptionExitCode2 eta_B1;
        ExitFailure b1_a8gMi ->
          case ds_d8hpG of { I# x_alMY ->
          case >=# x_alMY 11# of {
            __DEFAULT ->
              unpackAppendCString#
                GHC.IO.Exception.$fExceptionExitCode1
                (case b1_a8gMi of { I# ww3_i7NVa ->
                 case GHC.Show.$wshowSignedInt 11# ww3_i7NVa eta_B1 of
                 { (# ww5_i7NVe, ww6_i7NVf #) ->
                 GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
                 }
                 });
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (unpackAppendCString#
                   GHC.IO.Exception.$fExceptionExitCode1
                   (case b1_a8gMi of { I# ww3_i7NVa ->
                    case GHC.Show.$wshowSignedInt
                           11# ww3_i7NVa (GHC.Types.: @ Char GHC.Show.$fShow(,)2 eta_B1)
                    of
                    { (# ww5_i7NVe, ww6_i7NVf #) ->
                    GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
                    }
                    }))
          }
          }
      }

-- RHS size: {terms: 20, types: 16, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode_$cshow :: ExitCode -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 120 0}]
GHC.IO.Exception.$fExceptionExitCode_$cshow
  = \ (x_X7JkR :: ExitCode) ->
      case x_X7JkR of {
        ExitSuccess -> GHC.IO.Exception.$fExceptionExitCode2;
        ExitFailure b1_a8gMi ->
          unpackAppendCString#
            GHC.IO.Exception.$fExceptionExitCode1
            (case b1_a8gMi of { I# ww3_i7NVa ->
             case GHC.Show.$wshowSignedInt 11# ww3_i7NVa (GHC.Types.[] @ Char)
             of
             { (# ww5_i7NVe, ww6_i7NVf #) ->
             GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
             }
             })
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowExitCode1 :: ExitCode -> ShowS
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.IO.Exception.$fShowExitCode1
  = GHC.IO.Exception.$fShowExitCode_$cshowsPrec
      GHC.IO.Exception.$fExceptionArrayException1

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowExitCode_$cshowList :: [ExitCode] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [ExitCode])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ ExitCode GHC.IO.Exception.$fShowExitCode1 ls_i7JaB s_i7JaC}]
GHC.IO.Exception.$fShowExitCode_$cshowList
  = \ (ls_i7JaB :: [ExitCode]) (s_i7JaC :: String) ->
      showList__
        @ ExitCode GHC.IO.Exception.$fShowExitCode1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fShowExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Show ExitCode
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: ExitCode
                       GHC.IO.Exception.$fShowExitCode_$cshowsPrec
                       GHC.IO.Exception.$fExceptionExitCode_$cshow
                       GHC.IO.Exception.$fShowExitCode_$cshowList]
GHC.IO.Exception.$fShowExitCode
  = GHC.Show.C:Show
      @ ExitCode
      GHC.IO.Exception.$fShowExitCode_$cshowsPrec
      GHC.IO.Exception.$fExceptionExitCode_$cshow
      GHC.IO.Exception.$fShowExitCode_$cshowList

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fReadExitCode_lexeme1
  = Text.Read.Lex.Ident GHC.IO.Exception.$fExceptionExitCode2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$fReadExitCode5 = "ExitFailure"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fReadExitCode4
  = unpackCString# GHC.IO.Exception.$fReadExitCode5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fReadExitCode_lexeme
  = Text.Read.Lex.Ident GHC.IO.Exception.$fReadExitCode4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fReadExitCode3 = GHC.Types.I# 11#

-- RHS size: {terms: 37, types: 35, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode2
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ExitCode -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,1*U(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 60] 281 0}]
GHC.IO.Exception.$fReadExitCode2
  = \ (n_i88Yh :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815E)
      (eta_B1 :: ExitCode -> Text.ParserCombinators.ReadP.P b_i815E) ->
      case Text.Read.Lex.$wexpect
             GHC.IO.Exception.$fReadExitCode_lexeme1
             @ b_i815E
             (\ _ [Occ=Dead, OS=OneShot] -> eta_B1 GHC.IO.Exception.ExitSuccess)
      of
      { (# ww1_i88Ww #) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_i815E
        (Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww)
        (case n_i88Yh of { I# x_i88VZ ->
         case <=# x_i88VZ 10# of {
           __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
           1# ->
             case Text.Read.Lex.$wexpect
                    GHC.IO.Exception.$fReadExitCode_lexeme
                    @ b_i815E
                    (\ _ [Occ=Dead, OS=OneShot] ->
                       GHC.Read.$fReadInt_$sreadNumber
                         GHC.Read.$fReadInt2
                         GHC.IO.Exception.$fReadExitCode3
                         @ b_i815E
                         (\ (a2_i88WJ :: Int) ->
                            eta_B1 (GHC.IO.Exception.ExitFailure a2_i88WJ)))
             of
             { (# ww3_X897r #) ->
             Text.ParserCombinators.ReadP.Look @ b_i815E ww3_X897r
             }
         }
         })
      }

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fReadExitCode1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ExitCode -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.IO.Exception.$fReadExitCode1
  = GHC.Read.list3
      @ ExitCode
      (GHC.IO.Exception.$fReadExitCode2
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <ExitCode>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (ExitCode -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *)))

-- RHS size: {terms: 6, types: 5, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fReadExitCode_$creadsPrec
  :: Int -> ReadS ExitCode
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ ExitCode
                   (GHC.Read.list3
                      @ ExitCode
                      (GHC.IO.Exception.$fReadExitCode2
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        <ExitCode>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (ExitCode -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *)))
                      n_i8156
                      @ ExitCode
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ ExitCode))}]
GHC.IO.Exception.$fReadExitCode_$creadsPrec
  = \ (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ ExitCode
        (GHC.Read.list3
           @ ExitCode
           (GHC.IO.Exception.$fReadExitCode2
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <ExitCode>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (ExitCode -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *)))
           n_i8156
           @ ExitCode
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ ExitCode))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fReadExitCode_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [ExitCode]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$fReadExitCode_$creadListPrec
  = list
      @ ExitCode
      (GHC.IO.Exception.$fReadExitCode1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <ExitCode>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (ExitCode -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
GHC.IO.Exception.$fReadExitCode6
  :: Text.ParserCombinators.ReadP.P [ExitCode]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
GHC.IO.Exception.$fReadExitCode6
  = (((GHC.IO.Exception.$fReadExitCode_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                   <[ExitCode]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [ExitCode] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [ExitCode] :: *)))
        GHC.Read.$fRead()7)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[ExitCode]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [ExitCode] :: *)
                ~R# (forall b.
                     ([ExitCode] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [ExitCode]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [ExitCode])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fReadExitCode_$creadList :: ReadS [ExitCode]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.IO.Exception.$fReadExitCode_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [ExitCode] GHC.IO.Exception.$fReadExitCode6

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fReadExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Read ExitCode
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: ExitCode
                       GHC.IO.Exception.$fReadExitCode_$creadsPrec
                       GHC.IO.Exception.$fReadExitCode_$creadList
                       GHC.IO.Exception.$fReadExitCode1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        <ExitCode>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (ExitCode -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *))
                       GHC.IO.Exception.$fReadExitCode_$creadListPrec]
GHC.IO.Exception.$fReadExitCode
  = GHC.Read.C:Read
      @ ExitCode
      GHC.IO.Exception.$fReadExitCode_$creadsPrec
      GHC.IO.Exception.$fReadExitCode_$creadList
      (GHC.IO.Exception.$fReadExitCode1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <ExitCode>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <ExitCode>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (ExitCode -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ExitCode :: *)))
      GHC.IO.Exception.$fReadExitCode_$creadListPrec

-- RHS size: {terms: 20, types: 8, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$c< :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a8gM6 [Occ=Once!] :: ExitCode)
                 (b_a8gM7 [Occ=Once*!] :: ExitCode) ->
                 case a_a8gM6 of {
                   ExitSuccess ->
                     case b_a8gM7 of {
                       ExitSuccess -> GHC.Types.False;
                       ExitFailure _ [Occ=Dead] -> GHC.Types.True
                     };
                   ExitFailure a1_a8gM8 [Occ=Once] ->
                     case b_a8gM7 of {
                       ExitSuccess -> GHC.Types.False;
                       ExitFailure b1_a8gM9 [Occ=Once] -> ltInt a1_a8gM8 b1_a8gM9
                     }
                 }}]
GHC.IO.Exception.$fOrdExitCode_$c<
  = \ (a_a8gM6 :: ExitCode) (b_a8gM7 :: ExitCode) ->
      case a_a8gM6 of {
        ExitSuccess ->
          case b_a8gM7 of {
            ExitSuccess -> GHC.Types.False;
            ExitFailure ipv_s8hwO -> GHC.Types.True
          };
        ExitFailure a1_a8gM8 ->
          case b_a8gM7 of {
            ExitSuccess -> GHC.Types.False;
            ExitFailure b1_a8gM9 -> ltInt a1_a8gM8 b1_a8gM9
          }
      }

-- RHS size: {terms: 20, types: 8, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$ccompare
  :: ExitCode -> ExitCode -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a8gM2 [Occ=Once!] :: ExitCode)
                 (b_a8gM3 [Occ=Once*!] :: ExitCode) ->
                 case a_a8gM2 of {
                   ExitSuccess ->
                     case b_a8gM3 of {
                       ExitSuccess -> GHC.Types.EQ;
                       ExitFailure _ [Occ=Dead] -> GHC.Types.LT
                     };
                   ExitFailure a1_a8gM4 [Occ=Once] ->
                     case b_a8gM3 of {
                       ExitSuccess -> GHC.Types.GT;
                       ExitFailure b1_a8gM5 [Occ=Once] -> compareInt a1_a8gM4 b1_a8gM5
                     }
                 }}]
GHC.IO.Exception.$fOrdExitCode_$ccompare
  = \ (a_a8gM2 :: ExitCode) (b_a8gM3 :: ExitCode) ->
      case a_a8gM2 of {
        ExitSuccess ->
          case b_a8gM3 of {
            ExitSuccess -> GHC.Types.EQ;
            ExitFailure ipv_s8hwU -> GHC.Types.LT
          };
        ExitFailure a1_a8gM4 ->
          case b_a8gM3 of {
            ExitSuccess -> GHC.Types.GT;
            ExitFailure b1_a8gM5 -> compareInt a1_a8gM4 b1_a8gM5
          }
      }

-- RHS size: {terms: 20, types: 8, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqExitCode_$c== :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hpj [Occ=Once!] :: ExitCode)
                 (ds1_d8hpk [Occ=Once*!] :: ExitCode) ->
                 case ds_d8hpj of {
                   ExitSuccess ->
                     case ds1_d8hpk of {
                       ExitSuccess -> GHC.Types.True;
                       ExitFailure _ [Occ=Dead] -> GHC.Types.False
                     };
                   ExitFailure a1_a8gM0 [Occ=Once] ->
                     case ds1_d8hpk of {
                       ExitSuccess -> GHC.Types.False;
                       ExitFailure b1_a8gM1 [Occ=Once] -> eqInt a1_a8gM0 b1_a8gM1
                     }
                 }}]
GHC.IO.Exception.$fEqExitCode_$c==
  = \ (ds_d8hpj :: ExitCode) (ds1_d8hpk :: ExitCode) ->
      case ds_d8hpj of {
        ExitSuccess ->
          case ds1_d8hpk of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure ipv_s8hx0 -> GHC.Types.False
          };
        ExitFailure a1_a8gM0 ->
          case ds1_d8hpk of {
            ExitSuccess -> GHC.Types.False;
            ExitFailure b1_a8gM1 -> eqInt a1_a8gM0 b1_a8gM1
          }
      }

-- RHS size: {terms: 31, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqExitCode_$c/= [InlPrag=INLINE (sat-args=2)]
  :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: ExitCode)
                 (y_a22c [Occ=Once*!] :: ExitCode) ->
                 case x_a22b of {
                   ExitSuccess ->
                     case y_a22c of {
                       ExitSuccess -> GHC.Types.False;
                       ExitFailure _ [Occ=Dead] -> GHC.Types.True
                     };
                   ExitFailure a1_a8gM0 [Occ=Once] ->
                     case y_a22c of {
                       ExitSuccess -> GHC.Types.True;
                       ExitFailure b1_a8gM1 [Occ=Once] ->
                         case eqInt a1_a8gM0 b1_a8gM1 of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         }
                     }
                 }}]
GHC.IO.Exception.$fEqExitCode_$c/=
  = \ (eta_B2 :: ExitCode) (eta1_B1 :: ExitCode) ->
      case eta_B2 of {
        ExitSuccess ->
          case eta1_B1 of {
            ExitSuccess -> GHC.Types.False;
            ExitFailure ipv_s8hx0 -> GHC.Types.True
          };
        ExitFailure a1_a8gM0 ->
          case eta1_B1 of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure b1_a8gM1 ->
              case a1_a8gM0 of { I# x_a22G ->
              case b1_a8gM1 of { I# y_a22K ->
              case ==# x_a22G y_a22K of {
                __DEFAULT -> GHC.Types.True;
                1# -> GHC.Types.False
              }
              }
              }
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq ExitCode
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: ExitCode
                        GHC.IO.Exception.$fEqExitCode_$c==
                        GHC.IO.Exception.$fEqExitCode_$c/=]
GHC.IO.Exception.$fEqExitCode
  = GHC.Classes.C:Eq
      @ ExitCode
      GHC.IO.Exception.$fEqExitCode_$c==
      GHC.IO.Exception.$fEqExitCode_$c/=

-- RHS size: {terms: 31, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$c<= :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50] 101 50}]
GHC.IO.Exception.$fOrdExitCode_$c<=
  = \ (a_a8gMa :: ExitCode) (b_a8gMb :: ExitCode) ->
      case b_a8gMb of {
        ExitSuccess ->
          case a_a8gMa of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure ipv_s8hwO -> GHC.Types.False
          };
        ExitFailure a1_a8gM8 ->
          case a_a8gMa of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure b1_a8gM9 ->
              case a1_a8gM8 of { I# x_alN9 ->
              case b1_a8gM9 of { I# y_alNd ->
              case <# x_alN9 y_alNd of {
                __DEFAULT -> GHC.Types.True;
                1# -> GHC.Types.False
              }
              }
              }
          }
      }

-- RHS size: {terms: 26, types: 11, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$cmax
  :: ExitCode -> ExitCode -> ExitCode
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once*] :: ExitCode)
                 (y_a55e [Occ=Once!] :: ExitCode) ->
                 case y_a55e of wild_X5G {
                   ExitSuccess -> x_a55d;
                   ExitFailure a1_a8gM8 [Occ=Once!] ->
                     case x_a55d of wild1_X19 {
                       ExitSuccess -> wild_X5G;
                       ExitFailure b1_a8gM9 [Occ=Once!] ->
                         case a1_a8gM8 of { I# x1_alN9 [Occ=Once] ->
                         case b1_a8gM9 of { I# y1_alNd [Occ=Once] ->
                         case <# x1_alN9 y1_alNd of {
                           __DEFAULT -> wild_X5G;
                           1# -> wild1_X19
                         }
                         }
                         }
                     }
                 }}]
GHC.IO.Exception.$fOrdExitCode_$cmax
  = \ (x_a55d :: ExitCode) (y_a55e :: ExitCode) ->
      case y_a55e of wild_X5G {
        ExitSuccess -> x_a55d;
        ExitFailure a1_a8gM8 ->
          case x_a55d of wild1_X19 {
            ExitSuccess -> wild_X5G;
            ExitFailure b1_a8gM9 ->
              case a1_a8gM8 of { I# x1_alN9 ->
              case b1_a8gM9 of { I# y1_alNd ->
              case <# x1_alN9 y1_alNd of {
                __DEFAULT -> wild_X5G;
                1# -> wild1_X19
              }
              }
              }
          }
      }

-- RHS size: {terms: 31, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$c>= :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [50 60] 101 50}]
GHC.IO.Exception.$fOrdExitCode_$c>=
  = \ (a_a8gMe :: ExitCode) (b_a8gMf :: ExitCode) ->
      case a_a8gMe of {
        ExitSuccess ->
          case b_a8gMf of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure ipv_s8hwO -> GHC.Types.False
          };
        ExitFailure a1_a8gM8 ->
          case b_a8gMf of {
            ExitSuccess -> GHC.Types.True;
            ExitFailure b1_a8gM9 ->
              case a1_a8gM8 of { I# x_alN9 ->
              case b1_a8gM9 of { I# y_alNd ->
              case <# x_alN9 y_alNd of {
                __DEFAULT -> GHC.Types.True;
                1# -> GHC.Types.False
              }
              }
              }
          }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$c> :: ExitCode -> ExitCode -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_a8gMc [Occ=Once] :: ExitCode)
                 (b_a8gMd [Occ=Once] :: ExitCode) ->
                 GHC.IO.Exception.$fOrdExitCode_$c< b_a8gMd a_a8gMc}]
GHC.IO.Exception.$fOrdExitCode_$c>
  = \ (a_a8gMc :: ExitCode) (b_a8gMd :: ExitCode) ->
      GHC.IO.Exception.$fOrdExitCode_$c< b_a8gMd a_a8gMc

-- RHS size: {terms: 29, types: 12, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode_$cmin
  :: ExitCode -> ExitCode -> ExitCode
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [50 40] 91 20}]
GHC.IO.Exception.$fOrdExitCode_$cmin
  = \ (x_a55m :: ExitCode) (y_a55n :: ExitCode) ->
      case y_a55n of wild_X5G {
        ExitSuccess ->
          case x_a55m of { __DEFAULT -> GHC.IO.Exception.ExitSuccess };
        ExitFailure a1_a8gM8 ->
          case x_a55m of wild1_X19 {
            ExitSuccess -> GHC.IO.Exception.ExitSuccess;
            ExitFailure b1_a8gM9 ->
              case a1_a8gM8 of { I# x1_alN9 ->
              case b1_a8gM9 of { I# y1_alNd ->
              case <# x1_alN9 y1_alNd of {
                __DEFAULT -> wild1_X19;
                1# -> wild_X5G
              }
              }
              }
          }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord ExitCode
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: ExitCode
                         GHC.IO.Exception.$fEqExitCode
                         GHC.IO.Exception.$fOrdExitCode_$ccompare
                         GHC.IO.Exception.$fOrdExitCode_$c<
                         GHC.IO.Exception.$fOrdExitCode_$c<=
                         GHC.IO.Exception.$fOrdExitCode_$c>
                         GHC.IO.Exception.$fOrdExitCode_$c>=
                         GHC.IO.Exception.$fOrdExitCode_$cmax
                         GHC.IO.Exception.$fOrdExitCode_$cmin]
GHC.IO.Exception.$fOrdExitCode
  = GHC.Classes.C:Ord
      @ ExitCode
      GHC.IO.Exception.$fEqExitCode
      GHC.IO.Exception.$fOrdExitCode_$ccompare
      GHC.IO.Exception.$fOrdExitCode_$c<
      GHC.IO.Exception.$fOrdExitCode_$c<=
      GHC.IO.Exception.$fOrdExitCode_$c>
      GHC.IO.Exception.$fOrdExitCode_$c>=
      GHC.IO.Exception.$fOrdExitCode_$cmax
      GHC.IO.Exception.$fOrdExitCode_$cmin

-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$c<
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [80 60] 120 20}]
GHC.IO.Exception.$fOrdArrayException_$c<
  = \ (a_a8gLO :: ArrayException) (b_a8gLP :: ArrayException) ->
      case a_a8gLO of {
        IndexOutOfBounds a1_a8gLQ ->
          case b_a8gLP of {
            IndexOutOfBounds b1_a8gLR ->
              GHC.Classes.$fOrd[]_$s$c<1 a1_a8gLQ b1_a8gLR;
            UndefinedElement ipv_s8hxc -> GHC.Types.True
          };
        UndefinedElement a1_a8gLS ->
          case b_a8gLP of {
            IndexOutOfBounds ipv_s8hxf -> GHC.Types.False;
            UndefinedElement b1_a8gLT ->
              GHC.Classes.$fOrd[]_$s$c<1 a1_a8gLS b1_a8gLT
          }
      }

-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$ccompare
  :: ArrayException -> ArrayException -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [80 60] 120 20}]
GHC.IO.Exception.$fOrdArrayException_$ccompare
  = \ (a_a8gLI :: ArrayException) (b_a8gLJ :: ArrayException) ->
      case a_a8gLI of {
        IndexOutOfBounds a1_a8gLK ->
          case b_a8gLJ of {
            IndexOutOfBounds b1_a8gLL ->
              GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLK b1_a8gLL;
            UndefinedElement ipv_s8hxj -> GHC.Types.LT
          };
        UndefinedElement a1_a8gLM ->
          case b_a8gLJ of {
            IndexOutOfBounds ipv_s8hxm -> GHC.Types.GT;
            UndefinedElement b1_a8gLN ->
              GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLM b1_a8gLN
          }
      }

-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqArrayException_$c==
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [80 60] 120 20}]
GHC.IO.Exception.$fEqArrayException_$c==
  = \ (ds_d8hoX :: ArrayException) (ds1_d8hoY :: ArrayException) ->
      case ds_d8hoX of {
        IndexOutOfBounds a1_a8gLE ->
          case ds1_d8hoY of {
            IndexOutOfBounds b1_a8gLF -> eqString a1_a8gLE b1_a8gLF;
            UndefinedElement ipv_s8hxq -> GHC.Types.False
          };
        UndefinedElement a1_a8gLG ->
          case ds1_d8hoY of {
            IndexOutOfBounds ipv_s8hxt -> GHC.Types.False;
            UndefinedElement b1_a8gLH -> eqString a1_a8gLG b1_a8gLH
          }
      }

-- RHS size: {terms: 32, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqArrayException_$c/= [InlPrag=INLINE (sat-args=2)]
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: ArrayException)
                 (y_a22c [Occ=Once*!] :: ArrayException) ->
                 case x_a22b of {
                   IndexOutOfBounds a1_a8gLE [Occ=Once] ->
                     case y_a22c of {
                       IndexOutOfBounds b1_a8gLF [Occ=Once] ->
                         case eqString a1_a8gLE b1_a8gLF of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         };
                       UndefinedElement _ [Occ=Dead] -> GHC.Types.True
                     };
                   UndefinedElement a1_a8gLG [Occ=Once] ->
                     case y_a22c of {
                       IndexOutOfBounds _ [Occ=Dead] -> GHC.Types.True;
                       UndefinedElement b1_a8gLH [Occ=Once] ->
                         case eqString a1_a8gLG b1_a8gLH of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         }
                     }
                 }}]
GHC.IO.Exception.$fEqArrayException_$c/=
  = \ (eta_B2 :: ArrayException) (eta1_B1 :: ArrayException) ->
      case eta_B2 of {
        IndexOutOfBounds a1_a8gLE ->
          case eta1_B1 of {
            IndexOutOfBounds b1_a8gLF ->
              case eqString a1_a8gLE b1_a8gLF of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              };
            UndefinedElement ipv_s8hxq -> GHC.Types.True
          };
        UndefinedElement a1_a8gLG ->
          case eta1_B1 of {
            IndexOutOfBounds ipv_s8hxt -> GHC.Types.True;
            UndefinedElement b1_a8gLH ->
              case eqString a1_a8gLG b1_a8gLH of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqArrayException [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq ArrayException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: ArrayException
                        GHC.IO.Exception.$fEqArrayException_$c==
                        GHC.IO.Exception.$fEqArrayException_$c/=]
GHC.IO.Exception.$fEqArrayException
  = GHC.Classes.C:Eq
      @ ArrayException
      GHC.IO.Exception.$fEqArrayException_$c==
      GHC.IO.Exception.$fEqArrayException_$c/=

-- RHS size: {terms: 32, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$c<=
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 160 60}]
GHC.IO.Exception.$fOrdArrayException_$c<=
  = \ (a_a8gLU :: ArrayException) (b_a8gLV :: ArrayException) ->
      case b_a8gLV of {
        IndexOutOfBounds a1_a8gLQ ->
          case a_a8gLU of {
            IndexOutOfBounds b1_a8gLR ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLQ b1_a8gLR of {
                __DEFAULT -> GHC.Types.True;
                LT -> GHC.Types.False
              };
            UndefinedElement ipv_s8hxc -> GHC.Types.False
          };
        UndefinedElement a1_a8gLS ->
          case a_a8gLU of {
            IndexOutOfBounds ipv_s8hxf -> GHC.Types.True;
            UndefinedElement b1_a8gLT ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLS b1_a8gLT of {
                __DEFAULT -> GHC.Types.True;
                LT -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 32, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$cmax
  :: ArrayException -> ArrayException -> ArrayException
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 160 0}]
GHC.IO.Exception.$fOrdArrayException_$cmax
  = \ (x_a55d :: ArrayException) (y_a55e :: ArrayException) ->
      case y_a55e of wild_X5S {
        IndexOutOfBounds a1_a8gLQ ->
          case x_a55d of wild1_X1l {
            IndexOutOfBounds b1_a8gLR ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLQ b1_a8gLR of {
                __DEFAULT -> wild_X5S;
                LT -> wild1_X1l
              };
            UndefinedElement ipv_s8hxc -> wild1_X1l
          };
        UndefinedElement a1_a8gLS ->
          case x_a55d of wild1_X1l {
            IndexOutOfBounds ipv_s8hxf -> wild_X5S;
            UndefinedElement b1_a8gLT ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLS b1_a8gLT of {
                __DEFAULT -> wild_X5S;
                LT -> wild1_X1l
              }
          }
      }

-- RHS size: {terms: 32, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$c>=
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [100 60] 160 60}]
GHC.IO.Exception.$fOrdArrayException_$c>=
  = \ (a_a8gLY :: ArrayException) (b_a8gLZ :: ArrayException) ->
      case a_a8gLY of {
        IndexOutOfBounds a1_a8gLQ ->
          case b_a8gLZ of {
            IndexOutOfBounds b1_a8gLR ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLQ b1_a8gLR of {
                __DEFAULT -> GHC.Types.True;
                LT -> GHC.Types.False
              };
            UndefinedElement ipv_s8hxc -> GHC.Types.False
          };
        UndefinedElement a1_a8gLS ->
          case b_a8gLZ of {
            IndexOutOfBounds ipv_s8hxf -> GHC.Types.True;
            UndefinedElement b1_a8gLT ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLS b1_a8gLT of {
                __DEFAULT -> GHC.Types.True;
                LT -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$c>
  :: ArrayException -> ArrayException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_a8gLW [Occ=Once] :: ArrayException)
                 (b_a8gLX [Occ=Once] :: ArrayException) ->
                 GHC.IO.Exception.$fOrdArrayException_$c< b_a8gLX a_a8gLW}]
GHC.IO.Exception.$fOrdArrayException_$c>
  = \ (a_a8gLW :: ArrayException) (b_a8gLX :: ArrayException) ->
      GHC.IO.Exception.$fOrdArrayException_$c< b_a8gLX a_a8gLW

-- RHS size: {terms: 32, types: 13, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException_$cmin
  :: ArrayException -> ArrayException -> ArrayException
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 160 0}]
GHC.IO.Exception.$fOrdArrayException_$cmin
  = \ (x_a55m :: ArrayException) (y_a55n :: ArrayException) ->
      case y_a55n of wild_X5S {
        IndexOutOfBounds a1_a8gLQ ->
          case x_a55m of wild1_X1l {
            IndexOutOfBounds b1_a8gLR ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLQ b1_a8gLR of {
                __DEFAULT -> wild1_X1l;
                LT -> wild_X5S
              };
            UndefinedElement ipv_s8hxc -> wild_X5S
          };
        UndefinedElement a1_a8gLS ->
          case x_a55m of wild1_X1l {
            IndexOutOfBounds ipv_s8hxf -> wild1_X1l;
            UndefinedElement b1_a8gLT ->
              case GHC.Classes.$fOrd[]_$s$ccompare1 a1_a8gLS b1_a8gLT of {
                __DEFAULT -> wild1_X1l;
                LT -> wild_X5S
              }
          }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdArrayException [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord ArrayException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: ArrayException
                         GHC.IO.Exception.$fEqArrayException
                         GHC.IO.Exception.$fOrdArrayException_$ccompare
                         GHC.IO.Exception.$fOrdArrayException_$c<
                         GHC.IO.Exception.$fOrdArrayException_$c<=
                         GHC.IO.Exception.$fOrdArrayException_$c>
                         GHC.IO.Exception.$fOrdArrayException_$c>=
                         GHC.IO.Exception.$fOrdArrayException_$cmax
                         GHC.IO.Exception.$fOrdArrayException_$cmin]
GHC.IO.Exception.$fOrdArrayException
  = GHC.Classes.C:Ord
      @ ArrayException
      GHC.IO.Exception.$fEqArrayException
      GHC.IO.Exception.$fOrdArrayException_$ccompare
      GHC.IO.Exception.$fOrdArrayException_$c<
      GHC.IO.Exception.$fOrdArrayException_$c<=
      GHC.IO.Exception.$fOrdArrayException_$c>
      GHC.IO.Exception.$fOrdArrayException_$c>=
      GHC.IO.Exception.$fOrdArrayException_$cmax
      GHC.IO.Exception.$fOrdArrayException_$cmin

-- RHS size: {terms: 32, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqAsyncException_$c==
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [110 120] 120 80}]
GHC.IO.Exception.$fEqAsyncException_$c==
  = \ (ds_d8hoT :: AsyncException) (ds1_d8hoU :: AsyncException) ->
      case ds_d8hoT of {
        StackOverflow ->
          case ds1_d8hoU of {
            __DEFAULT -> GHC.Types.False;
            StackOverflow -> GHC.Types.True
          };
        HeapOverflow ->
          case ds1_d8hoU of {
            __DEFAULT -> GHC.Types.False;
            HeapOverflow -> GHC.Types.True
          };
        ThreadKilled ->
          case ds1_d8hoU of {
            __DEFAULT -> GHC.Types.False;
            ThreadKilled -> GHC.Types.True
          };
        UserInterrupt ->
          case ds1_d8hoU of {
            __DEFAULT -> GHC.Types.False;
            UserInterrupt -> GHC.Types.True
          }
      }

-- RHS size: {terms: 32, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqAsyncException_$c/= [InlPrag=INLINE (sat-args=2)]
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: AsyncException)
                 (y_a22c [Occ=Once*!] :: AsyncException) ->
                 case x_a22b of {
                   StackOverflow ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       StackOverflow -> GHC.Types.False
                     };
                   HeapOverflow ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       HeapOverflow -> GHC.Types.False
                     };
                   ThreadKilled ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       ThreadKilled -> GHC.Types.False
                     };
                   UserInterrupt ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       UserInterrupt -> GHC.Types.False
                     }
                 }}]
GHC.IO.Exception.$fEqAsyncException_$c/=
  = \ (eta_B2 :: AsyncException) (eta1_B1 :: AsyncException) ->
      case eta_B2 of {
        StackOverflow ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            StackOverflow -> GHC.Types.False
          };
        HeapOverflow ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            HeapOverflow -> GHC.Types.False
          };
        ThreadKilled ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            ThreadKilled -> GHC.Types.False
          };
        UserInterrupt ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            UserInterrupt -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fEqAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq AsyncException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: AsyncException
                        GHC.IO.Exception.$fEqAsyncException_$c==
                        GHC.IO.Exception.$fEqAsyncException_$c/=]
GHC.IO.Exception.$fEqAsyncException
  = GHC.Classes.C:Eq
      @ AsyncException
      GHC.IO.Exception.$fEqAsyncException_$c==
      GHC.IO.Exception.$fEqAsyncException_$c/=

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_filename :: IOException -> Maybe FilePath
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),1*U(A,A,A,A,A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hoM [Occ=Once!] :: IOException) ->
                 case ds_d8hoM of
                 { IOError _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                           _ [Occ=Dead] ds6_d8hoS [Occ=Once] ->
                 ds6_d8hoS
                 }}]
ioe_filename
  = \ (ds_d8hoM :: IOException) ->
      case ds_d8hoM of
      { IOError ds1_d8hoN ds2_d8hoO ds3_d8hoP ds4_d8hoQ ds5_d8hoR
                ds6_d8hoS ->
      ds6_d8hoS
      }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_errno :: IOException -> Maybe CInt
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),1*U(A,A,A,A,1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hoF [Occ=Once!] :: IOException) ->
                 case ds_d8hoF of
                 { IOError _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                           ds5_d8hoK [Occ=Once] _ [Occ=Dead] ->
                 ds5_d8hoK
                 }}]
ioe_errno
  = \ (ds_d8hoF :: IOException) ->
      case ds_d8hoF of
      { IOError ds1_d8hoG ds2_d8hoH ds3_d8hoI ds4_d8hoJ ds5_d8hoK
                ds6_d8hoL ->
      ds5_d8hoK
      }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_description :: IOException -> String
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),1*U(A,A,A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hoy [Occ=Once!] :: IOException) ->
                 case ds_d8hoy of
                 { IOError _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                           ds4_d8hoC [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                 ds4_d8hoC
                 }}]
ioe_description
  = \ (ds_d8hoy :: IOException) ->
      case ds_d8hoy of
      { IOError ds1_d8hoz ds2_d8hoA ds3_d8hoB ds4_d8hoC ds5_d8hoD
                ds6_d8hoE ->
      ds4_d8hoC
      }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_location :: IOException -> String
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),1*U(A,A,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hor [Occ=Once!] :: IOException) ->
                 case ds_d8hor of
                 { IOError _ [Occ=Dead] _ [Occ=Dead] ds3_d8hou [Occ=Once]
                           _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 ds3_d8hou
                 }}]
ioe_location
  = \ (ds_d8hor :: IOException) ->
      case ds_d8hor of
      { IOError ds1_d8hos ds2_d8hot ds3_d8hou ds4_d8hov ds5_d8how
                ds6_d8hox ->
      ds3_d8hou
      }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_type :: IOException -> IOErrorType
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),1*U(A,1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hok [Occ=Once!] :: IOException) ->
                 case ds_d8hok of
                 { IOError _ [Occ=Dead] ds2_d8hom [Occ=Once] _ [Occ=Dead]
                           _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 ds2_d8hom
                 }}]
ioe_type
  = \ (ds_d8hok :: IOException) ->
      case ds_d8hok of
      { IOError ds1_d8hol ds2_d8hom ds3_d8hon ds4_d8hoo ds5_d8hop
                ds6_d8hoq ->
      ds2_d8hom
      }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
ioe_handle :: IOException -> Maybe Handle
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),1*U(1*U,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d8hod [Occ=Once!] :: IOException) ->
                 case ds_d8hod of
                 { IOError ds1_d8hoe [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                           _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 ds1_d8hoe
                 }}]
ioe_handle
  = \ (ds_d8hod :: IOException) ->
      case ds_d8hod of
      { IOError ds1_d8hoe ds2_d8hof ds3_d8hog ds4_d8hoh ds5_d8hoi
                ds6_d8hoj ->
      ds1_d8hoe
      }

-- RHS size: {terms: 8, types: 5, coercions: 0, joins: 0/0}
userError :: String -> IOError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str_a8gzl [Occ=Once] :: String) ->
                 GHC.IO.Exception.IOError
                   (GHC.Base.Nothing @ Handle)
                   GHC.IO.Exception.UserError
                   (GHC.Types.[] @ Char)
                   str_a8gzl
                   (GHC.Base.Nothing @ CInt)
                   (GHC.Base.Nothing @ FilePath)}]
userError
  = \ (str_a8gzl :: String) ->
      GHC.IO.Exception.IOError
        (GHC.Base.Nothing @ Handle)
        GHC.IO.Exception.UserError
        (GHC.Types.[] @ Char)
        str_a8gzl
        (GHC.Base.Nothing @ CInt)
        (GHC.Base.Nothing @ FilePath)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.unsupportedOperation2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.unsupportedOperation2
  = "Operation is not supported"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.unsupportedOperation1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.unsupportedOperation1
  = unpackCString# GHC.IO.Exception.unsupportedOperation2

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
unsupportedOperation :: IOError
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
unsupportedOperation
  = GHC.IO.Exception.IOError
      (GHC.Base.Nothing @ Handle)
      GHC.IO.Exception.UnsupportedOperation
      (GHC.Types.[] @ Char)
      GHC.IO.Exception.unsupportedOperation1
      (GHC.Base.Nothing @ CInt)
      (GHC.Base.Nothing @ FilePath)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.untangle1 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.untangle1 = GHC.Types.C# ' '#

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.IO.Exception.untangle4 :: Char -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_a8gzB [Occ=Once!] :: Char) ->
                 case c_a8gzB of { C# x_a3vE4 [Occ=Once!] ->
                 case x_a3vE4 of {
                   __DEFAULT -> GHC.Types.True;
                   '|'# -> GHC.Types.False
                 }
                 }}]
GHC.IO.Exception.untangle4
  = \ (c_a8gzB :: Char) ->
      case c_a8gzB of { C# x_a3vE4 ->
      case x_a3vE4 of {
        __DEFAULT -> GHC.Types.True;
        '|'# -> GHC.Types.False
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.untangle3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.untangle3 = "\n"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.untangle2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.untangle2
  = unpackCString# GHC.IO.Exception.untangle3

-- RHS size: {terms: 42, types: 38, coercions: 0, joins: 1/1}
untangle :: Addr# -> String -> String
[GblId,
 Arity=2,
 Str=<S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 258 0}]
untangle
  = \ (coded_a8gzs :: Addr#) (message_a8gzt :: String) ->
      case GHC.List.$wspan
             @ Char GHC.IO.Exception.untangle4 (unpackCStringUtf8# coded_a8gzs)
      of
      { (# ww1_i8hm4, ww2_i8hm5 #) ->
      join {
        $w$j_s8ivk [InlPrag=NOUSERINLINE[0], Dmd=<C(C(S)),1*C1(C1(U))>]
          :: [Char] -> [Char] -> [Char]
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []]
        $w$j_s8ivk (w_s8ivh [OS=OneShot] :: [Char])
                   (w1_s8ivi [OS=OneShot] :: [Char])
          = ++
              @ Char
              w_s8ivh
              (unpackAppendCString#
                 GHC.IO.Exception.$fExceptionArrayException3
                 (++
                    @ Char
                    message_a8gzt
                    (++ @ Char w1_s8ivi GHC.IO.Exception.untangle2))) } in
      case ww2_i8hm5 of {
        [] -> jump $w$j_s8ivk ww1_i8hm4 (GHC.Types.[] @ Char);
        : ds_d8hmg det_a8gzA ->
          case ds_d8hmg of { C# ds1_d8hmh ->
          case ds1_d8hmh of {
            __DEFAULT -> jump $w$j_s8ivk ww1_i8hm4 (GHC.Types.[] @ Char);
            '|'# ->
              jump $w$j_s8ivk
                ww1_i8hm4 (GHC.Types.: @ Char GHC.IO.Exception.untangle1 det_a8gzA)
          }
          }
      }
      }

-- RHS size: {terms: 42, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$ccompare
  :: AsyncException -> AsyncException -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [140 170] 170 130}]
GHC.IO.Exception.$fOrdAsyncException_$ccompare
  = \ (a_a8gLq :: AsyncException) (b_a8gLr :: AsyncException) ->
      case a_a8gLq of {
        StackOverflow ->
          case b_a8gLr of {
            StackOverflow -> GHC.Types.EQ;
            HeapOverflow -> GHC.Types.LT;
            ThreadKilled -> GHC.Types.LT;
            UserInterrupt -> GHC.Types.LT
          };
        HeapOverflow ->
          case b_a8gLr of {
            StackOverflow -> GHC.Types.GT;
            HeapOverflow -> GHC.Types.EQ;
            ThreadKilled -> GHC.Types.LT;
            UserInterrupt -> GHC.Types.LT
          };
        ThreadKilled ->
          case b_a8gLr of {
            __DEFAULT -> GHC.Types.GT;
            ThreadKilled -> GHC.Types.EQ;
            UserInterrupt -> GHC.Types.LT
          };
        UserInterrupt ->
          case b_a8gLr of {
            __DEFAULT -> GHC.Types.GT;
            UserInterrupt -> GHC.Types.EQ
          }
      }

-- RHS size: {terms: 36, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$c<
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [110 140] 140 100}]
GHC.IO.Exception.$fOrdAsyncException_$c<
  = \ (a_a8gLu :: AsyncException) (b_a8gLv :: AsyncException) ->
      case a_a8gLu of {
        StackOverflow ->
          case b_a8gLv of {
            StackOverflow -> GHC.Types.False;
            HeapOverflow -> GHC.Types.True;
            ThreadKilled -> GHC.Types.True;
            UserInterrupt -> GHC.Types.True
          };
        HeapOverflow ->
          case b_a8gLv of {
            __DEFAULT -> GHC.Types.False;
            ThreadKilled -> GHC.Types.True;
            UserInterrupt -> GHC.Types.True
          };
        ThreadKilled ->
          case b_a8gLv of {
            __DEFAULT -> GHC.Types.False;
            UserInterrupt -> GHC.Types.True
          };
        UserInterrupt -> case b_a8gLv of { __DEFAULT -> GHC.Types.False }
      }

-- RHS size: {terms: 36, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$c<=
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [140 110] 140 100}]
GHC.IO.Exception.$fOrdAsyncException_$c<=
  = \ (a_a8gLy :: AsyncException) (b_a8gLz :: AsyncException) ->
      case b_a8gLz of {
        StackOverflow ->
          case a_a8gLy of {
            StackOverflow -> GHC.Types.True;
            HeapOverflow -> GHC.Types.False;
            ThreadKilled -> GHC.Types.False;
            UserInterrupt -> GHC.Types.False
          };
        HeapOverflow ->
          case a_a8gLy of {
            __DEFAULT -> GHC.Types.True;
            ThreadKilled -> GHC.Types.False;
            UserInterrupt -> GHC.Types.False
          };
        ThreadKilled ->
          case a_a8gLy of {
            __DEFAULT -> GHC.Types.True;
            UserInterrupt -> GHC.Types.False
          };
        UserInterrupt -> case a_a8gLy of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 27, types: 6, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$cmax
  :: AsyncException -> AsyncException -> AsyncException
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 80] 100 60}]
GHC.IO.Exception.$fOrdAsyncException_$cmax
  = \ (x_a55d :: AsyncException) (y_a55e :: AsyncException) ->
      case y_a55e of {
        StackOverflow -> x_a55d;
        HeapOverflow ->
          case x_a55d of {
            __DEFAULT -> GHC.IO.Exception.HeapOverflow;
            ThreadKilled -> GHC.IO.Exception.ThreadKilled;
            UserInterrupt -> GHC.IO.Exception.UserInterrupt
          };
        ThreadKilled ->
          case x_a55d of {
            __DEFAULT -> GHC.IO.Exception.ThreadKilled;
            UserInterrupt -> GHC.IO.Exception.UserInterrupt
          };
        UserInterrupt ->
          case x_a55d of { __DEFAULT -> GHC.IO.Exception.UserInterrupt }
      }

-- RHS size: {terms: 36, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$c>=
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [110 140] 140 100}]
GHC.IO.Exception.$fOrdAsyncException_$c>=
  = \ (a_a8gLC :: AsyncException) (b_a8gLD :: AsyncException) ->
      case a_a8gLC of {
        StackOverflow ->
          case b_a8gLD of {
            StackOverflow -> GHC.Types.True;
            HeapOverflow -> GHC.Types.False;
            ThreadKilled -> GHC.Types.False;
            UserInterrupt -> GHC.Types.False
          };
        HeapOverflow ->
          case b_a8gLD of {
            __DEFAULT -> GHC.Types.True;
            ThreadKilled -> GHC.Types.False;
            UserInterrupt -> GHC.Types.False
          };
        ThreadKilled ->
          case b_a8gLD of {
            __DEFAULT -> GHC.Types.True;
            UserInterrupt -> GHC.Types.False
          };
        UserInterrupt -> case b_a8gLD of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$c>
  :: AsyncException -> AsyncException -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_a8gLA [Occ=Once] :: AsyncException)
                 (b_a8gLB [Occ=Once] :: AsyncException) ->
                 GHC.IO.Exception.$fOrdAsyncException_$c< b_a8gLB a_a8gLA}]
GHC.IO.Exception.$fOrdAsyncException_$c>
  = \ (a_a8gLA :: AsyncException) (b_a8gLB :: AsyncException) ->
      GHC.IO.Exception.$fOrdAsyncException_$c< b_a8gLB a_a8gLA

-- RHS size: {terms: 27, types: 6, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException_$cmin
  :: AsyncException -> AsyncException -> AsyncException
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 80] 100 40}]
GHC.IO.Exception.$fOrdAsyncException_$cmin
  = \ (x_a55m :: AsyncException) (y_a55n :: AsyncException) ->
      case y_a55n of {
        StackOverflow ->
          case x_a55m of { __DEFAULT -> GHC.IO.Exception.StackOverflow };
        HeapOverflow ->
          case x_a55m of wild1_Xhi {
            __DEFAULT -> wild1_Xhi;
            ThreadKilled -> GHC.IO.Exception.HeapOverflow;
            UserInterrupt -> GHC.IO.Exception.HeapOverflow
          };
        ThreadKilled ->
          case x_a55m of wild1_Xhi {
            __DEFAULT -> wild1_Xhi;
            UserInterrupt -> GHC.IO.Exception.ThreadKilled
          };
        UserInterrupt -> x_a55m
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fOrdAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord AsyncException
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: AsyncException
                         GHC.IO.Exception.$fEqAsyncException
                         GHC.IO.Exception.$fOrdAsyncException_$ccompare
                         GHC.IO.Exception.$fOrdAsyncException_$c<
                         GHC.IO.Exception.$fOrdAsyncException_$c<=
                         GHC.IO.Exception.$fOrdAsyncException_$c>
                         GHC.IO.Exception.$fOrdAsyncException_$c>=
                         GHC.IO.Exception.$fOrdAsyncException_$cmax
                         GHC.IO.Exception.$fOrdAsyncException_$cmin]
GHC.IO.Exception.$fOrdAsyncException
  = GHC.Classes.C:Ord
      @ AsyncException
      GHC.IO.Exception.$fEqAsyncException
      GHC.IO.Exception.$fOrdAsyncException_$ccompare
      GHC.IO.Exception.$fOrdAsyncException_$c<
      GHC.IO.Exception.$fOrdAsyncException_$c<=
      GHC.IO.Exception.$fOrdAsyncException_$c>
      GHC.IO.Exception.$fOrdAsyncException_$c>=
      GHC.IO.Exception.$fOrdAsyncException_$cmax
      GHC.IO.Exception.$fOrdAsyncException_$cmin

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$trModule3
  = GHC.Types.TrNameS GHC.IO.Exception.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$trModule2 = "GHC.IO.Exception"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$trModule1
  = GHC.Types.TrNameS GHC.IO.Exception.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.IO.Exception.$trModule
  = GHC.Types.Module
      GHC.IO.Exception.$trModule3 GHC.IO.Exception.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r8j3f :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r8j3f
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r8j3g :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r8j3g
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r8j3h :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r8j3h
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r8j3i :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r8j3i
  = GHC.Types.KindRepTyConApp
      GHC.IO.Handle.Types.$tcHandle (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4_r8j3j :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_r8j3j
  = GHC.Types.: @ KindRep $krep1_r8j3g (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r8j3k :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep5_r8j3k
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep4_r8j3j

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_r8j3l :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_r8j3l
  = GHC.Types.: @ KindRep $krep3_r8j3i (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_r8j3m :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_r8j3m
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep6_r8j3l

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep8_r8j3n :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep8_r8j3n
  = GHC.Types.: @ KindRep $krep2_r8j3h (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r8j3o :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_r8j3o
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep8_r8j3n

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep10_r8j3p :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep10_r8j3p
  = GHC.Types.: @ KindRep $krep9_r8j3o (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r8j3q :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_r8j3q
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep10_r8j3p

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep12_r8j3r :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep12_r8j3r = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep13_r8j3s :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep13_r8j3s
  = GHC.Types.: @ KindRep $krep12_r8j3r (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_r8j3t :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_r8j3t
  = GHC.Types.KindRepTyConApp
      GHC.Exception.$tcException $krep13_r8j3s

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5
  = "BlockedIndefinitelyOnMVar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4
  = GHC.Types.TrNameS
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar
  = GHC.Types.TyCon
      5532209509574600699##
      13011219155706606307##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcBlockedIndefinitelyOnMVar
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3
  = "'BlockedIndefinitelyOnMVar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar
  = GHC.Types.TyCon
      6834741829236713234##
      5957659317954655195##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar2
      0#
      GHC.IO.Exception.$tc'BlockedIndefinitelyOnMVar1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3
  :: Data.Typeable.Internal.TypeRep BlockedIndefinitelyOnMVar
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ BlockedIndefinitelyOnMVar
           5532209509574600699##
           13011219155706606307##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ BlockedIndefinitelyOnMVar
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5
  = "BlockedIndefinitelyOnSTM"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4
  = GHC.Types.TrNameS
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM
  = GHC.Types.TyCon
      13946898568638194917##
      3504019511763148288##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcBlockedIndefinitelyOnSTM
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3
  = "'BlockedIndefinitelyOnSTM"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM
  = GHC.Types.TyCon
      13856829326869447687##
      12209020643191939554##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM2
      0#
      GHC.IO.Exception.$tc'BlockedIndefinitelyOnSTM1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3
  :: Data.Typeable.Internal.TypeRep BlockedIndefinitelyOnSTM
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ BlockedIndefinitelyOnSTM
           13946898568638194917##
           3504019511763148288##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ BlockedIndefinitelyOnSTM
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.IO.Exception.$fExceptionDeadlock5 = "Deadlock"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionDeadlock4
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionDeadlock5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcDeadlock :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcDeadlock
  = GHC.Types.TyCon
      18363794241794644491##
      11186984538024031318##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionDeadlock4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Deadlock1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'Deadlock1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcDeadlock (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Deadlock3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'Deadlock3 = "'Deadlock"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Deadlock2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'Deadlock2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'Deadlock3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Deadlock :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'Deadlock
  = GHC.Types.TyCon
      8732553870978897242##
      16079179228471909431##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'Deadlock2
      0#
      GHC.IO.Exception.$tc'Deadlock1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock3
  :: Data.Typeable.Internal.TypeRep Deadlock
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionDeadlock3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Deadlock
           18363794241794644491##
           11186984538024031318##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionDeadlock4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Deadlock ww8_i8htw ww9_i8htx ww10_i8hty ww11_i8htz ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock_$cfromException
  :: SomeException -> Maybe Deadlock
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionDeadlock_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ Deadlock
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionDeadlock3
      of {
        False -> GHC.Base.Nothing @ Deadlock;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW Deadlock))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe Deadlock :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception Deadlock
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: Deadlock
                                 GHC.IO.Exception.$fExceptionDeadlock3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Deadlock>_N
                                         :: (Data.Typeable.Internal.TypeRep Deadlock :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   Deadlock :: Constraint))
                                 GHC.IO.Exception.$fShowDeadlock
                                 GHC.IO.Exception.$fExceptionDeadlock_$ctoException
                                 GHC.IO.Exception.$fExceptionDeadlock_$cfromException
                                 GHC.IO.Exception.$fExceptionDeadlock_$cshow]
GHC.IO.Exception.$fExceptionDeadlock
  = GHC.Exception.C:Exception
      @ Deadlock
      (GHC.IO.Exception.$fExceptionDeadlock3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Deadlock>_N
               :: (Data.Typeable.Internal.TypeRep Deadlock :: *)
                  ~R# (Data.Typeable.Internal.Typeable Deadlock :: Constraint)))
      GHC.IO.Exception.$fShowDeadlock
      GHC.IO.Exception.$fExceptionDeadlock_$ctoException
      GHC.IO.Exception.$fExceptionDeadlock_$cfromException
      GHC.IO.Exception.$fExceptionDeadlock_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionDeadlock_$ctoException [Occ=LoopBreaker]
  :: Deadlock -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionDeadlock_$ctoException
  = GHC.Exception.SomeException
      @ Deadlock GHC.IO.Exception.$fExceptionDeadlock
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded5
  = "AllocationLimitExceeded"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded4
  = GHC.Types.TrNameS
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcAllocationLimitExceeded :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcAllocationLimitExceeded
  = GHC.Types.TyCon
      13160607835047152551##
      6828489586181860176##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AllocationLimitExceeded1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'AllocationLimitExceeded1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcAllocationLimitExceeded
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AllocationLimitExceeded3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$tc'AllocationLimitExceeded3
  = "'AllocationLimitExceeded"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AllocationLimitExceeded2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'AllocationLimitExceeded2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'AllocationLimitExceeded3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AllocationLimitExceeded :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'AllocationLimitExceeded
  = GHC.Types.TyCon
      14911686161474736107##
      16735957051754280572##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'AllocationLimitExceeded2
      0#
      GHC.IO.Exception.$tc'AllocationLimitExceeded1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded3
  :: Data.Typeable.Internal.TypeRep AllocationLimitExceeded
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ AllocationLimitExceeded
           13160607835047152551##
           6828489586181860176##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionAllocationLimitExceeded4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ AllocationLimitExceeded
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionCompactionFailed4 = "CompactionFailed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionCompactionFailed3
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionCompactionFailed4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcCompactionFailed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcCompactionFailed
  = GHC.Types.TyCon
      7633933266579528523##
      6393060685738357435##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionCompactionFailed3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep15_r8j3u :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep15_r8j3u
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcCompactionFailed (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'CompactionFailed1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'CompactionFailed1
  = GHC.Types.KindRepFun $krep9_r8j3o $krep15_r8j3u

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'CompactionFailed3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'CompactionFailed3 = "'CompactionFailed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'CompactionFailed2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'CompactionFailed2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'CompactionFailed3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'CompactionFailed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'CompactionFailed
  = GHC.Types.TyCon
      5917738941224226344##
      8436844331187314000##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'CompactionFailed2
      0#
      GHC.IO.Exception.$tc'CompactionFailed1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed2
  :: Data.Typeable.Internal.TypeRep CompactionFailed
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionCompactionFailed2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ CompactionFailed
           7633933266579528523##
           6393060685738357435##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionCompactionFailed3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ CompactionFailed
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAssertionFailed4 = "AssertionFailed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionAssertionFailed3
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionAssertionFailed4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcAssertionFailed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcAssertionFailed
  = GHC.Types.TyCon
      7013231185527166567##
      11481669896152761825##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionAssertionFailed3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep16_r8j3v :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep16_r8j3v
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcAssertionFailed (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AssertionFailed1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'AssertionFailed1
  = GHC.Types.KindRepFun $krep9_r8j3o $krep16_r8j3v

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AssertionFailed3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'AssertionFailed3 = "'AssertionFailed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AssertionFailed2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'AssertionFailed2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'AssertionFailed3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AssertionFailed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'AssertionFailed
  = GHC.Types.TyCon
      6421416346863765662##
      16131786633010342764##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'AssertionFailed2
      0#
      GHC.IO.Exception.$tc'AssertionFailed1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed2
  :: Data.Typeable.Internal.TypeRep AssertionFailed
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionAssertionFailed2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ AssertionFailed
           7013231185527166567##
           11481669896152761825##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionAssertionFailed3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ AssertionFailed
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException
  :: SomeException -> Maybe AssertionFailed
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ AssertionFailed
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionAssertionFailed2
      of {
        False -> GHC.Base.Nothing @ AssertionFailed;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW AssertionFailed))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe AssertionFailed :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception AssertionFailed
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: AssertionFailed
                                 GHC.IO.Exception.$fExceptionAssertionFailed2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AssertionFailed>_N
                                         :: (Data.Typeable.Internal.TypeRep AssertionFailed :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   AssertionFailed :: Constraint))
                                 GHC.IO.Exception.$fShowAssertionFailed
                                 GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException
                                 GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException
                                 GHC.IO.Exception.$fExceptionAssertionFailed1
                                 `cast` (<AssertionFailed>_R
                                         ->_R GHC.IO.Exception.N:AssertionFailed[0]
                                         :: (AssertionFailed -> AssertionFailed :: *)
                                            ~R# (AssertionFailed -> String :: *))]
GHC.IO.Exception.$fExceptionAssertionFailed
  = GHC.Exception.C:Exception
      @ AssertionFailed
      (GHC.IO.Exception.$fExceptionAssertionFailed2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AssertionFailed>_N
               :: (Data.Typeable.Internal.TypeRep AssertionFailed :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         AssertionFailed :: Constraint)))
      GHC.IO.Exception.$fShowAssertionFailed
      GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException
      GHC.IO.Exception.$fExceptionAssertionFailed_$cfromException
      (GHC.IO.Exception.$fExceptionAssertionFailed1
       `cast` (<AssertionFailed>_R
               ->_R GHC.IO.Exception.N:AssertionFailed[0]
               :: (AssertionFailed -> AssertionFailed :: *)
                  ~R# (AssertionFailed -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException [Occ=LoopBreaker]
  :: AssertionFailed -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException
  = GHC.Exception.SomeException
      @ AssertionFailed GHC.IO.Exception.$fExceptionAssertionFailed
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl38_r8j3w :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl38_r8j3w = "Assertion failed\n"#

-- RHS size: {terms: 57, types: 90, coercions: 5, joins: 0/2}
GHC.IO.Exception.assertError1
  :: forall a.
     (?callStack::CallStack) =>
     [String] -> State# RealWorld -> (# State# RealWorld, a #)
[GblId, Arity=3, Str=<B,1*U><B,1*U><B,U>x, Unf=OtherCon []]
GHC.IO.Exception.assertError1
  = \ (@ a_a8gPl)
      ($dIP_a8gPn :: ?callStack::CallStack)
      (ipv1_i7IAz :: [String])
      (ipv_i7IAy :: State# RealWorld) ->
      raiseIO#
        @ SomeException
        @ a_a8gPl
        (GHC.IO.Exception.$fExceptionAssertionFailed_$ctoException
           ((unpackAppendCString#
               lvl38_r8j3w
               (let {
                  n_i7JbW :: [[Char]]
                  [LclId]
                  n_i7JbW
                    = case ipv1_i7IAz of wild_i8hnd {
                        [] -> GHC.Types.[] @ String;
                        : ipv2_i8hnj ipv3_i8hnk ->
                          GHC.Types.:
                            @ [Char]
                            GHC.Exception.errorCallWithCallStackException11
                            (map
                               @ [Char]
                               @ [Char]
                               GHC.Exception.errorCallWithCallStackException9
                               (GHC.List.reverse1 @ String wild_i8hnd (GHC.Types.[] @ String)))
                      } } in
                case getCallStack
                       ($dIP_a8gPn
                        `cast` (GHC.Classes.N:IP[0] <"callStack">_N <CallStack>_N
                                :: (?callStack::CallStack :: Constraint) ~R# (CallStack :: *)))
                of wild_i8hn0 {
                  [] ->
                    case n_i7JbW of {
                      [] -> GHC.Types.[] @ Char;
                      : x_i8hmU xs1_i8hmV ->
                        Data.OldList.intercalate1
                          @ Char
                          (GHC.Types.:
                             @ [Char]
                             x_i8hmU
                             (Data.OldList.prependToAll
                                @ [Char] GHC.IO.Exception.untangle2 xs1_i8hmV))
                    };
                  : ipv2_i8hn7 ipv3_i8hn8 ->
                    Data.OldList.intercalate1
                      @ Char
                      (GHC.Types.:
                         @ [Char]
                         GHC.Exception.errorCallWithCallStackException6
                         (letrec {
                            go_i7Jcj [Occ=LoopBreaker] :: [([Char], SrcLoc)] -> [[Char]]
                            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                            go_i7Jcj
                              = \ (ds_i7Jck :: [([Char], SrcLoc)]) ->
                                  case ds_i7Jck of {
                                    [] -> n_i7JbW;
                                    : y_i7Jcp ys_i7Jcq ->
                                      GHC.Types.:
                                        @ [Char]
                                        (GHC.Exception.errorCallWithCallStackException1 y_i7Jcp)
                                        (go_i7Jcj ys_i7Jcq)
                                  }; } in
                          Data.OldList.prependToAll
                            @ [Char] GHC.IO.Exception.untangle2 (go_i7Jcj wild_i8hn0)))
                }))
            `cast` (Sym (GHC.IO.Exception.N:AssertionFailed[0])
                    :: (String :: *) ~R# (AssertionFailed :: *))))
        ipv_i7IAy

-- RHS size: {terms: 23, types: 55, coercions: 3, joins: 0/0}
assertError :: forall a. (?callStack::CallStack) => Bool -> a -> a
[GblId,
 Arity=3,
 Str=<L,1*U><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 50 0] 120 0}]
assertError
  = \ (@ a_a8gPl)
      ($dIP_a8gPn :: ?callStack::CallStack)
      (predicate_a8gzm :: Bool)
      (v_a8gzn :: a_a8gPl) ->
      case predicate_a8gzm of {
        False ->
          case runRW#
                 @ ('TupleRep '['TupleRep '[], 'LiftedRep])
                 @ (# State# RealWorld, a_a8gPl #)
                 (\ (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
                    case (currentCallStack
                          `cast` (GHC.Types.N:IO[0] <[String]>_R
                                  :: (IO [String] :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, [String] #) :: *)))
                           s_i7IAv
                    of
                    { (# ipv_i7IAy, ipv1_i7IAz #) ->
                    GHC.IO.Exception.assertError1
                      @ a_a8gPl $dIP_a8gPn ipv1_i7IAz ipv_i7IAy
                    })
          of
          { (# ipv_i8hmF, ipv1_i8hmG #) ->
          ipv1_i8hmG
          };
        True -> lazy @ a_a8gPl v_a8gzn
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded8
  = "SomeAsyncException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded7 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded7
  = GHC.Types.TrNameS
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded8

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcSomeAsyncException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcSomeAsyncException
  = GHC.Types.TyCon
      7698277271892269964##
      12603180528693821542##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded7
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep17_r8j3x :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep17_r8j3x
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcSomeAsyncException (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep18_r8j3y :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep18_r8j3y = GHC.Types.KindRepFun $krep12_r8j3r $krep17_r8j3x

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SomeAsyncException1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'SomeAsyncException1
  = GHC.Types.KindRepFun $krep14_r8j3t $krep18_r8j3y

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SomeAsyncException3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'SomeAsyncException3 = "'SomeAsyncException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SomeAsyncException2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'SomeAsyncException2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'SomeAsyncException3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SomeAsyncException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'SomeAsyncException
  = GHC.Types.TyCon
      2590663161510005226##
      12089333203895315586##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'SomeAsyncException2
      1#
      GHC.IO.Exception.$tc'SomeAsyncException1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
  :: Data.Typeable.Internal.TypeRep SomeAsyncException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ SomeAsyncException
           7698277271892269964##
           12603180528693821542##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionAllocationLimitExceeded7
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ SomeAsyncException
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException
  :: SomeException -> Maybe SomeAsyncException
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ SomeAsyncException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
      of {
        False -> GHC.Base.Nothing @ SomeAsyncException;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW SomeAsyncException))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe SomeAsyncException :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionSomeAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception SomeAsyncException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: SomeAsyncException
                                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SomeAsyncException>_N
                                         :: (Data.Typeable.Internal.TypeRep SomeAsyncException :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   SomeAsyncException :: Constraint))
                                 GHC.IO.Exception.$fShowSomeAsyncException
                                 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
                                 GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException
                                 GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow]
GHC.IO.Exception.$fExceptionSomeAsyncException
  = GHC.Exception.C:Exception
      @ SomeAsyncException
      (GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SomeAsyncException>_N
               :: (Data.Typeable.Internal.TypeRep SomeAsyncException :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         SomeAsyncException :: Constraint)))
      GHC.IO.Exception.$fShowSomeAsyncException
      GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
      GHC.IO.Exception.$fExceptionSomeAsyncException_$cfromException
      GHC.IO.Exception.$fExceptionSomeAsyncException_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException [Occ=LoopBreaker]
  :: SomeAsyncException -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
  = GHC.Exception.SomeException
      @ SomeAsyncException GHC.IO.Exception.$fExceptionSomeAsyncException
end Rec }

-- RHS size: {terms: 28, types: 37, coercions: 21, joins: 0/0}
asyncExceptionFromException
  :: forall e. Exception e => SomeException -> Maybe e
[GblId,
 Arity=2,
 Str=<L,1*U(1*U,A,A,A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 20] 190 40}]
asyncExceptionFromException
  = \ (@ e_a8gQw)
      ($dException_a8gQy :: Exception e_a8gQw)
      (eta_B1 :: SomeException) ->
      case eta_B1 of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ SomeAsyncException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
      of {
        False -> GHC.Base.Nothing @ e_a8gQw;
        True ->
          case e2_i8hqY
               `cast` (UnsafeCo representational e1_i8hqW SomeAsyncException
                       :: (e1_i8hqW :: *) ~R# (SomeAsyncException :: *))
          of
          { SomeAsyncException @ e4_a8gQF $dException2_a8gQG a_a8gzj ->
          case Data.Typeable.Internal.sameTypeRep
                 @ *
                 @ *
                 @ e4_a8gQF
                 @ e_a8gQw
                 ((GHC.Exception.$p1Exception @ e4_a8gQF $dException2_a8gQG)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e4_a8gQF>_N
                          :: (Data.Typeable.Internal.Typeable e4_a8gQF :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep e4_a8gQF :: *)))
                 ((GHC.Exception.$p1Exception @ e_a8gQw $dException_a8gQy)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_a8gQw>_N
                          :: (Data.Typeable.Internal.Typeable e_a8gQw :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep e_a8gQw :: *)))
          of {
            False -> GHC.Base.Nothing @ e_a8gQw;
            True ->
              (GHC.Base.Just @ e4_a8gQF a_a8gzj)
              `cast` ((Maybe (UnsafeCo representational e4_a8gQF e_a8gQw))_R
                      :: (Maybe e4_a8gQF :: *) ~R# (Maybe e_a8gQw :: *))
          }
          }
      }
      }

-- RHS size: {terms: 7, types: 6, coercions: 0, joins: 0/0}
asyncExceptionToException
  :: forall e. Exception e => e -> SomeException
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a8gQQ)
                 ($dException_a8gQS [Occ=Once] :: Exception e_a8gQQ)
                 (x_i7Rxi [Occ=Once] :: e_a8gQQ) ->
                 GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
                   (GHC.IO.Exception.SomeAsyncException
                      @ e_a8gQQ $dException_a8gQS x_i7Rxi)}]
asyncExceptionToException
  = \ (@ e_a8gQQ)
      ($dException_a8gQS :: Exception e_a8gQQ)
      (x_i7Rxi :: e_a8gQQ) ->
      GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
        (GHC.IO.Exception.SomeAsyncException
           @ e_a8gQQ $dException_a8gQS x_i7Rxi)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException11 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionAsyncException11 = "AsyncException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException10 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionAsyncException10
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionAsyncException11

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcAsyncException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcAsyncException
  = GHC.Types.TyCon
      3223192752092240512##
      6151543105744102738##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionAsyncException10
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HeapOverflow1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'HeapOverflow1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcAsyncException (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'StackOverflow2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'StackOverflow2 = "'StackOverflow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'StackOverflow1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'StackOverflow1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'StackOverflow2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'StackOverflow :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'StackOverflow
  = GHC.Types.TyCon
      7140728310745047686##
      9210977118047764825##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'StackOverflow1
      0#
      GHC.IO.Exception.$tc'HeapOverflow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HeapOverflow3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'HeapOverflow3 = "'HeapOverflow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HeapOverflow2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'HeapOverflow2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'HeapOverflow3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HeapOverflow :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'HeapOverflow
  = GHC.Types.TyCon
      6603650813243937168##
      2046005135570222520##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'HeapOverflow2
      0#
      GHC.IO.Exception.$tc'HeapOverflow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ThreadKilled2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'ThreadKilled2 = "'ThreadKilled"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ThreadKilled1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ThreadKilled1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ThreadKilled2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ThreadKilled :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ThreadKilled
  = GHC.Types.TyCon
      13600447017231937444##
      101896852196063416##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ThreadKilled1
      0#
      GHC.IO.Exception.$tc'HeapOverflow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserInterrupt2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'UserInterrupt2 = "'UserInterrupt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserInterrupt1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'UserInterrupt1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'UserInterrupt2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserInterrupt :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'UserInterrupt
  = GHC.Types.TyCon
      1214873852534998649##
      13851718192780849484##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'UserInterrupt1
      0#
      GHC.IO.Exception.$tc'HeapOverflow1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException9
  :: Data.Typeable.Internal.TypeRep AsyncException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionAsyncException9
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ AsyncException
           3223192752092240512##
           6151543105744102738##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionAsyncException10
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ AsyncException
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionArrayException7 = "ArrayException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException6 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionArrayException6
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionArrayException7

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcArrayException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcArrayException
  = GHC.Types.TyCon
      14361659568498315305##
      6805143727974531880##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionArrayException6
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep19_r8j3z :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep19_r8j3z
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcArrayException (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IndexOutOfBounds1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'IndexOutOfBounds1
  = GHC.Types.KindRepFun $krep9_r8j3o $krep19_r8j3z

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IndexOutOfBounds3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'IndexOutOfBounds3 = "'IndexOutOfBounds"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IndexOutOfBounds2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'IndexOutOfBounds2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'IndexOutOfBounds3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IndexOutOfBounds :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'IndexOutOfBounds
  = GHC.Types.TyCon
      14241149568806879436##
      10551655754853710333##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'IndexOutOfBounds2
      0#
      GHC.IO.Exception.$tc'IndexOutOfBounds1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UndefinedElement2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'UndefinedElement2 = "'UndefinedElement"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UndefinedElement1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'UndefinedElement1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'UndefinedElement2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UndefinedElement :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'UndefinedElement
  = GHC.Types.TyCon
      9439210122732754255##
      8562757414325900819##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'UndefinedElement1
      0#
      GHC.IO.Exception.$tc'IndexOutOfBounds1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException5
  :: Data.Typeable.Internal.TypeRep ArrayException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionArrayException5
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ ArrayException
           14361659568498315305##
           6805143727974531880##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionArrayException6
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ ArrayException
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException_$cfromException
  :: SomeException -> Maybe ArrayException
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionArrayException_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ ArrayException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionArrayException5
      of {
        False -> GHC.Base.Nothing @ ArrayException;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW ArrayException))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe ArrayException :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception ArrayException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: ArrayException
                                 GHC.IO.Exception.$fExceptionArrayException5
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ArrayException>_N
                                         :: (Data.Typeable.Internal.TypeRep ArrayException :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   ArrayException :: Constraint))
                                 GHC.IO.Exception.$fShowArrayException
                                 GHC.IO.Exception.$fExceptionArrayException_$ctoException
                                 GHC.IO.Exception.$fExceptionArrayException_$cfromException
                                 GHC.IO.Exception.$fExceptionArrayException_$cshow]
GHC.IO.Exception.$fExceptionArrayException
  = GHC.Exception.C:Exception
      @ ArrayException
      (GHC.IO.Exception.$fExceptionArrayException5
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ArrayException>_N
               :: (Data.Typeable.Internal.TypeRep ArrayException :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         ArrayException :: Constraint)))
      GHC.IO.Exception.$fShowArrayException
      GHC.IO.Exception.$fExceptionArrayException_$ctoException
      GHC.IO.Exception.$fExceptionArrayException_$cfromException
      GHC.IO.Exception.$fExceptionArrayException_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionArrayException_$ctoException [Occ=LoopBreaker]
  :: ArrayException -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionArrayException_$ctoException
  = GHC.Exception.SomeException
      @ ArrayException GHC.IO.Exception.$fExceptionArrayException
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$fExceptionFixIOException5 = "FixIOException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionFixIOException4
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionFixIOException5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcFixIOException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcFixIOException
  = GHC.Types.TyCon
      175794591112768165##
      12820711924146365796##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionFixIOException4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'FixIOException1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'FixIOException1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcFixIOException (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'FixIOException3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'FixIOException3 = "'FixIOException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'FixIOException2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'FixIOException2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'FixIOException3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'FixIOException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'FixIOException
  = GHC.Types.TyCon
      1253631570386628537##
      15724415228749653558##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'FixIOException2
      0#
      GHC.IO.Exception.$tc'FixIOException1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException3
  :: Data.Typeable.Internal.TypeRep FixIOException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionFixIOException3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ FixIOException
           175794591112768165##
           12820711924146365796##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionFixIOException4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ FixIOException
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException_$cfromException
  :: SomeException -> Maybe FixIOException
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionFixIOException_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ FixIOException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionFixIOException3
      of {
        False -> GHC.Base.Nothing @ FixIOException;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW FixIOException))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe FixIOException :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception FixIOException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: FixIOException
                                 GHC.IO.Exception.$fExceptionFixIOException3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <FixIOException>_N
                                         :: (Data.Typeable.Internal.TypeRep FixIOException :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   FixIOException :: Constraint))
                                 GHC.IO.Exception.$fShowFixIOException
                                 GHC.IO.Exception.$fExceptionFixIOException_$ctoException
                                 GHC.IO.Exception.$fExceptionFixIOException_$cfromException
                                 GHC.IO.Exception.$fExceptionFixIOException_$cshow]
GHC.IO.Exception.$fExceptionFixIOException
  = GHC.Exception.C:Exception
      @ FixIOException
      (GHC.IO.Exception.$fExceptionFixIOException3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <FixIOException>_N
               :: (Data.Typeable.Internal.TypeRep FixIOException :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         FixIOException :: Constraint)))
      GHC.IO.Exception.$fShowFixIOException
      GHC.IO.Exception.$fExceptionFixIOException_$ctoException
      GHC.IO.Exception.$fExceptionFixIOException_$cfromException
      GHC.IO.Exception.$fExceptionFixIOException_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionFixIOException_$ctoException [Occ=LoopBreaker]
  :: FixIOException -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionFixIOException_$ctoException
  = GHC.Exception.SomeException
      @ FixIOException GHC.IO.Exception.$fExceptionFixIOException
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.IO.Exception.$fExceptionExitCode6 = "ExitCode"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode5 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionExitCode5
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionExitCode6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcExitCode :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcExitCode
  = GHC.Types.TyCon
      8177210543059932106##
      3694335570555580912##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionExitCode5
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitSuccess1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'ExitSuccess1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcExitCode (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitSuccess3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'ExitSuccess3 = "'ExitSuccess"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitSuccess2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ExitSuccess2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ExitSuccess3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitSuccess :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ExitSuccess
  = GHC.Types.TyCon
      6011095708053053284##
      14896688531190285489##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ExitSuccess2
      0#
      GHC.IO.Exception.$tc'ExitSuccess1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitFailure1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'ExitFailure1
  = GHC.Types.KindRepFun
      $krep_r8j3f GHC.IO.Exception.$tc'ExitSuccess1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitFailure3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'ExitFailure3 = "'ExitFailure"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitFailure2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ExitFailure2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ExitFailure3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ExitFailure :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ExitFailure
  = GHC.Types.TyCon
      13149331685465745995##
      10453046320643141131##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ExitFailure2
      0#
      GHC.IO.Exception.$tc'ExitFailure1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode4
  :: Data.Typeable.Internal.TypeRep ExitCode
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionExitCode4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ ExitCode
           8177210543059932106##
           3694335570555580912##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionExitCode5
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ ExitCode ww8_i8htw ww9_i8htx ww10_i8hty ww11_i8htz ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode_$cfromException
  :: SomeException -> Maybe ExitCode
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionExitCode_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ ExitCode
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionExitCode4
      of {
        False -> GHC.Base.Nothing @ ExitCode;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW ExitCode))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe ExitCode :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception ExitCode
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: ExitCode
                                 GHC.IO.Exception.$fExceptionExitCode4
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ExitCode>_N
                                         :: (Data.Typeable.Internal.TypeRep ExitCode :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   ExitCode :: Constraint))
                                 GHC.IO.Exception.$fShowExitCode
                                 GHC.IO.Exception.$fExceptionExitCode_$ctoException
                                 GHC.IO.Exception.$fExceptionExitCode_$cfromException
                                 GHC.IO.Exception.$fExceptionExitCode_$cshow]
GHC.IO.Exception.$fExceptionExitCode
  = GHC.Exception.C:Exception
      @ ExitCode
      (GHC.IO.Exception.$fExceptionExitCode4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ExitCode>_N
               :: (Data.Typeable.Internal.TypeRep ExitCode :: *)
                  ~R# (Data.Typeable.Internal.Typeable ExitCode :: Constraint)))
      GHC.IO.Exception.$fShowExitCode
      GHC.IO.Exception.$fExceptionExitCode_$ctoException
      GHC.IO.Exception.$fExceptionExitCode_$cfromException
      GHC.IO.Exception.$fExceptionExitCode_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionExitCode_$ctoException [Occ=LoopBreaker]
  :: ExitCode -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionExitCode_$ctoException
  = GHC.Exception.SomeException
      @ ExitCode GHC.IO.Exception.$fExceptionExitCode
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcIOErrorType2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tcIOErrorType2 = "IOErrorType"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcIOErrorType1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tcIOErrorType1
  = GHC.Types.TrNameS GHC.IO.Exception.$tcIOErrorType2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcIOErrorType :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcIOErrorType
  = GHC.Types.TyCon
      13260403802836574836##
      9962456285013293537##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tcIOErrorType1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AlreadyExists1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.Exception.$tc'AlreadyExists1
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcIOErrorType (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AlreadyExists3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'AlreadyExists3 = "'AlreadyExists"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AlreadyExists2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'AlreadyExists2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'AlreadyExists3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'AlreadyExists :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'AlreadyExists
  = GHC.Types.TyCon
      13383994725479033447##
      16077735236426702934##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'AlreadyExists2
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'NoSuchThing2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'NoSuchThing2 = "'NoSuchThing"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'NoSuchThing1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'NoSuchThing1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'NoSuchThing2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'NoSuchThing :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'NoSuchThing
  = GHC.Types.TyCon
      1065788776620214811##
      7708272823769791518##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'NoSuchThing1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceBusy2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'ResourceBusy2 = "'ResourceBusy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceBusy1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ResourceBusy1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ResourceBusy2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceBusy :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ResourceBusy
  = GHC.Types.TyCon
      81041156937828521##
      16732677038738772765##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ResourceBusy1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceExhausted2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'ResourceExhausted2 = "'ResourceExhausted"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceExhausted1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ResourceExhausted1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ResourceExhausted2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceExhausted :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ResourceExhausted
  = GHC.Types.TyCon
      661664682644939150##
      17978068149744050586##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ResourceExhausted1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'EOF2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.$tc'EOF2 = "'EOF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'EOF1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'EOF1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'EOF2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'EOF :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'EOF
  = GHC.Types.TyCon
      15446447841260182649##
      9615135582901540009##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'EOF1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IllegalOperation2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'IllegalOperation2 = "'IllegalOperation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IllegalOperation1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'IllegalOperation1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'IllegalOperation2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IllegalOperation :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'IllegalOperation
  = GHC.Types.TyCon
      2997750042243464947##
      13732497530673208550##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'IllegalOperation1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'PermissionDenied2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'PermissionDenied2 = "'PermissionDenied"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'PermissionDenied1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'PermissionDenied1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'PermissionDenied2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'PermissionDenied :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'PermissionDenied
  = GHC.Types.TyCon
      17002959889944859215##
      11679101384562499698##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'PermissionDenied1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserError2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'UserError2 = "'UserError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserError1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'UserError1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'UserError2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UserError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'UserError
  = GHC.Types.TyCon
      2110707588451626880##
      793010194601470118##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'UserError1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsatisfiedConstraints2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$tc'UnsatisfiedConstraints2
  = "'UnsatisfiedConstraints"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsatisfiedConstraints1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'UnsatisfiedConstraints1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'UnsatisfiedConstraints2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsatisfiedConstraints :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'UnsatisfiedConstraints
  = GHC.Types.TyCon
      7774786765253276509##
      11159080782866109022##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'UnsatisfiedConstraints1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SystemError2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'SystemError2 = "'SystemError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SystemError1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'SystemError1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'SystemError2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'SystemError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'SystemError
  = GHC.Types.TyCon
      14723310935893761222##
      8619015840207109406##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'SystemError1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ProtocolError2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'ProtocolError2 = "'ProtocolError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ProtocolError1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ProtocolError1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ProtocolError2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ProtocolError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ProtocolError
  = GHC.Types.TyCon
      2348878698518162749##
      1616623917153004368##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ProtocolError1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'OtherError2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'OtherError2 = "'OtherError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'OtherError1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'OtherError1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'OtherError2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'OtherError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'OtherError
  = GHC.Types.TyCon
      11457353566076247204##
      7448318885269020484##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'OtherError1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InvalidArgument2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'InvalidArgument2 = "'InvalidArgument"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InvalidArgument1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'InvalidArgument1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'InvalidArgument2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InvalidArgument :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'InvalidArgument
  = GHC.Types.TyCon
      2877905627043716713##
      870624010466166536##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'InvalidArgument1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InappropriateType2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'InappropriateType2 = "'InappropriateType"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InappropriateType1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'InappropriateType1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'InappropriateType2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'InappropriateType :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'InappropriateType
  = GHC.Types.TyCon
      12194312324817842633##
      15900888301186079347##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'InappropriateType1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HardwareFault2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.IO.Exception.$tc'HardwareFault2 = "'HardwareFault"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HardwareFault1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'HardwareFault1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'HardwareFault2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'HardwareFault :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'HardwareFault
  = GHC.Types.TyCon
      56378797976289033##
      18431513512258190916##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'HardwareFault1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsupportedOperation2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.$tc'UnsupportedOperation2
  = "'UnsupportedOperation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsupportedOperation1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'UnsupportedOperation1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'UnsupportedOperation2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'UnsupportedOperation :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'UnsupportedOperation
  = GHC.Types.TyCon
      8512525638220727204##
      8859286885870192330##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'UnsupportedOperation1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'TimeExpired2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'TimeExpired2 = "'TimeExpired"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'TimeExpired1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'TimeExpired1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'TimeExpired2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'TimeExpired :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'TimeExpired
  = GHC.Types.TyCon
      10911629093425571025##
      350480745296812363##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'TimeExpired1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceVanished2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.Exception.$tc'ResourceVanished2 = "'ResourceVanished"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceVanished1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'ResourceVanished1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'ResourceVanished2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'ResourceVanished :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'ResourceVanished
  = GHC.Types.TyCon
      14859807110076739958##
      15612633629389469803##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'ResourceVanished1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Interrupted2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$tc'Interrupted2 = "'Interrupted"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Interrupted1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'Interrupted1
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'Interrupted2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'Interrupted :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'Interrupted
  = GHC.Types.TyCon
      17492795632142579451##
      15910845476779721305##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'Interrupted1
      0#
      GHC.IO.Exception.$tc'AlreadyExists1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.Exception.$fExceptionIOException6 = "IOException"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException5 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$fExceptionIOException5
  = GHC.Types.TrNameS GHC.IO.Exception.$fExceptionIOException6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tcIOException :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tcIOException
  = GHC.Types.TyCon
      10434000377887324342##
      16509375198449321302##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$fExceptionIOException5
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep20_r8j3A :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep20_r8j3A
  = GHC.Types.KindRepTyConApp
      GHC.IO.Exception.$tcIOException (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep21_r8j3B :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep21_r8j3B = GHC.Types.KindRepFun $krep11_r8j3q $krep20_r8j3A

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep22_r8j3C :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep22_r8j3C = GHC.Types.KindRepFun $krep5_r8j3k $krep21_r8j3B

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep23_r8j3D :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep23_r8j3D = GHC.Types.KindRepFun $krep9_r8j3o $krep22_r8j3C

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep24_r8j3E :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep24_r8j3E = GHC.Types.KindRepFun $krep9_r8j3o $krep23_r8j3D

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25_r8j3F :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep25_r8j3F
  = GHC.Types.KindRepFun
      GHC.IO.Exception.$tc'AlreadyExists1 $krep24_r8j3E

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IOError1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.IO.Exception.$tc'IOError1
  = GHC.Types.KindRepFun $krep7_r8j3m $krep25_r8j3F

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IOError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.IO.Exception.$tc'IOError3 = "'IOError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IOError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.Exception.$tc'IOError2
  = GHC.Types.TrNameS GHC.IO.Exception.$tc'IOError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$tc'IOError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.Exception.$tc'IOError
  = GHC.Types.TyCon
      16489485703680136625##
      16514523686887444952##
      GHC.IO.Exception.$trModule
      GHC.IO.Exception.$tc'IOError2
      0#
      GHC.IO.Exception.$tc'IOError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException4
  :: Data.Typeable.Internal.TypeRep IOException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
GHC.IO.Exception.$fExceptionIOException4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ IOException
           10434000377887324342##
           16509375198449321302##
           GHC.IO.Exception.$trModule
           GHC.IO.Exception.$fExceptionIOException5
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ IOException
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException_$cfromException
  :: SomeException -> Maybe IOException
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionIOException_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ IOException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionIOException4
      of {
        False -> GHC.Base.Nothing @ IOException;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW IOException))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe IOException :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception IOException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: IOException
                                 GHC.IO.Exception.$fExceptionIOException4
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <IOException>_N
                                         :: (Data.Typeable.Internal.TypeRep IOException :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   IOException :: Constraint))
                                 GHC.IO.Exception.$fShowIOException
                                 GHC.IO.Exception.$fExceptionIOException_$ctoException
                                 GHC.IO.Exception.$fExceptionIOException_$cfromException
                                 GHC.IO.Exception.$fExceptionIOException_$cshow]
GHC.IO.Exception.$fExceptionIOException
  = GHC.Exception.C:Exception
      @ IOException
      (GHC.IO.Exception.$fExceptionIOException4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <IOException>_N
               :: (Data.Typeable.Internal.TypeRep IOException :: *)
                  ~R# (Data.Typeable.Internal.Typeable IOException :: Constraint)))
      GHC.IO.Exception.$fShowIOException
      GHC.IO.Exception.$fExceptionIOException_$ctoException
      GHC.IO.Exception.$fExceptionIOException_$cfromException
      GHC.IO.Exception.$fExceptionIOException_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionIOException_$ctoException [Occ=LoopBreaker]
  :: IOException -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionIOException_$ctoException
  = GHC.Exception.SomeException
      @ IOException GHC.IO.Exception.$fExceptionIOException
end Rec }

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
GHC.IO.Exception.ioError1
  :: forall a.
     IOException -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Str=<B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a8gQh)
                 (err_a8gzk [Occ=Once] :: IOException)
                 (eta_i8hAC [Occ=Once] :: State# RealWorld) ->
                 raiseIO#
                   @ SomeException
                   @ a_a8gQh
                   (GHC.IO.Exception.$fExceptionIOException_$ctoException err_a8gzk)
                   eta_i8hAC}]
GHC.IO.Exception.ioError1
  = \ (@ a_a8gQh)
      (err_a8gzk :: IOException)
      (eta_i8hAC :: State# RealWorld) ->
      raiseIO#
        @ SomeException
        @ a_a8gQh
        (GHC.IO.Exception.$fExceptionIOException_$ctoException err_a8gzk)
        eta_i8hAC

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
ioException :: forall a. IOException -> IO a
[GblId,
 Arity=2,
 Str=<B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.Exception.ioError1
               `cast` (forall (a :: <*>_N).
                       <IOException>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IOException -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IOException -> IO a :: *))}]
ioException
  = GHC.IO.Exception.ioError1
    `cast` (forall (a :: <*>_N).
            <IOException>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IOException -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IOException -> IO a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
ioError :: forall a. IOError -> IO a
[GblId,
 Arity=2,
 Str=<B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.Exception.ioError1
               `cast` (forall (a :: <*>_N).
                       <IOException>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IOException -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IOException -> IO a :: *))}]
ioError
  = GHC.IO.Exception.ioError1
    `cast` (forall (a :: <*>_N).
            <IOException>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IOException -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IOException -> IO a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fxExceptionIOException :: Exception IOException
[GblId,
 Str=m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=False, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.Exception.$fExceptionIOException}]
GHC.IO.Exception.$fxExceptionIOException
  = GHC.IO.Exception.$fExceptionIOException

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException
  :: SomeException -> Maybe BlockedIndefinitelyOnMVar
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ BlockedIndefinitelyOnMVar
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3
      of {
        False -> GHC.Base.Nothing @ BlockedIndefinitelyOnMVar;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW BlockedIndefinitelyOnMVar))_R
                  :: (Maybe e1_i8hqW :: *)
                     ~R# (Maybe BlockedIndefinitelyOnMVar :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception BlockedIndefinitelyOnMVar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: BlockedIndefinitelyOnMVar
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <BlockedIndefinitelyOnMVar>_N
                                         :: (Data.Typeable.Internal.TypeRep
                                               BlockedIndefinitelyOnMVar :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   BlockedIndefinitelyOnMVar :: Constraint))
                                 GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar
  = GHC.Exception.C:Exception
      @ BlockedIndefinitelyOnMVar
      (GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <BlockedIndefinitelyOnMVar>_N
               :: (Data.Typeable.Internal.TypeRep BlockedIndefinitelyOnMVar :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         BlockedIndefinitelyOnMVar :: Constraint)))
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnMVar
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cfromException
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException [Occ=LoopBreaker]
  :: BlockedIndefinitelyOnMVar -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException
  = GHC.Exception.SomeException
      @ BlockedIndefinitelyOnMVar
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
blockedIndefinitelyOnMVar :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
blockedIndefinitelyOnMVar
  = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar_$ctoException
      GHC.IO.Exception.BlockedIndefinitelyOnMVar

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException
  :: SomeException -> Maybe BlockedIndefinitelyOnSTM
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ BlockedIndefinitelyOnSTM
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3
      of {
        False -> GHC.Base.Nothing @ BlockedIndefinitelyOnSTM;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW BlockedIndefinitelyOnSTM))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe BlockedIndefinitelyOnSTM :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception BlockedIndefinitelyOnSTM
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: BlockedIndefinitelyOnSTM
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <BlockedIndefinitelyOnSTM>_N
                                         :: (Data.Typeable.Internal.TypeRep
                                               BlockedIndefinitelyOnSTM :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   BlockedIndefinitelyOnSTM :: Constraint))
                                 GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException
                                 GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM
  = GHC.Exception.C:Exception
      @ BlockedIndefinitelyOnSTM
      (GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <BlockedIndefinitelyOnSTM>_N
               :: (Data.Typeable.Internal.TypeRep BlockedIndefinitelyOnSTM :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         BlockedIndefinitelyOnSTM :: Constraint)))
      GHC.IO.Exception.$fShowBlockedIndefinitelyOnSTM
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cfromException
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException [Occ=LoopBreaker]
  :: BlockedIndefinitelyOnSTM -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException
  = GHC.Exception.SomeException
      @ BlockedIndefinitelyOnSTM
      GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
blockedIndefinitelyOnSTM :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
blockedIndefinitelyOnSTM
  = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM_$ctoException
      GHC.IO.Exception.BlockedIndefinitelyOnSTM

-- RHS size: {terms: 25, types: 32, coercions: 17, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException
  :: SomeException -> Maybe AllocationLimitExceeded
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 170 40}]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException
  = \ (eta_B1 :: SomeException) ->
      case eta_B1 of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ SomeAsyncException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
      of {
        False -> GHC.Base.Nothing @ AllocationLimitExceeded;
        True ->
          case e2_i8hqY
               `cast` (UnsafeCo representational e1_i8hqW SomeAsyncException
                       :: (e1_i8hqW :: *) ~R# (SomeAsyncException :: *))
          of
          { SomeAsyncException @ e_a8gQF $dException_a8gQG a_a8gzj ->
          case Data.Typeable.Internal.sameTypeRep
                 @ *
                 @ *
                 @ e_a8gQF
                 @ AllocationLimitExceeded
                 ((GHC.Exception.$p1Exception @ e_a8gQF $dException_a8gQG)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_a8gQF>_N
                          :: (Data.Typeable.Internal.Typeable e_a8gQF :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep e_a8gQF :: *)))
                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3
          of {
            False -> GHC.Base.Nothing @ AllocationLimitExceeded;
            True ->
              (GHC.Base.Just @ e_a8gQF a_a8gzj)
              `cast` ((Maybe
                         (UnsafeCo representational e_a8gQF AllocationLimitExceeded))_R
                      :: (Maybe e_a8gQF :: *) ~R# (Maybe AllocationLimitExceeded :: *))
          }
          }
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception AllocationLimitExceeded
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: AllocationLimitExceeded
                                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AllocationLimitExceeded>_N
                                         :: (Data.Typeable.Internal.TypeRep
                                               AllocationLimitExceeded :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   AllocationLimitExceeded :: Constraint))
                                 GHC.IO.Exception.$fShowAllocationLimitExceeded
                                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException
                                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException
                                 GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded
  = GHC.Exception.C:Exception
      @ AllocationLimitExceeded
      (GHC.IO.Exception.$fExceptionAllocationLimitExceeded3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AllocationLimitExceeded>_N
               :: (Data.Typeable.Internal.TypeRep AllocationLimitExceeded :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         AllocationLimitExceeded :: Constraint)))
      GHC.IO.Exception.$fShowAllocationLimitExceeded
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cfromException
      GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$cshow

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException [Occ=LoopBreaker]
  :: AllocationLimitExceeded -> SomeException
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException
  = \ (x_i7Rxi :: AllocationLimitExceeded) ->
      GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
        (GHC.IO.Exception.SomeAsyncException
           @ AllocationLimitExceeded
           GHC.IO.Exception.$fExceptionAllocationLimitExceeded
           x_i7Rxi)
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
allocationLimitExceeded :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
allocationLimitExceeded
  = GHC.IO.Exception.$fExceptionAllocationLimitExceeded_$ctoException
      GHC.IO.Exception.AllocationLimitExceeded

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException
  :: SomeException -> Maybe CompactionFailed
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ CompactionFailed
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionCompactionFailed2
      of {
        False -> GHC.Base.Nothing @ CompactionFailed;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW CompactionFailed))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe CompactionFailed :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception CompactionFailed
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: CompactionFailed
                                 GHC.IO.Exception.$fExceptionCompactionFailed2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <CompactionFailed>_N
                                         :: (Data.Typeable.Internal.TypeRep CompactionFailed :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   CompactionFailed :: Constraint))
                                 GHC.IO.Exception.$fShowCompactionFailed
                                 GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
                                 GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException
                                 GHC.IO.Exception.$fExceptionCompactionFailed_$cshow]
GHC.IO.Exception.$fExceptionCompactionFailed
  = GHC.Exception.C:Exception
      @ CompactionFailed
      (GHC.IO.Exception.$fExceptionCompactionFailed2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <CompactionFailed>_N
               :: (Data.Typeable.Internal.TypeRep CompactionFailed :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         CompactionFailed :: Constraint)))
      GHC.IO.Exception.$fShowCompactionFailed
      GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
      GHC.IO.Exception.$fExceptionCompactionFailed_$cfromException
      GHC.IO.Exception.$fExceptionCompactionFailed_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException [Occ=LoopBreaker]
  :: CompactionFailed -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
  = GHC.Exception.SomeException
      @ CompactionFailed GHC.IO.Exception.$fExceptionCompactionFailed
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactMutable2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 90 0}]
GHC.IO.Exception.cannotCompactMutable2
  = "cannot compact mutable objects"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactMutable1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.cannotCompactMutable1
  = unpackCString# GHC.IO.Exception.cannotCompactMutable2

-- RHS size: {terms: 2, types: 0, coercions: 2, joins: 0/0}
cannotCompactMutable :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
cannotCompactMutable
  = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
      (GHC.IO.Exception.cannotCompactMutable1
       `cast` (Sym (GHC.IO.Exception.N:CompactionFailed[0])
               :: (String :: *) ~R# (CompactionFailed :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactPinned2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 90 0}]
GHC.IO.Exception.cannotCompactPinned2
  = "cannot compact pinned objects"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactPinned1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.cannotCompactPinned1
  = unpackCString# GHC.IO.Exception.cannotCompactPinned2

-- RHS size: {terms: 2, types: 0, coercions: 2, joins: 0/0}
cannotCompactPinned :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
cannotCompactPinned
  = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
      (GHC.IO.Exception.cannotCompactPinned1
       `cast` (Sym (GHC.IO.Exception.N:CompactionFailed[0])
               :: (String :: *) ~R# (CompactionFailed :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactFunction2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.Exception.cannotCompactFunction2
  = "cannot compact functions"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.Exception.cannotCompactFunction1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.Exception.cannotCompactFunction1
  = unpackCString# GHC.IO.Exception.cannotCompactFunction2

-- RHS size: {terms: 2, types: 0, coercions: 2, joins: 0/0}
cannotCompactFunction :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
cannotCompactFunction
  = GHC.IO.Exception.$fExceptionCompactionFailed_$ctoException
      (GHC.IO.Exception.cannotCompactFunction1
       `cast` (Sym (GHC.IO.Exception.N:CompactionFailed[0])
               :: (String :: *) ~R# (CompactionFailed :: *)))

-- RHS size: {terms: 25, types: 32, coercions: 17, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException_$cfromException
  :: SomeException -> Maybe AsyncException
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 170 40}]
GHC.IO.Exception.$fExceptionAsyncException_$cfromException
  = \ (eta_B1 :: SomeException) ->
      case eta_B1 of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ SomeAsyncException
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             GHC.IO.Exception.$fExceptionAllocationLimitExceeded6
      of {
        False -> GHC.Base.Nothing @ AsyncException;
        True ->
          case e2_i8hqY
               `cast` (UnsafeCo representational e1_i8hqW SomeAsyncException
                       :: (e1_i8hqW :: *) ~R# (SomeAsyncException :: *))
          of
          { SomeAsyncException @ e_a8gQF $dException_a8gQG a_a8gzj ->
          case Data.Typeable.Internal.sameTypeRep
                 @ *
                 @ *
                 @ e_a8gQF
                 @ AsyncException
                 ((GHC.Exception.$p1Exception @ e_a8gQF $dException_a8gQG)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_a8gQF>_N
                          :: (Data.Typeable.Internal.Typeable e_a8gQF :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep e_a8gQF :: *)))
                 GHC.IO.Exception.$fExceptionAsyncException9
          of {
            False -> GHC.Base.Nothing @ AsyncException;
            True ->
              (GHC.Base.Just @ e_a8gQF a_a8gzj)
              `cast` ((Maybe
                         (UnsafeCo representational e_a8gQF AsyncException))_R
                      :: (Maybe e_a8gQF :: *) ~R# (Maybe AsyncException :: *))
          }
          }
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception AsyncException
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: AsyncException
                                 GHC.IO.Exception.$fExceptionAsyncException9
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AsyncException>_N
                                         :: (Data.Typeable.Internal.TypeRep AsyncException :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   AsyncException :: Constraint))
                                 GHC.IO.Exception.$fShowAsyncException
                                 GHC.IO.Exception.$fExceptionAsyncException_$ctoException
                                 GHC.IO.Exception.$fExceptionAsyncException_$cfromException
                                 GHC.IO.Exception.$fExceptionAsyncException_$cshow]
GHC.IO.Exception.$fExceptionAsyncException
  = GHC.Exception.C:Exception
      @ AsyncException
      (GHC.IO.Exception.$fExceptionAsyncException9
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <AsyncException>_N
               :: (Data.Typeable.Internal.TypeRep AsyncException :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         AsyncException :: Constraint)))
      GHC.IO.Exception.$fShowAsyncException
      GHC.IO.Exception.$fExceptionAsyncException_$ctoException
      GHC.IO.Exception.$fExceptionAsyncException_$cfromException
      GHC.IO.Exception.$fExceptionAsyncException_$cshow

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.IO.Exception.$fExceptionAsyncException_$ctoException [Occ=LoopBreaker]
  :: AsyncException -> SomeException
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.IO.Exception.$fExceptionAsyncException_$ctoException
  = \ (x_i7Rxi :: AsyncException) ->
      GHC.IO.Exception.$fExceptionSomeAsyncException_$ctoException
        (GHC.IO.Exception.SomeAsyncException
           @ AsyncException
           GHC.IO.Exception.$fExceptionAsyncException
           x_i7Rxi)
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
heapOverflow :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
heapOverflow
  = GHC.IO.Exception.$fExceptionAsyncException_$ctoException
      GHC.IO.Exception.HeapOverflow

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
stackOverflow :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
stackOverflow
  = GHC.IO.Exception.$fExceptionAsyncException_$ctoException
      GHC.IO.Exception.StackOverflow


